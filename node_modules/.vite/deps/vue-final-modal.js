import "./chunk-JXEL5ADO.js";
import {
  Fragment,
  Teleport,
  Transition,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createSlots,
  createVNode,
  defineComponent,
  getCurrentInstance,
  getCurrentScope,
  guardReactiveProps,
  inject,
  markRaw,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onBeforeUnmount,
  onMounted,
  onScopeDispose,
  onUnmounted,
  openBlock,
  reactive,
  ref,
  renderList,
  renderSlot,
  resolveDynamicComponent,
  shallowReactive,
  shallowRef,
  toHandlers,
  toRef,
  unref,
  useAttrs,
  vShow,
  watch,
  withCtx,
  withDirectives,
  withKeys,
  withModifiers
} from "./chunk-TYUBDKXE.js";
import "./chunk-AC2VUBZ6.js";

// node_modules/@vueuse/shared/index.mjs
var _a;
var isClient = typeof window !== "undefined";
var isString = (val) => typeof val === "string";
var noop = () => {
};
var isIOS = isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function resolveUnref(r) {
  return typeof r === "function" ? r() : unref(r);
}
function identity(arg) {
  return arg;
}
function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
function tryOnUnmounted(fn) {
  if (getCurrentInstance())
    onUnmounted(fn);
}

// node_modules/@vueuse/core/index.mjs
function unrefElement(elRef) {
  var _a2;
  const plain = resolveUnref(elRef);
  return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
}
var defaultWindow = isClient ? window : void 0;
var defaultDocument = isClient ? window.document : void 0;
var defaultNavigator = isClient ? window.navigator : void 0;
var defaultLocation = isClient ? window.location : void 0;
function useEventListener(...args) {
  let target;
  let events;
  let listeners;
  let options;
  if (isString(args[0]) || Array.isArray(args[0])) {
    [events, listeners, options] = args;
    target = defaultWindow;
  } else {
    [target, events, listeners, options] = args;
  }
  if (!target)
    return noop;
  if (!Array.isArray(events))
    events = [events];
  if (!Array.isArray(listeners))
    listeners = [listeners];
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register = (el, event, listener) => {
    el.addEventListener(event, listener, options);
    return () => el.removeEventListener(event, listener, options);
  };
  const stopWatch = watch(() => unrefElement(target), (el) => {
    cleanup();
    if (!el)
      return;
    cleanups.push(...events.flatMap((event) => {
      return listeners.map((listener) => register(el, event, listener));
    }));
  }, { immediate: true, flush: "post" });
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return stop;
}
var _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var globalKey = "__vueuse_ssr_handlers__";
_global[globalKey] = _global[globalKey] || {};
var handlers = _global[globalKey];
var defaultState = {
  x: 0,
  y: 0,
  pointerId: 0,
  pressure: 0,
  tiltX: 0,
  tiltY: 0,
  width: 0,
  height: 0,
  twist: 0,
  pointerType: null
};
var keys = Object.keys(defaultState);
var SwipeDirection;
(function(SwipeDirection2) {
  SwipeDirection2["UP"] = "UP";
  SwipeDirection2["RIGHT"] = "RIGHT";
  SwipeDirection2["DOWN"] = "DOWN";
  SwipeDirection2["LEFT"] = "LEFT";
  SwipeDirection2["NONE"] = "NONE";
})(SwipeDirection || (SwipeDirection = {}));
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var _TransitionPresets = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
var TransitionPresets = __spreadValues({
  linear: identity
}, _TransitionPresets);

// node_modules/tabbable/dist/index.esm.js
var candidateSelectors = ["input", "select", "textarea", "a[href]", "button", "[tabindex]:not(slot)", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])', "details>summary:first-of-type", "details"];
var candidateSelector = candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  return element.getRootNode();
} : function(element) {
  return element.ownerDocument;
};
var getCandidates = function getCandidates2(el, includeContainer, filter) {
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter);
  return candidates;
};
var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (element.tagName === "SLOT") {
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively2(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scopeParent: element,
          candidates: nestedCandidates
        });
      }
    } else {
      var validCandidate = matches.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }
      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
      typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
      var validShadowRoot = !options.shadowRootFilter || options.shadowRootFilter(element);
      if (shadowRoot && validShadowRoot) {
        var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var getTabindex = function getTabindex2(node, isScope) {
  if (node.tabIndex < 0) {
    if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || node.isContentEditable) && isNaN(parseInt(node.getAttribute("tabindex"), 10))) {
      return 0;
    }
  }
  return node.tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a, b) {
  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
};
var isInput = function isInput2(node) {
  return node.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node) {
  return isInput(node) && node.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node) {
  var r = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r;
};
var getCheckedRadio = function getCheckedRadio2(nodes, form) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].checked && nodes[i].form === form) {
      return nodes[i];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode(node);
  var queryRadios = function queryRadios2(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio2(node) {
  return isInput(node) && node.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node) {
  return isRadio(node) && !isTabbableRadio(node);
};
var isNodeAttached = function isNodeAttached2(node) {
  var _nodeRootHost;
  var nodeRootHost = getRootNode(node).host;
  var attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && _nodeRootHost.ownerDocument.contains(nodeRootHost) || node.ownerDocument.contains(node));
  while (!attached && nodeRootHost) {
    var _nodeRootHost2;
    nodeRootHost = getRootNode(nodeRootHost).host;
    attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && _nodeRootHost2.ownerDocument.contains(nodeRootHost));
  }
  return attached;
};
var isZeroArea = function isZeroArea2(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden2(node, _ref) {
  var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
  if (getComputedStyle(node).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches.call(node, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
    if (typeof getShadowRoot === "function") {
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          node = rootNode.host;
        } else {
          node = parentElement;
        }
      }
      node = originalNode;
    }
    if (isNodeAttached(node)) {
      return !node.getClientRects().length;
    }
    if (displayCheck !== "legacy-full") {
      return true;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode = node.parentElement;
    while (parentNode) {
      if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
        for (var i = 0; i < parentNode.children.length; i++) {
          var child = parentNode.children.item(i);
          if (child.tagName === "LEGEND") {
            return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
          }
        }
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
  if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
  if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  return false;
};
var sortByOrder = function sortByOrder2(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function(item, i) {
    var isScope = !!item.scopeParent;
    var element = isScope ? item.scopeParent : item;
    var candidateTabindex = getTabindex(element, isScope);
    var elements = isScope ? sortByOrder2(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i,
        tabIndex: candidateTabindex,
        item,
        isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable2(el, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([el], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
var focusable = function focusable2(el, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([el], options.includeContainer, {
      filter: isNodeMatchingSelectorFocusable.bind(null, options),
      flatten: true,
      getShadowRoot: options.getShadowRoot
    });
  } else {
    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
  }
  return candidates;
};
var isTabbable = function isTabbable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, candidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorTabbable(options, node);
};
var focusableCandidateSelector = candidateSelectors.concat("iframe").join(",");
var isFocusable = function isFocusable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, focusableCandidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorFocusable(options, node);
};

// node_modules/focus-trap/dist/focus-trap.esm.js
function ownKeys(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
var activeFocusTraps = {
  activateTrap: function activateTrap(trapStack, trap) {
    if (trapStack.length > 0) {
      var activeTrap = trapStack[trapStack.length - 1];
      if (activeTrap !== trap) {
        activeTrap.pause();
      }
    }
    var trapIndex = trapStack.indexOf(trap);
    if (trapIndex === -1) {
      trapStack.push(trap);
    } else {
      trapStack.splice(trapIndex, 1);
      trapStack.push(trap);
    }
  },
  deactivateTrap: function deactivateTrap(trapStack, trap) {
    var trapIndex = trapStack.indexOf(trap);
    if (trapIndex !== -1) {
      trapStack.splice(trapIndex, 1);
    }
    if (trapStack.length > 0) {
      trapStack[trapStack.length - 1].unpause();
    }
  }
};
var isSelectableInput = function isSelectableInput2(node) {
  return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
};
var isEscapeEvent = function isEscapeEvent2(e) {
  return e.key === "Escape" || e.key === "Esc" || e.keyCode === 27;
};
var isTabEvent = function isTabEvent2(e) {
  return e.key === "Tab" || e.keyCode === 9;
};
var isKeyForward = function isKeyForward2(e) {
  return isTabEvent(e) && !e.shiftKey;
};
var isKeyBackward = function isKeyBackward2(e) {
  return isTabEvent(e) && e.shiftKey;
};
var delay = function delay2(fn) {
  return setTimeout(fn, 0);
};
var findIndex = function findIndex2(arr, fn) {
  var idx = -1;
  arr.every(function(value, i) {
    if (fn(value)) {
      idx = i;
      return false;
    }
    return true;
  });
  return idx;
};
var valueOrHandler = function valueOrHandler2(value) {
  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    params[_key - 1] = arguments[_key];
  }
  return typeof value === "function" ? value.apply(void 0, params) : value;
};
var getActualTarget = function getActualTarget2(event) {
  return event.target.shadowRoot && typeof event.composedPath === "function" ? event.composedPath()[0] : event.target;
};
var internalTrapStack = [];
var createFocusTrap = function createFocusTrap2(elements, userOptions) {
  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
  var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;
  var config = _objectSpread2({
    returnFocusOnDeactivate: true,
    escapeDeactivates: true,
    delayInitialFocus: true,
    isKeyForward,
    isKeyBackward
  }, userOptions);
  var state = {
    // containers given to createFocusTrap()
    // @type {Array<HTMLElement>}
    containers: [],
    // list of objects identifying tabbable nodes in `containers` in the trap
    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
    //  is active, but the trap should never get to a state where there isn't at least one group
    //  with at least one tabbable node in it (that would lead to an error condition that would
    //  result in an error being thrown)
    // @type {Array<{
    //   container: HTMLElement,
    //   tabbableNodes: Array<HTMLElement>, // empty if none
    //   focusableNodes: Array<HTMLElement>, // empty if none
    //   firstTabbableNode: HTMLElement|null,
    //   lastTabbableNode: HTMLElement|null,
    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
    // }>}
    containerGroups: [],
    // same order/length as `containers` list
    // references to objects in `containerGroups`, but only those that actually have
    //  tabbable nodes in them
    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
    //  the same length
    tabbableGroups: [],
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: false,
    paused: false,
    // timer ID for when delayInitialFocus is true and initial focus in this trap
    //  has been delayed during activation
    delayInitialFocusTimer: void 0
  };
  var trap;
  var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
    return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config[configOptionName || optionName];
  };
  var findContainerIndex = function findContainerIndex2(element) {
    return state.containerGroups.findIndex(function(_ref) {
      var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
      return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any
      //  web components if the `tabbableOptions.getShadowRoot` option was used for
      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
      //  look inside web components even if open)
      tabbableNodes.find(function(node) {
        return node === element;
      });
    });
  };
  var getNodeForOption = function getNodeForOption2(optionName) {
    var optionValue = config[optionName];
    if (typeof optionValue === "function") {
      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        params[_key2 - 1] = arguments[_key2];
      }
      optionValue = optionValue.apply(void 0, params);
    }
    if (optionValue === true) {
      optionValue = void 0;
    }
    if (!optionValue) {
      if (optionValue === void 0 || optionValue === false) {
        return optionValue;
      }
      throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
    }
    var node = optionValue;
    if (typeof optionValue === "string") {
      node = doc.querySelector(optionValue);
      if (!node) {
        throw new Error("`".concat(optionName, "` as selector refers to no known node"));
      }
    }
    return node;
  };
  var getInitialFocusNode = function getInitialFocusNode2() {
    var node = getNodeForOption("initialFocus");
    if (node === false) {
      return false;
    }
    if (node === void 0) {
      if (findContainerIndex(doc.activeElement) >= 0) {
        node = doc.activeElement;
      } else {
        var firstTabbableGroup = state.tabbableGroups[0];
        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
        node = firstTabbableNode || getNodeForOption("fallbackFocus");
      }
    }
    if (!node) {
      throw new Error("Your focus-trap needs to have at least one focusable element");
    }
    return node;
  };
  var updateTabbableNodes = function updateTabbableNodes2() {
    state.containerGroups = state.containers.map(function(container) {
      var tabbableNodes = tabbable(container, config.tabbableOptions);
      var focusableNodes = focusable(container, config.tabbableOptions);
      return {
        container,
        tabbableNodes,
        focusableNodes,
        firstTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[0] : null,
        lastTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : null,
        /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
        nextTabbableNode: function nextTabbableNode(node) {
          var forward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var nodeIdx = focusableNodes.findIndex(function(n) {
            return n === node;
          });
          if (nodeIdx < 0) {
            return void 0;
          }
          if (forward) {
            return focusableNodes.slice(nodeIdx + 1).find(function(n) {
              return isTabbable(n, config.tabbableOptions);
            });
          }
          return focusableNodes.slice(0, nodeIdx).reverse().find(function(n) {
            return isTabbable(n, config.tabbableOptions);
          });
        }
      };
    });
    state.tabbableGroups = state.containerGroups.filter(function(group) {
      return group.tabbableNodes.length > 0;
    });
    if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
      throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
    }
  };
  var tryFocus = function tryFocus2(node) {
    if (node === false) {
      return;
    }
    if (node === doc.activeElement) {
      return;
    }
    if (!node || !node.focus) {
      tryFocus2(getInitialFocusNode());
      return;
    }
    node.focus({
      preventScroll: !!config.preventScroll
    });
    state.mostRecentlyFocusedNode = node;
    if (isSelectableInput(node)) {
      node.select();
    }
  };
  var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
    var node = getNodeForOption("setReturnFocus", previousActiveElement);
    return node ? node : node === false ? false : previousActiveElement;
  };
  var checkPointerDown = function checkPointerDown2(e) {
    var target = getActualTarget(e);
    if (findContainerIndex(target) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e)) {
      trap.deactivate({
        // if, on deactivation, we should return focus to the node originally-focused
        //  when the trap was activated (or the configured `setReturnFocus` node),
        //  then assume it's also OK to return focus to the outside node that was
        //  just clicked, causing deactivation, as long as that node is focusable;
        //  if it isn't focusable, then return focus to the original node focused
        //  on activation (or the configured `setReturnFocus` node)
        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
        //  which will result in the outside click setting focus to the node
        //  that was clicked, whether it's focusable or not; by setting
        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
        //  on activation (or the configured `setReturnFocus` node)
        returnFocus: config.returnFocusOnDeactivate && !isFocusable(target, config.tabbableOptions)
      });
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e)) {
      return;
    }
    e.preventDefault();
  };
  var checkFocusIn = function checkFocusIn2(e) {
    var target = getActualTarget(e);
    var targetContained = findContainerIndex(target) >= 0;
    if (targetContained || target instanceof Document) {
      if (targetContained) {
        state.mostRecentlyFocusedNode = target;
      }
    } else {
      e.stopImmediatePropagation();
      tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
    }
  };
  var checkKeyNav = function checkKeyNav2(event) {
    var isBackward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var target = getActualTarget(event);
    updateTabbableNodes();
    var destinationNode = null;
    if (state.tabbableGroups.length > 0) {
      var containerIndex = findContainerIndex(target);
      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : void 0;
      if (containerIndex < 0) {
        if (isBackward) {
          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
        } else {
          destinationNode = state.tabbableGroups[0].firstTabbableNode;
        }
      } else if (isBackward) {
        var startOfGroupIndex = findIndex(state.tabbableGroups, function(_ref2) {
          var firstTabbableNode = _ref2.firstTabbableNode;
          return target === firstTabbableNode;
        });
        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
          startOfGroupIndex = containerIndex;
        }
        if (startOfGroupIndex >= 0) {
          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
          var destinationGroup = state.tabbableGroups[destinationGroupIndex];
          destinationNode = destinationGroup.lastTabbableNode;
        } else if (!isTabEvent(event)) {
          destinationNode = containerGroup.nextTabbableNode(target, false);
        }
      } else {
        var lastOfGroupIndex = findIndex(state.tabbableGroups, function(_ref3) {
          var lastTabbableNode = _ref3.lastTabbableNode;
          return target === lastTabbableNode;
        });
        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
          lastOfGroupIndex = containerIndex;
        }
        if (lastOfGroupIndex >= 0) {
          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
          destinationNode = _destinationGroup.firstTabbableNode;
        } else if (!isTabEvent(event)) {
          destinationNode = containerGroup.nextTabbableNode(target);
        }
      }
    } else {
      destinationNode = getNodeForOption("fallbackFocus");
    }
    if (destinationNode) {
      if (isTabEvent(event)) {
        event.preventDefault();
      }
      tryFocus(destinationNode);
    }
  };
  var checkKey = function checkKey2(event) {
    if (isEscapeEvent(event) && valueOrHandler(config.escapeDeactivates, event) !== false) {
      event.preventDefault();
      trap.deactivate();
      return;
    }
    if (config.isKeyForward(event) || config.isKeyBackward(event)) {
      checkKeyNav(event, config.isKeyBackward(event));
    }
  };
  var checkClick = function checkClick2(e) {
    var target = getActualTarget(e);
    if (findContainerIndex(target) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e)) {
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e)) {
      return;
    }
    e.preventDefault();
    e.stopImmediatePropagation();
  };
  var addListeners = function addListeners2() {
    if (!state.active) {
      return;
    }
    activeFocusTraps.activateTrap(trapStack, trap);
    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function() {
      tryFocus(getInitialFocusNode());
    }) : tryFocus(getInitialFocusNode());
    doc.addEventListener("focusin", checkFocusIn, true);
    doc.addEventListener("mousedown", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("touchstart", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("click", checkClick, {
      capture: true,
      passive: false
    });
    doc.addEventListener("keydown", checkKey, {
      capture: true,
      passive: false
    });
    return trap;
  };
  var removeListeners = function removeListeners2() {
    if (!state.active) {
      return;
    }
    doc.removeEventListener("focusin", checkFocusIn, true);
    doc.removeEventListener("mousedown", checkPointerDown, true);
    doc.removeEventListener("touchstart", checkPointerDown, true);
    doc.removeEventListener("click", checkClick, true);
    doc.removeEventListener("keydown", checkKey, true);
    return trap;
  };
  trap = {
    get active() {
      return state.active;
    },
    get paused() {
      return state.paused;
    },
    activate: function activate(activateOptions) {
      if (state.active) {
        return this;
      }
      var onActivate = getOption(activateOptions, "onActivate");
      var onPostActivate = getOption(activateOptions, "onPostActivate");
      var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
      if (!checkCanFocusTrap) {
        updateTabbableNodes();
      }
      state.active = true;
      state.paused = false;
      state.nodeFocusedBeforeActivation = doc.activeElement;
      if (onActivate) {
        onActivate();
      }
      var finishActivation = function finishActivation2() {
        if (checkCanFocusTrap) {
          updateTabbableNodes();
        }
        addListeners();
        if (onPostActivate) {
          onPostActivate();
        }
      };
      if (checkCanFocusTrap) {
        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
        return this;
      }
      finishActivation();
      return this;
    },
    deactivate: function deactivate(deactivateOptions) {
      if (!state.active) {
        return this;
      }
      var options = _objectSpread2({
        onDeactivate: config.onDeactivate,
        onPostDeactivate: config.onPostDeactivate,
        checkCanReturnFocus: config.checkCanReturnFocus
      }, deactivateOptions);
      clearTimeout(state.delayInitialFocusTimer);
      state.delayInitialFocusTimer = void 0;
      removeListeners();
      state.active = false;
      state.paused = false;
      activeFocusTraps.deactivateTrap(trapStack, trap);
      var onDeactivate = getOption(options, "onDeactivate");
      var onPostDeactivate = getOption(options, "onPostDeactivate");
      var checkCanReturnFocus = getOption(options, "checkCanReturnFocus");
      var returnFocus = getOption(options, "returnFocus", "returnFocusOnDeactivate");
      if (onDeactivate) {
        onDeactivate();
      }
      var finishDeactivation = function finishDeactivation2() {
        delay(function() {
          if (returnFocus) {
            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
          }
          if (onPostDeactivate) {
            onPostDeactivate();
          }
        });
      };
      if (returnFocus && checkCanReturnFocus) {
        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
        return this;
      }
      finishDeactivation();
      return this;
    },
    pause: function pause() {
      if (state.paused || !state.active) {
        return this;
      }
      state.paused = true;
      removeListeners();
      return this;
    },
    unpause: function unpause() {
      if (!state.paused || !state.active) {
        return this;
      }
      state.paused = false;
      updateTabbableNodes();
      addListeners();
      return this;
    },
    updateContainerElements: function updateContainerElements(containerElements) {
      var elementsAsArray = [].concat(containerElements).filter(Boolean);
      state.containers = elementsAsArray.map(function(element) {
        return typeof element === "string" ? doc.querySelector(element) : element;
      });
      if (state.active) {
        updateTabbableNodes();
      }
      return this;
    }
  };
  trap.updateContainerElements(elements);
  return trap;
};

// node_modules/@vueuse/integrations/useFocusTrap.mjs
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp2.call(b, prop))
      __defNormalProp2(a, prop, b[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b)) {
      if (__propIsEnum2.call(b, prop))
        __defNormalProp2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp2.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum2.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function useFocusTrap(target, options = {}) {
  let trap;
  const _a2 = options, { immediate } = _a2, focusTrapOptions = __objRest(_a2, ["immediate"]);
  const hasFocus = ref(false);
  const isPaused = ref(false);
  const activate = (opts) => trap && trap.activate(opts);
  const deactivate = (opts) => trap && trap.deactivate(opts);
  const pause = () => {
    if (trap) {
      trap.pause();
      isPaused.value = true;
    }
  };
  const unpause = () => {
    if (trap) {
      trap.unpause();
      isPaused.value = false;
    }
  };
  watch(() => unrefElement(target), (el) => {
    if (!el)
      return;
    trap = createFocusTrap(el, __spreadProps(__spreadValues2({}, focusTrapOptions), {
      onActivate() {
        hasFocus.value = true;
        if (options.onActivate)
          options.onActivate();
      },
      onDeactivate() {
        hasFocus.value = false;
        if (options.onDeactivate)
          options.onDeactivate();
      }
    }));
    if (immediate)
      activate();
  }, { flush: "post" });
  tryOnScopeDispose(() => deactivate());
  return {
    hasFocus,
    isPaused,
    activate,
    deactivate,
    pause,
    unpause
  };
}

// node_modules/vue-final-modal/dist/index.es.js
var ue = {
  /**
   * @description An uniq name for the open/close a modal via vfm.open/vfm.close APIs.
   * @default `undefined`
   * @example Symbol: `Symbol('MyModal')`
   * @example String: `'AUniqString'`
   * @example Number: `300`
   */
  modalId: {
    type: [String, Number, Symbol],
    default: void 0
  },
  /**
   * @description Display the modal or not.
   * @default `undefined`
   * @example
   * ```js
   * const showModal = ref(false)
   * v-model="showModal"
   * ```
   */
  modelValue: {
    type: Boolean,
    default: void 0
  },
  /**
   * @description Render the modal via `if` or `show`.
   * @default `'if'`
   * @example
   * ```js
   * displayDirective: 'if'
   * ```
   * @example
   * ```js
   * displayDirective: 'show'
   * ```
   */
  displayDirective: {
    type: String,
    default: "if",
    validator: (e) => ["if", "show"].includes(e)
  },
  /**
   * @description Hide the overlay or not.
   * @default `undefined`
   * @example
   * ```js
   * hideOverlay="true"
   * ```
   */
  hideOverlay: {
    type: Boolean,
    default: void 0
  },
  /**
   * @description Customize the overlay transition.
   * @default `undefined`
   */
  overlayTransition: {
    type: [String, Object],
    default: void 0
  },
  /**
   * @description Customize the content transition.
   * @default `undefined`
   */
  contentTransition: {
    type: [String, Object],
    default: void 0
  },
  /**
   * @description Bind class to vfm__overlay.
   * @default `undefined`
   */
  overlayClass: {
    type: void 0,
    default: void 0
  },
  /**
   * @description Bind class to vfm__content.
   * @default `undefined`
   */
  contentClass: {
    type: void 0,
    default: void 0
  },
  /**
   * @description Bind style to vfm__overlay.
   * @default `undefined`
   */
  overlayStyle: {
    type: [String, Object, Array],
    default: void 0
  },
  /**
   * @description Bind style to vfm__content.
   * @default `undefined`
   */
  contentStyle: {
    type: [String, Object, Array],
    default: void 0
  },
  /**
   * @description Is it allow to close the modal by clicking the overlay.
   * @default `true`
   */
  clickToClose: {
    type: Boolean,
    default: true
  },
  /**
   * @description Is it allow to close the modal by keypress `esc`.
   * @default `true`
   */
  escToClose: {
    type: Boolean,
    default: true
  },
  /**
   * @description Is it allow to click outside of the vfm__content when the modal is opened
   * @default `'non-interactive'`
   */
  background: {
    type: String,
    default: "non-interactive",
    validator: (e) => ["interactive", "non-interactive"].includes(e)
  },
  /**
   * @description
   * * Use `{ disabled: true }` to disable the focusTrap.
   * * Checkout the createOptions type here https://github.com/focus-trap/focus-trap for more.
   * @default `{ allowOutsideClick: true }`
   */
  focusTrap: {
    type: [Boolean, Object],
    default: () => ({
      allowOutsideClick: true
    })
  },
  /**
   * @description Lock body scroll or not when the modal is opened.
   * @default `true`
   */
  lockScroll: {
    type: Boolean,
    default: true
  },
  /**
   * @description Define how to increase the zIndex when there are nested modals
   * @default `({ index }) => 1000 + 2 * index`
   */
  zIndexFn: {
    type: Function,
    default: ({ index: e }) => 1e3 + 2 * e
  },
  /**
   * @description The direction of swiping to close the modal
   * @default `none`
   * @example
   * Set swipeToClose="none" to disable swiping to close
   * ```js
   * swipeToClose="none"
   * ```
   */
  swipeToClose: {
    type: String,
    default: "none",
    validator: (e) => ["none", "up", "right", "down", "left"].includes(e)
  },
  /**
   * @description Threshold for swipe to close
   * @default `0`
   */
  threshold: {
    type: Number,
    default: 0
  },
  /**
   * @description If set `:showSwipeBanner="true"`, only allow clicking `swipe-banner` slot to swipe to close
   * @default `undefined`
   * @example
   * ```js
   * swipeToClose="right"
   * :showSwipeBanner="true"
   * ```
   * ```html
   * <VueFinalModal
   *   ...
   *   swipeToClose="right"
   *   :showSwipeBanner="true"
   * >
   *   <template #swipe-banner>
   *     <div style="position: absolute; height: 100%; top: 0; left: 0; width: 10px;" />
   *   </template>
   *   ...modal content
   * </VueFinalModal>
   * ```
   */
  showSwipeBanner: {
    type: Boolean,
    default: void 0
  },
  /**
   * @description When set `:preventNavigationGestures="true"`, there will be two invisible bars for prevent navigation gestures including swiping back/forward on mobile webkit. For example: Safari mobile.
   * @default `undefined`
   * @example
   * Set preventNavigationGestures="true" to prevent Safari navigation gestures including swiping back/forward.
   * ```js
   * :preventNavigationGestures="true"
   * ```
   */
  preventNavigationGestures: {
    type: Boolean,
    default: void 0
  }
};
function Oe(e = false) {
  const o = ref(e), n = ref(o.value ? 0 : void 0);
  return [o, n, {
    beforeEnter() {
      n.value = 1;
    },
    afterEnter() {
      n.value = 0;
    },
    beforeLeave() {
      n.value = 3;
    },
    afterLeave() {
      n.value = 2;
    }
  }];
}
function oo(e, o) {
  const { modelValueLocal: n, onEntering: t, onEnter: u, onLeaving: l, onLeave: s } = o, a = ref(n.value), [i, c, d] = Oe(a.value), [m, f, v] = Oe(a.value), g = computed(() => typeof e.contentTransition == "string" ? { name: e.contentTransition } : { ...e.contentTransition }), V = computed(() => typeof e.overlayTransition == "string" ? { name: e.overlayTransition } : { ...e.overlayTransition }), k = computed(
    () => (e.hideOverlay || f.value === 2) && c.value === 2
    /* Leave */
  );
  watch(
    k,
    (B) => {
      B && (a.value = false);
    }
  ), watch(c, (B) => {
    switch (B) {
      case 1:
        return t();
      case 0:
        return u();
      case 3:
        return l();
      case 2:
        return s();
    }
  });
  async function y() {
    a.value = true, await nextTick(), i.value = true, m.value = true;
  }
  function C() {
    i.value = false, m.value = false;
  }
  return {
    visible: a,
    contentVisible: i,
    contentListeners: d,
    contentTransition: g,
    overlayVisible: m,
    overlayListeners: v,
    overlayTransition: V,
    enterTransition: y,
    leaveTransition: C
  };
}
function no(e, o, n) {
  const { vfmRootEl: t, visible: u, modelValueLocal: l } = n, s = ref();
  function a() {
    u.value && e.escToClose && (l.value = false);
  }
  function i(d) {
    s.value = d == null ? void 0 : d.target;
  }
  function c() {
    s.value === t.value && (e.clickToClose ? l.value = false : o("clickOutside"));
  }
  return {
    onEsc: a,
    onMouseupRoot: c,
    onMousedown: i
  };
}
function to(e, o) {
  const n = ref(!!e.modelValue);
  return watch(() => e.modelValue, (t) => {
    n.value = !!t;
  }), watch(n, (t) => {
    t !== e.modelValue && o("update:modelValue", t);
  }), {
    modelValueLocal: n
  };
}
function lo(e, o) {
  if (e.focusTrap === false)
    return {
      focus() {
      },
      focusLast() {
      },
      blur() {
      }
    };
  const { focusEl: n, openedModals: t } = o, { hasFocus: u, activate: l, deactivate: s } = useFocusTrap(n, e.focusTrap);
  function a() {
    requestAnimationFrame(() => {
      l();
    });
  }
  function i() {
    t.length <= 0 || nextTick(() => {
      const d = t[t.length - 1];
      d == null || d.value.focus();
    });
  }
  function c() {
    u.value && s();
  }
  return { focus: a, focusLast: i, blur: c };
}
var ce = false;
if (typeof window < "u") {
  const e = {
    get passive() {
      ce = true;
    }
  };
  window.addEventListener("testPassive", null, e), window.removeEventListener("testPassive", null, e);
}
var xe = typeof window < "u" && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === "MacIntel" && window.navigator.maxTouchPoints > 1);
var R = [];
var Q = false;
var q = 0;
var Ae = -1;
var G;
var U;
var so = (e) => {
  if (!e || e.nodeType !== Node.ELEMENT_NODE)
    return false;
  const o = window.getComputedStyle(e);
  return ["auto", "scroll"].includes(o.overflowY) && e.scrollHeight > e.clientHeight;
};
var ro = (e, o) => !(e.scrollTop === 0 && o < 0 || e.scrollTop + e.clientHeight + o >= e.scrollHeight && o > 0);
var ao = (e) => {
  const o = [];
  for (; e; ) {
    if (o.push(e), e.classList.contains("vfm"))
      return o;
    e = e.parentElement;
  }
  return o;
};
var io = (e, o) => {
  let n = false;
  return ao(e).forEach((u) => {
    so(u) && ro(u, o) && (n = true);
  }), n;
};
var Fe = (e) => R.some(() => io(e, -q));
var ee = (e) => {
  const o = e || window.event;
  return Fe(o.target) || o.touches.length > 1 ? true : (o.preventDefault && o.preventDefault(), false);
};
var uo = (e) => {
  if (U === void 0) {
    const o = !!e && e.reserveScrollBarGap === true, n = window.innerWidth - document.documentElement.clientWidth;
    if (o && n > 0) {
      const t = parseInt(getComputedStyle(document.body).getPropertyValue("padding-right"), 10);
      U = document.body.style.paddingRight, document.body.style.paddingRight = `${t + n}px`;
    }
  }
  G === void 0 && (G = document.body.style.overflow, document.body.style.overflow = "hidden");
};
var co = () => {
  U !== void 0 && (document.body.style.paddingRight = U, U = void 0), G !== void 0 && (document.body.style.overflow = G, G = void 0);
};
var fo = (e) => e ? e.scrollHeight - e.scrollTop <= e.clientHeight : false;
var vo = (e, o) => (q = e.targetTouches[0].clientY - Ae, Fe(e.target) ? false : o && o.scrollTop === 0 && q > 0 || fo(o) && q < 0 ? ee(e) : (e.stopPropagation(), true));
var po = (e, o) => {
  if (!e) {
    console.error(
      "disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices."
    );
    return;
  }
  if (R.some((t) => t.targetElement === e))
    return;
  const n = {
    targetElement: e,
    options: o || {}
  };
  R = [...R, n], xe ? (e.ontouchstart = (t) => {
    t.targetTouches.length === 1 && (Ae = t.targetTouches[0].clientY);
  }, e.ontouchmove = (t) => {
    t.targetTouches.length === 1 && vo(t, e);
  }, Q || (document.addEventListener("touchmove", ee, ce ? { passive: false } : void 0), Q = true)) : uo(o);
};
var mo = (e) => {
  if (!e) {
    console.error(
      "enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices."
    );
    return;
  }
  R = R.filter((o) => o.targetElement !== e), xe ? (e.ontouchstart = null, e.ontouchmove = null, Q && R.length === 0 && (document.removeEventListener("touchmove", ee, ce ? { passive: false } : void 0), Q = false)) : R.length || co();
};
function yo(e, o) {
  const { lockScrollEl: n } = o;
  watch(() => e.lockScroll, (l) => {
    l ? u() : t();
  }), onBeforeUnmount(() => {
    t();
  });
  function t() {
    n.value && mo(n.value);
  }
  function u() {
    e.lockScroll && n.value && po(n.value, {
      reserveScrollBarGap: true,
      allowTouchMove: (l) => {
        for (; l && l !== document.body; ) {
          if (l.getAttribute("vfm-scroll-lock-ignore") !== null)
            return true;
          l = l.parentElement;
        }
        return false;
      }
    });
  }
  return {
    enableBodyScroll: t,
    disableBodyScroll: u
  };
}
function ho(e) {
  function o(n) {
    switch (n) {
      case "beforeOpen":
        e(n);
        break;
      case "beforeClose":
        e(n);
        break;
      case "opened":
        e(n);
        break;
      case "closed":
        e(n);
        break;
    }
  }
  return {
    emitEvent: o
  };
}
function wo(e, o) {
  const { openedModals: n } = o, t = ref();
  function u() {
    var l;
    t.value = (l = e.zIndexFn) == null ? void 0 : l.call(e, { index: n.length });
  }
  return {
    zIndex: t,
    refreshZIndex: u
  };
}
var bo = (e) => (...o) => {
  e && (e == null || e(...o), e = null);
};
var F = () => {
};
function Z(e, o, n) {
  return e > n ? n : e < o ? o : e;
}
var Ve = (e) => {
  if (e instanceof TouchEvent) {
    const { clientX: o, clientY: n } = e.targetTouches[0];
    return { x: o, y: n };
  } else {
    const { clientX: o, clientY: n } = e;
    return { x: o, y: n };
  }
};
function To(e) {
  if (!e)
    return false;
  let o = false;
  const n = {
    get passive() {
      return o = true, false;
    }
  };
  return e.addEventListener("x", F, n), e.removeEventListener("x", F), o;
}
function So(e, {
  threshold: o = 0,
  onSwipeStart: n,
  onSwipe: t,
  onSwipeEnd: u,
  passive: l = true
}) {
  const s = reactive({ x: 0, y: 0 }), a = reactive({ x: 0, y: 0 }), i = computed(() => s.x - a.x), c = computed(() => s.y - a.y), { max: d, abs: m } = Math, f = computed(
    () => d(m(i.value), m(c.value)) >= o
  ), v = ref(false), g = computed(() => f.value ? m(i.value) > m(c.value) ? i.value > 0 ? "left" : "right" : c.value > 0 ? "up" : "down" : "none"), V = (p, b) => {
    s.x = p, s.y = b;
  }, k = (p, b) => {
    a.x = p, a.y = b;
  };
  let y, C;
  function B(p) {
    y.capture && !y.passive && p.preventDefault();
    const { x: b, y: x } = Ve(p);
    V(b, x), k(b, x), n == null || n(p), C = [
      useEventListener(e, "mousemove", D, y),
      useEventListener(e, "touchmove", D, y),
      useEventListener(e, "mouseup", r, y),
      useEventListener(e, "touchend", r, y),
      useEventListener(e, "touchcancel", r, y)
    ];
  }
  function D(p) {
    const { x: b, y: x } = Ve(p);
    k(b, x), !v.value && f.value && (v.value = true), v.value && (t == null || t(p));
  }
  function r(p) {
    v.value && (u == null || u(p, g.value)), v.value = false, C.forEach((b) => b());
  }
  let w = [];
  return onMounted(() => {
    const p = To(window == null ? void 0 : window.document);
    l ? y = p ? { passive: true } : { capture: false } : y = p ? { passive: false, capture: true } : { capture: true }, w = [
      useEventListener(e, "mousedown", B, y),
      useEventListener(e, "touchstart", B, y)
    ];
  }), {
    isSwiping: v,
    direction: g,
    coordsStart: s,
    coordsEnd: a,
    lengthX: i,
    lengthY: c,
    stop: () => {
      w.forEach((p) => p()), C.forEach((p) => p());
    }
  };
}
function Mo(e, o) {
  const { modelValueLocal: n } = o, t = 0.1, u = 300, l = ref(), s = ref(), a = computed(() => e.showSwipeBanner ? s.value : l.value), i = ref(0), c = ref(true);
  let d = F, m = true, f, v = false;
  const { lengthX: g, lengthY: V, direction: k, isSwiping: y } = So(a, {
    threshold: e.threshold,
    onSwipeStart(r) {
      d = useEventListener(document, "selectionchange", () => {
        var w;
        c.value = (w = window.getSelection()) == null ? void 0 : w.isCollapsed;
      }), f = new Date().getTime(), v = C(r == null ? void 0 : r.target);
    },
    onSwipe() {
      var r, w, P, p;
      if (v && c.value && k.value === e.swipeToClose) {
        if (k.value === "up") {
          const b = Z(Math.abs(V.value || 0), 0, ((r = a.value) == null ? void 0 : r.offsetHeight) || 0) - (e.threshold || 0);
          i.value = b;
        } else if (k.value === "down") {
          const b = Z(Math.abs(V.value || 0), 0, ((w = a.value) == null ? void 0 : w.offsetHeight) || 0) - (e.threshold || 0);
          i.value = -b;
        } else if (k.value === "right") {
          const b = Z(Math.abs(g.value || 0), 0, ((P = a.value) == null ? void 0 : P.offsetWidth) || 0) - (e.threshold || 0);
          i.value = -b;
        } else if (k.value === "left") {
          const b = Z(Math.abs(g.value || 0), 0, ((p = a.value) == null ? void 0 : p.offsetWidth) || 0) - (e.threshold || 0);
          i.value = b;
        }
      }
    },
    onSwipeEnd(r, w) {
      if (d(), !c.value) {
        c.value = true;
        return;
      }
      const P = new Date().getTime(), p = w === e.swipeToClose, b = (() => {
        var W, X;
        if (w === "up" || w === "down")
          return Math.abs((V == null ? void 0 : V.value) || 0) > t * (((W = a.value) == null ? void 0 : W.offsetHeight) || 0);
        if (w === "left" || w === "right")
          return Math.abs((g == null ? void 0 : g.value) || 0) > t * (((X = a.value) == null ? void 0 : X.offsetWidth) || 0);
      })(), x = P - f <= u;
      if (m && v && p && (b || x)) {
        i.value = 0, n.value = false;
        return;
      }
      i.value = 0;
    }
  });
  watch(
    () => c.value,
    (r) => {
      r || (i.value = 0);
    }
  ), watch(
    () => i.value,
    (r, w) => {
      switch (e.swipeToClose) {
        case "down":
        case "right":
          m = r < w;
          break;
        case "up":
        case "left":
          m = r > w;
          break;
      }
    }
  );
  function C(r) {
    const w = r == null ? void 0 : r.tagName;
    if (!w || ["INPUT", "TEXTAREA"].includes(w))
      return false;
    const P = (() => {
      switch (e.swipeToClose) {
        case "up":
          return (r == null ? void 0 : r.scrollTop) + (r == null ? void 0 : r.clientHeight) === (r == null ? void 0 : r.scrollHeight);
        case "left":
          return (r == null ? void 0 : r.scrollLeft) + (r == null ? void 0 : r.clientWidth) === (r == null ? void 0 : r.scrollWidth);
        case "down":
          return (r == null ? void 0 : r.scrollTop) === 0;
        case "right":
          return (r == null ? void 0 : r.scrollLeft) === 0;
        default:
          return false;
      }
    })();
    return r === a.value ? P : P && C(r == null ? void 0 : r.parentElement);
  }
  watch(
    () => n.value,
    (r) => {
      r && (i.value = 0);
    }
  );
  const B = computed(() => {
    if (e.swipeToClose === "none")
      return;
    const r = (() => {
      switch (e.swipeToClose) {
        case "up":
        case "down":
          return "translateY";
        case "left":
        case "right":
          return "translateX";
      }
    })();
    return {
      class: { "vfm-bounce-back": !y.value },
      style: y.value ? { transform: `${r}(${-i.value}px)` } : ""
    };
  });
  function D(r) {
    e.preventNavigationGestures && r.preventDefault();
  }
  return {
    vfmContentEl: l,
    swipeBannerEl: s,
    bindSwipe: B,
    onTouchStartSwipeBanner: D
  };
}
var de = Symbol("vfm");
var fe = Symbol("internalVfm");
var go = defineComponent({
  __name: "CoreModal",
  props: ue,
  emits: ["update:modelValue", "beforeOpen", "opened", "beforeClose", "closed", "clickOutside"],
  setup(e, { emit: o }) {
    const n = e, { modals: t, openedModals: u } = inject(de, {
      modals: [],
      openedModals: []
    }), {
      moveToLastOpenedModals: l,
      openLastOverlay: s,
      deleteFromOpenedModals: a,
      deleteFromModals: i
    } = inject(fe, {
      moveToLastOpenedModals: F,
      openLastOverlay: F,
      deleteFromOpenedModals: F,
      deleteFromModals: F
    }), c = ref(), { zIndex: d, refreshZIndex: m } = wo(n, { openedModals: u }), { focus: f, focusLast: v, blur: g } = lo(n, { focusEl: c, openedModals: u }), { enableBodyScroll: V, disableBodyScroll: k } = yo(n, { lockScrollEl: c }), { modelValueLocal: y } = to(n, o), { emitEvent: C } = ho(o);
    let B = F;
    const {
      visible: D,
      contentVisible: r,
      contentListeners: w,
      contentTransition: P,
      overlayVisible: p,
      overlayListeners: b,
      overlayTransition: x,
      enterTransition: W,
      leaveTransition: X
    } = oo(n, {
      modelValueLocal: y,
      async onEntering() {
        f(), await nextTick(), k();
      },
      onEnter() {
        C("opened"), B("opened");
      },
      onLeaving() {
        g();
      },
      onLeave() {
        C("closed"), B("closed");
      }
    }), { onEsc: ve, onMouseupRoot: He, onMousedown: pe } = no(n, o, { vfmRootEl: c, visible: D, modelValueLocal: y }), {
      vfmContentEl: Ne,
      swipeBannerEl: je,
      bindSwipe: Ye,
      onTouchStartSwipeBanner: me
    } = Mo(n, { modelValueLocal: y }), ye = toRef(n, "hideOverlay"), N = computed(() => ({
      modalId: n.modalId,
      hideOverlay: ye,
      overlayVisible: p,
      focus: f,
      toggle(T) {
        return new Promise((S) => {
          B = bo((ze) => S(ze));
          const M = typeof T == "boolean" ? T : !y.value;
          y.value = M, o("update:modelValue", M);
        });
      }
    }));
    onMounted(() => {
      t.push(N);
    }), y.value && he(), watch(y, (T) => {
      T ? he() : $e();
    });
    async function he() {
      C("beforeOpen"), m(), l(N), s(), W();
    }
    function $e() {
      C("beforeClose"), V(), a(N), v(), s(), X();
    }
    return onBeforeUnmount(() => {
      V(), i(N), a(N), v(), s();
    }), (T, S) => T.displayDirective !== "if" || unref(D) ? withDirectives((openBlock(), createElementBlock("div", {
      key: 0,
      ref_key: "vfmRootEl",
      ref: c,
      class: normalizeClass(["vfm vfm--fixed vfm--inset", { "vfm--prevent-none": T.background === "interactive" }]),
      style: normalizeStyle({ zIndex: unref(d) }),
      role: "dialog",
      "aria-modal": "true",
      onKeydown: S[7] || (S[7] = withKeys(
        //@ts-ignore
        (...M) => unref(ve) && unref(ve)(...M),
        ["esc"]
      )),
      onMouseup: S[8] || (S[8] = withModifiers(() => unref(He)(), ["self"])),
      onMousedown: S[9] || (S[9] = withModifiers((M) => unref(pe)(M), ["self"]))
    }, [
      unref(ye) ? createCommentVNode("", true) : (openBlock(), createBlock(Transition, mergeProps({ key: 0 }, unref(x), { appear: "" }, toHandlers(unref(b))), {
        default: withCtx(() => [
          unref(p) ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(["vfm__overlay vfm--overlay vfm--absolute vfm--inset vfm--prevent-none", T.overlayClass]),
            style: normalizeStyle([{ "z-index": "-1" }, T.overlayStyle]),
            "aria-hidden": "true"
          }, null, 6)) : createCommentVNode("", true)
        ]),
        _: 1
      }, 16)),
      createVNode(Transition, mergeProps(unref(P), { appear: "" }, toHandlers(unref(w))), {
        default: withCtx(() => [
          withDirectives(createBaseVNode("div", mergeProps({
            ref_key: "vfmContentEl",
            ref: Ne,
            class: ["vfm__content vfm--outline-none", [T.contentClass, { "vfm--prevent-auto": T.background === "interactive" }]],
            style: T.contentStyle,
            tabindex: "0"
          }, unref(Ye), {
            onMousedown: S[6] || (S[6] = () => unref(pe)())
          }), [
            renderSlot(T.$slots, "default"),
            T.showSwipeBanner ? (openBlock(), createElementBlock("div", {
              key: 0,
              ref_key: "swipeBannerEl",
              ref: je,
              class: "vfm-swipe-banner-container",
              onTouchstart: S[2] || (S[2] = (M) => unref(me)(M))
            }, [
              renderSlot(T.$slots, "swipe-banner", {}, () => [
                createBaseVNode("div", {
                  class: "vfm-swipe-banner-back",
                  onTouchstart: S[0] || (S[0] = (M) => T.swipeToClose === "left" && M.preventDefault())
                }, null, 32),
                createBaseVNode("div", {
                  class: "vfm-swipe-banner-forward",
                  onTouchstart: S[1] || (S[1] = (M) => T.swipeToClose === "right" && M.preventDefault())
                }, null, 32)
              ])
            ], 544)) : !T.showSwipeBanner && T.preventNavigationGestures ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: "vfm-swipe-banner-container",
              onTouchstart: S[5] || (S[5] = (M) => unref(me)(M))
            }, [
              createBaseVNode("div", {
                class: "vfm-swipe-banner-back",
                onTouchstart: S[3] || (S[3] = (M) => T.swipeToClose === "left" && M.preventDefault())
              }, null, 32),
              createBaseVNode("div", {
                class: "vfm-swipe-banner-forward",
                onTouchstart: S[4] || (S[4] = (M) => T.swipeToClose === "right" && M.preventDefault())
              }, null, 32)
            ], 32)) : createCommentVNode("", true)
          ], 16), [
            [vShow, unref(r)]
          ])
        ]),
        _: 3
      }, 16)
    ], 38)), [
      [vShow, T.displayDirective !== "show" || unref(D)]
    ]) : createCommentVNode("", true);
  }
});
var Co = {
  ...ue,
  /**
   * @description Set `null | false` to disable teleport.
   * @default `'body'`
   * @example
   * ```js
   * teleportTo: '#modals'
   * ```
   */
  teleportTo: {
    type: [String, null, Boolean, Object],
    default: "body"
  }
};
var Eo = defineComponent({
  inheritAttrs: false
});
var Oo = defineComponent({
  ...Eo,
  __name: "VueFinalModal",
  props: Co,
  emits: ["update:modelValue", "beforeOpen", "opened", "beforeClose", "closed", "clickOutside"],
  setup(e, { emit: o }) {
    const t = Po({
      props: e,
      modalProps: ue,
      emit: o
    });
    return (u, l) => (openBlock(), createBlock(Teleport, {
      to: u.teleportTo ? u.teleportTo : void 0,
      disabled: !u.teleportTo
    }, [
      createVNode(go, normalizeProps(guardReactiveProps(unref(t))), {
        default: withCtx(() => [
          renderSlot(u.$slots, "default")
        ]),
        _: 3
      }, 16)
    ], 8, ["to", "disabled"]));
  }
});
function Re() {
  return inject(de);
}
function Vo() {
  return inject(fe);
}
function ke(e, o = Oo) {
  const { component: n, slots: t, ...u } = e, l = typeof t > "u" ? {} : Object.fromEntries(Object.entries(t).map(([s, a]) => isString(a) ? [s, a] : "component" in a ? [s, {
    ...a,
    component: markRaw(a.component)
  }] : [s, markRaw(a)]));
  return {
    ...u,
    component: markRaw(n || o),
    slots: l
  };
}
function Ro(e) {
  var a;
  const o = reactive({
    id: Symbol("useModal"),
    modelValue: !!(e != null && e.defaultModelValue),
    resolveOpened: () => {
    },
    resolveClosed: () => {
    },
    attrs: {},
    ...ke(e)
  });
  o.context || (getCurrentInstance() ? o.context = Re() : console.warn("[Vue Final Modal warn] useModal() can only be used inside setup() or functional components."));
  function n() {
    return o.modelValue ? Promise.resolve("[Vue Final Modal] modal is already opened") : (o.modelValue = true, new Promise((i) => {
      o.resolveOpened = () => i("opened");
    }));
  }
  function t() {
    return o.modelValue ? (o.modelValue = false, new Promise((i) => {
      o.resolveClosed = () => i("closed");
    })) : Promise.resolve("[Vue Final Modal] modal is already closed");
  }
  function u(i) {
    const { slots: c, ...d } = ke(i, o.component);
    Be(o, d), c && Object.entries(c).forEach(([m, f]) => {
      const v = o.slots[m];
      isString(v) ? o.slots[m] = f : Le(v) && Le(f) ? Be(v, f) : o.slots[m] = f;
    });
  }
  function l() {
    if (!o.context)
      return;
    const i = o.context.dynamicModals.indexOf(o);
    i !== -1 && o.context.dynamicModals.splice(i, 1);
  }
  const s = {
    options: o,
    open: n,
    close: t,
    patchOptions: u,
    destroy: l
  };
  return (a = s.options.context) == null || a.dynamicModals.push(s.options), tryOnUnmounted(() => s.destroy()), s;
}
function Ho(e) {
  return e;
}
function ko(e, o) {
  return Object.entries(o).forEach(([n, t]) => {
    e[n] = t;
  }), e;
}
function Be(e, o) {
  o.component && (e.component = o.component), o.attrs && ko(e.attrs, o.attrs);
}
function Le(e) {
  return "component" in e || "attrs" in e;
}
function Bo(e, o) {
  return Object.keys(o).reduce((n, t) => (n[t] = e[t], n), {});
}
function Lo(e) {
  return e ? {
    "onUpdate:modelValue": (o) => e("update:modelValue", o),
    onBeforeClose: () => e("beforeClose"),
    onClosed: () => e("closed"),
    onBeforeOpen: () => e("beforeOpen"),
    onOpened: () => e("opened"),
    /** onClickOutside will only be emitted when clickToClose equal to `false` */
    onClickOutside: () => e("clickOutside")
  } : {};
}
function Po(e) {
  const { props: o, modalProps: n, emit: t } = e, u = computed(() => Bo(o, n)), l = Lo(t), s = useAttrs();
  return computed(() => ({
    ...u.value,
    ...l,
    ...s
  }));
}
var Io = ["innerHTML"];
var No = defineComponent({
  __name: "ModalsContainer",
  setup(e) {
    const o = Re(), n = Vo(), t = Symbol("ModalsContainer"), u = computed(() => {
      var i;
      return t === ((i = o.modalsContainers.value) == null ? void 0 : i[0]);
    }), l = shallowRef([]);
    function s() {
      l.value = o.dynamicModals.filter((i) => i.modelValue);
    }
    function a(i) {
      i == null || i(), s();
    }
    return watch(() => {
      var i;
      return (i = o.dynamicModals) == null ? void 0 : i.map((c) => c.modelValue);
    }, (i, c) => {
      if (!c || i.length !== c.length) {
        s();
        return;
      }
      let d = i.length, m = false;
      for (; !m && d--; )
        i[d] === true && c[d] === false && (m = true);
      m && s();
    }, {
      immediate: true
    }), o.modalsContainers.value.push(t), onBeforeUnmount(() => {
      o.modalsContainers.value = o.modalsContainers.value.filter((i) => i !== t);
    }), (i, c) => unref(u) ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(l), (d, m) => (openBlock(), createBlock(resolveDynamicComponent(d.component), mergeProps({
      key: d.id
    }, d.attrs, {
      modelValue: d.modelValue,
      "onUpdate:modelValue": (f) => d.modelValue = f,
      onClosed: (f) => a(() => {
        var v, g;
        return (g = (v = unref(n)).resolvedClosed) == null ? void 0 : g.call(v, m);
      }),
      onOpened: () => {
        var f, v;
        return (v = (f = unref(n)).resolvedOpened) == null ? void 0 : v.call(f, m);
      }
    }), createSlots({ _: 2 }, [
      renderList(d.slots, (f, v) => ({
        name: v,
        fn: withCtx(() => [
          unref(isString)(f) ? (openBlock(), createElementBlock("div", {
            key: 0,
            innerHTML: f
          }, null, 8, Io)) : "component" in f ? (openBlock(), createBlock(resolveDynamicComponent(f.component), normalizeProps(mergeProps({ key: 1 }, f.attrs)), null, 16)) : (openBlock(), createBlock(resolveDynamicComponent(f), { key: 2 }))
        ])
      }))
    ]), 1040, ["modelValue", "onUpdate:modelValue", "onClosed", "onOpened"]))), 128)) : createCommentVNode("", true);
  }
});
function jo() {
  const e = shallowReactive([]), o = shallowReactive([]), n = shallowReactive([]), t = ref([]), u = markRaw({
    install(l) {
      l.provide(de, u), l.config.globalProperties.$vfm = u;
      const s = Do(u);
      l.provide(fe, s);
    },
    modals: e,
    openedModals: o,
    dynamicModals: n,
    modalsContainers: t,
    get(l) {
      return e.find((s) => s.value.modalId && l === s.value.modalId);
    },
    toggle(l, s) {
      const a = u.get(l);
      return a == null ? void 0 : a.value.toggle(s);
    },
    open(l) {
      return u.toggle(l, true);
    },
    close(l) {
      return u.toggle(l, false);
    },
    closeAll() {
      return Promise.allSettled([o.map((l) => l.value.toggle(false))]);
    }
  });
  return u;
}
function Do(e) {
  const { modals: o, openedModals: n, dynamicModals: t } = e, u = {
    deleteFromModals(l) {
      const s = o.findIndex((a) => a.value === l.value);
      s !== -1 && o.splice(s, 1);
    },
    moveToLastOpenedModals(l) {
      u.deleteFromOpenedModals(l), n.push(l);
    },
    deleteFromOpenedModals(l) {
      const s = n.findIndex((a) => a.value === l.value);
      s !== -1 && n.splice(s, 1);
    },
    async openLastOverlay() {
      var l;
      if (await nextTick(), n.forEach((s) => s.value.overlayVisible.value = false), n.length > 0) {
        const s = n[n.length - 1];
        !((l = s.value.hideOverlay) != null && l.value) && (s.value.overlayVisible.value = true);
      }
    },
    resolvedClosed(l) {
      var s, a;
      (a = (s = t[l]) == null ? void 0 : s.resolveClosed) == null || a.call(s);
    },
    resolvedOpened(l) {
      var s, a;
      (a = (s = t[l]) == null ? void 0 : s.resolveOpened) == null || a.call(s);
    }
  };
  return u;
}
export {
  go as CoreModal,
  No as ModalsContainer,
  Oo as VueFinalModal,
  ue as coreModalProps,
  jo as createVfm,
  Ro as useModal,
  Ho as useModalSlot,
  Re as useVfm,
  Po as useVfmAttrs,
  Co as vueFinalModalProps
};
/*! Bundled license information:

tabbable/dist/index.esm.js:
  (*!
  * tabbable 6.0.1
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)

focus-trap/dist/focus-trap.esm.js:
  (*!
  * focus-trap 7.2.0
  * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
  *)
*/
//# sourceMappingURL=vue-final-modal.js.map
