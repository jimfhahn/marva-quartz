var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var require_index_001 = __commonJS({
  "assets/index-JG6QQx_o.js"(exports, module) {
    (function polyfill() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) {
        return;
      }
      for (const link2 of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link2);
      }
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") {
            continue;
          }
          for (const node of mutation.addedNodes) {
            if (node.tagName === "LINK" && node.rel === "modulepreload")
              processPreload(node);
          }
        }
      }).observe(document, { childList: true, subtree: true });
      function getFetchOpts(link2) {
        const fetchOpts = {};
        if (link2.integrity)
          fetchOpts.integrity = link2.integrity;
        if (link2.referrerPolicy)
          fetchOpts.referrerPolicy = link2.referrerPolicy;
        if (link2.crossOrigin === "use-credentials")
          fetchOpts.credentials = "include";
        else if (link2.crossOrigin === "anonymous")
          fetchOpts.credentials = "omit";
        else
          fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link2) {
        if (link2.ep)
          return;
        link2.ep = true;
        const fetchOpts = getFetchOpts(link2);
        fetch(link2.href, fetchOpts);
      }
    })();
    /**
    * @vue/shared v3.4.27
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    /*! #__NO_SIDE_EFFECTS__ */
    // @__NO_SIDE_EFFECTS__
    function makeMap(str, expectsLowerCase) {
      const set2 = new Set(str.split(","));
      return (val) => set2.has(val);
    }
    const EMPTY_OBJ = {};
    const EMPTY_ARR = [];
    const NOOP = () => {
    };
    const NO = () => false;
    const isOn = (key2) => key2.charCodeAt(0) === 111 && key2.charCodeAt(1) === 110 && // uppercase letter
    (key2.charCodeAt(2) > 122 || key2.charCodeAt(2) < 97);
    const isModelListener = (key2) => key2.startsWith("onUpdate:");
    const extend$1 = Object.assign;
    const remove = (arr, el) => {
      const i2 = arr.indexOf(el);
      if (i2 > -1) {
        arr.splice(i2, 1);
      }
    };
    const hasOwnProperty$a = Object.prototype.hasOwnProperty;
    const hasOwn$1 = (val, key2) => hasOwnProperty$a.call(val, key2);
    const isArray$4 = Array.isArray;
    const isMap = (val) => toTypeString$2(val) === "[object Map]";
    const isSet = (val) => toTypeString$2(val) === "[object Set]";
    const isDate$2 = (val) => toTypeString$2(val) === "[object Date]";
    const isRegExp$2 = (val) => toTypeString$2(val) === "[object RegExp]";
    const isFunction$3 = (val) => typeof val === "function";
    const isString$2 = (val) => typeof val === "string";
    const isSymbol$1 = (val) => typeof val === "symbol";
    const isObject$6 = (val) => val !== null && typeof val === "object";
    const isPromise$2 = (val) => {
      return (isObject$6(val) || isFunction$3(val)) && isFunction$3(val.then) && isFunction$3(val.catch);
    };
    const objectToString$3 = Object.prototype.toString;
    const toTypeString$2 = (value) => objectToString$3.call(value);
    const toRawType = (value) => {
      return toTypeString$2(value).slice(8, -1);
    };
    const isPlainObject$5 = (val) => toTypeString$2(val) === "[object Object]";
    const isIntegerKey = (key2) => isString$2(key2) && key2 !== "NaN" && key2[0] !== "-" && "" + parseInt(key2, 10) === key2;
    const isReservedProp = /* @__PURE__ */ makeMap(
      // the leading comma is intentional so empty string "" is also included
      ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
    );
    const cacheStringFunction = (fn2) => {
      const cache2 = /* @__PURE__ */ Object.create(null);
      return (str) => {
        const hit = cache2[str];
        return hit || (cache2[str] = fn2(str));
      };
    };
    const camelizeRE = /-(\w)/g;
    const camelize = cacheStringFunction((str) => {
      return str.replace(camelizeRE, (_2, c2) => c2 ? c2.toUpperCase() : "");
    });
    const hyphenateRE = /\B([A-Z])/g;
    const hyphenate = cacheStringFunction(
      (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
    );
    const capitalize$1 = cacheStringFunction((str) => {
      return str.charAt(0).toUpperCase() + str.slice(1);
    });
    const toHandlerKey = cacheStringFunction((str) => {
      const s2 = str ? `on${capitalize$1(str)}` : ``;
      return s2;
    });
    const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
    const invokeArrayFns = (fns, arg) => {
      for (let i2 = 0; i2 < fns.length; i2++) {
        fns[i2](arg);
      }
    };
    const def = (obj, key2, value, writable = false) => {
      Object.defineProperty(obj, key2, {
        configurable: true,
        enumerable: false,
        writable,
        value
      });
    };
    const looseToNumber = (val) => {
      const n2 = parseFloat(val);
      return isNaN(n2) ? val : n2;
    };
    const toNumber = (val) => {
      const n2 = isString$2(val) ? Number(val) : NaN;
      return isNaN(n2) ? val : n2;
    };
    let _globalThis$1;
    const getGlobalThis$1 = () => {
      return _globalThis$1 || (_globalThis$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    };
    const GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error";
    const isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);
    function normalizeStyle(value) {
      if (isArray$4(value)) {
        const res = {};
        for (let i2 = 0; i2 < value.length; i2++) {
          const item = value[i2];
          const normalized = isString$2(item) ? parseStringStyle(item) : normalizeStyle(item);
          if (normalized) {
            for (const key2 in normalized) {
              res[key2] = normalized[key2];
            }
          }
        }
        return res;
      } else if (isString$2(value) || isObject$6(value)) {
        return value;
      }
    }
    const listDelimiterRE = /;(?![^(]*\))/g;
    const propertyDelimiterRE = /:([^]+)/;
    const styleCommentRE = /\/\*[^]*?\*\//g;
    function parseStringStyle(cssText) {
      const ret = {};
      cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
        if (item) {
          const tmp = item.split(propertyDelimiterRE);
          tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
      });
      return ret;
    }
    function normalizeClass(value) {
      let res = "";
      if (isString$2(value)) {
        res = value;
      } else if (isArray$4(value)) {
        for (let i2 = 0; i2 < value.length; i2++) {
          const normalized = normalizeClass(value[i2]);
          if (normalized) {
            res += normalized + " ";
          }
        }
      } else if (isObject$6(value)) {
        for (const name in value) {
          if (value[name]) {
            res += name + " ";
          }
        }
      }
      return res.trim();
    }
    function normalizeProps(props) {
      if (!props)
        return null;
      let { class: klass, style } = props;
      if (klass && !isString$2(klass)) {
        props.class = normalizeClass(klass);
      }
      if (style) {
        props.style = normalizeStyle(style);
      }
      return props;
    }
    const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
    const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
    function includeBooleanAttr(value) {
      return !!value || value === "";
    }
    function looseCompareArrays(a2, b2) {
      if (a2.length !== b2.length)
        return false;
      let equal = true;
      for (let i2 = 0; equal && i2 < a2.length; i2++) {
        equal = looseEqual(a2[i2], b2[i2]);
      }
      return equal;
    }
    function looseEqual(a2, b2) {
      if (a2 === b2)
        return true;
      let aValidType = isDate$2(a2);
      let bValidType = isDate$2(b2);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? a2.getTime() === b2.getTime() : false;
      }
      aValidType = isSymbol$1(a2);
      bValidType = isSymbol$1(b2);
      if (aValidType || bValidType) {
        return a2 === b2;
      }
      aValidType = isArray$4(a2);
      bValidType = isArray$4(b2);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? looseCompareArrays(a2, b2) : false;
      }
      aValidType = isObject$6(a2);
      bValidType = isObject$6(b2);
      if (aValidType || bValidType) {
        if (!aValidType || !bValidType) {
          return false;
        }
        const aKeysCount = Object.keys(a2).length;
        const bKeysCount = Object.keys(b2).length;
        if (aKeysCount !== bKeysCount) {
          return false;
        }
        for (const key2 in a2) {
          const aHasKey = a2.hasOwnProperty(key2);
          const bHasKey = b2.hasOwnProperty(key2);
          if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a2[key2], b2[key2])) {
            return false;
          }
        }
      }
      return String(a2) === String(b2);
    }
    function looseIndexOf(arr, val) {
      return arr.findIndex((item) => looseEqual(item, val));
    }
    const toDisplayString$2 = (val) => {
      return isString$2(val) ? val : val == null ? "" : isArray$4(val) || isObject$6(val) && (val.toString === objectToString$3 || !isFunction$3(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
    };
    const replacer = (_key, val) => {
      if (val && val.__v_isRef) {
        return replacer(_key, val.value);
      } else if (isMap(val)) {
        return {
          [`Map(${val.size})`]: [...val.entries()].reduce(
            (entries, [key2, val2], i2) => {
              entries[stringifySymbol(key2, i2) + " =>"] = val2;
              return entries;
            },
            {}
          )
        };
      } else if (isSet(val)) {
        return {
          [`Set(${val.size})`]: [...val.values()].map((v2) => stringifySymbol(v2))
        };
      } else if (isSymbol$1(val)) {
        return stringifySymbol(val);
      } else if (isObject$6(val) && !isArray$4(val) && !isPlainObject$5(val)) {
        return String(val);
      }
      return val;
    };
    const stringifySymbol = (v2, i2 = "") => {
      var _a;
      return (
        // Symbol.description in es2019+ so we need to cast here to pass
        // the lib: es2016 check
        isSymbol$1(v2) ? `Symbol(${(_a = v2.description) != null ? _a : i2})` : v2
      );
    };
    /**
    * @vue/reactivity v3.4.27
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    let activeEffectScope;
    class EffectScope {
      constructor(detached = false) {
        this.detached = detached;
        this._active = true;
        this.effects = [];
        this.cleanups = [];
        this.parent = activeEffectScope;
        if (!detached && activeEffectScope) {
          this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
            this
          ) - 1;
        }
      }
      get active() {
        return this._active;
      }
      run(fn2) {
        if (this._active) {
          const currentEffectScope = activeEffectScope;
          try {
            activeEffectScope = this;
            return fn2();
          } finally {
            activeEffectScope = currentEffectScope;
          }
        }
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      on() {
        activeEffectScope = this;
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      off() {
        activeEffectScope = this.parent;
      }
      stop(fromParent) {
        if (this._active) {
          let i2, l2;
          for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
            this.effects[i2].stop();
          }
          for (i2 = 0, l2 = this.cleanups.length; i2 < l2; i2++) {
            this.cleanups[i2]();
          }
          if (this.scopes) {
            for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
              this.scopes[i2].stop(true);
            }
          }
          if (!this.detached && this.parent && !fromParent) {
            const last = this.parent.scopes.pop();
            if (last && last !== this) {
              this.parent.scopes[this.index] = last;
              last.index = this.index;
            }
          }
          this.parent = void 0;
          this._active = false;
        }
      }
    }
    function effectScope(detached) {
      return new EffectScope(detached);
    }
    function recordEffectScope(effect2, scope = activeEffectScope) {
      if (scope && scope.active) {
        scope.effects.push(effect2);
      }
    }
    function getCurrentScope() {
      return activeEffectScope;
    }
    function onScopeDispose(fn2) {
      if (activeEffectScope) {
        activeEffectScope.cleanups.push(fn2);
      }
    }
    let activeEffect;
    class ReactiveEffect {
      constructor(fn2, trigger2, scheduler, scope) {
        this.fn = fn2;
        this.trigger = trigger2;
        this.scheduler = scheduler;
        this.active = true;
        this.deps = [];
        this._dirtyLevel = 4;
        this._trackId = 0;
        this._runnings = 0;
        this._shouldSchedule = false;
        this._depsLength = 0;
        recordEffectScope(this, scope);
      }
      get dirty() {
        if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
          this._dirtyLevel = 1;
          pauseTracking();
          for (let i2 = 0; i2 < this._depsLength; i2++) {
            const dep = this.deps[i2];
            if (dep.computed) {
              triggerComputed(dep.computed);
              if (this._dirtyLevel >= 4) {
                break;
              }
            }
          }
          if (this._dirtyLevel === 1) {
            this._dirtyLevel = 0;
          }
          resetTracking();
        }
        return this._dirtyLevel >= 4;
      }
      set dirty(v2) {
        this._dirtyLevel = v2 ? 4 : 0;
      }
      run() {
        this._dirtyLevel = 0;
        if (!this.active) {
          return this.fn();
        }
        let lastShouldTrack = shouldTrack;
        let lastEffect = activeEffect;
        try {
          shouldTrack = true;
          activeEffect = this;
          this._runnings++;
          preCleanupEffect(this);
          return this.fn();
        } finally {
          postCleanupEffect(this);
          this._runnings--;
          activeEffect = lastEffect;
          shouldTrack = lastShouldTrack;
        }
      }
      stop() {
        if (this.active) {
          preCleanupEffect(this);
          postCleanupEffect(this);
          this.onStop && this.onStop();
          this.active = false;
        }
      }
    }
    function triggerComputed(computed2) {
      return computed2.value;
    }
    function preCleanupEffect(effect2) {
      effect2._trackId++;
      effect2._depsLength = 0;
    }
    function postCleanupEffect(effect2) {
      if (effect2.deps.length > effect2._depsLength) {
        for (let i2 = effect2._depsLength; i2 < effect2.deps.length; i2++) {
          cleanupDepEffect(effect2.deps[i2], effect2);
        }
        effect2.deps.length = effect2._depsLength;
      }
    }
    function cleanupDepEffect(dep, effect2) {
      const trackId = dep.get(effect2);
      if (trackId !== void 0 && effect2._trackId !== trackId) {
        dep.delete(effect2);
        if (dep.size === 0) {
          dep.cleanup();
        }
      }
    }
    function effect$3(fn2, options) {
      if (fn2.effect instanceof ReactiveEffect) {
        fn2 = fn2.effect.fn;
      }
      const _effect = new ReactiveEffect(fn2, NOOP, () => {
        if (_effect.dirty) {
          _effect.run();
        }
      });
      if (options) {
        extend$1(_effect, options);
        if (options.scope)
          recordEffectScope(_effect, options.scope);
      }
      if (!options || !options.lazy) {
        _effect.run();
      }
      const runner2 = _effect.run.bind(_effect);
      runner2.effect = _effect;
      return runner2;
    }
    function stop(runner2) {
      runner2.effect.stop();
    }
    let shouldTrack = true;
    let pauseScheduleStack = 0;
    const trackStack = [];
    function pauseTracking() {
      trackStack.push(shouldTrack);
      shouldTrack = false;
    }
    function resetTracking() {
      const last = trackStack.pop();
      shouldTrack = last === void 0 ? true : last;
    }
    function pauseScheduling() {
      pauseScheduleStack++;
    }
    function resetScheduling() {
      pauseScheduleStack--;
      while (!pauseScheduleStack && queueEffectSchedulers.length) {
        queueEffectSchedulers.shift()();
      }
    }
    function trackEffect(effect2, dep, debuggerEventExtraInfo) {
      if (dep.get(effect2) !== effect2._trackId) {
        dep.set(effect2, effect2._trackId);
        const oldDep = effect2.deps[effect2._depsLength];
        if (oldDep !== dep) {
          if (oldDep) {
            cleanupDepEffect(oldDep, effect2);
          }
          effect2.deps[effect2._depsLength++] = dep;
        } else {
          effect2._depsLength++;
        }
      }
    }
    const queueEffectSchedulers = [];
    function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
      pauseScheduling();
      for (const effect2 of dep.keys()) {
        let tracking;
        if (effect2._dirtyLevel < dirtyLevel && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
          effect2._shouldSchedule || (effect2._shouldSchedule = effect2._dirtyLevel === 0);
          effect2._dirtyLevel = dirtyLevel;
        }
        if (effect2._shouldSchedule && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
          effect2.trigger();
          if ((!effect2._runnings || effect2.allowRecurse) && effect2._dirtyLevel !== 2) {
            effect2._shouldSchedule = false;
            if (effect2.scheduler) {
              queueEffectSchedulers.push(effect2.scheduler);
            }
          }
        }
      }
      resetScheduling();
    }
    const createDep = (cleanup, computed2) => {
      const dep = /* @__PURE__ */ new Map();
      dep.cleanup = cleanup;
      dep.computed = computed2;
      return dep;
    };
    const targetMap = /* @__PURE__ */ new WeakMap();
    const ITERATE_KEY = Symbol("");
    const MAP_KEY_ITERATE_KEY = Symbol("");
    function track(target, type, key2) {
      if (shouldTrack && activeEffect) {
        let depsMap = targetMap.get(target);
        if (!depsMap) {
          targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
        }
        let dep = depsMap.get(key2);
        if (!dep) {
          depsMap.set(key2, dep = createDep(() => depsMap.delete(key2)));
        }
        trackEffect(
          activeEffect,
          dep
        );
      }
    }
    function trigger$1(target, type, key2, newValue, oldValue, oldTarget) {
      const depsMap = targetMap.get(target);
      if (!depsMap) {
        return;
      }
      let deps = [];
      if (type === "clear") {
        deps = [...depsMap.values()];
      } else if (key2 === "length" && isArray$4(target)) {
        const newLength = Number(newValue);
        depsMap.forEach((dep, key22) => {
          if (key22 === "length" || !isSymbol$1(key22) && key22 >= newLength) {
            deps.push(dep);
          }
        });
      } else {
        if (key2 !== void 0) {
          deps.push(depsMap.get(key2));
        }
        switch (type) {
          case "add":
            if (!isArray$4(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
              if (isMap(target)) {
                deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            } else if (isIntegerKey(key2)) {
              deps.push(depsMap.get("length"));
            }
            break;
          case "delete":
            if (!isArray$4(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
              if (isMap(target)) {
                deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            }
            break;
          case "set":
            if (isMap(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
            }
            break;
        }
      }
      pauseScheduling();
      for (const dep of deps) {
        if (dep) {
          triggerEffects(
            dep,
            4
          );
        }
      }
      resetScheduling();
    }
    function getDepFromReactive(object, key2) {
      const depsMap = targetMap.get(object);
      return depsMap && depsMap.get(key2);
    }
    const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
    const builtInSymbols = new Set(
      /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key2) => key2 !== "arguments" && key2 !== "caller").map((key2) => Symbol[key2]).filter(isSymbol$1)
    );
    const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
    function createArrayInstrumentations() {
      const instrumentations = {};
      ["includes", "indexOf", "lastIndexOf"].forEach((key2) => {
        instrumentations[key2] = function(...args) {
          const arr = toRaw(this);
          for (let i2 = 0, l2 = this.length; i2 < l2; i2++) {
            track(arr, "get", i2 + "");
          }
          const res = arr[key2](...args);
          if (res === -1 || res === false) {
            return arr[key2](...args.map(toRaw));
          } else {
            return res;
          }
        };
      });
      ["push", "pop", "shift", "unshift", "splice"].forEach((key2) => {
        instrumentations[key2] = function(...args) {
          pauseTracking();
          pauseScheduling();
          const res = toRaw(this)[key2].apply(this, args);
          resetScheduling();
          resetTracking();
          return res;
        };
      });
      return instrumentations;
    }
    function hasOwnProperty$9(key2) {
      if (!isSymbol$1(key2))
        key2 = String(key2);
      const obj = toRaw(this);
      track(obj, "has", key2);
      return obj.hasOwnProperty(key2);
    }
    class BaseReactiveHandler {
      constructor(_isReadonly = false, _isShallow = false) {
        this._isReadonly = _isReadonly;
        this._isShallow = _isShallow;
      }
      get(target, key2, receiver) {
        const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
        if (key2 === "__v_isReactive") {
          return !isReadonly2;
        } else if (key2 === "__v_isReadonly") {
          return isReadonly2;
        } else if (key2 === "__v_isShallow") {
          return isShallow2;
        } else if (key2 === "__v_raw") {
          if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
          // this means the reciever is a user proxy of the reactive proxy
          Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
            return target;
          }
          return;
        }
        const targetIsArray = isArray$4(target);
        if (!isReadonly2) {
          if (targetIsArray && hasOwn$1(arrayInstrumentations, key2)) {
            return Reflect.get(arrayInstrumentations, key2, receiver);
          }
          if (key2 === "hasOwnProperty") {
            return hasOwnProperty$9;
          }
        }
        const res = Reflect.get(target, key2, receiver);
        if (isSymbol$1(key2) ? builtInSymbols.has(key2) : isNonTrackableKeys(key2)) {
          return res;
        }
        if (!isReadonly2) {
          track(target, "get", key2);
        }
        if (isShallow2) {
          return res;
        }
        if (isRef(res)) {
          return targetIsArray && isIntegerKey(key2) ? res : res.value;
        }
        if (isObject$6(res)) {
          return isReadonly2 ? readonly(res) : reactive(res);
        }
        return res;
      }
    }
    class MutableReactiveHandler extends BaseReactiveHandler {
      constructor(isShallow2 = false) {
        super(false, isShallow2);
      }
      set(target, key2, value, receiver) {
        let oldValue = target[key2];
        if (!this._isShallow) {
          const isOldValueReadonly = isReadonly(oldValue);
          if (!isShallow(value) && !isReadonly(value)) {
            oldValue = toRaw(oldValue);
            value = toRaw(value);
          }
          if (!isArray$4(target) && isRef(oldValue) && !isRef(value)) {
            if (isOldValueReadonly) {
              return false;
            } else {
              oldValue.value = value;
              return true;
            }
          }
        }
        const hadKey = isArray$4(target) && isIntegerKey(key2) ? Number(key2) < target.length : hasOwn$1(target, key2);
        const result = Reflect.set(target, key2, value, receiver);
        if (target === toRaw(receiver)) {
          if (!hadKey) {
            trigger$1(target, "add", key2, value);
          } else if (hasChanged(value, oldValue)) {
            trigger$1(target, "set", key2, value);
          }
        }
        return result;
      }
      deleteProperty(target, key2) {
        const hadKey = hasOwn$1(target, key2);
        target[key2];
        const result = Reflect.deleteProperty(target, key2);
        if (result && hadKey) {
          trigger$1(target, "delete", key2, void 0);
        }
        return result;
      }
      has(target, key2) {
        const result = Reflect.has(target, key2);
        if (!isSymbol$1(key2) || !builtInSymbols.has(key2)) {
          track(target, "has", key2);
        }
        return result;
      }
      ownKeys(target) {
        track(
          target,
          "iterate",
          isArray$4(target) ? "length" : ITERATE_KEY
        );
        return Reflect.ownKeys(target);
      }
    }
    class ReadonlyReactiveHandler extends BaseReactiveHandler {
      constructor(isShallow2 = false) {
        super(true, isShallow2);
      }
      set(target, key2) {
        return true;
      }
      deleteProperty(target, key2) {
        return true;
      }
    }
    const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
    const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
    const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(
      true
    );
    const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
    const toShallow = (value) => value;
    const getProto = (v2) => Reflect.getPrototypeOf(v2);
    function get(target, key2, isReadonly2 = false, isShallow2 = false) {
      target = target["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key2);
      if (!isReadonly2) {
        if (hasChanged(key2, rawKey)) {
          track(rawTarget, "get", key2);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has: has2 } = getProto(rawTarget);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      if (has2.call(rawTarget, key2)) {
        return wrap(target.get(key2));
      } else if (has2.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key2);
      }
    }
    function has(key2, isReadonly2 = false) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key2);
      if (!isReadonly2) {
        if (hasChanged(key2, rawKey)) {
          track(rawTarget, "has", key2);
        }
        track(rawTarget, "has", rawKey);
      }
      return key2 === rawKey ? target.has(key2) : target.has(key2) || target.has(rawKey);
    }
    function size$1(target, isReadonly2 = false) {
      target = target["__v_raw"];
      !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
      return Reflect.get(target, "size", target);
    }
    function add(value) {
      value = toRaw(value);
      const target = toRaw(this);
      const proto = getProto(target);
      const hadKey = proto.has.call(target, value);
      if (!hadKey) {
        target.add(value);
        trigger$1(target, "add", value, value);
      }
      return this;
    }
    function set(key2, value) {
      value = toRaw(value);
      const target = toRaw(this);
      const { has: has2, get: get2 } = getProto(target);
      let hadKey = has2.call(target, key2);
      if (!hadKey) {
        key2 = toRaw(key2);
        hadKey = has2.call(target, key2);
      }
      const oldValue = get2.call(target, key2);
      target.set(key2, value);
      if (!hadKey) {
        trigger$1(target, "add", key2, value);
      } else if (hasChanged(value, oldValue)) {
        trigger$1(target, "set", key2, value);
      }
      return this;
    }
    function deleteEntry(key2) {
      const target = toRaw(this);
      const { has: has2, get: get2 } = getProto(target);
      let hadKey = has2.call(target, key2);
      if (!hadKey) {
        key2 = toRaw(key2);
        hadKey = has2.call(target, key2);
      }
      get2 ? get2.call(target, key2) : void 0;
      const result = target.delete(key2);
      if (hadKey) {
        trigger$1(target, "delete", key2, void 0);
      }
      return result;
    }
    function clear() {
      const target = toRaw(this);
      const hadItems = target.size !== 0;
      const result = target.clear();
      if (hadItems) {
        trigger$1(target, "clear", void 0, void 0);
      }
      return result;
    }
    function createForEach(isReadonly2, isShallow2) {
      return function forEach(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw"];
        const rawTarget = toRaw(target);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
        return target.forEach((value, key2) => {
          return callback.call(thisArg, wrap(value), wrap(key2), observed);
        });
      };
    }
    function createIterableMethod(method, isReadonly2, isShallow2) {
      return function(...args) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const targetIsMap = isMap(rawTarget);
        const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
        const isKeyOnly = method === "keys" && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(
          rawTarget,
          "iterate",
          isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
        );
        return {
          // iterator protocol
          next() {
            const { value, done } = innerIterator.next();
            return done ? { value, done } : {
              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
              done
            };
          },
          // iterable protocol
          [Symbol.iterator]() {
            return this;
          }
        };
      };
    }
    function createReadonlyMethod(type) {
      return function(...args) {
        return type === "delete" ? false : type === "clear" ? void 0 : this;
      };
    }
    function createInstrumentations() {
      const mutableInstrumentations2 = {
        get(key2) {
          return get(this, key2);
        },
        get size() {
          return size$1(this);
        },
        has,
        add,
        set,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, false)
      };
      const shallowInstrumentations2 = {
        get(key2) {
          return get(this, key2, false, true);
        },
        get size() {
          return size$1(this);
        },
        has,
        add,
        set,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, true)
      };
      const readonlyInstrumentations2 = {
        get(key2) {
          return get(this, key2, true);
        },
        get size() {
          return size$1(this, true);
        },
        has(key2) {
          return has.call(this, key2, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, false)
      };
      const shallowReadonlyInstrumentations2 = {
        get(key2) {
          return get(this, key2, true, true);
        },
        get size() {
          return size$1(this, true);
        },
        has(key2) {
          return has.call(this, key2, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, true)
      };
      const iteratorMethods = [
        "keys",
        "values",
        "entries",
        Symbol.iterator
      ];
      iteratorMethods.forEach((method) => {
        mutableInstrumentations2[method] = createIterableMethod(method, false, false);
        readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
        shallowInstrumentations2[method] = createIterableMethod(method, false, true);
        shallowReadonlyInstrumentations2[method] = createIterableMethod(
          method,
          true,
          true
        );
      });
      return [
        mutableInstrumentations2,
        readonlyInstrumentations2,
        shallowInstrumentations2,
        shallowReadonlyInstrumentations2
      ];
    }
    const [
      mutableInstrumentations,
      readonlyInstrumentations,
      shallowInstrumentations,
      shallowReadonlyInstrumentations
    ] = /* @__PURE__ */ createInstrumentations();
    function createInstrumentationGetter(isReadonly2, shallow) {
      const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
      return (target, key2, receiver) => {
        if (key2 === "__v_isReactive") {
          return !isReadonly2;
        } else if (key2 === "__v_isReadonly") {
          return isReadonly2;
        } else if (key2 === "__v_raw") {
          return target;
        }
        return Reflect.get(
          hasOwn$1(instrumentations, key2) && key2 in target ? instrumentations : target,
          key2,
          receiver
        );
      };
    }
    const mutableCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, false)
    };
    const shallowCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, true)
    };
    const readonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, false)
    };
    const shallowReadonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, true)
    };
    const reactiveMap = /* @__PURE__ */ new WeakMap();
    const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
    const readonlyMap = /* @__PURE__ */ new WeakMap();
    const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
    function targetTypeMap(rawType) {
      switch (rawType) {
        case "Object":
        case "Array":
          return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
          return 2;
        default:
          return 0;
      }
    }
    function getTargetType(value) {
      return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
    }
    function reactive(target) {
      if (isReadonly(target)) {
        return target;
      }
      return createReactiveObject(
        target,
        false,
        mutableHandlers,
        mutableCollectionHandlers,
        reactiveMap
      );
    }
    function shallowReactive(target) {
      return createReactiveObject(
        target,
        false,
        shallowReactiveHandlers,
        shallowCollectionHandlers,
        shallowReactiveMap
      );
    }
    function readonly(target) {
      return createReactiveObject(
        target,
        true,
        readonlyHandlers,
        readonlyCollectionHandlers,
        readonlyMap
      );
    }
    function shallowReadonly(target) {
      return createReactiveObject(
        target,
        true,
        shallowReadonlyHandlers,
        shallowReadonlyCollectionHandlers,
        shallowReadonlyMap
      );
    }
    function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
      if (!isObject$6(target)) {
        return target;
      }
      if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
        return target;
      }
      const existingProxy = proxyMap.get(target);
      if (existingProxy) {
        return existingProxy;
      }
      const targetType = getTargetType(target);
      if (targetType === 0) {
        return target;
      }
      const proxy = new Proxy(
        target,
        targetType === 2 ? collectionHandlers : baseHandlers
      );
      proxyMap.set(target, proxy);
      return proxy;
    }
    function isReactive(value) {
      if (isReadonly(value)) {
        return isReactive(value["__v_raw"]);
      }
      return !!(value && value["__v_isReactive"]);
    }
    function isReadonly(value) {
      return !!(value && value["__v_isReadonly"]);
    }
    function isShallow(value) {
      return !!(value && value["__v_isShallow"]);
    }
    function isProxy(value) {
      return value ? !!value["__v_raw"] : false;
    }
    function toRaw(observed) {
      const raw = observed && observed["__v_raw"];
      return raw ? toRaw(raw) : observed;
    }
    function markRaw(value) {
      if (Object.isExtensible(value)) {
        def(value, "__v_skip", true);
      }
      return value;
    }
    const toReactive = (value) => isObject$6(value) ? reactive(value) : value;
    const toReadonly = (value) => isObject$6(value) ? readonly(value) : value;
    class ComputedRefImpl {
      constructor(getter, _setter, isReadonly2, isSSR) {
        this.getter = getter;
        this._setter = _setter;
        this.dep = void 0;
        this.__v_isRef = true;
        this["__v_isReadonly"] = false;
        this.effect = new ReactiveEffect(
          () => getter(this._value),
          () => triggerRefValue(
            this,
            this.effect._dirtyLevel === 2 ? 2 : 3
          )
        );
        this.effect.computed = this;
        this.effect.active = this._cacheable = !isSSR;
        this["__v_isReadonly"] = isReadonly2;
      }
      get value() {
        const self2 = toRaw(this);
        if ((!self2._cacheable || self2.effect.dirty) && hasChanged(self2._value, self2._value = self2.effect.run())) {
          triggerRefValue(self2, 4);
        }
        trackRefValue(self2);
        if (self2.effect._dirtyLevel >= 2) {
          triggerRefValue(self2, 2);
        }
        return self2._value;
      }
      set value(newValue) {
        this._setter(newValue);
      }
      // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
      get _dirty() {
        return this.effect.dirty;
      }
      set _dirty(v2) {
        this.effect.dirty = v2;
      }
      // #endregion
    }
    function computed$1(getterOrOptions, debugOptions, isSSR = false) {
      let getter;
      let setter;
      const onlyGetter = isFunction$3(getterOrOptions);
      if (onlyGetter) {
        getter = getterOrOptions;
        setter = NOOP;
      } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
      }
      const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
      return cRef;
    }
    function trackRefValue(ref2) {
      var _a;
      if (shouldTrack && activeEffect) {
        ref2 = toRaw(ref2);
        trackEffect(
          activeEffect,
          (_a = ref2.dep) != null ? _a : ref2.dep = createDep(
            () => ref2.dep = void 0,
            ref2 instanceof ComputedRefImpl ? ref2 : void 0
          )
        );
      }
    }
    function triggerRefValue(ref2, dirtyLevel = 4, newVal) {
      ref2 = toRaw(ref2);
      const dep = ref2.dep;
      if (dep) {
        triggerEffects(
          dep,
          dirtyLevel
        );
      }
    }
    function isRef(r2) {
      return !!(r2 && r2.__v_isRef === true);
    }
    function ref(value) {
      return createRef(value, false);
    }
    function shallowRef(value) {
      return createRef(value, true);
    }
    function createRef(rawValue, shallow) {
      if (isRef(rawValue)) {
        return rawValue;
      }
      return new RefImpl(rawValue, shallow);
    }
    class RefImpl {
      constructor(value, __v_isShallow) {
        this.__v_isShallow = __v_isShallow;
        this.dep = void 0;
        this.__v_isRef = true;
        this._rawValue = __v_isShallow ? value : toRaw(value);
        this._value = __v_isShallow ? value : toReactive(value);
      }
      get value() {
        trackRefValue(this);
        return this._value;
      }
      set value(newVal) {
        const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
        newVal = useDirectValue ? newVal : toRaw(newVal);
        if (hasChanged(newVal, this._rawValue)) {
          this._rawValue = newVal;
          this._value = useDirectValue ? newVal : toReactive(newVal);
          triggerRefValue(this, 4);
        }
      }
    }
    function triggerRef(ref2) {
      triggerRefValue(ref2, 4);
    }
    function unref(ref2) {
      return isRef(ref2) ? ref2.value : ref2;
    }
    function toValue$1(source) {
      return isFunction$3(source) ? source() : unref(source);
    }
    const shallowUnwrapHandlers = {
      get: (target, key2, receiver) => unref(Reflect.get(target, key2, receiver)),
      set: (target, key2, value, receiver) => {
        const oldValue = target[key2];
        if (isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        } else {
          return Reflect.set(target, key2, value, receiver);
        }
      }
    };
    function proxyRefs(objectWithRefs) {
      return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
    }
    class CustomRefImpl {
      constructor(factory2) {
        this.dep = void 0;
        this.__v_isRef = true;
        const { get: get2, set: set2 } = factory2(
          () => trackRefValue(this),
          () => triggerRefValue(this)
        );
        this._get = get2;
        this._set = set2;
      }
      get value() {
        return this._get();
      }
      set value(newVal) {
        this._set(newVal);
      }
    }
    function customRef(factory2) {
      return new CustomRefImpl(factory2);
    }
    function toRefs(object) {
      const ret = isArray$4(object) ? new Array(object.length) : {};
      for (const key2 in object) {
        ret[key2] = propertyToRef(object, key2);
      }
      return ret;
    }
    class ObjectRefImpl {
      constructor(_object, _key, _defaultValue) {
        this._object = _object;
        this._key = _key;
        this._defaultValue = _defaultValue;
        this.__v_isRef = true;
      }
      get value() {
        const val = this._object[this._key];
        return val === void 0 ? this._defaultValue : val;
      }
      set value(newVal) {
        this._object[this._key] = newVal;
      }
      get dep() {
        return getDepFromReactive(toRaw(this._object), this._key);
      }
    }
    class GetterRefImpl {
      constructor(_getter) {
        this._getter = _getter;
        this.__v_isRef = true;
        this.__v_isReadonly = true;
      }
      get value() {
        return this._getter();
      }
    }
    function toRef(source, key2, defaultValue) {
      if (isRef(source)) {
        return source;
      } else if (isFunction$3(source)) {
        return new GetterRefImpl(source);
      } else if (isObject$6(source) && arguments.length > 1) {
        return propertyToRef(source, key2, defaultValue);
      } else {
        return ref(source);
      }
    }
    function propertyToRef(source, key2, defaultValue) {
      const val = source[key2];
      return isRef(val) ? val : new ObjectRefImpl(source, key2, defaultValue);
    }
    const TrackOpTypes = {
      "GET": "get",
      "HAS": "has",
      "ITERATE": "iterate"
    };
    const TriggerOpTypes = {
      "SET": "set",
      "ADD": "add",
      "DELETE": "delete",
      "CLEAR": "clear"
    };
    /**
    * @vue/runtime-core v3.4.27
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    const stack = [];
    function warn$1$1(msg, ...args) {
      pauseTracking();
      const instance = stack.length ? stack[stack.length - 1].component : null;
      const appWarnHandler = instance && instance.appContext.config.warnHandler;
      const trace = getComponentTrace();
      if (appWarnHandler) {
        callWithErrorHandling(
          appWarnHandler,
          instance,
          11,
          [
            msg + args.map((a2) => {
              var _a, _b;
              return (_b = (_a = a2.toString) == null ? void 0 : _a.call(a2)) != null ? _b : JSON.stringify(a2);
            }).join(""),
            instance && instance.proxy,
            trace.map(
              ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
            ).join("\n"),
            trace
          ]
        );
      } else {
        const warnArgs = [`[Vue warn]: ${msg}`, ...args];
        if (trace.length && // avoid spamming console during tests
        true) {
          warnArgs.push(`
`, ...formatTrace(trace));
        }
        console.warn(...warnArgs);
      }
      resetTracking();
    }
    function getComponentTrace() {
      let currentVNode = stack[stack.length - 1];
      if (!currentVNode) {
        return [];
      }
      const normalizedStack = [];
      while (currentVNode) {
        const last = normalizedStack[0];
        if (last && last.vnode === currentVNode) {
          last.recurseCount++;
        } else {
          normalizedStack.push({
            vnode: currentVNode,
            recurseCount: 0
          });
        }
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
      }
      return normalizedStack;
    }
    function formatTrace(trace) {
      const logs = [];
      trace.forEach((entry, i2) => {
        logs.push(...i2 === 0 ? [] : [`
`], ...formatTraceEntry(entry));
      });
      return logs;
    }
    function formatTraceEntry({ vnode, recurseCount }) {
      const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
      const isRoot = vnode.component ? vnode.component.parent == null : false;
      const open = ` at <${formatComponentName(
        vnode.component,
        vnode.type,
        isRoot
      )}`;
      const close = `>` + postfix;
      return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
    }
    function formatProps(props) {
      const res = [];
      const keys = Object.keys(props);
      keys.slice(0, 3).forEach((key2) => {
        res.push(...formatProp(key2, props[key2]));
      });
      if (keys.length > 3) {
        res.push(` ...`);
      }
      return res;
    }
    function formatProp(key2, value, raw) {
      if (isString$2(value)) {
        value = JSON.stringify(value);
        return raw ? value : [`${key2}=${value}`];
      } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
        return raw ? value : [`${key2}=${value}`];
      } else if (isRef(value)) {
        value = formatProp(key2, toRaw(value.value), true);
        return raw ? value : [`${key2}=Ref<`, value, `>`];
      } else if (isFunction$3(value)) {
        return [`${key2}=fn${value.name ? `<${value.name}>` : ``}`];
      } else {
        value = toRaw(value);
        return raw ? value : [`${key2}=`, value];
      }
    }
    function assertNumber(val, type) {
      return;
    }
    const ErrorCodes = {
      "SETUP_FUNCTION": 0,
      "0": "SETUP_FUNCTION",
      "RENDER_FUNCTION": 1,
      "1": "RENDER_FUNCTION",
      "WATCH_GETTER": 2,
      "2": "WATCH_GETTER",
      "WATCH_CALLBACK": 3,
      "3": "WATCH_CALLBACK",
      "WATCH_CLEANUP": 4,
      "4": "WATCH_CLEANUP",
      "NATIVE_EVENT_HANDLER": 5,
      "5": "NATIVE_EVENT_HANDLER",
      "COMPONENT_EVENT_HANDLER": 6,
      "6": "COMPONENT_EVENT_HANDLER",
      "VNODE_HOOK": 7,
      "7": "VNODE_HOOK",
      "DIRECTIVE_HOOK": 8,
      "8": "DIRECTIVE_HOOK",
      "TRANSITION_HOOK": 9,
      "9": "TRANSITION_HOOK",
      "APP_ERROR_HANDLER": 10,
      "10": "APP_ERROR_HANDLER",
      "APP_WARN_HANDLER": 11,
      "11": "APP_WARN_HANDLER",
      "FUNCTION_REF": 12,
      "12": "FUNCTION_REF",
      "ASYNC_COMPONENT_LOADER": 13,
      "13": "ASYNC_COMPONENT_LOADER",
      "SCHEDULER": 14,
      "14": "SCHEDULER"
    };
    const ErrorTypeStrings$1 = {
      ["sp"]: "serverPrefetch hook",
      ["bc"]: "beforeCreate hook",
      ["c"]: "created hook",
      ["bm"]: "beforeMount hook",
      ["m"]: "mounted hook",
      ["bu"]: "beforeUpdate hook",
      ["u"]: "updated",
      ["bum"]: "beforeUnmount hook",
      ["um"]: "unmounted hook",
      ["a"]: "activated hook",
      ["da"]: "deactivated hook",
      ["ec"]: "errorCaptured hook",
      ["rtc"]: "renderTracked hook",
      ["rtg"]: "renderTriggered hook",
      [0]: "setup function",
      [1]: "render function",
      [2]: "watcher getter",
      [3]: "watcher callback",
      [4]: "watcher cleanup function",
      [5]: "native event handler",
      [6]: "component event handler",
      [7]: "vnode hook",
      [8]: "directive hook",
      [9]: "transition hook",
      [10]: "app errorHandler",
      [11]: "app warnHandler",
      [12]: "ref function",
      [13]: "async component loader",
      [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://github.com/vuejs/core ."
    };
    function callWithErrorHandling(fn2, instance, type, args) {
      try {
        return args ? fn2(...args) : fn2();
      } catch (err) {
        handleError(err, instance, type);
      }
    }
    function callWithAsyncErrorHandling(fn2, instance, type, args) {
      if (isFunction$3(fn2)) {
        const res = callWithErrorHandling(fn2, instance, type, args);
        if (res && isPromise$2(res)) {
          res.catch((err) => {
            handleError(err, instance, type);
          });
        }
        return res;
      }
      if (isArray$4(fn2)) {
        const values = [];
        for (let i2 = 0; i2 < fn2.length; i2++) {
          values.push(callWithAsyncErrorHandling(fn2[i2], instance, type, args));
        }
        return values;
      }
    }
    function handleError(err, instance, type, throwInDev = true) {
      const contextVNode = instance ? instance.vnode : null;
      if (instance) {
        let cur = instance.parent;
        const exposedInstance = instance.proxy;
        const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
        while (cur) {
          const errorCapturedHooks = cur.ec;
          if (errorCapturedHooks) {
            for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
              if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
                return;
              }
            }
          }
          cur = cur.parent;
        }
        const appErrorHandler = instance.appContext.config.errorHandler;
        if (appErrorHandler) {
          pauseTracking();
          callWithErrorHandling(
            appErrorHandler,
            null,
            10,
            [err, exposedInstance, errorInfo]
          );
          resetTracking();
          return;
        }
      }
      logError(err, type, contextVNode, throwInDev);
    }
    function logError(err, type, contextVNode, throwInDev = true) {
      {
        console.error(err);
      }
    }
    let isFlushing = false;
    let isFlushPending = false;
    const queue = [];
    let flushIndex = 0;
    const pendingPostFlushCbs = [];
    let activePostFlushCbs = null;
    let postFlushIndex = 0;
    const resolvedPromise = /* @__PURE__ */ Promise.resolve();
    let currentFlushPromise = null;
    function nextTick(fn2) {
      const p2 = currentFlushPromise || resolvedPromise;
      return fn2 ? p2.then(this ? fn2.bind(this) : fn2) : p2;
    }
    function findInsertionIndex(id2) {
      let start2 = flushIndex + 1;
      let end2 = queue.length;
      while (start2 < end2) {
        const middle = start2 + end2 >>> 1;
        const middleJob = queue[middle];
        const middleJobId = getId(middleJob);
        if (middleJobId < id2 || middleJobId === id2 && middleJob.pre) {
          start2 = middle + 1;
        } else {
          end2 = middle;
        }
      }
      return start2;
    }
    function queueJob(job) {
      if (!queue.length || !queue.includes(
        job,
        isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
      )) {
        if (job.id == null) {
          queue.push(job);
        } else {
          queue.splice(findInsertionIndex(job.id), 0, job);
        }
        queueFlush();
      }
    }
    function queueFlush() {
      if (!isFlushing && !isFlushPending) {
        isFlushPending = true;
        currentFlushPromise = resolvedPromise.then(flushJobs);
      }
    }
    function invalidateJob(job) {
      const i2 = queue.indexOf(job);
      if (i2 > flushIndex) {
        queue.splice(i2, 1);
      }
    }
    function queuePostFlushCb(cb) {
      if (!isArray$4(cb)) {
        if (!activePostFlushCbs || !activePostFlushCbs.includes(
          cb,
          cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
        )) {
          pendingPostFlushCbs.push(cb);
        }
      } else {
        pendingPostFlushCbs.push(...cb);
      }
      queueFlush();
    }
    function flushPreFlushCbs(instance, seen2, i2 = isFlushing ? flushIndex + 1 : 0) {
      for (; i2 < queue.length; i2++) {
        const cb = queue[i2];
        if (cb && cb.pre) {
          if (instance && cb.id !== instance.uid) {
            continue;
          }
          queue.splice(i2, 1);
          i2--;
          cb();
        }
      }
    }
    function flushPostFlushCbs(seen2) {
      if (pendingPostFlushCbs.length) {
        const deduped = [...new Set(pendingPostFlushCbs)].sort(
          (a2, b2) => getId(a2) - getId(b2)
        );
        pendingPostFlushCbs.length = 0;
        if (activePostFlushCbs) {
          activePostFlushCbs.push(...deduped);
          return;
        }
        activePostFlushCbs = deduped;
        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
          activePostFlushCbs[postFlushIndex]();
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
      }
    }
    const getId = (job) => job.id == null ? Infinity : job.id;
    const comparator = (a2, b2) => {
      const diff = getId(a2) - getId(b2);
      if (diff === 0) {
        if (a2.pre && !b2.pre)
          return -1;
        if (b2.pre && !a2.pre)
          return 1;
      }
      return diff;
    };
    function flushJobs(seen2) {
      isFlushPending = false;
      isFlushing = true;
      queue.sort(comparator);
      try {
        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
          const job = queue[flushIndex];
          if (job && job.active !== false) {
            if (false)
              ;
            callWithErrorHandling(job, null, 14);
          }
        }
      } finally {
        flushIndex = 0;
        queue.length = 0;
        flushPostFlushCbs();
        isFlushing = false;
        currentFlushPromise = null;
        if (queue.length || pendingPostFlushCbs.length) {
          flushJobs();
        }
      }
    }
    let devtools$1;
    let buffer = [];
    function setDevtoolsHook$1(hook2, target) {
      var _a, _b;
      devtools$1 = hook2;
      if (devtools$1) {
        devtools$1.enabled = true;
        buffer.forEach(({ event: event2, args }) => devtools$1.emit(event2, ...args));
        buffer = [];
      } else if (
        // handle late devtools injection - only do this if we are in an actual
        // browser environment to avoid the timer handle stalling test runner exit
        // (#4815)
        typeof window !== "undefined" && // some envs mock window but not fully
        window.HTMLElement && // also exclude jsdom
        !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))
      ) {
        const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
        replay.push((newHook) => {
          setDevtoolsHook$1(newHook, target);
        });
        setTimeout(() => {
          if (!devtools$1) {
            target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
            buffer = [];
          }
        }, 3e3);
      } else {
        buffer = [];
      }
    }
    function emit(instance, event2, ...rawArgs) {
      if (instance.isUnmounted)
        return;
      const props = instance.vnode.props || EMPTY_OBJ;
      let args = rawArgs;
      const isModelListener2 = event2.startsWith("update:");
      const modelArg = isModelListener2 && event2.slice(7);
      if (modelArg && modelArg in props) {
        const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
        const { number: number2, trim } = props[modifiersKey] || EMPTY_OBJ;
        if (trim) {
          args = rawArgs.map((a2) => isString$2(a2) ? a2.trim() : a2);
        }
        if (number2) {
          args = rawArgs.map(looseToNumber);
        }
      }
      let handlerName;
      let handler = props[handlerName = toHandlerKey(event2)] || // also try camelCase event handler (#2249)
      props[handlerName = toHandlerKey(camelize(event2))];
      if (!handler && isModelListener2) {
        handler = props[handlerName = toHandlerKey(hyphenate(event2))];
      }
      if (handler) {
        callWithAsyncErrorHandling(
          handler,
          instance,
          6,
          args
        );
      }
      const onceHandler = props[handlerName + `Once`];
      if (onceHandler) {
        if (!instance.emitted) {
          instance.emitted = {};
        } else if (instance.emitted[handlerName]) {
          return;
        }
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(
          onceHandler,
          instance,
          6,
          args
        );
      }
    }
    function normalizeEmitsOptions(comp, appContext, asMixin = false) {
      const cache2 = appContext.emitsCache;
      const cached = cache2.get(comp);
      if (cached !== void 0) {
        return cached;
      }
      const raw = comp.emits;
      let normalized = {};
      let hasExtends = false;
      if (!isFunction$3(comp)) {
        const extendEmits = (raw2) => {
          const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
          if (normalizedFromExtend) {
            hasExtends = true;
            extend$1(normalized, normalizedFromExtend);
          }
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendEmits);
        }
        if (comp.extends) {
          extendEmits(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendEmits);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject$6(comp)) {
          cache2.set(comp, null);
        }
        return null;
      }
      if (isArray$4(raw)) {
        raw.forEach((key2) => normalized[key2] = null);
      } else {
        extend$1(normalized, raw);
      }
      if (isObject$6(comp)) {
        cache2.set(comp, normalized);
      }
      return normalized;
    }
    function isEmitListener(options, key2) {
      if (!options || !isOn(key2)) {
        return false;
      }
      key2 = key2.slice(2).replace(/Once$/, "");
      return hasOwn$1(options, key2[0].toLowerCase() + key2.slice(1)) || hasOwn$1(options, hyphenate(key2)) || hasOwn$1(options, key2);
    }
    let currentRenderingInstance = null;
    let currentScopeId = null;
    function setCurrentRenderingInstance(instance) {
      const prev = currentRenderingInstance;
      currentRenderingInstance = instance;
      currentScopeId = instance && instance.type.__scopeId || null;
      return prev;
    }
    function pushScopeId(id2) {
      currentScopeId = id2;
    }
    function popScopeId() {
      currentScopeId = null;
    }
    const withScopeId = (_id) => withCtx;
    function withCtx(fn2, ctx = currentRenderingInstance, isNonScopedSlot) {
      if (!ctx)
        return fn2;
      if (fn2._n) {
        return fn2;
      }
      const renderFnWithContext = (...args) => {
        if (renderFnWithContext._d) {
          setBlockTracking(-1);
        }
        const prevInstance = setCurrentRenderingInstance(ctx);
        let res;
        try {
          res = fn2(...args);
        } finally {
          setCurrentRenderingInstance(prevInstance);
          if (renderFnWithContext._d) {
            setBlockTracking(1);
          }
        }
        return res;
      };
      renderFnWithContext._n = true;
      renderFnWithContext._c = true;
      renderFnWithContext._d = true;
      return renderFnWithContext;
    }
    function markAttrsAccessed() {
    }
    function renderComponentRoot(instance) {
      const {
        type: Component,
        vnode,
        proxy,
        withProxy,
        propsOptions: [propsOptions],
        slots,
        attrs,
        emit: emit2,
        render: render2,
        renderCache,
        props,
        data,
        setupState,
        ctx,
        inheritAttrs
      } = instance;
      const prev = setCurrentRenderingInstance(instance);
      let result;
      let fallthroughAttrs;
      try {
        if (vnode.shapeFlag & 4) {
          const proxyToUse = withProxy || proxy;
          const thisProxy = false ? new Proxy(proxyToUse, {
            get(target, key2, receiver) {
              warn$1$1(
                `Property '${String(
                  key2
                )}' was accessed via 'this'. Avoid using 'this' in templates.`
              );
              return Reflect.get(target, key2, receiver);
            }
          }) : proxyToUse;
          result = normalizeVNode(
            render2.call(
              thisProxy,
              proxyToUse,
              renderCache,
              false ? shallowReadonly(props) : props,
              setupState,
              data,
              ctx
            )
          );
          fallthroughAttrs = attrs;
        } else {
          const render22 = Component;
          if (false)
            ;
          result = normalizeVNode(
            render22.length > 1 ? render22(
              false ? shallowReadonly(props) : props,
              false ? {
                get attrs() {
                  markAttrsAccessed();
                  return shallowReadonly(attrs);
                },
                slots,
                emit: emit2
              } : { attrs, slots, emit: emit2 }
            ) : render22(
              false ? shallowReadonly(props) : props,
              null
            )
          );
          fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
        }
      } catch (err) {
        blockStack.length = 0;
        handleError(err, instance, 1);
        result = createVNode(Comment);
      }
      let root2 = result;
      if (fallthroughAttrs && inheritAttrs !== false) {
        const keys = Object.keys(fallthroughAttrs);
        const { shapeFlag } = root2;
        if (keys.length) {
          if (shapeFlag & (1 | 6)) {
            if (propsOptions && keys.some(isModelListener)) {
              fallthroughAttrs = filterModelListeners(
                fallthroughAttrs,
                propsOptions
              );
            }
            root2 = cloneVNode(root2, fallthroughAttrs, false, true);
          }
        }
      }
      if (vnode.dirs) {
        root2 = cloneVNode(root2, null, false, true);
        root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
      }
      if (vnode.transition) {
        root2.transition = vnode.transition;
      }
      {
        result = root2;
      }
      setCurrentRenderingInstance(prev);
      return result;
    }
    function filterSingleRoot(children, recurse = true) {
      let singleRoot;
      for (let i2 = 0; i2 < children.length; i2++) {
        const child2 = children[i2];
        if (isVNode$1(child2)) {
          if (child2.type !== Comment || child2.children === "v-if") {
            if (singleRoot) {
              return;
            } else {
              singleRoot = child2;
            }
          }
        } else {
          return;
        }
      }
      return singleRoot;
    }
    const getFunctionalFallthrough = (attrs) => {
      let res;
      for (const key2 in attrs) {
        if (key2 === "class" || key2 === "style" || isOn(key2)) {
          (res || (res = {}))[key2] = attrs[key2];
        }
      }
      return res;
    };
    const filterModelListeners = (attrs, props) => {
      const res = {};
      for (const key2 in attrs) {
        if (!isModelListener(key2) || !(key2.slice(9) in props)) {
          res[key2] = attrs[key2];
        }
      }
      return res;
    };
    function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
      const { props: prevProps, children: prevChildren, component } = prevVNode;
      const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
      const emits = component.emitsOptions;
      if (nextVNode.dirs || nextVNode.transition) {
        return true;
      }
      if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024) {
          return true;
        }
        if (patchFlag & 16) {
          if (!prevProps) {
            return !!nextProps;
          }
          return hasPropsChanged(prevProps, nextProps, emits);
        } else if (patchFlag & 8) {
          const dynamicProps = nextVNode.dynamicProps;
          for (let i2 = 0; i2 < dynamicProps.length; i2++) {
            const key2 = dynamicProps[i2];
            if (nextProps[key2] !== prevProps[key2] && !isEmitListener(emits, key2)) {
              return true;
            }
          }
        }
      } else {
        if (prevChildren || nextChildren) {
          if (!nextChildren || !nextChildren.$stable) {
            return true;
          }
        }
        if (prevProps === nextProps) {
          return false;
        }
        if (!prevProps) {
          return !!nextProps;
        }
        if (!nextProps) {
          return true;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      }
      return false;
    }
    function hasPropsChanged(prevProps, nextProps, emitsOptions) {
      const nextKeys = Object.keys(nextProps);
      if (nextKeys.length !== Object.keys(prevProps).length) {
        return true;
      }
      for (let i2 = 0; i2 < nextKeys.length; i2++) {
        const key2 = nextKeys[i2];
        if (nextProps[key2] !== prevProps[key2] && !isEmitListener(emitsOptions, key2)) {
          return true;
        }
      }
      return false;
    }
    function updateHOCHostEl({ vnode, parent }, el) {
      while (parent) {
        const root2 = parent.subTree;
        if (root2.suspense && root2.suspense.activeBranch === vnode) {
          root2.el = vnode.el;
        }
        if (root2 === vnode) {
          (vnode = parent.vnode).el = el;
          parent = parent.parent;
        } else {
          break;
        }
      }
    }
    const COMPONENTS = "components";
    const DIRECTIVES = "directives";
    function resolveComponent(name, maybeSelfReference) {
      return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
    }
    const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
    function resolveDynamicComponent(component) {
      if (isString$2(component)) {
        return resolveAsset(COMPONENTS, component, false) || component;
      } else {
        return component || NULL_DYNAMIC_COMPONENT;
      }
    }
    function resolveDirective(name) {
      return resolveAsset(DIRECTIVES, name);
    }
    function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
      const instance = currentRenderingInstance || currentInstance;
      if (instance) {
        const Component = instance.type;
        if (type === COMPONENTS) {
          const selfName = getComponentName(
            Component,
            false
          );
          if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize$1(camelize(name)))) {
            return Component;
          }
        }
        const res = (
          // local registration
          // check instance[type] first which is resolved for options API
          resolve(instance[type] || Component[type], name) || // global registration
          resolve(instance.appContext[type], name)
        );
        if (!res && maybeSelfReference) {
          return Component;
        }
        return res;
      }
    }
    function resolve(registry, name) {
      return registry && (registry[name] || registry[camelize(name)] || registry[capitalize$1(camelize(name))]);
    }
    const isSuspense = (type) => type.__isSuspense;
    let suspenseId = 0;
    const SuspenseImpl = {
      name: "Suspense",
      // In order to make Suspense tree-shakable, we need to avoid importing it
      // directly in the renderer. The renderer checks for the __isSuspense flag
      // on a vnode's type and calls the `process` method, passing in renderer
      // internals.
      __isSuspense: true,
      process(n1, n2, container, anchor2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
        if (n1 == null) {
          mountSuspense(
            n2,
            container,
            anchor2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            rendererInternals
          );
        } else {
          if (parentSuspense && parentSuspense.deps > 0 && !n1.suspense.isInFallback) {
            n2.suspense = n1.suspense;
            n2.suspense.vnode = n2;
            n2.el = n1.el;
            return;
          }
          patchSuspense(
            n1,
            n2,
            container,
            anchor2,
            parentComponent,
            namespace,
            slotScopeIds,
            optimized,
            rendererInternals
          );
        }
      },
      hydrate: hydrateSuspense,
      create: createSuspenseBoundary,
      normalize: normalizeSuspenseChildren
    };
    const Suspense = SuspenseImpl;
    function triggerEvent(vnode, name) {
      const eventListener = vnode.props && vnode.props[name];
      if (isFunction$3(eventListener)) {
        eventListener();
      }
    }
    function mountSuspense(vnode, container, anchor2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {
      const {
        p: patch,
        o: { createElement }
      } = rendererInternals;
      const hiddenContainer = createElement("div");
      const suspense = vnode.suspense = createSuspenseBoundary(
        vnode,
        parentSuspense,
        parentComponent,
        container,
        hiddenContainer,
        anchor2,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals
      );
      patch(
        null,
        suspense.pendingBranch = vnode.ssContent,
        hiddenContainer,
        null,
        parentComponent,
        suspense,
        namespace,
        slotScopeIds
      );
      if (suspense.deps > 0) {
        triggerEvent(vnode, "onPending");
        triggerEvent(vnode, "onFallback");
        patch(
          null,
          vnode.ssFallback,
          container,
          anchor2,
          parentComponent,
          null,
          // fallback tree will not have suspense context
          namespace,
          slotScopeIds
        );
        setActiveBranch(suspense, vnode.ssFallback);
      } else {
        suspense.resolve(false, true);
      }
    }
    function patchSuspense(n1, n2, container, anchor2, parentComponent, namespace, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
      const suspense = n2.suspense = n1.suspense;
      suspense.vnode = n2;
      n2.el = n1.el;
      const newBranch = n2.ssContent;
      const newFallback = n2.ssFallback;
      const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
      if (pendingBranch) {
        suspense.pendingBranch = newBranch;
        if (isSameVNodeType(newBranch, pendingBranch)) {
          patch(
            pendingBranch,
            newBranch,
            suspense.hiddenContainer,
            null,
            parentComponent,
            suspense,
            namespace,
            slotScopeIds,
            optimized
          );
          if (suspense.deps <= 0) {
            suspense.resolve();
          } else if (isInFallback) {
            if (!isHydrating) {
              patch(
                activeBranch,
                newFallback,
                container,
                anchor2,
                parentComponent,
                null,
                // fallback tree will not have suspense context
                namespace,
                slotScopeIds,
                optimized
              );
              setActiveBranch(suspense, newFallback);
            }
          }
        } else {
          suspense.pendingId = suspenseId++;
          if (isHydrating) {
            suspense.isHydrating = false;
            suspense.activeBranch = pendingBranch;
          } else {
            unmount(pendingBranch, parentComponent, suspense);
          }
          suspense.deps = 0;
          suspense.effects.length = 0;
          suspense.hiddenContainer = createElement("div");
          if (isInFallback) {
            patch(
              null,
              newBranch,
              suspense.hiddenContainer,
              null,
              parentComponent,
              suspense,
              namespace,
              slotScopeIds,
              optimized
            );
            if (suspense.deps <= 0) {
              suspense.resolve();
            } else {
              patch(
                activeBranch,
                newFallback,
                container,
                anchor2,
                parentComponent,
                null,
                // fallback tree will not have suspense context
                namespace,
                slotScopeIds,
                optimized
              );
              setActiveBranch(suspense, newFallback);
            }
          } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
            patch(
              activeBranch,
              newBranch,
              container,
              anchor2,
              parentComponent,
              suspense,
              namespace,
              slotScopeIds,
              optimized
            );
            suspense.resolve(true);
          } else {
            patch(
              null,
              newBranch,
              suspense.hiddenContainer,
              null,
              parentComponent,
              suspense,
              namespace,
              slotScopeIds,
              optimized
            );
            if (suspense.deps <= 0) {
              suspense.resolve();
            }
          }
        }
      } else {
        if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
          patch(
            activeBranch,
            newBranch,
            container,
            anchor2,
            parentComponent,
            suspense,
            namespace,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newBranch);
        } else {
          triggerEvent(n2, "onPending");
          suspense.pendingBranch = newBranch;
          if (newBranch.shapeFlag & 512) {
            suspense.pendingId = newBranch.component.suspenseId;
          } else {
            suspense.pendingId = suspenseId++;
          }
          patch(
            null,
            newBranch,
            suspense.hiddenContainer,
            null,
            parentComponent,
            suspense,
            namespace,
            slotScopeIds,
            optimized
          );
          if (suspense.deps <= 0) {
            suspense.resolve();
          } else {
            const { timeout, pendingId } = suspense;
            if (timeout > 0) {
              setTimeout(() => {
                if (suspense.pendingId === pendingId) {
                  suspense.fallback(newFallback);
                }
              }, timeout);
            } else if (timeout === 0) {
              suspense.fallback(newFallback);
            }
          }
        }
      }
    }
    function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor2, namespace, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
      const {
        p: patch,
        m: move,
        um: unmount,
        n: next,
        o: { parentNode, remove: remove2 }
      } = rendererInternals;
      let parentSuspenseId;
      const isSuspensible = isVNodeSuspensible(vnode);
      if (isSuspensible) {
        if (parentSuspense && parentSuspense.pendingBranch) {
          parentSuspenseId = parentSuspense.pendingId;
          parentSuspense.deps++;
        }
      }
      const timeout = vnode.props ? toNumber(vnode.props.timeout) : void 0;
      const initialAnchor = anchor2;
      const suspense = {
        vnode,
        parent: parentSuspense,
        parentComponent,
        namespace,
        container,
        hiddenContainer,
        deps: 0,
        pendingId: suspenseId++,
        timeout: typeof timeout === "number" ? timeout : -1,
        activeBranch: null,
        pendingBranch: null,
        isInFallback: !isHydrating,
        isHydrating,
        isUnmounted: false,
        effects: [],
        resolve(resume = false, sync = false) {
          const {
            vnode: vnode2,
            activeBranch,
            pendingBranch,
            pendingId,
            effects,
            parentComponent: parentComponent2,
            container: container2
          } = suspense;
          let delayEnter = false;
          if (suspense.isHydrating) {
            suspense.isHydrating = false;
          } else if (!resume) {
            delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
            if (delayEnter) {
              activeBranch.transition.afterLeave = () => {
                if (pendingId === suspense.pendingId) {
                  move(
                    pendingBranch,
                    container2,
                    anchor2 === initialAnchor ? next(activeBranch) : anchor2,
                    0
                  );
                  queuePostFlushCb(effects);
                }
              };
            }
            if (activeBranch) {
              if (parentNode(activeBranch.el) !== suspense.hiddenContainer) {
                anchor2 = next(activeBranch);
              }
              unmount(activeBranch, parentComponent2, suspense, true);
            }
            if (!delayEnter) {
              move(pendingBranch, container2, anchor2, 0);
            }
          }
          setActiveBranch(suspense, pendingBranch);
          suspense.pendingBranch = null;
          suspense.isInFallback = false;
          let parent = suspense.parent;
          let hasUnresolvedAncestor = false;
          while (parent) {
            if (parent.pendingBranch) {
              parent.effects.push(...effects);
              hasUnresolvedAncestor = true;
              break;
            }
            parent = parent.parent;
          }
          if (!hasUnresolvedAncestor && !delayEnter) {
            queuePostFlushCb(effects);
          }
          suspense.effects = [];
          if (isSuspensible) {
            if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
              parentSuspense.deps--;
              if (parentSuspense.deps === 0 && !sync) {
                parentSuspense.resolve();
              }
            }
          }
          triggerEvent(vnode2, "onResolve");
        },
        fallback(fallbackVNode) {
          if (!suspense.pendingBranch) {
            return;
          }
          const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, namespace: namespace2 } = suspense;
          triggerEvent(vnode2, "onFallback");
          const anchor22 = next(activeBranch);
          const mountFallback = () => {
            if (!suspense.isInFallback) {
              return;
            }
            patch(
              null,
              fallbackVNode,
              container2,
              anchor22,
              parentComponent2,
              null,
              // fallback tree will not have suspense context
              namespace2,
              slotScopeIds,
              optimized
            );
            setActiveBranch(suspense, fallbackVNode);
          };
          const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
          if (delayEnter) {
            activeBranch.transition.afterLeave = mountFallback;
          }
          suspense.isInFallback = true;
          unmount(
            activeBranch,
            parentComponent2,
            null,
            // no suspense so unmount hooks fire now
            true
            // shouldRemove
          );
          if (!delayEnter) {
            mountFallback();
          }
        },
        move(container2, anchor22, type) {
          suspense.activeBranch && move(suspense.activeBranch, container2, anchor22, type);
          suspense.container = container2;
        },
        next() {
          return suspense.activeBranch && next(suspense.activeBranch);
        },
        registerDep(instance, setupRenderEffect) {
          const isInPendingSuspense = !!suspense.pendingBranch;
          if (isInPendingSuspense) {
            suspense.deps++;
          }
          const hydratedEl = instance.vnode.el;
          instance.asyncDep.catch((err) => {
            handleError(err, instance, 0);
          }).then((asyncSetupResult) => {
            if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
              return;
            }
            instance.asyncResolved = true;
            const { vnode: vnode2 } = instance;
            handleSetupResult(instance, asyncSetupResult, false);
            if (hydratedEl) {
              vnode2.el = hydratedEl;
            }
            const placeholder = !hydratedEl && instance.subTree.el;
            setupRenderEffect(
              instance,
              vnode2,
              // component may have been moved before resolve.
              // if this is not a hydration, instance.subTree will be the comment
              // placeholder.
              parentNode(hydratedEl || instance.subTree.el),
              // anchor will not be used if this is hydration, so only need to
              // consider the comment placeholder case.
              hydratedEl ? null : next(instance.subTree),
              suspense,
              namespace,
              optimized
            );
            if (placeholder) {
              remove2(placeholder);
            }
            updateHOCHostEl(instance, vnode2.el);
            if (isInPendingSuspense && --suspense.deps === 0) {
              suspense.resolve();
            }
          });
        },
        unmount(parentSuspense2, doRemove) {
          suspense.isUnmounted = true;
          if (suspense.activeBranch) {
            unmount(
              suspense.activeBranch,
              parentComponent,
              parentSuspense2,
              doRemove
            );
          }
          if (suspense.pendingBranch) {
            unmount(
              suspense.pendingBranch,
              parentComponent,
              parentSuspense2,
              doRemove
            );
          }
        }
      };
      return suspense;
    }
    function hydrateSuspense(node, vnode, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals, hydrateNode) {
      const suspense = vnode.suspense = createSuspenseBoundary(
        vnode,
        parentSuspense,
        parentComponent,
        node.parentNode,
        // eslint-disable-next-line no-restricted-globals
        document.createElement("div"),
        null,
        namespace,
        slotScopeIds,
        optimized,
        rendererInternals,
        true
      );
      const result = hydrateNode(
        node,
        suspense.pendingBranch = vnode.ssContent,
        parentComponent,
        suspense,
        slotScopeIds,
        optimized
      );
      if (suspense.deps === 0) {
        suspense.resolve(false, true);
      }
      return result;
    }
    function normalizeSuspenseChildren(vnode) {
      const { shapeFlag, children } = vnode;
      const isSlotChildren = shapeFlag & 32;
      vnode.ssContent = normalizeSuspenseSlot(
        isSlotChildren ? children.default : children
      );
      vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
    }
    function normalizeSuspenseSlot(s2) {
      let block;
      if (isFunction$3(s2)) {
        const trackBlock = isBlockTreeEnabled && s2._c;
        if (trackBlock) {
          s2._d = false;
          openBlock();
        }
        s2 = s2();
        if (trackBlock) {
          s2._d = true;
          block = currentBlock;
          closeBlock();
        }
      }
      if (isArray$4(s2)) {
        const singleChild = filterSingleRoot(s2);
        s2 = singleChild;
      }
      s2 = normalizeVNode(s2);
      if (block && !s2.dynamicChildren) {
        s2.dynamicChildren = block.filter((c2) => c2 !== s2);
      }
      return s2;
    }
    function queueEffectWithSuspense(fn2, suspense) {
      if (suspense && suspense.pendingBranch) {
        if (isArray$4(fn2)) {
          suspense.effects.push(...fn2);
        } else {
          suspense.effects.push(fn2);
        }
      } else {
        queuePostFlushCb(fn2);
      }
    }
    function setActiveBranch(suspense, branch) {
      suspense.activeBranch = branch;
      const { vnode, parentComponent } = suspense;
      let el = branch.el;
      while (!el && branch.component) {
        branch = branch.component.subTree;
        el = branch.el;
      }
      vnode.el = el;
      if (parentComponent && parentComponent.subTree === vnode) {
        parentComponent.vnode.el = el;
        updateHOCHostEl(parentComponent, el);
      }
    }
    function isVNodeSuspensible(vnode) {
      const suspensible = vnode.props && vnode.props.suspensible;
      return suspensible != null && suspensible !== false;
    }
    const ssrContextKey = Symbol.for("v-scx");
    const useSSRContext = () => {
      {
        const ctx = inject(ssrContextKey);
        return ctx;
      }
    };
    function watchEffect(effect2, options) {
      return doWatch(effect2, null, options);
    }
    function watchPostEffect(effect2, options) {
      return doWatch(
        effect2,
        null,
        { flush: "post" }
      );
    }
    function watchSyncEffect(effect2, options) {
      return doWatch(
        effect2,
        null,
        { flush: "sync" }
      );
    }
    const INITIAL_WATCHER_VALUE = {};
    function watch$1(source, cb, options) {
      return doWatch(source, cb, options);
    }
    function doWatch(source, cb, {
      immediate,
      deep,
      flush,
      once,
      onTrack,
      onTrigger
    } = EMPTY_OBJ) {
      if (cb && once) {
        const _cb = cb;
        cb = (...args) => {
          _cb(...args);
          unwatch();
        };
      }
      const instance = currentInstance;
      const reactiveGetter = (source2) => deep === true ? source2 : (
        // for deep: false, only traverse root-level properties
        traverse(source2, deep === false ? 1 : void 0)
      );
      let getter;
      let forceTrigger = false;
      let isMultiSource = false;
      if (isRef(source)) {
        getter = () => source.value;
        forceTrigger = isShallow(source);
      } else if (isReactive(source)) {
        getter = () => reactiveGetter(source);
        forceTrigger = true;
      } else if (isArray$4(source)) {
        isMultiSource = true;
        forceTrigger = source.some((s2) => isReactive(s2) || isShallow(s2));
        getter = () => source.map((s2) => {
          if (isRef(s2)) {
            return s2.value;
          } else if (isReactive(s2)) {
            return reactiveGetter(s2);
          } else if (isFunction$3(s2)) {
            return callWithErrorHandling(s2, instance, 2);
          } else
            ;
        });
      } else if (isFunction$3(source)) {
        if (cb) {
          getter = () => callWithErrorHandling(source, instance, 2);
        } else {
          getter = () => {
            if (cleanup) {
              cleanup();
            }
            return callWithAsyncErrorHandling(
              source,
              instance,
              3,
              [onCleanup]
            );
          };
        }
      } else {
        getter = NOOP;
      }
      if (cb && deep) {
        const baseGetter = getter;
        getter = () => traverse(baseGetter());
      }
      let cleanup;
      let onCleanup = (fn2) => {
        cleanup = effect2.onStop = () => {
          callWithErrorHandling(fn2, instance, 4);
          cleanup = effect2.onStop = void 0;
        };
      };
      let ssrCleanup;
      if (isInSSRComponentSetup) {
        onCleanup = NOOP;
        if (!cb) {
          getter();
        } else if (immediate) {
          callWithAsyncErrorHandling(cb, instance, 3, [
            getter(),
            isMultiSource ? [] : void 0,
            onCleanup
          ]);
        }
        if (flush === "sync") {
          const ctx = useSSRContext();
          ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
        } else {
          return NOOP;
        }
      }
      let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
      const job = () => {
        if (!effect2.active || !effect2.dirty) {
          return;
        }
        if (cb) {
          const newValue = effect2.run();
          if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i2) => hasChanged(v2, oldValue[i2])) : hasChanged(newValue, oldValue)) || false) {
            if (cleanup) {
              cleanup();
            }
            callWithAsyncErrorHandling(cb, instance, 3, [
              newValue,
              // pass undefined as the old value when it's changed for the first time
              oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
              onCleanup
            ]);
            oldValue = newValue;
          }
        } else {
          effect2.run();
        }
      };
      job.allowRecurse = !!cb;
      let scheduler;
      if (flush === "sync") {
        scheduler = job;
      } else if (flush === "post") {
        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
      } else {
        job.pre = true;
        if (instance)
          job.id = instance.uid;
        scheduler = () => queueJob(job);
      }
      const effect2 = new ReactiveEffect(getter, NOOP, scheduler);
      const scope = getCurrentScope();
      const unwatch = () => {
        effect2.stop();
        if (scope) {
          remove(scope.effects, effect2);
        }
      };
      if (cb) {
        if (immediate) {
          job();
        } else {
          oldValue = effect2.run();
        }
      } else if (flush === "post") {
        queuePostRenderEffect(
          effect2.run.bind(effect2),
          instance && instance.suspense
        );
      } else {
        effect2.run();
      }
      if (ssrCleanup)
        ssrCleanup.push(unwatch);
      return unwatch;
    }
    function instanceWatch(source, value, options) {
      const publicThis = this.proxy;
      const getter = isString$2(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
      let cb;
      if (isFunction$3(value)) {
        cb = value;
      } else {
        cb = value.handler;
        options = value;
      }
      const reset = setCurrentInstance(this);
      const res = doWatch(getter, cb.bind(publicThis), options);
      reset();
      return res;
    }
    function createPathGetter(ctx, path) {
      const segments = path.split(".");
      return () => {
        let cur = ctx;
        for (let i2 = 0; i2 < segments.length && cur; i2++) {
          cur = cur[segments[i2]];
        }
        return cur;
      };
    }
    function traverse(value, depth = Infinity, seen2) {
      if (depth <= 0 || !isObject$6(value) || value["__v_skip"]) {
        return value;
      }
      seen2 = seen2 || /* @__PURE__ */ new Set();
      if (seen2.has(value)) {
        return value;
      }
      seen2.add(value);
      depth--;
      if (isRef(value)) {
        traverse(value.value, depth, seen2);
      } else if (isArray$4(value)) {
        for (let i2 = 0; i2 < value.length; i2++) {
          traverse(value[i2], depth, seen2);
        }
      } else if (isSet(value) || isMap(value)) {
        value.forEach((v2) => {
          traverse(v2, depth, seen2);
        });
      } else if (isPlainObject$5(value)) {
        for (const key2 in value) {
          traverse(value[key2], depth, seen2);
        }
      }
      return value;
    }
    function withDirectives(vnode, directives) {
      if (currentRenderingInstance === null) {
        return vnode;
      }
      const instance = getExposeProxy(currentRenderingInstance) || currentRenderingInstance.proxy;
      const bindings = vnode.dirs || (vnode.dirs = []);
      for (let i2 = 0; i2 < directives.length; i2++) {
        let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i2];
        if (dir) {
          if (isFunction$3(dir)) {
            dir = {
              mounted: dir,
              updated: dir
            };
          }
          if (dir.deep) {
            traverse(value);
          }
          bindings.push({
            dir,
            instance,
            value,
            oldValue: void 0,
            arg,
            modifiers
          });
        }
      }
      return vnode;
    }
    function invokeDirectiveHook(vnode, prevVNode, instance, name) {
      const bindings = vnode.dirs;
      const oldBindings = prevVNode && prevVNode.dirs;
      for (let i2 = 0; i2 < bindings.length; i2++) {
        const binding = bindings[i2];
        if (oldBindings) {
          binding.oldValue = oldBindings[i2].value;
        }
        let hook2 = binding.dir[name];
        if (hook2) {
          pauseTracking();
          callWithAsyncErrorHandling(hook2, instance, 8, [
            vnode.el,
            binding,
            vnode,
            prevVNode
          ]);
          resetTracking();
        }
      }
    }
    const leaveCbKey = Symbol("_leaveCb");
    const enterCbKey$1 = Symbol("_enterCb");
    function useTransitionState() {
      const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: /* @__PURE__ */ new Map()
      };
      onMounted(() => {
        state.isMounted = true;
      });
      onBeforeUnmount(() => {
        state.isUnmounting = true;
      });
      return state;
    }
    const TransitionHookValidator = [Function, Array];
    const BaseTransitionPropsValidators = {
      mode: String,
      appear: Boolean,
      persisted: Boolean,
      // enter
      onBeforeEnter: TransitionHookValidator,
      onEnter: TransitionHookValidator,
      onAfterEnter: TransitionHookValidator,
      onEnterCancelled: TransitionHookValidator,
      // leave
      onBeforeLeave: TransitionHookValidator,
      onLeave: TransitionHookValidator,
      onAfterLeave: TransitionHookValidator,
      onLeaveCancelled: TransitionHookValidator,
      // appear
      onBeforeAppear: TransitionHookValidator,
      onAppear: TransitionHookValidator,
      onAfterAppear: TransitionHookValidator,
      onAppearCancelled: TransitionHookValidator
    };
    const BaseTransitionImpl = {
      name: `BaseTransition`,
      props: BaseTransitionPropsValidators,
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        return () => {
          const children = slots.default && getTransitionRawChildren(slots.default(), true);
          if (!children || !children.length) {
            return;
          }
          let child2 = children[0];
          if (children.length > 1) {
            for (const c2 of children) {
              if (c2.type !== Comment) {
                child2 = c2;
                break;
              }
            }
          }
          const rawProps = toRaw(props);
          const { mode } = rawProps;
          if (state.isLeaving) {
            return emptyPlaceholder(child2);
          }
          const innerChild = getKeepAliveChild(child2);
          if (!innerChild) {
            return emptyPlaceholder(child2);
          }
          const enterHooks = resolveTransitionHooks(
            innerChild,
            rawProps,
            state,
            instance
          );
          setTransitionHooks(innerChild, enterHooks);
          const oldChild = instance.subTree;
          const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
          if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild)) {
            const leavingHooks = resolveTransitionHooks(
              oldInnerChild,
              rawProps,
              state,
              instance
            );
            setTransitionHooks(oldInnerChild, leavingHooks);
            if (mode === "out-in" && innerChild.type !== Comment) {
              state.isLeaving = true;
              leavingHooks.afterLeave = () => {
                state.isLeaving = false;
                if (instance.update.active !== false) {
                  instance.effect.dirty = true;
                  instance.update();
                }
              };
              return emptyPlaceholder(child2);
            } else if (mode === "in-out" && innerChild.type !== Comment) {
              leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                const leavingVNodesCache = getLeavingNodesForType(
                  state,
                  oldInnerChild
                );
                leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                el[leaveCbKey] = () => {
                  earlyRemove();
                  el[leaveCbKey] = void 0;
                  delete enterHooks.delayedLeave;
                };
                enterHooks.delayedLeave = delayedLeave;
              };
            }
          }
          return child2;
        };
      }
    };
    const BaseTransition = BaseTransitionImpl;
    function getLeavingNodesForType(state, vnode) {
      const { leavingVNodes } = state;
      let leavingVNodesCache = leavingVNodes.get(vnode.type);
      if (!leavingVNodesCache) {
        leavingVNodesCache = /* @__PURE__ */ Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
      }
      return leavingVNodesCache;
    }
    function resolveTransitionHooks(vnode, props, state, instance) {
      const {
        appear,
        mode,
        persisted = false,
        onBeforeEnter,
        onEnter,
        onAfterEnter,
        onEnterCancelled,
        onBeforeLeave,
        onLeave,
        onAfterLeave,
        onLeaveCancelled,
        onBeforeAppear,
        onAppear,
        onAfterAppear,
        onAppearCancelled
      } = props;
      const key2 = String(vnode.key);
      const leavingVNodesCache = getLeavingNodesForType(state, vnode);
      const callHook2 = (hook2, args) => {
        hook2 && callWithAsyncErrorHandling(
          hook2,
          instance,
          9,
          args
        );
      };
      const callAsyncHook = (hook2, args) => {
        const done = args[1];
        callHook2(hook2, args);
        if (isArray$4(hook2)) {
          if (hook2.every((hook22) => hook22.length <= 1))
            done();
        } else if (hook2.length <= 1) {
          done();
        }
      };
      const hooks = {
        mode,
        persisted,
        beforeEnter(el) {
          let hook2 = onBeforeEnter;
          if (!state.isMounted) {
            if (appear) {
              hook2 = onBeforeAppear || onBeforeEnter;
            } else {
              return;
            }
          }
          if (el[leaveCbKey]) {
            el[leaveCbKey](
              true
              /* cancelled */
            );
          }
          const leavingVNode = leavingVNodesCache[key2];
          if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
            leavingVNode.el[leaveCbKey]();
          }
          callHook2(hook2, [el]);
        },
        enter(el) {
          let hook2 = onEnter;
          let afterHook = onAfterEnter;
          let cancelHook = onEnterCancelled;
          if (!state.isMounted) {
            if (appear) {
              hook2 = onAppear || onEnter;
              afterHook = onAfterAppear || onAfterEnter;
              cancelHook = onAppearCancelled || onEnterCancelled;
            } else {
              return;
            }
          }
          let called = false;
          const done = el[enterCbKey$1] = (cancelled) => {
            if (called)
              return;
            called = true;
            if (cancelled) {
              callHook2(cancelHook, [el]);
            } else {
              callHook2(afterHook, [el]);
            }
            if (hooks.delayedLeave) {
              hooks.delayedLeave();
            }
            el[enterCbKey$1] = void 0;
          };
          if (hook2) {
            callAsyncHook(hook2, [el, done]);
          } else {
            done();
          }
        },
        leave(el, remove2) {
          const key22 = String(vnode.key);
          if (el[enterCbKey$1]) {
            el[enterCbKey$1](
              true
              /* cancelled */
            );
          }
          if (state.isUnmounting) {
            return remove2();
          }
          callHook2(onBeforeLeave, [el]);
          let called = false;
          const done = el[leaveCbKey] = (cancelled) => {
            if (called)
              return;
            called = true;
            remove2();
            if (cancelled) {
              callHook2(onLeaveCancelled, [el]);
            } else {
              callHook2(onAfterLeave, [el]);
            }
            el[leaveCbKey] = void 0;
            if (leavingVNodesCache[key22] === vnode) {
              delete leavingVNodesCache[key22];
            }
          };
          leavingVNodesCache[key22] = vnode;
          if (onLeave) {
            callAsyncHook(onLeave, [el, done]);
          } else {
            done();
          }
        },
        clone(vnode2) {
          return resolveTransitionHooks(vnode2, props, state, instance);
        }
      };
      return hooks;
    }
    function emptyPlaceholder(vnode) {
      if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
      }
    }
    function getKeepAliveChild(vnode) {
      if (!isKeepAlive(vnode)) {
        return vnode;
      }
      const { shapeFlag, children } = vnode;
      if (children) {
        if (shapeFlag & 16) {
          return children[0];
        }
        if (shapeFlag & 32 && isFunction$3(children.default)) {
          return children.default();
        }
      }
    }
    function setTransitionHooks(vnode, hooks) {
      if (vnode.shapeFlag & 6 && vnode.component) {
        setTransitionHooks(vnode.component.subTree, hooks);
      } else if (vnode.shapeFlag & 128) {
        vnode.ssContent.transition = hooks.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
      } else {
        vnode.transition = hooks;
      }
    }
    function getTransitionRawChildren(children, keepComment = false, parentKey) {
      let ret = [];
      let keyedFragmentCount = 0;
      for (let i2 = 0; i2 < children.length; i2++) {
        let child2 = children[i2];
        const key2 = parentKey == null ? child2.key : String(parentKey) + String(child2.key != null ? child2.key : i2);
        if (child2.type === Fragment) {
          if (child2.patchFlag & 128)
            keyedFragmentCount++;
          ret = ret.concat(
            getTransitionRawChildren(child2.children, keepComment, key2)
          );
        } else if (keepComment || child2.type !== Comment) {
          ret.push(key2 != null ? cloneVNode(child2, { key: key2 }) : child2);
        }
      }
      if (keyedFragmentCount > 1) {
        for (let i2 = 0; i2 < ret.length; i2++) {
          ret[i2].patchFlag = -2;
        }
      }
      return ret;
    }
    /*! #__NO_SIDE_EFFECTS__ */
    // @__NO_SIDE_EFFECTS__
    function defineComponent(options, extraOptions) {
      return isFunction$3(options) ? (
        // #8326: extend call and options.name access are considered side-effects
        // by Rollup, so we have to wrap it in a pure-annotated IIFE.
        /* @__PURE__ */ (() => extend$1({ name: options.name }, extraOptions, { setup: options }))()
      ) : options;
    }
    const isAsyncWrapper = (i2) => !!i2.type.__asyncLoader;
    /*! #__NO_SIDE_EFFECTS__ */
    // @__NO_SIDE_EFFECTS__
    function defineAsyncComponent(source) {
      if (isFunction$3(source)) {
        source = { loader: source };
      }
      const {
        loader,
        loadingComponent,
        errorComponent,
        delay: delay2 = 200,
        timeout,
        // undefined = never times out
        suspensible = true,
        onError: userOnError
      } = source;
      let pendingRequest = null;
      let resolvedComp;
      let retries = 0;
      const retry = () => {
        retries++;
        pendingRequest = null;
        return load();
      };
      const load = () => {
        let thisRequest;
        return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
          err = err instanceof Error ? err : new Error(String(err));
          if (userOnError) {
            return new Promise((resolve2, reject) => {
              const userRetry = () => resolve2(retry());
              const userFail = () => reject(err);
              userOnError(err, userRetry, userFail, retries + 1);
            });
          } else {
            throw err;
          }
        }).then((comp) => {
          if (thisRequest !== pendingRequest && pendingRequest) {
            return pendingRequest;
          }
          if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
            comp = comp.default;
          }
          resolvedComp = comp;
          return comp;
        }));
      };
      return /* @__PURE__ */ defineComponent({
        name: "AsyncComponentWrapper",
        __asyncLoader: load,
        get __asyncResolved() {
          return resolvedComp;
        },
        setup() {
          const instance = currentInstance;
          if (resolvedComp) {
            return () => createInnerComp(resolvedComp, instance);
          }
          const onError = (err) => {
            pendingRequest = null;
            handleError(
              err,
              instance,
              13,
              !errorComponent
            );
          };
          if (suspensible && instance.suspense || isInSSRComponentSetup) {
            return load().then((comp) => {
              return () => createInnerComp(comp, instance);
            }).catch((err) => {
              onError(err);
              return () => errorComponent ? createVNode(errorComponent, {
                error: err
              }) : null;
            });
          }
          const loaded = ref(false);
          const error = ref();
          const delayed = ref(!!delay2);
          if (delay2) {
            setTimeout(() => {
              delayed.value = false;
            }, delay2);
          }
          if (timeout != null) {
            setTimeout(() => {
              if (!loaded.value && !error.value) {
                const err = new Error(
                  `Async component timed out after ${timeout}ms.`
                );
                onError(err);
                error.value = err;
              }
            }, timeout);
          }
          load().then(() => {
            loaded.value = true;
            if (instance.parent && isKeepAlive(instance.parent.vnode)) {
              instance.parent.effect.dirty = true;
              queueJob(instance.parent.update);
            }
          }).catch((err) => {
            onError(err);
            error.value = err;
          });
          return () => {
            if (loaded.value && resolvedComp) {
              return createInnerComp(resolvedComp, instance);
            } else if (error.value && errorComponent) {
              return createVNode(errorComponent, {
                error: error.value
              });
            } else if (loadingComponent && !delayed.value) {
              return createVNode(loadingComponent);
            }
          };
        }
      });
    }
    function createInnerComp(comp, parent) {
      const { ref: ref22, props, children, ce: ce2 } = parent.vnode;
      const vnode = createVNode(comp, props, children);
      vnode.ref = ref22;
      vnode.ce = ce2;
      delete parent.vnode.ce;
      return vnode;
    }
    const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
    const KeepAliveImpl = {
      name: `KeepAlive`,
      // Marker for special handling inside the renderer. We are not using a ===
      // check directly on KeepAlive in the renderer, because importing it directly
      // would prevent it from being tree-shaken.
      __isKeepAlive: true,
      props: {
        include: [String, RegExp, Array],
        exclude: [String, RegExp, Array],
        max: [String, Number]
      },
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const sharedContext = instance.ctx;
        if (!sharedContext.renderer) {
          return () => {
            const children = slots.default && slots.default();
            return children && children.length === 1 ? children[0] : children;
          };
        }
        const cache2 = /* @__PURE__ */ new Map();
        const keys = /* @__PURE__ */ new Set();
        let current = null;
        const parentSuspense = instance.suspense;
        const {
          renderer: {
            p: patch,
            m: move,
            um: _unmount,
            o: { createElement }
          }
        } = sharedContext;
        const storageContainer = createElement("div");
        sharedContext.activate = (vnode, container, anchor2, namespace, optimized) => {
          const instance2 = vnode.component;
          move(vnode, container, anchor2, 0, parentSuspense);
          patch(
            instance2.vnode,
            vnode,
            container,
            anchor2,
            instance2,
            parentSuspense,
            namespace,
            vnode.slotScopeIds,
            optimized
          );
          queuePostRenderEffect(() => {
            instance2.isDeactivated = false;
            if (instance2.a) {
              invokeArrayFns(instance2.a);
            }
            const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
            if (vnodeHook) {
              invokeVNodeHook(vnodeHook, instance2.parent, vnode);
            }
          }, parentSuspense);
        };
        sharedContext.deactivate = (vnode) => {
          const instance2 = vnode.component;
          move(vnode, storageContainer, null, 1, parentSuspense);
          queuePostRenderEffect(() => {
            if (instance2.da) {
              invokeArrayFns(instance2.da);
            }
            const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
            if (vnodeHook) {
              invokeVNodeHook(vnodeHook, instance2.parent, vnode);
            }
            instance2.isDeactivated = true;
          }, parentSuspense);
        };
        function unmount(vnode) {
          resetShapeFlag(vnode);
          _unmount(vnode, instance, parentSuspense, true);
        }
        function pruneCache(filter2) {
          cache2.forEach((vnode, key2) => {
            const name = getComponentName(vnode.type);
            if (name && (!filter2 || !filter2(name))) {
              pruneCacheEntry(key2);
            }
          });
        }
        function pruneCacheEntry(key2) {
          const cached = cache2.get(key2);
          if (!current || !isSameVNodeType(cached, current)) {
            unmount(cached);
          } else if (current) {
            resetShapeFlag(current);
          }
          cache2.delete(key2);
          keys.delete(key2);
        }
        watch$1(
          () => [props.include, props.exclude],
          ([include, exclude]) => {
            include && pruneCache((name) => matches$2(include, name));
            exclude && pruneCache((name) => !matches$2(exclude, name));
          },
          // prune post-render after `current` has been updated
          { flush: "post", deep: true }
        );
        let pendingCacheKey = null;
        const cacheSubtree = () => {
          if (pendingCacheKey != null) {
            cache2.set(pendingCacheKey, getInnerChild(instance.subTree));
          }
        };
        onMounted(cacheSubtree);
        onUpdated(cacheSubtree);
        onBeforeUnmount(() => {
          cache2.forEach((cached) => {
            const { subTree, suspense } = instance;
            const vnode = getInnerChild(subTree);
            if (cached.type === vnode.type && cached.key === vnode.key) {
              resetShapeFlag(vnode);
              const da = vnode.component.da;
              da && queuePostRenderEffect(da, suspense);
              return;
            }
            unmount(cached);
          });
        });
        return () => {
          pendingCacheKey = null;
          if (!slots.default) {
            return null;
          }
          const children = slots.default();
          const rawVNode = children[0];
          if (children.length > 1) {
            current = null;
            return children;
          } else if (!isVNode$1(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
            current = null;
            return rawVNode;
          }
          let vnode = getInnerChild(rawVNode);
          const comp = vnode.type;
          const name = getComponentName(
            isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp
          );
          const { include, exclude, max: max2 } = props;
          if (include && (!name || !matches$2(include, name)) || exclude && name && matches$2(exclude, name)) {
            current = vnode;
            return rawVNode;
          }
          const key2 = vnode.key == null ? comp : vnode.key;
          const cachedVNode = cache2.get(key2);
          if (vnode.el) {
            vnode = cloneVNode(vnode);
            if (rawVNode.shapeFlag & 128) {
              rawVNode.ssContent = vnode;
            }
          }
          pendingCacheKey = key2;
          if (cachedVNode) {
            vnode.el = cachedVNode.el;
            vnode.component = cachedVNode.component;
            if (vnode.transition) {
              setTransitionHooks(vnode, vnode.transition);
            }
            vnode.shapeFlag |= 512;
            keys.delete(key2);
            keys.add(key2);
          } else {
            keys.add(key2);
            if (max2 && keys.size > parseInt(max2, 10)) {
              pruneCacheEntry(keys.values().next().value);
            }
          }
          vnode.shapeFlag |= 256;
          current = vnode;
          return isSuspense(rawVNode.type) ? rawVNode : vnode;
        };
      }
    };
    const KeepAlive = KeepAliveImpl;
    function matches$2(pattern, name) {
      if (isArray$4(pattern)) {
        return pattern.some((p2) => matches$2(p2, name));
      } else if (isString$2(pattern)) {
        return pattern.split(",").includes(name);
      } else if (isRegExp$2(pattern)) {
        return pattern.test(name);
      }
      return false;
    }
    function onActivated(hook2, target) {
      registerKeepAliveHook(hook2, "a", target);
    }
    function onDeactivated(hook2, target) {
      registerKeepAliveHook(hook2, "da", target);
    }
    function registerKeepAliveHook(hook2, type, target = currentInstance) {
      const wrappedHook = hook2.__wdc || (hook2.__wdc = () => {
        let current = target;
        while (current) {
          if (current.isDeactivated) {
            return;
          }
          current = current.parent;
        }
        return hook2();
      });
      injectHook(type, wrappedHook, target);
      if (target) {
        let current = target.parent;
        while (current && current.parent) {
          if (isKeepAlive(current.parent.vnode)) {
            injectToKeepAliveRoot(wrappedHook, type, target, current);
          }
          current = current.parent;
        }
      }
    }
    function injectToKeepAliveRoot(hook2, type, target, keepAliveRoot) {
      const injected = injectHook(
        type,
        hook2,
        keepAliveRoot,
        true
        /* prepend */
      );
      onUnmounted(() => {
        remove(keepAliveRoot[type], injected);
      }, target);
    }
    function resetShapeFlag(vnode) {
      vnode.shapeFlag &= ~256;
      vnode.shapeFlag &= ~512;
    }
    function getInnerChild(vnode) {
      return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
    }
    function injectHook(type, hook2, target = currentInstance, prepend = false) {
      if (target) {
        const hooks = target[type] || (target[type] = []);
        const wrappedHook = hook2.__weh || (hook2.__weh = (...args) => {
          if (target.isUnmounted) {
            return;
          }
          pauseTracking();
          const reset = setCurrentInstance(target);
          const res = callWithAsyncErrorHandling(hook2, target, type, args);
          reset();
          resetTracking();
          return res;
        });
        if (prepend) {
          hooks.unshift(wrappedHook);
        } else {
          hooks.push(wrappedHook);
        }
        return wrappedHook;
      }
    }
    const createHook = (lifecycle) => (hook2, target = currentInstance) => (
      // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
      (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook2(...args), target)
    );
    const onBeforeMount = createHook("bm");
    const onMounted = createHook("m");
    const onBeforeUpdate = createHook("bu");
    const onUpdated = createHook("u");
    const onBeforeUnmount = createHook("bum");
    const onUnmounted = createHook("um");
    const onServerPrefetch = createHook("sp");
    const onRenderTriggered = createHook(
      "rtg"
    );
    const onRenderTracked = createHook(
      "rtc"
    );
    function onErrorCaptured(hook2, target = currentInstance) {
      injectHook("ec", hook2, target);
    }
    function renderList(source, renderItem, cache2, index2) {
      let ret;
      const cached = cache2 && cache2[index2];
      if (isArray$4(source) || isString$2(source)) {
        ret = new Array(source.length);
        for (let i2 = 0, l2 = source.length; i2 < l2; i2++) {
          ret[i2] = renderItem(source[i2], i2, void 0, cached && cached[i2]);
        }
      } else if (typeof source === "number") {
        ret = new Array(source);
        for (let i2 = 0; i2 < source; i2++) {
          ret[i2] = renderItem(i2 + 1, i2, void 0, cached && cached[i2]);
        }
      } else if (isObject$6(source)) {
        if (source[Symbol.iterator]) {
          ret = Array.from(
            source,
            (item, i2) => renderItem(item, i2, void 0, cached && cached[i2])
          );
        } else {
          const keys = Object.keys(source);
          ret = new Array(keys.length);
          for (let i2 = 0, l2 = keys.length; i2 < l2; i2++) {
            const key2 = keys[i2];
            ret[i2] = renderItem(source[key2], key2, i2, cached && cached[i2]);
          }
        }
      } else {
        ret = [];
      }
      if (cache2) {
        cache2[index2] = ret;
      }
      return ret;
    }
    function createSlots(slots, dynamicSlots) {
      for (let i2 = 0; i2 < dynamicSlots.length; i2++) {
        const slot = dynamicSlots[i2];
        if (isArray$4(slot)) {
          for (let j2 = 0; j2 < slot.length; j2++) {
            slots[slot[j2].name] = slot[j2].fn;
          }
        } else if (slot) {
          slots[slot.name] = slot.key ? (...args) => {
            const res = slot.fn(...args);
            if (res)
              res.key = slot.key;
            return res;
          } : slot.fn;
        }
      }
      return slots;
    }
    function renderSlot(slots, name, props = {}, fallback, noSlotted) {
      if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
        if (name !== "default")
          props.name = name;
        return createVNode("slot", props, fallback && fallback());
      }
      let slot = slots[name];
      if (slot && slot._c) {
        slot._d = false;
      }
      openBlock();
      const validSlotContent = slot && ensureValidVNode(slot(props));
      const rendered = createBlock(
        Fragment,
        {
          key: props.key || // slot content array of a dynamic conditional slot may have a branch
          // key attached in the `createSlots` helper, respect that
          validSlotContent && validSlotContent.key || `_${name}`
        },
        validSlotContent || (fallback ? fallback() : []),
        validSlotContent && slots._ === 1 ? 64 : -2
      );
      if (!noSlotted && rendered.scopeId) {
        rendered.slotScopeIds = [rendered.scopeId + "-s"];
      }
      if (slot && slot._c) {
        slot._d = true;
      }
      return rendered;
    }
    function ensureValidVNode(vnodes) {
      return vnodes.some((child2) => {
        if (!isVNode$1(child2))
          return true;
        if (child2.type === Comment)
          return false;
        if (child2.type === Fragment && !ensureValidVNode(child2.children))
          return false;
        return true;
      }) ? vnodes : null;
    }
    function toHandlers(obj, preserveCaseIfNecessary) {
      const ret = {};
      for (const key2 in obj) {
        ret[preserveCaseIfNecessary && /[A-Z]/.test(key2) ? `on:${key2}` : toHandlerKey(key2)] = obj[key2];
      }
      return ret;
    }
    const getPublicInstance = (i2) => {
      if (!i2)
        return null;
      if (isStatefulComponent(i2))
        return getExposeProxy(i2) || i2.proxy;
      return getPublicInstance(i2.parent);
    };
    const publicPropertiesMap = (
      // Move PURE marker to new line to workaround compiler discarding it
      // due to type annotation
      /* @__PURE__ */ extend$1(/* @__PURE__ */ Object.create(null), {
        $: (i2) => i2,
        $el: (i2) => i2.vnode.el,
        $data: (i2) => i2.data,
        $props: (i2) => i2.props,
        $attrs: (i2) => i2.attrs,
        $slots: (i2) => i2.slots,
        $refs: (i2) => i2.refs,
        $parent: (i2) => getPublicInstance(i2.parent),
        $root: (i2) => getPublicInstance(i2.root),
        $emit: (i2) => i2.emit,
        $options: (i2) => resolveMergedOptions(i2),
        $forceUpdate: (i2) => i2.f || (i2.f = () => {
          i2.effect.dirty = true;
          queueJob(i2.update);
        }),
        $nextTick: (i2) => i2.n || (i2.n = nextTick.bind(i2.proxy)),
        $watch: (i2) => instanceWatch.bind(i2)
      })
    );
    const hasSetupBinding = (state, key2) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn$1(state, key2);
    const PublicInstanceProxyHandlers = {
      get({ _: instance }, key2) {
        if (key2 === "__v_skip") {
          return true;
        }
        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
        let normalizedProps;
        if (key2[0] !== "$") {
          const n2 = accessCache[key2];
          if (n2 !== void 0) {
            switch (n2) {
              case 1:
                return setupState[key2];
              case 2:
                return data[key2];
              case 4:
                return ctx[key2];
              case 3:
                return props[key2];
            }
          } else if (hasSetupBinding(setupState, key2)) {
            accessCache[key2] = 1;
            return setupState[key2];
          } else if (data !== EMPTY_OBJ && hasOwn$1(data, key2)) {
            accessCache[key2] = 2;
            return data[key2];
          } else if (
            // only cache other properties when instance has declared (thus stable)
            // props
            (normalizedProps = instance.propsOptions[0]) && hasOwn$1(normalizedProps, key2)
          ) {
            accessCache[key2] = 3;
            return props[key2];
          } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key2)) {
            accessCache[key2] = 4;
            return ctx[key2];
          } else if (shouldCacheAccess) {
            accessCache[key2] = 0;
          }
        }
        const publicGetter = publicPropertiesMap[key2];
        let cssModule, globalProperties;
        if (publicGetter) {
          if (key2 === "$attrs") {
            track(instance.attrs, "get", "");
          }
          return publicGetter(instance);
        } else if (
          // css module (injected by vue-loader)
          (cssModule = type.__cssModules) && (cssModule = cssModule[key2])
        ) {
          return cssModule;
        } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key2)) {
          accessCache[key2] = 4;
          return ctx[key2];
        } else if (
          // global properties
          globalProperties = appContext.config.globalProperties, hasOwn$1(globalProperties, key2)
        ) {
          {
            return globalProperties[key2];
          }
        } else
          ;
      },
      set({ _: instance }, key2, value) {
        const { data, setupState, ctx } = instance;
        if (hasSetupBinding(setupState, key2)) {
          setupState[key2] = value;
          return true;
        } else if (data !== EMPTY_OBJ && hasOwn$1(data, key2)) {
          data[key2] = value;
          return true;
        } else if (hasOwn$1(instance.props, key2)) {
          return false;
        }
        if (key2[0] === "$" && key2.slice(1) in instance) {
          return false;
        } else {
          {
            ctx[key2] = value;
          }
        }
        return true;
      },
      has({
        _: { data, setupState, accessCache, ctx, appContext, propsOptions }
      }, key2) {
        let normalizedProps;
        return !!accessCache[key2] || data !== EMPTY_OBJ && hasOwn$1(data, key2) || hasSetupBinding(setupState, key2) || (normalizedProps = propsOptions[0]) && hasOwn$1(normalizedProps, key2) || hasOwn$1(ctx, key2) || hasOwn$1(publicPropertiesMap, key2) || hasOwn$1(appContext.config.globalProperties, key2);
      },
      defineProperty(target, key2, descriptor) {
        if (descriptor.get != null) {
          target._.accessCache[key2] = 0;
        } else if (hasOwn$1(descriptor, "value")) {
          this.set(target, key2, descriptor.value, null);
        }
        return Reflect.defineProperty(target, key2, descriptor);
      }
    };
    const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ extend$1(
      {},
      PublicInstanceProxyHandlers,
      {
        get(target, key2) {
          if (key2 === Symbol.unscopables) {
            return;
          }
          return PublicInstanceProxyHandlers.get(target, key2, target);
        },
        has(_2, key2) {
          const has2 = key2[0] !== "_" && !isGloballyAllowed(key2);
          return has2;
        }
      }
    );
    function defineProps() {
      return null;
    }
    function defineEmits() {
      return null;
    }
    function defineExpose(exposed) {
    }
    function defineOptions(options) {
    }
    function defineSlots() {
      return null;
    }
    function defineModel() {
    }
    function withDefaults(props, defaults2) {
      return null;
    }
    function useSlots() {
      return getContext().slots;
    }
    function useAttrs() {
      return getContext().attrs;
    }
    function getContext() {
      const i2 = getCurrentInstance();
      return i2.setupContext || (i2.setupContext = createSetupContext(i2));
    }
    function normalizePropsOrEmits(props) {
      return isArray$4(props) ? props.reduce(
        (normalized, p2) => (normalized[p2] = null, normalized),
        {}
      ) : props;
    }
    function mergeDefaults(raw, defaults2) {
      const props = normalizePropsOrEmits(raw);
      for (const key2 in defaults2) {
        if (key2.startsWith("__skip"))
          continue;
        let opt = props[key2];
        if (opt) {
          if (isArray$4(opt) || isFunction$3(opt)) {
            opt = props[key2] = { type: opt, default: defaults2[key2] };
          } else {
            opt.default = defaults2[key2];
          }
        } else if (opt === null) {
          opt = props[key2] = { default: defaults2[key2] };
        } else
          ;
        if (opt && defaults2[`__skip_${key2}`]) {
          opt.skipFactory = true;
        }
      }
      return props;
    }
    function mergeModels(a2, b2) {
      if (!a2 || !b2)
        return a2 || b2;
      if (isArray$4(a2) && isArray$4(b2))
        return a2.concat(b2);
      return extend$1({}, normalizePropsOrEmits(a2), normalizePropsOrEmits(b2));
    }
    function createPropsRestProxy(props, excludedKeys) {
      const ret = {};
      for (const key2 in props) {
        if (!excludedKeys.includes(key2)) {
          Object.defineProperty(ret, key2, {
            enumerable: true,
            get: () => props[key2]
          });
        }
      }
      return ret;
    }
    function withAsyncContext(getAwaitable) {
      const ctx = getCurrentInstance();
      let awaitable = getAwaitable();
      unsetCurrentInstance();
      if (isPromise$2(awaitable)) {
        awaitable = awaitable.catch((e2) => {
          setCurrentInstance(ctx);
          throw e2;
        });
      }
      return [awaitable, () => setCurrentInstance(ctx)];
    }
    let shouldCacheAccess = true;
    function applyOptions(instance) {
      const options = resolveMergedOptions(instance);
      const publicThis = instance.proxy;
      const ctx = instance.ctx;
      shouldCacheAccess = false;
      if (options.beforeCreate) {
        callHook$1(options.beforeCreate, instance, "bc");
      }
      const {
        // state
        data: dataOptions,
        computed: computedOptions,
        methods,
        watch: watchOptions,
        provide: provideOptions,
        inject: injectOptions,
        // lifecycle
        created,
        beforeMount,
        mounted,
        beforeUpdate,
        updated,
        activated,
        deactivated,
        beforeDestroy,
        beforeUnmount,
        destroyed,
        unmounted,
        render: render2,
        renderTracked,
        renderTriggered,
        errorCaptured,
        serverPrefetch,
        // public API
        expose,
        inheritAttrs,
        // assets
        components: components2,
        directives,
        filters
      } = options;
      const checkDuplicateProperties = null;
      if (injectOptions) {
        resolveInjections(injectOptions, ctx, checkDuplicateProperties);
      }
      if (methods) {
        for (const key2 in methods) {
          const methodHandler = methods[key2];
          if (isFunction$3(methodHandler)) {
            {
              ctx[key2] = methodHandler.bind(publicThis);
            }
          }
        }
      }
      if (dataOptions) {
        const data = dataOptions.call(publicThis, publicThis);
        if (!isObject$6(data))
          ;
        else {
          instance.data = reactive(data);
        }
      }
      shouldCacheAccess = true;
      if (computedOptions) {
        for (const key2 in computedOptions) {
          const opt = computedOptions[key2];
          const get2 = isFunction$3(opt) ? opt.bind(publicThis, publicThis) : isFunction$3(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
          const set2 = !isFunction$3(opt) && isFunction$3(opt.set) ? opt.set.bind(publicThis) : NOOP;
          const c2 = computed({
            get: get2,
            set: set2
          });
          Object.defineProperty(ctx, key2, {
            enumerable: true,
            configurable: true,
            get: () => c2.value,
            set: (v2) => c2.value = v2
          });
        }
      }
      if (watchOptions) {
        for (const key2 in watchOptions) {
          createWatcher(watchOptions[key2], ctx, publicThis, key2);
        }
      }
      if (provideOptions) {
        const provides = isFunction$3(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
        Reflect.ownKeys(provides).forEach((key2) => {
          provide(key2, provides[key2]);
        });
      }
      if (created) {
        callHook$1(created, instance, "c");
      }
      function registerLifecycleHook(register, hook2) {
        if (isArray$4(hook2)) {
          hook2.forEach((_hook) => register(_hook.bind(publicThis)));
        } else if (hook2) {
          register(hook2.bind(publicThis));
        }
      }
      registerLifecycleHook(onBeforeMount, beforeMount);
      registerLifecycleHook(onMounted, mounted);
      registerLifecycleHook(onBeforeUpdate, beforeUpdate);
      registerLifecycleHook(onUpdated, updated);
      registerLifecycleHook(onActivated, activated);
      registerLifecycleHook(onDeactivated, deactivated);
      registerLifecycleHook(onErrorCaptured, errorCaptured);
      registerLifecycleHook(onRenderTracked, renderTracked);
      registerLifecycleHook(onRenderTriggered, renderTriggered);
      registerLifecycleHook(onBeforeUnmount, beforeUnmount);
      registerLifecycleHook(onUnmounted, unmounted);
      registerLifecycleHook(onServerPrefetch, serverPrefetch);
      if (isArray$4(expose)) {
        if (expose.length) {
          const exposed = instance.exposed || (instance.exposed = {});
          expose.forEach((key2) => {
            Object.defineProperty(exposed, key2, {
              get: () => publicThis[key2],
              set: (val) => publicThis[key2] = val
            });
          });
        } else if (!instance.exposed) {
          instance.exposed = {};
        }
      }
      if (render2 && instance.render === NOOP) {
        instance.render = render2;
      }
      if (inheritAttrs != null) {
        instance.inheritAttrs = inheritAttrs;
      }
      if (components2)
        instance.components = components2;
      if (directives)
        instance.directives = directives;
    }
    function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
      if (isArray$4(injectOptions)) {
        injectOptions = normalizeInject(injectOptions);
      }
      for (const key2 in injectOptions) {
        const opt = injectOptions[key2];
        let injected;
        if (isObject$6(opt)) {
          if ("default" in opt) {
            injected = inject(
              opt.from || key2,
              opt.default,
              true
            );
          } else {
            injected = inject(opt.from || key2);
          }
        } else {
          injected = inject(opt);
        }
        if (isRef(injected)) {
          Object.defineProperty(ctx, key2, {
            enumerable: true,
            configurable: true,
            get: () => injected.value,
            set: (v2) => injected.value = v2
          });
        } else {
          ctx[key2] = injected;
        }
      }
    }
    function callHook$1(hook2, instance, type) {
      callWithAsyncErrorHandling(
        isArray$4(hook2) ? hook2.map((h2) => h2.bind(instance.proxy)) : hook2.bind(instance.proxy),
        instance,
        type
      );
    }
    function createWatcher(raw, ctx, publicThis, key2) {
      const getter = key2.includes(".") ? createPathGetter(publicThis, key2) : () => publicThis[key2];
      if (isString$2(raw)) {
        const handler = ctx[raw];
        if (isFunction$3(handler)) {
          watch$1(getter, handler);
        }
      } else if (isFunction$3(raw)) {
        watch$1(getter, raw.bind(publicThis));
      } else if (isObject$6(raw)) {
        if (isArray$4(raw)) {
          raw.forEach((r2) => createWatcher(r2, ctx, publicThis, key2));
        } else {
          const handler = isFunction$3(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
          if (isFunction$3(handler)) {
            watch$1(getter, handler, raw);
          }
        }
      } else
        ;
    }
    function resolveMergedOptions(instance) {
      const base = instance.type;
      const { mixins, extends: extendsOptions } = base;
      const {
        mixins: globalMixins,
        optionsCache: cache2,
        config: { optionMergeStrategies }
      } = instance.appContext;
      const cached = cache2.get(base);
      let resolved;
      if (cached) {
        resolved = cached;
      } else if (!globalMixins.length && !mixins && !extendsOptions) {
        {
          resolved = base;
        }
      } else {
        resolved = {};
        if (globalMixins.length) {
          globalMixins.forEach(
            (m2) => mergeOptions$1(resolved, m2, optionMergeStrategies, true)
          );
        }
        mergeOptions$1(resolved, base, optionMergeStrategies);
      }
      if (isObject$6(base)) {
        cache2.set(base, resolved);
      }
      return resolved;
    }
    function mergeOptions$1(to2, from, strats, asMixin = false) {
      const { mixins, extends: extendsOptions } = from;
      if (extendsOptions) {
        mergeOptions$1(to2, extendsOptions, strats, true);
      }
      if (mixins) {
        mixins.forEach(
          (m2) => mergeOptions$1(to2, m2, strats, true)
        );
      }
      for (const key2 in from) {
        if (asMixin && key2 === "expose")
          ;
        else {
          const strat = internalOptionMergeStrats[key2] || strats && strats[key2];
          to2[key2] = strat ? strat(to2[key2], from[key2]) : from[key2];
        }
      }
      return to2;
    }
    const internalOptionMergeStrats = {
      data: mergeDataFn,
      props: mergeEmitsOrPropsOptions,
      emits: mergeEmitsOrPropsOptions,
      // objects
      methods: mergeObjectOptions,
      computed: mergeObjectOptions,
      // lifecycle
      beforeCreate: mergeAsArray,
      created: mergeAsArray,
      beforeMount: mergeAsArray,
      mounted: mergeAsArray,
      beforeUpdate: mergeAsArray,
      updated: mergeAsArray,
      beforeDestroy: mergeAsArray,
      beforeUnmount: mergeAsArray,
      destroyed: mergeAsArray,
      unmounted: mergeAsArray,
      activated: mergeAsArray,
      deactivated: mergeAsArray,
      errorCaptured: mergeAsArray,
      serverPrefetch: mergeAsArray,
      // assets
      components: mergeObjectOptions,
      directives: mergeObjectOptions,
      // watch
      watch: mergeWatchOptions,
      // provide / inject
      provide: mergeDataFn,
      inject: mergeInject
    };
    function mergeDataFn(to2, from) {
      if (!from) {
        return to2;
      }
      if (!to2) {
        return from;
      }
      return function mergedDataFn() {
        return extend$1(
          isFunction$3(to2) ? to2.call(this, this) : to2,
          isFunction$3(from) ? from.call(this, this) : from
        );
      };
    }
    function mergeInject(to2, from) {
      return mergeObjectOptions(normalizeInject(to2), normalizeInject(from));
    }
    function normalizeInject(raw) {
      if (isArray$4(raw)) {
        const res = {};
        for (let i2 = 0; i2 < raw.length; i2++) {
          res[raw[i2]] = raw[i2];
        }
        return res;
      }
      return raw;
    }
    function mergeAsArray(to2, from) {
      return to2 ? [...new Set([].concat(to2, from))] : from;
    }
    function mergeObjectOptions(to2, from) {
      return to2 ? extend$1(/* @__PURE__ */ Object.create(null), to2, from) : from;
    }
    function mergeEmitsOrPropsOptions(to2, from) {
      if (to2) {
        if (isArray$4(to2) && isArray$4(from)) {
          return [.../* @__PURE__ */ new Set([...to2, ...from])];
        }
        return extend$1(
          /* @__PURE__ */ Object.create(null),
          normalizePropsOrEmits(to2),
          normalizePropsOrEmits(from != null ? from : {})
        );
      } else {
        return from;
      }
    }
    function mergeWatchOptions(to2, from) {
      if (!to2)
        return from;
      if (!from)
        return to2;
      const merged = extend$1(/* @__PURE__ */ Object.create(null), to2);
      for (const key2 in from) {
        merged[key2] = mergeAsArray(to2[key2], from[key2]);
      }
      return merged;
    }
    function createAppContext() {
      return {
        app: null,
        config: {
          isNativeTag: NO,
          performance: false,
          globalProperties: {},
          optionMergeStrategies: {},
          errorHandler: void 0,
          warnHandler: void 0,
          compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: /* @__PURE__ */ Object.create(null),
        optionsCache: /* @__PURE__ */ new WeakMap(),
        propsCache: /* @__PURE__ */ new WeakMap(),
        emitsCache: /* @__PURE__ */ new WeakMap()
      };
    }
    let uid$1 = 0;
    function createAppAPI(render2, hydrate2) {
      return function createApp2(rootComponent, rootProps = null) {
        if (!isFunction$3(rootComponent)) {
          rootComponent = extend$1({}, rootComponent);
        }
        if (rootProps != null && !isObject$6(rootProps)) {
          rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = /* @__PURE__ */ new WeakSet();
        let isMounted = false;
        const app2 = context.app = {
          _uid: uid$1++,
          _component: rootComponent,
          _props: rootProps,
          _container: null,
          _context: context,
          _instance: null,
          version: version$2,
          get config() {
            return context.config;
          },
          set config(v2) {
          },
          use(plugin, ...options) {
            if (installedPlugins.has(plugin))
              ;
            else if (plugin && isFunction$3(plugin.install)) {
              installedPlugins.add(plugin);
              plugin.install(app2, ...options);
            } else if (isFunction$3(plugin)) {
              installedPlugins.add(plugin);
              plugin(app2, ...options);
            } else
              ;
            return app2;
          },
          mixin(mixin) {
            {
              if (!context.mixins.includes(mixin)) {
                context.mixins.push(mixin);
              }
            }
            return app2;
          },
          component(name, component) {
            if (!component) {
              return context.components[name];
            }
            context.components[name] = component;
            return app2;
          },
          directive(name, directive) {
            if (!directive) {
              return context.directives[name];
            }
            context.directives[name] = directive;
            return app2;
          },
          mount(rootContainer, isHydrate, namespace) {
            if (!isMounted) {
              const vnode = createVNode(rootComponent, rootProps);
              vnode.appContext = context;
              if (namespace === true) {
                namespace = "svg";
              } else if (namespace === false) {
                namespace = void 0;
              }
              if (isHydrate && hydrate2) {
                hydrate2(vnode, rootContainer);
              } else {
                render2(vnode, rootContainer, namespace);
              }
              isMounted = true;
              app2._container = rootContainer;
              rootContainer.__vue_app__ = app2;
              return getExposeProxy(vnode.component) || vnode.component.proxy;
            }
          },
          unmount() {
            if (isMounted) {
              render2(null, app2._container);
              delete app2._container.__vue_app__;
            }
          },
          provide(key2, value) {
            context.provides[key2] = value;
            return app2;
          },
          runWithContext(fn2) {
            const lastApp = currentApp;
            currentApp = app2;
            try {
              return fn2();
            } finally {
              currentApp = lastApp;
            }
          }
        };
        return app2;
      };
    }
    let currentApp = null;
    function provide(key2, value) {
      if (!currentInstance)
        ;
      else {
        let provides = currentInstance.provides;
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) {
          provides = currentInstance.provides = Object.create(parentProvides);
        }
        provides[key2] = value;
      }
    }
    function inject(key2, defaultValue, treatDefaultAsFactory = false) {
      const instance = currentInstance || currentRenderingInstance;
      if (instance || currentApp) {
        const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
        if (provides && key2 in provides) {
          return provides[key2];
        } else if (arguments.length > 1) {
          return treatDefaultAsFactory && isFunction$3(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
        } else
          ;
      }
    }
    function hasInjectionContext() {
      return !!(currentInstance || currentRenderingInstance || currentApp);
    }
    const internalObjectProto = {};
    const createInternalObject = () => Object.create(internalObjectProto);
    const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
    function initProps(instance, rawProps, isStateful, isSSR = false) {
      const props = {};
      const attrs = createInternalObject();
      instance.propsDefaults = /* @__PURE__ */ Object.create(null);
      setFullProps(instance, rawProps, props, attrs);
      for (const key2 in instance.propsOptions[0]) {
        if (!(key2 in props)) {
          props[key2] = void 0;
        }
      }
      if (isStateful) {
        instance.props = isSSR ? props : shallowReactive(props);
      } else {
        if (!instance.type.props) {
          instance.props = attrs;
        } else {
          instance.props = props;
        }
      }
      instance.attrs = attrs;
    }
    function updateProps(instance, rawProps, rawPrevProps, optimized) {
      const {
        props,
        attrs,
        vnode: { patchFlag }
      } = instance;
      const rawCurrentProps = toRaw(props);
      const [options] = instance.propsOptions;
      let hasAttrsChanged = false;
      if (
        // always force full diff in dev
        // - #1942 if hmr is enabled with sfc component
        // - vite#872 non-sfc component used by sfc component
        (optimized || patchFlag > 0) && !(patchFlag & 16)
      ) {
        if (patchFlag & 8) {
          const propsToUpdate = instance.vnode.dynamicProps;
          for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
            let key2 = propsToUpdate[i2];
            if (isEmitListener(instance.emitsOptions, key2)) {
              continue;
            }
            const value = rawProps[key2];
            if (options) {
              if (hasOwn$1(attrs, key2)) {
                if (value !== attrs[key2]) {
                  attrs[key2] = value;
                  hasAttrsChanged = true;
                }
              } else {
                const camelizedKey = camelize(key2);
                props[camelizedKey] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  camelizedKey,
                  value,
                  instance,
                  false
                );
              }
            } else {
              if (value !== attrs[key2]) {
                attrs[key2] = value;
                hasAttrsChanged = true;
              }
            }
          }
        }
      } else {
        if (setFullProps(instance, rawProps, props, attrs)) {
          hasAttrsChanged = true;
        }
        let kebabKey;
        for (const key2 in rawCurrentProps) {
          if (!rawProps || // for camelCase
          !hasOwn$1(rawProps, key2) && // it's possible the original props was passed in as kebab-case
          // and converted to camelCase (#955)
          ((kebabKey = hyphenate(key2)) === key2 || !hasOwn$1(rawProps, kebabKey))) {
            if (options) {
              if (rawPrevProps && // for camelCase
              (rawPrevProps[key2] !== void 0 || // for kebab-case
              rawPrevProps[kebabKey] !== void 0)) {
                props[key2] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  key2,
                  void 0,
                  instance,
                  true
                );
              }
            } else {
              delete props[key2];
            }
          }
        }
        if (attrs !== rawCurrentProps) {
          for (const key2 in attrs) {
            if (!rawProps || !hasOwn$1(rawProps, key2) && true) {
              delete attrs[key2];
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (hasAttrsChanged) {
        trigger$1(instance.attrs, "set", "");
      }
    }
    function setFullProps(instance, rawProps, props, attrs) {
      const [options, needCastKeys] = instance.propsOptions;
      let hasAttrsChanged = false;
      let rawCastValues;
      if (rawProps) {
        for (let key2 in rawProps) {
          if (isReservedProp(key2)) {
            continue;
          }
          const value = rawProps[key2];
          let camelKey;
          if (options && hasOwn$1(options, camelKey = camelize(key2))) {
            if (!needCastKeys || !needCastKeys.includes(camelKey)) {
              props[camelKey] = value;
            } else {
              (rawCastValues || (rawCastValues = {}))[camelKey] = value;
            }
          } else if (!isEmitListener(instance.emitsOptions, key2)) {
            if (!(key2 in attrs) || value !== attrs[key2]) {
              attrs[key2] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (needCastKeys) {
        const rawCurrentProps = toRaw(props);
        const castValues = rawCastValues || EMPTY_OBJ;
        for (let i2 = 0; i2 < needCastKeys.length; i2++) {
          const key2 = needCastKeys[i2];
          props[key2] = resolvePropValue(
            options,
            rawCurrentProps,
            key2,
            castValues[key2],
            instance,
            !hasOwn$1(castValues, key2)
          );
        }
      }
      return hasAttrsChanged;
    }
    function resolvePropValue(options, props, key2, value, instance, isAbsent) {
      const opt = options[key2];
      if (opt != null) {
        const hasDefault = hasOwn$1(opt, "default");
        if (hasDefault && value === void 0) {
          const defaultValue = opt.default;
          if (opt.type !== Function && !opt.skipFactory && isFunction$3(defaultValue)) {
            const { propsDefaults } = instance;
            if (key2 in propsDefaults) {
              value = propsDefaults[key2];
            } else {
              const reset = setCurrentInstance(instance);
              value = propsDefaults[key2] = defaultValue.call(
                null,
                props
              );
              reset();
            }
          } else {
            value = defaultValue;
          }
        }
        if (opt[
          0
          /* shouldCast */
        ]) {
          if (isAbsent && !hasDefault) {
            value = false;
          } else if (opt[
            1
            /* shouldCastTrue */
          ] && (value === "" || value === hyphenate(key2))) {
            value = true;
          }
        }
      }
      return value;
    }
    function normalizePropsOptions(comp, appContext, asMixin = false) {
      const cache2 = appContext.propsCache;
      const cached = cache2.get(comp);
      if (cached) {
        return cached;
      }
      const raw = comp.props;
      const normalized = {};
      const needCastKeys = [];
      let hasExtends = false;
      if (!isFunction$3(comp)) {
        const extendProps = (raw2) => {
          hasExtends = true;
          const [props, keys] = normalizePropsOptions(raw2, appContext, true);
          extend$1(normalized, props);
          if (keys)
            needCastKeys.push(...keys);
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendProps);
        }
        if (comp.extends) {
          extendProps(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendProps);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject$6(comp)) {
          cache2.set(comp, EMPTY_ARR);
        }
        return EMPTY_ARR;
      }
      if (isArray$4(raw)) {
        for (let i2 = 0; i2 < raw.length; i2++) {
          const normalizedKey = camelize(raw[i2]);
          if (validatePropName(normalizedKey)) {
            normalized[normalizedKey] = EMPTY_OBJ;
          }
        }
      } else if (raw) {
        for (const key2 in raw) {
          const normalizedKey = camelize(key2);
          if (validatePropName(normalizedKey)) {
            const opt = raw[key2];
            const prop = normalized[normalizedKey] = isArray$4(opt) || isFunction$3(opt) ? { type: opt } : extend$1({}, opt);
            if (prop) {
              const booleanIndex = getTypeIndex(Boolean, prop.type);
              const stringIndex = getTypeIndex(String, prop.type);
              prop[
                0
                /* shouldCast */
              ] = booleanIndex > -1;
              prop[
                1
                /* shouldCastTrue */
              ] = stringIndex < 0 || booleanIndex < stringIndex;
              if (booleanIndex > -1 || hasOwn$1(prop, "default")) {
                needCastKeys.push(normalizedKey);
              }
            }
          }
        }
      }
      const res = [normalized, needCastKeys];
      if (isObject$6(comp)) {
        cache2.set(comp, res);
      }
      return res;
    }
    function validatePropName(key2) {
      if (key2[0] !== "$" && !isReservedProp(key2)) {
        return true;
      }
      return false;
    }
    function getType(ctor) {
      if (ctor === null) {
        return "null";
      }
      if (typeof ctor === "function") {
        return ctor.name || "";
      } else if (typeof ctor === "object") {
        const name = ctor.constructor && ctor.constructor.name;
        return name || "";
      }
      return "";
    }
    function isSameType(a2, b2) {
      return getType(a2) === getType(b2);
    }
    function getTypeIndex(type, expectedTypes) {
      if (isArray$4(expectedTypes)) {
        return expectedTypes.findIndex((t2) => isSameType(t2, type));
      } else if (isFunction$3(expectedTypes)) {
        return isSameType(expectedTypes, type) ? 0 : -1;
      }
      return -1;
    }
    const isInternalKey = (key2) => key2[0] === "_" || key2 === "$stable";
    const normalizeSlotValue = (value) => isArray$4(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
    const normalizeSlot$1 = (key2, rawSlot, ctx) => {
      if (rawSlot._n) {
        return rawSlot;
      }
      const normalized = withCtx((...args) => {
        if (false)
          ;
        return normalizeSlotValue(rawSlot(...args));
      }, ctx);
      normalized._c = false;
      return normalized;
    };
    const normalizeObjectSlots = (rawSlots, slots, instance) => {
      const ctx = rawSlots._ctx;
      for (const key2 in rawSlots) {
        if (isInternalKey(key2))
          continue;
        const value = rawSlots[key2];
        if (isFunction$3(value)) {
          slots[key2] = normalizeSlot$1(key2, value, ctx);
        } else if (value != null) {
          const normalized = normalizeSlotValue(value);
          slots[key2] = () => normalized;
        }
      }
    };
    const normalizeVNodeSlots = (instance, children) => {
      const normalized = normalizeSlotValue(children);
      instance.slots.default = () => normalized;
    };
    const initSlots = (instance, children) => {
      const slots = instance.slots = createInternalObject();
      if (instance.vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
          extend$1(slots, children);
          def(slots, "_", type, true);
        } else {
          normalizeObjectSlots(children, slots);
        }
      } else if (children) {
        normalizeVNodeSlots(instance, children);
      }
    };
    const updateSlots = (instance, children, optimized) => {
      const { vnode, slots } = instance;
      let needDeletionCheck = true;
      let deletionComparisonTarget = EMPTY_OBJ;
      if (vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
          if (optimized && type === 1) {
            needDeletionCheck = false;
          } else {
            extend$1(slots, children);
            if (!optimized && type === 1) {
              delete slots._;
            }
          }
        } else {
          needDeletionCheck = !children.$stable;
          normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
      } else if (children) {
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = { default: 1 };
      }
      if (needDeletionCheck) {
        for (const key2 in slots) {
          if (!isInternalKey(key2) && deletionComparisonTarget[key2] == null) {
            delete slots[key2];
          }
        }
      }
    };
    function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
      if (isArray$4(rawRef)) {
        rawRef.forEach(
          (r2, i2) => setRef(
            r2,
            oldRawRef && (isArray$4(oldRawRef) ? oldRawRef[i2] : oldRawRef),
            parentSuspense,
            vnode,
            isUnmount
          )
        );
        return;
      }
      if (isAsyncWrapper(vnode) && !isUnmount) {
        return;
      }
      const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
      const value = isUnmount ? null : refValue;
      const { i: owner, r: ref3 } = rawRef;
      const oldRef = oldRawRef && oldRawRef.r;
      const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
      const setupState = owner.setupState;
      if (oldRef != null && oldRef !== ref3) {
        if (isString$2(oldRef)) {
          refs[oldRef] = null;
          if (hasOwn$1(setupState, oldRef)) {
            setupState[oldRef] = null;
          }
        } else if (isRef(oldRef)) {
          oldRef.value = null;
        }
      }
      if (isFunction$3(ref3)) {
        callWithErrorHandling(ref3, owner, 12, [value, refs]);
      } else {
        const _isString = isString$2(ref3);
        const _isRef = isRef(ref3);
        if (_isString || _isRef) {
          const doSet = () => {
            if (rawRef.f) {
              const existing = _isString ? hasOwn$1(setupState, ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
              if (isUnmount) {
                isArray$4(existing) && remove(existing, refValue);
              } else {
                if (!isArray$4(existing)) {
                  if (_isString) {
                    refs[ref3] = [refValue];
                    if (hasOwn$1(setupState, ref3)) {
                      setupState[ref3] = refs[ref3];
                    }
                  } else {
                    ref3.value = [refValue];
                    if (rawRef.k)
                      refs[rawRef.k] = ref3.value;
                  }
                } else if (!existing.includes(refValue)) {
                  existing.push(refValue);
                }
              }
            } else if (_isString) {
              refs[ref3] = value;
              if (hasOwn$1(setupState, ref3)) {
                setupState[ref3] = value;
              }
            } else if (_isRef) {
              ref3.value = value;
              if (rawRef.k)
                refs[rawRef.k] = value;
            } else
              ;
          };
          if (value) {
            doSet.id = -1;
            queuePostRenderEffect(doSet, parentSuspense);
          } else {
            doSet();
          }
        }
      }
    }
    let hasMismatch = false;
    const isSVGContainer = (container) => container.namespaceURI.includes("svg") && container.tagName !== "foreignObject";
    const isMathMLContainer = (container) => container.namespaceURI.includes("MathML");
    const getContainerType = (container) => {
      if (isSVGContainer(container))
        return "svg";
      if (isMathMLContainer(container))
        return "mathml";
      return void 0;
    };
    const isComment = (node) => node.nodeType === 8;
    function createHydrationFunctions(rendererInternals) {
      const {
        mt: mountComponent,
        p: patch,
        o: {
          patchProp: patchProp2,
          createText,
          nextSibling,
          parentNode,
          remove: remove2,
          insert,
          createComment
        }
      } = rendererInternals;
      const hydrate2 = (vnode, container) => {
        if (!container.hasChildNodes()) {
          patch(null, vnode, container);
          flushPostFlushCbs();
          container._vnode = vnode;
          return;
        }
        hasMismatch = false;
        hydrateNode(container.firstChild, vnode, null, null, null);
        flushPostFlushCbs();
        container._vnode = vnode;
        if (hasMismatch && true) {
          console.error(`Hydration completed but contains mismatches.`);
        }
      };
      const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
        optimized = optimized || !!vnode.dynamicChildren;
        const isFragmentStart = isComment(node) && node.data === "[";
        const onMismatch = () => handleMismatch(
          node,
          vnode,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          isFragmentStart
        );
        const { type, ref: ref3, shapeFlag, patchFlag } = vnode;
        let domType = node.nodeType;
        vnode.el = node;
        if (patchFlag === -2) {
          optimized = false;
          vnode.dynamicChildren = null;
        }
        let nextNode = null;
        switch (type) {
          case Text:
            if (domType !== 3) {
              if (vnode.children === "") {
                insert(vnode.el = createText(""), parentNode(node), node);
                nextNode = node;
              } else {
                nextNode = onMismatch();
              }
            } else {
              if (node.data !== vnode.children) {
                hasMismatch = true;
                node.data = vnode.children;
              }
              nextNode = nextSibling(node);
            }
            break;
          case Comment:
            if (isTemplateNode(node)) {
              nextNode = nextSibling(node);
              replaceNode(
                vnode.el = node.content.firstChild,
                node,
                parentComponent
              );
            } else if (domType !== 8 || isFragmentStart) {
              nextNode = onMismatch();
            } else {
              nextNode = nextSibling(node);
            }
            break;
          case Static:
            if (isFragmentStart) {
              node = nextSibling(node);
              domType = node.nodeType;
            }
            if (domType === 1 || domType === 3) {
              nextNode = node;
              const needToAdoptContent = !vnode.children.length;
              for (let i2 = 0; i2 < vnode.staticCount; i2++) {
                if (needToAdoptContent)
                  vnode.children += nextNode.nodeType === 1 ? nextNode.outerHTML : nextNode.data;
                if (i2 === vnode.staticCount - 1) {
                  vnode.anchor = nextNode;
                }
                nextNode = nextSibling(nextNode);
              }
              return isFragmentStart ? nextSibling(nextNode) : nextNode;
            } else {
              onMismatch();
            }
            break;
          case Fragment:
            if (!isFragmentStart) {
              nextNode = onMismatch();
            } else {
              nextNode = hydrateFragment(
                node,
                vnode,
                parentComponent,
                parentSuspense,
                slotScopeIds,
                optimized
              );
            }
            break;
          default:
            if (shapeFlag & 1) {
              if ((domType !== 1 || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) && !isTemplateNode(node)) {
                nextNode = onMismatch();
              } else {
                nextNode = hydrateElement(
                  node,
                  vnode,
                  parentComponent,
                  parentSuspense,
                  slotScopeIds,
                  optimized
                );
              }
            } else if (shapeFlag & 6) {
              vnode.slotScopeIds = slotScopeIds;
              const container = parentNode(node);
              if (isFragmentStart) {
                nextNode = locateClosingAnchor(node);
              } else if (isComment(node) && node.data === "teleport start") {
                nextNode = locateClosingAnchor(node, node.data, "teleport end");
              } else {
                nextNode = nextSibling(node);
              }
              mountComponent(
                vnode,
                container,
                null,
                parentComponent,
                parentSuspense,
                getContainerType(container),
                optimized
              );
              if (isAsyncWrapper(vnode)) {
                let subTree;
                if (isFragmentStart) {
                  subTree = createVNode(Fragment);
                  subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
                } else {
                  subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
                }
                subTree.el = node;
                vnode.component.subTree = subTree;
              }
            } else if (shapeFlag & 64) {
              if (domType !== 8) {
                nextNode = onMismatch();
              } else {
                nextNode = vnode.type.hydrate(
                  node,
                  vnode,
                  parentComponent,
                  parentSuspense,
                  slotScopeIds,
                  optimized,
                  rendererInternals,
                  hydrateChildren
                );
              }
            } else if (shapeFlag & 128) {
              nextNode = vnode.type.hydrate(
                node,
                vnode,
                parentComponent,
                parentSuspense,
                getContainerType(parentNode(node)),
                slotScopeIds,
                optimized,
                rendererInternals,
                hydrateNode
              );
            } else
              ;
        }
        if (ref3 != null) {
          setRef(ref3, null, parentSuspense, vnode);
        }
        return nextNode;
      };
      const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
        optimized = optimized || !!vnode.dynamicChildren;
        const { type, props, patchFlag, shapeFlag, dirs, transition } = vnode;
        const forcePatch = type === "input" || type === "option";
        if (forcePatch || patchFlag !== -1) {
          if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "created");
          }
          let needCallTransitionHooks = false;
          if (isTemplateNode(el)) {
            needCallTransitionHooks = needTransition(parentSuspense, transition) && parentComponent && parentComponent.vnode.props && parentComponent.vnode.props.appear;
            const content = el.content.firstChild;
            if (needCallTransitionHooks) {
              transition.beforeEnter(content);
            }
            replaceNode(content, el, parentComponent);
            vnode.el = el = content;
          }
          if (shapeFlag & 16 && // skip if element has innerHTML / textContent
          !(props && (props.innerHTML || props.textContent))) {
            let next = hydrateChildren(
              el.firstChild,
              vnode,
              el,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
            while (next) {
              hasMismatch = true;
              const cur = next;
              next = next.nextSibling;
              remove2(cur);
            }
          } else if (shapeFlag & 8) {
            if (el.textContent !== vnode.children) {
              hasMismatch = true;
              el.textContent = vnode.children;
            }
          }
          if (props) {
            if (forcePatch || !optimized || patchFlag & (16 | 32)) {
              for (const key2 in props) {
                if (forcePatch && (key2.endsWith("value") || key2 === "indeterminate") || isOn(key2) && !isReservedProp(key2) || // force hydrate v-bind with .prop modifiers
                key2[0] === ".") {
                  patchProp2(
                    el,
                    key2,
                    null,
                    props[key2],
                    void 0,
                    void 0,
                    parentComponent
                  );
                }
              }
            } else if (props.onClick) {
              patchProp2(
                el,
                "onClick",
                null,
                props.onClick,
                void 0,
                void 0,
                parentComponent
              );
            }
          }
          let vnodeHooks;
          if (vnodeHooks = props && props.onVnodeBeforeMount) {
            invokeVNodeHook(vnodeHooks, parentComponent, vnode);
          }
          if (dirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
          }
          if ((vnodeHooks = props && props.onVnodeMounted) || dirs || needCallTransitionHooks) {
            queueEffectWithSuspense(() => {
              vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
              needCallTransitionHooks && transition.enter(el);
              dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
            }, parentSuspense);
          }
        }
        return el.nextSibling;
      };
      const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
        optimized = optimized || !!parentVNode.dynamicChildren;
        const children = parentVNode.children;
        const l2 = children.length;
        for (let i2 = 0; i2 < l2; i2++) {
          const vnode = optimized ? children[i2] : children[i2] = normalizeVNode(children[i2]);
          if (node) {
            node = hydrateNode(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          } else if (vnode.type === Text && !vnode.children) {
            continue;
          } else {
            hasMismatch = true;
            patch(
              null,
              vnode,
              container,
              null,
              parentComponent,
              parentSuspense,
              getContainerType(container),
              slotScopeIds
            );
          }
        }
        return node;
      };
      const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
        const { slotScopeIds: fragmentSlotScopeIds } = vnode;
        if (fragmentSlotScopeIds) {
          slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        }
        const container = parentNode(node);
        const next = hydrateChildren(
          nextSibling(node),
          vnode,
          container,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        if (next && isComment(next) && next.data === "]") {
          return nextSibling(vnode.anchor = next);
        } else {
          hasMismatch = true;
          insert(vnode.anchor = createComment(`]`), container, next);
          return next;
        }
      };
      const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
        hasMismatch = true;
        vnode.el = null;
        if (isFragment) {
          const end2 = locateClosingAnchor(node);
          while (true) {
            const next2 = nextSibling(node);
            if (next2 && next2 !== end2) {
              remove2(next2);
            } else {
              break;
            }
          }
        }
        const next = nextSibling(node);
        const container = parentNode(node);
        remove2(node);
        patch(
          null,
          vnode,
          container,
          next,
          parentComponent,
          parentSuspense,
          getContainerType(container),
          slotScopeIds
        );
        return next;
      };
      const locateClosingAnchor = (node, open = "[", close = "]") => {
        let match = 0;
        while (node) {
          node = nextSibling(node);
          if (node && isComment(node)) {
            if (node.data === open)
              match++;
            if (node.data === close) {
              if (match === 0) {
                return nextSibling(node);
              } else {
                match--;
              }
            }
          }
        }
        return node;
      };
      const replaceNode = (newNode, oldNode, parentComponent) => {
        const parentNode2 = oldNode.parentNode;
        if (parentNode2) {
          parentNode2.replaceChild(newNode, oldNode);
        }
        let parent = parentComponent;
        while (parent) {
          if (parent.vnode.el === oldNode) {
            parent.vnode.el = parent.subTree.el = newNode;
          }
          parent = parent.parent;
        }
      };
      const isTemplateNode = (node) => {
        return node.nodeType === 1 && node.tagName.toLowerCase() === "template";
      };
      return [hydrate2, hydrateNode];
    }
    const queuePostRenderEffect = queueEffectWithSuspense;
    function createRenderer(options) {
      return baseCreateRenderer(options);
    }
    function createHydrationRenderer(options) {
      return baseCreateRenderer(options, createHydrationFunctions);
    }
    function baseCreateRenderer(options, createHydrationFns) {
      const target = getGlobalThis$1();
      target.__VUE__ = true;
      const {
        insert: hostInsert,
        remove: hostRemove,
        patchProp: hostPatchProp,
        createElement: hostCreateElement,
        createText: hostCreateText,
        createComment: hostCreateComment,
        setText: hostSetText,
        setElementText: hostSetElementText,
        parentNode: hostParentNode,
        nextSibling: hostNextSibling,
        setScopeId: hostSetScopeId = NOOP,
        insertStaticContent: hostInsertStaticContent
      } = options;
      const patch = (n1, n2, container, anchor2 = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
        if (n1 === n2) {
          return;
        }
        if (n1 && !isSameVNodeType(n1, n2)) {
          anchor2 = getNextHostNode(n1);
          unmount(n1, parentComponent, parentSuspense, true);
          n1 = null;
        }
        if (n2.patchFlag === -2) {
          optimized = false;
          n2.dynamicChildren = null;
        }
        const { type, ref: ref3, shapeFlag } = n2;
        switch (type) {
          case Text:
            processText(n1, n2, container, anchor2);
            break;
          case Comment:
            processCommentNode(n1, n2, container, anchor2);
            break;
          case Static:
            if (n1 == null) {
              mountStaticNode(n2, container, anchor2, namespace);
            }
            break;
          case Fragment:
            processFragment(
              n1,
              n2,
              container,
              anchor2,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            break;
          default:
            if (shapeFlag & 1) {
              processElement(
                n1,
                n2,
                container,
                anchor2,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 6) {
              processComponent(
                n1,
                n2,
                container,
                anchor2,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 64) {
              type.process(
                n1,
                n2,
                container,
                anchor2,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized,
                internals
              );
            } else if (shapeFlag & 128) {
              type.process(
                n1,
                n2,
                container,
                anchor2,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized,
                internals
              );
            } else
              ;
        }
        if (ref3 != null && parentComponent) {
          setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
        }
      };
      const processText = (n1, n2, container, anchor2) => {
        if (n1 == null) {
          hostInsert(
            n2.el = hostCreateText(n2.children),
            container,
            anchor2
          );
        } else {
          const el = n2.el = n1.el;
          if (n2.children !== n1.children) {
            hostSetText(el, n2.children);
          }
        }
      };
      const processCommentNode = (n1, n2, container, anchor2) => {
        if (n1 == null) {
          hostInsert(
            n2.el = hostCreateComment(n2.children || ""),
            container,
            anchor2
          );
        } else {
          n2.el = n1.el;
        }
      };
      const mountStaticNode = (n2, container, anchor2, namespace) => {
        [n2.el, n2.anchor] = hostInsertStaticContent(
          n2.children,
          container,
          anchor2,
          namespace,
          n2.el,
          n2.anchor
        );
      };
      const moveStaticNode = ({ el, anchor: anchor2 }, container, nextSibling) => {
        let next;
        while (el && el !== anchor2) {
          next = hostNextSibling(el);
          hostInsert(el, container, nextSibling);
          el = next;
        }
        hostInsert(anchor2, container, nextSibling);
      };
      const removeStaticNode = ({ el, anchor: anchor2 }) => {
        let next;
        while (el && el !== anchor2) {
          next = hostNextSibling(el);
          hostRemove(el);
          el = next;
        }
        hostRemove(anchor2);
      };
      const processElement = (n1, n2, container, anchor2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        if (n2.type === "svg") {
          namespace = "svg";
        } else if (n2.type === "math") {
          namespace = "mathml";
        }
        if (n1 == null) {
          mountElement(
            n2,
            container,
            anchor2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          patchElement(
            n1,
            n2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const mountElement = (vnode, container, anchor2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        let el;
        let vnodeHook;
        const { props, shapeFlag, transition, dirs } = vnode;
        el = vnode.el = hostCreateElement(
          vnode.type,
          namespace,
          props && props.is,
          props
        );
        if (shapeFlag & 8) {
          hostSetElementText(el, vnode.children);
        } else if (shapeFlag & 16) {
          mountChildren(
            vnode.children,
            el,
            null,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(vnode, namespace),
            slotScopeIds,
            optimized
          );
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "created");
        }
        setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        if (props) {
          for (const key2 in props) {
            if (key2 !== "value" && !isReservedProp(key2)) {
              hostPatchProp(
                el,
                key2,
                null,
                props[key2],
                namespace,
                vnode.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
          if ("value" in props) {
            hostPatchProp(el, "value", null, props.value, namespace);
          }
          if (vnodeHook = props.onVnodeBeforeMount) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
          }
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
        }
        const needCallTransitionHooks = needTransition(parentSuspense, transition);
        if (needCallTransitionHooks) {
          transition.beforeEnter(el);
        }
        hostInsert(el, container, anchor2);
        if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            needCallTransitionHooks && transition.enter(el);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
          }, parentSuspense);
        }
      };
      const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
        if (scopeId) {
          hostSetScopeId(el, scopeId);
        }
        if (slotScopeIds) {
          for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
            hostSetScopeId(el, slotScopeIds[i2]);
          }
        }
        if (parentComponent) {
          let subTree = parentComponent.subTree;
          if (vnode === subTree) {
            const parentVNode = parentComponent.vnode;
            setScopeId(
              el,
              parentVNode,
              parentVNode.scopeId,
              parentVNode.slotScopeIds,
              parentComponent.parent
            );
          }
        }
      };
      const mountChildren = (children, container, anchor2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start2 = 0) => {
        for (let i2 = start2; i2 < children.length; i2++) {
          const child2 = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
          patch(
            null,
            child2,
            container,
            anchor2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        const el = n2.el = n1.el;
        let { patchFlag, dynamicChildren, dirs } = n2;
        patchFlag |= n1.patchFlag & 16;
        const oldProps = n1.props || EMPTY_OBJ;
        const newProps = n2.props || EMPTY_OBJ;
        let vnodeHook;
        parentComponent && toggleRecurse(parentComponent, false);
        if (vnodeHook = newProps.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        }
        if (dirs) {
          invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
        }
        parentComponent && toggleRecurse(parentComponent, true);
        if (dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            el,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(n2, namespace),
            slotScopeIds
          );
        } else if (!optimized) {
          patchChildren(
            n1,
            n2,
            el,
            null,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(n2, namespace),
            slotScopeIds,
            false
          );
        }
        if (patchFlag > 0) {
          if (patchFlag & 16) {
            patchProps(
              el,
              n2,
              oldProps,
              newProps,
              parentComponent,
              parentSuspense,
              namespace
            );
          } else {
            if (patchFlag & 2) {
              if (oldProps.class !== newProps.class) {
                hostPatchProp(el, "class", null, newProps.class, namespace);
              }
            }
            if (patchFlag & 4) {
              hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
            }
            if (patchFlag & 8) {
              const propsToUpdate = n2.dynamicProps;
              for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
                const key2 = propsToUpdate[i2];
                const prev = oldProps[key2];
                const next = newProps[key2];
                if (next !== prev || key2 === "value") {
                  hostPatchProp(
                    el,
                    key2,
                    prev,
                    next,
                    namespace,
                    n1.children,
                    parentComponent,
                    parentSuspense,
                    unmountChildren
                  );
                }
              }
            }
          }
          if (patchFlag & 1) {
            if (n1.children !== n2.children) {
              hostSetElementText(el, n2.children);
            }
          }
        } else if (!optimized && dynamicChildren == null) {
          patchProps(
            el,
            n2,
            oldProps,
            newProps,
            parentComponent,
            parentSuspense,
            namespace
          );
        }
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
            dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
          }, parentSuspense);
        }
      };
      const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
        for (let i2 = 0; i2 < newChildren.length; i2++) {
          const oldVNode = oldChildren[i2];
          const newVNode = newChildren[i2];
          const container = (
            // oldVNode may be an errored async setup() component inside Suspense
            // which will not have a mounted element
            oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
            // of the Fragment itself so it can move its children.
            (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
            // which also requires the correct parent container
            !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
            oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
              // In other cases, the parent container is not actually used so we
              // just pass the block element here to avoid a DOM parentNode call.
              fallbackContainer
            )
          );
          patch(
            oldVNode,
            newVNode,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            true
          );
        }
      };
      const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, namespace) => {
        if (oldProps !== newProps) {
          if (oldProps !== EMPTY_OBJ) {
            for (const key2 in oldProps) {
              if (!isReservedProp(key2) && !(key2 in newProps)) {
                hostPatchProp(
                  el,
                  key2,
                  oldProps[key2],
                  null,
                  namespace,
                  vnode.children,
                  parentComponent,
                  parentSuspense,
                  unmountChildren
                );
              }
            }
          }
          for (const key2 in newProps) {
            if (isReservedProp(key2))
              continue;
            const next = newProps[key2];
            const prev = oldProps[key2];
            if (next !== prev && key2 !== "value") {
              hostPatchProp(
                el,
                key2,
                prev,
                next,
                namespace,
                vnode.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
          if ("value" in newProps) {
            hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
          }
        }
      };
      const processFragment = (n1, n2, container, anchor2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
        const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
        if (fragmentSlotScopeIds) {
          slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        }
        if (n1 == null) {
          hostInsert(fragmentStartAnchor, container, anchor2);
          hostInsert(fragmentEndAnchor, container, anchor2);
          mountChildren(
            // #10007
            // such fragment like `<></>` will be compiled into
            // a fragment which doesn't have a children.
            // In this case fallback to an empty array
            n2.children || [],
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
          // of renderSlot() with no valid children
          n1.dynamicChildren) {
            patchBlockChildren(
              n1.dynamicChildren,
              dynamicChildren,
              container,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds
            );
            if (
              // #2080 if the stable fragment has a key, it's a <template v-for> that may
              //  get moved around. Make sure all root level vnodes inherit el.
              // #2134 or if it's a component root, it may also get moved around
              // as the component is being moved.
              n2.key != null || parentComponent && n2 === parentComponent.subTree
            ) {
              traverseStaticChildren(
                n1,
                n2,
                true
                /* shallow */
              );
            }
          } else {
            patchChildren(
              n1,
              n2,
              container,
              fragmentEndAnchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        }
      };
      const processComponent = (n1, n2, container, anchor2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        n2.slotScopeIds = slotScopeIds;
        if (n1 == null) {
          if (n2.shapeFlag & 512) {
            parentComponent.ctx.activate(
              n2,
              container,
              anchor2,
              namespace,
              optimized
            );
          } else {
            mountComponent(
              n2,
              container,
              anchor2,
              parentComponent,
              parentSuspense,
              namespace,
              optimized
            );
          }
        } else {
          updateComponent(n1, n2, optimized);
        }
      };
      const mountComponent = (initialVNode, container, anchor2, parentComponent, parentSuspense, namespace, optimized) => {
        const instance = initialVNode.component = createComponentInstance(
          initialVNode,
          parentComponent,
          parentSuspense
        );
        if (isKeepAlive(initialVNode)) {
          instance.ctx.renderer = internals;
        }
        {
          setupComponent(instance);
        }
        if (instance.asyncDep) {
          parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
          if (!initialVNode.el) {
            const placeholder = instance.subTree = createVNode(Comment);
            processCommentNode(null, placeholder, container, anchor2);
          }
        } else {
          setupRenderEffect(
            instance,
            initialVNode,
            container,
            anchor2,
            parentSuspense,
            namespace,
            optimized
          );
        }
      };
      const updateComponent = (n1, n2, optimized) => {
        const instance = n2.component = n1.component;
        if (shouldUpdateComponent(n1, n2, optimized)) {
          if (instance.asyncDep && !instance.asyncResolved) {
            updateComponentPreRender(instance, n2, optimized);
            return;
          } else {
            instance.next = n2;
            invalidateJob(instance.update);
            instance.effect.dirty = true;
            instance.update();
          }
        } else {
          n2.el = n1.el;
          instance.vnode = n2;
        }
      };
      const setupRenderEffect = (instance, initialVNode, container, anchor2, parentSuspense, namespace, optimized) => {
        const componentUpdateFn = () => {
          if (!instance.isMounted) {
            let vnodeHook;
            const { el, props } = initialVNode;
            const { bm, m: m2, parent } = instance;
            const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
            toggleRecurse(instance, false);
            if (bm) {
              invokeArrayFns(bm);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
              invokeVNodeHook(vnodeHook, parent, initialVNode);
            }
            toggleRecurse(instance, true);
            if (el && hydrateNode) {
              const hydrateSubTree = () => {
                instance.subTree = renderComponentRoot(instance);
                hydrateNode(
                  el,
                  instance.subTree,
                  instance,
                  parentSuspense,
                  null
                );
              };
              if (isAsyncWrapperVNode) {
                initialVNode.type.__asyncLoader().then(
                  // note: we are moving the render call into an async callback,
                  // which means it won't track dependencies - but it's ok because
                  // a server-rendered async wrapper is already in resolved state
                  // and it will never need to change.
                  () => !instance.isUnmounted && hydrateSubTree()
                );
              } else {
                hydrateSubTree();
              }
            } else {
              const subTree = instance.subTree = renderComponentRoot(instance);
              patch(
                null,
                subTree,
                container,
                anchor2,
                instance,
                parentSuspense,
                namespace
              );
              initialVNode.el = subTree.el;
            }
            if (m2) {
              queuePostRenderEffect(m2, parentSuspense);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
              const scopedInitialVNode = initialVNode;
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
                parentSuspense
              );
            }
            if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
              instance.a && queuePostRenderEffect(instance.a, parentSuspense);
            }
            instance.isMounted = true;
            initialVNode = container = anchor2 = null;
          } else {
            let { next, bu, u: u2, parent, vnode } = instance;
            {
              const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
              if (nonHydratedAsyncRoot) {
                if (next) {
                  next.el = vnode.el;
                  updateComponentPreRender(instance, next, optimized);
                }
                nonHydratedAsyncRoot.asyncDep.then(() => {
                  if (!instance.isUnmounted) {
                    componentUpdateFn();
                  }
                });
                return;
              }
            }
            let originNext = next;
            let vnodeHook;
            toggleRecurse(instance, false);
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            } else {
              next = vnode;
            }
            if (bu) {
              invokeArrayFns(bu);
            }
            if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
              invokeVNodeHook(vnodeHook, parent, next, vnode);
            }
            toggleRecurse(instance, true);
            const nextTree = renderComponentRoot(instance);
            const prevTree = instance.subTree;
            instance.subTree = nextTree;
            patch(
              prevTree,
              nextTree,
              // parent may have changed if it's in a teleport
              hostParentNode(prevTree.el),
              // anchor may have changed if it's in a fragment
              getNextHostNode(prevTree),
              instance,
              parentSuspense,
              namespace
            );
            next.el = nextTree.el;
            if (originNext === null) {
              updateHOCHostEl(instance, nextTree.el);
            }
            if (u2) {
              queuePostRenderEffect(u2, parentSuspense);
            }
            if (vnodeHook = next.props && next.props.onVnodeUpdated) {
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent, next, vnode),
                parentSuspense
              );
            }
          }
        };
        const effect2 = instance.effect = new ReactiveEffect(
          componentUpdateFn,
          NOOP,
          () => queueJob(update),
          instance.scope
          // track it in component's effect scope
        );
        const update = instance.update = () => {
          if (effect2.dirty) {
            effect2.run();
          }
        };
        update.id = instance.uid;
        toggleRecurse(instance, true);
        update();
      };
      const updateComponentPreRender = (instance, nextVNode, optimized) => {
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        pauseTracking();
        flushPreFlushCbs(instance);
        resetTracking();
      };
      const patchChildren = (n1, n2, container, anchor2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
        const c1 = n1 && n1.children;
        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        if (patchFlag > 0) {
          if (patchFlag & 128) {
            patchKeyedChildren(
              c1,
              c2,
              container,
              anchor2,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            return;
          } else if (patchFlag & 256) {
            patchUnkeyedChildren(
              c1,
              c2,
              container,
              anchor2,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            return;
          }
        }
        if (shapeFlag & 8) {
          if (prevShapeFlag & 16) {
            unmountChildren(c1, parentComponent, parentSuspense);
          }
          if (c2 !== c1) {
            hostSetElementText(container, c2);
          }
        } else {
          if (prevShapeFlag & 16) {
            if (shapeFlag & 16) {
              patchKeyedChildren(
                c1,
                c2,
                container,
                anchor2,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else {
              unmountChildren(c1, parentComponent, parentSuspense, true);
            }
          } else {
            if (prevShapeFlag & 8) {
              hostSetElementText(container, "");
            }
            if (shapeFlag & 16) {
              mountChildren(
                c2,
                container,
                anchor2,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            }
          }
        }
      };
      const patchUnkeyedChildren = (c1, c2, container, anchor2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        c1 = c1 || EMPTY_ARR;
        c2 = c2 || EMPTY_ARR;
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i2;
        for (i2 = 0; i2 < commonLength; i2++) {
          const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
          patch(
            c1[i2],
            nextChild,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
        if (oldLength > newLength) {
          unmountChildren(
            c1,
            parentComponent,
            parentSuspense,
            true,
            false,
            commonLength
          );
        } else {
          mountChildren(
            c2,
            container,
            anchor2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            commonLength
          );
        }
      };
      const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        let i2 = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1;
        let e2 = l2 - 1;
        while (i2 <= e1 && i2 <= e2) {
          const n1 = c1[i2];
          const n2 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
          if (isSameVNodeType(n1, n2)) {
            patch(
              n1,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          i2++;
        }
        while (i2 <= e1 && i2 <= e2) {
          const n1 = c1[e1];
          const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
          if (isSameVNodeType(n1, n2)) {
            patch(
              n1,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          e1--;
          e2--;
        }
        if (i2 > e1) {
          if (i2 <= e2) {
            const nextPos = e2 + 1;
            const anchor2 = nextPos < l2 ? c2[nextPos].el : parentAnchor;
            while (i2 <= e2) {
              patch(
                null,
                c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]),
                container,
                anchor2,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
              i2++;
            }
          }
        } else if (i2 > e2) {
          while (i2 <= e1) {
            unmount(c1[i2], parentComponent, parentSuspense, true);
            i2++;
          }
        } else {
          const s1 = i2;
          const s2 = i2;
          const keyToNewIndexMap = /* @__PURE__ */ new Map();
          for (i2 = s2; i2 <= e2; i2++) {
            const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
            if (nextChild.key != null) {
              keyToNewIndexMap.set(nextChild.key, i2);
            }
          }
          let j2;
          let patched = 0;
          const toBePatched = e2 - s2 + 1;
          let moved2 = false;
          let maxNewIndexSoFar = 0;
          const newIndexToOldIndexMap = new Array(toBePatched);
          for (i2 = 0; i2 < toBePatched; i2++)
            newIndexToOldIndexMap[i2] = 0;
          for (i2 = s1; i2 <= e1; i2++) {
            const prevChild = c1[i2];
            if (patched >= toBePatched) {
              unmount(prevChild, parentComponent, parentSuspense, true);
              continue;
            }
            let newIndex2;
            if (prevChild.key != null) {
              newIndex2 = keyToNewIndexMap.get(prevChild.key);
            } else {
              for (j2 = s2; j2 <= e2; j2++) {
                if (newIndexToOldIndexMap[j2 - s2] === 0 && isSameVNodeType(prevChild, c2[j2])) {
                  newIndex2 = j2;
                  break;
                }
              }
            }
            if (newIndex2 === void 0) {
              unmount(prevChild, parentComponent, parentSuspense, true);
            } else {
              newIndexToOldIndexMap[newIndex2 - s2] = i2 + 1;
              if (newIndex2 >= maxNewIndexSoFar) {
                maxNewIndexSoFar = newIndex2;
              } else {
                moved2 = true;
              }
              patch(
                prevChild,
                c2[newIndex2],
                container,
                null,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
              patched++;
            }
          }
          const increasingNewIndexSequence = moved2 ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
          j2 = increasingNewIndexSequence.length - 1;
          for (i2 = toBePatched - 1; i2 >= 0; i2--) {
            const nextIndex = s2 + i2;
            const nextChild = c2[nextIndex];
            const anchor2 = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
            if (newIndexToOldIndexMap[i2] === 0) {
              patch(
                null,
                nextChild,
                container,
                anchor2,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else if (moved2) {
              if (j2 < 0 || i2 !== increasingNewIndexSequence[j2]) {
                move(nextChild, container, anchor2, 2);
              } else {
                j2--;
              }
            }
          }
        }
      };
      const move = (vnode, container, anchor2, moveType, parentSuspense = null) => {
        const { el, type, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6) {
          move(vnode.component.subTree, container, anchor2, moveType);
          return;
        }
        if (shapeFlag & 128) {
          vnode.suspense.move(container, anchor2, moveType);
          return;
        }
        if (shapeFlag & 64) {
          type.move(vnode, container, anchor2, internals);
          return;
        }
        if (type === Fragment) {
          hostInsert(el, container, anchor2);
          for (let i2 = 0; i2 < children.length; i2++) {
            move(children[i2], container, anchor2, moveType);
          }
          hostInsert(vnode.anchor, container, anchor2);
          return;
        }
        if (type === Static) {
          moveStaticNode(vnode, container, anchor2);
          return;
        }
        const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
        if (needTransition2) {
          if (moveType === 0) {
            transition.beforeEnter(el);
            hostInsert(el, container, anchor2);
            queuePostRenderEffect(() => transition.enter(el), parentSuspense);
          } else {
            const { leave, delayLeave, afterLeave } = transition;
            const remove22 = () => hostInsert(el, container, anchor2);
            const performLeave = () => {
              leave(el, () => {
                remove22();
                afterLeave && afterLeave();
              });
            };
            if (delayLeave) {
              delayLeave(el, remove22, performLeave);
            } else {
              performLeave();
            }
          }
        } else {
          hostInsert(el, container, anchor2);
        }
      };
      const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
        const {
          type,
          props,
          ref: ref3,
          children,
          dynamicChildren,
          shapeFlag,
          patchFlag,
          dirs
        } = vnode;
        if (ref3 != null) {
          setRef(ref3, null, parentSuspense, vnode, true);
        }
        if (shapeFlag & 256) {
          parentComponent.ctx.deactivate(vnode);
          return;
        }
        const shouldInvokeDirs = shapeFlag & 1 && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        if (shapeFlag & 6) {
          unmountComponent(vnode.component, parentSuspense, doRemove);
        } else {
          if (shapeFlag & 128) {
            vnode.suspense.unmount(parentSuspense, doRemove);
            return;
          }
          if (shouldInvokeDirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
          }
          if (shapeFlag & 64) {
            vnode.type.remove(
              vnode,
              parentComponent,
              parentSuspense,
              optimized,
              internals,
              doRemove
            );
          } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
          (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
            unmountChildren(
              dynamicChildren,
              parentComponent,
              parentSuspense,
              false,
              true
            );
          } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
            unmountChildren(children, parentComponent, parentSuspense);
          }
          if (doRemove) {
            remove2(vnode);
          }
        }
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
          }, parentSuspense);
        }
      };
      const remove2 = (vnode) => {
        const { type, el, anchor: anchor2, transition } = vnode;
        if (type === Fragment) {
          {
            removeFragment(el, anchor2);
          }
          return;
        }
        if (type === Static) {
          removeStaticNode(vnode);
          return;
        }
        const performRemove = () => {
          hostRemove(el);
          if (transition && !transition.persisted && transition.afterLeave) {
            transition.afterLeave();
          }
        };
        if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
          const { leave, delayLeave } = transition;
          const performLeave = () => leave(el, performRemove);
          if (delayLeave) {
            delayLeave(vnode.el, performRemove, performLeave);
          } else {
            performLeave();
          }
        } else {
          performRemove();
        }
      };
      const removeFragment = (cur, end2) => {
        let next;
        while (cur !== end2) {
          next = hostNextSibling(cur);
          hostRemove(cur);
          cur = next;
        }
        hostRemove(end2);
      };
      const unmountComponent = (instance, parentSuspense, doRemove) => {
        const { bum, scope, update, subTree, um } = instance;
        if (bum) {
          invokeArrayFns(bum);
        }
        scope.stop();
        if (update) {
          update.active = false;
          unmount(subTree, instance, parentSuspense, doRemove);
        }
        if (um) {
          queuePostRenderEffect(um, parentSuspense);
        }
        queuePostRenderEffect(() => {
          instance.isUnmounted = true;
        }, parentSuspense);
        if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0) {
            parentSuspense.resolve();
          }
        }
      };
      const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start2 = 0) => {
        for (let i2 = start2; i2 < children.length; i2++) {
          unmount(children[i2], parentComponent, parentSuspense, doRemove, optimized);
        }
      };
      const getNextHostNode = (vnode) => {
        if (vnode.shapeFlag & 6) {
          return getNextHostNode(vnode.component.subTree);
        }
        if (vnode.shapeFlag & 128) {
          return vnode.suspense.next();
        }
        return hostNextSibling(vnode.anchor || vnode.el);
      };
      let isFlushing2 = false;
      const render2 = (vnode, container, namespace) => {
        if (vnode == null) {
          if (container._vnode) {
            unmount(container._vnode, null, null, true);
          }
        } else {
          patch(
            container._vnode || null,
            vnode,
            container,
            null,
            null,
            null,
            namespace
          );
        }
        if (!isFlushing2) {
          isFlushing2 = true;
          flushPreFlushCbs();
          flushPostFlushCbs();
          isFlushing2 = false;
        }
        container._vnode = vnode;
      };
      const internals = {
        p: patch,
        um: unmount,
        m: move,
        r: remove2,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
      };
      let hydrate2;
      let hydrateNode;
      if (createHydrationFns) {
        [hydrate2, hydrateNode] = createHydrationFns(
          internals
        );
      }
      return {
        render: render2,
        hydrate: hydrate2,
        createApp: createAppAPI(render2, hydrate2)
      };
    }
    function resolveChildrenNamespace({ type, props }, currentNamespace) {
      return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
    }
    function toggleRecurse({ effect: effect2, update }, allowed) {
      effect2.allowRecurse = update.allowRecurse = allowed;
    }
    function needTransition(parentSuspense, transition) {
      return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    }
    function traverseStaticChildren(n1, n2, shallow = false) {
      const ch1 = n1.children;
      const ch2 = n2.children;
      if (isArray$4(ch1) && isArray$4(ch2)) {
        for (let i2 = 0; i2 < ch1.length; i2++) {
          const c1 = ch1[i2];
          let c2 = ch2[i2];
          if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
            if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
              c2 = ch2[i2] = cloneIfMounted(ch2[i2]);
              c2.el = c1.el;
            }
            if (!shallow)
              traverseStaticChildren(c1, c2);
          }
          if (c2.type === Text) {
            c2.el = c1.el;
          }
        }
      }
    }
    function getSequence(arr) {
      const p2 = arr.slice();
      const result = [0];
      let i2, j2, u2, v2, c2;
      const len = arr.length;
      for (i2 = 0; i2 < len; i2++) {
        const arrI = arr[i2];
        if (arrI !== 0) {
          j2 = result[result.length - 1];
          if (arr[j2] < arrI) {
            p2[i2] = j2;
            result.push(i2);
            continue;
          }
          u2 = 0;
          v2 = result.length - 1;
          while (u2 < v2) {
            c2 = u2 + v2 >> 1;
            if (arr[result[c2]] < arrI) {
              u2 = c2 + 1;
            } else {
              v2 = c2;
            }
          }
          if (arrI < arr[result[u2]]) {
            if (u2 > 0) {
              p2[i2] = result[u2 - 1];
            }
            result[u2] = i2;
          }
        }
      }
      u2 = result.length;
      v2 = result[u2 - 1];
      while (u2-- > 0) {
        result[u2] = v2;
        v2 = p2[v2];
      }
      return result;
    }
    function locateNonHydratedAsyncRoot(instance) {
      const subComponent = instance.subTree.component;
      if (subComponent) {
        if (subComponent.asyncDep && !subComponent.asyncResolved) {
          return subComponent;
        } else {
          return locateNonHydratedAsyncRoot(subComponent);
        }
      }
    }
    const isTeleport = (type) => type.__isTeleport;
    const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
    const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
    const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
    const resolveTarget = (props, select) => {
      const targetSelector = props && props.to;
      if (isString$2(targetSelector)) {
        if (!select) {
          return null;
        } else {
          const target = select(targetSelector);
          return target;
        }
      } else {
        return targetSelector;
      }
    };
    const TeleportImpl = {
      name: "Teleport",
      __isTeleport: true,
      process(n1, n2, container, anchor2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
        const {
          mc: mountChildren,
          pc: patchChildren,
          pbc: patchBlockChildren,
          o: { insert, querySelector, createText, createComment }
        } = internals;
        const disabled = isTeleportDisabled(n2.props);
        let { shapeFlag, children, dynamicChildren } = n2;
        if (n1 == null) {
          const placeholder = n2.el = createText("");
          const mainAnchor = n2.anchor = createText("");
          insert(placeholder, container, anchor2);
          insert(mainAnchor, container, anchor2);
          const target = n2.target = resolveTarget(n2.props, querySelector);
          const targetAnchor = n2.targetAnchor = createText("");
          if (target) {
            insert(targetAnchor, target);
            if (namespace === "svg" || isTargetSVG(target)) {
              namespace = "svg";
            } else if (namespace === "mathml" || isTargetMathML(target)) {
              namespace = "mathml";
            }
          }
          const mount = (container2, anchor22) => {
            if (shapeFlag & 16) {
              mountChildren(
                children,
                container2,
                anchor22,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            }
          };
          if (disabled) {
            mount(container, mainAnchor);
          } else if (target) {
            mount(target, targetAnchor);
          }
        } else {
          n2.el = n1.el;
          const mainAnchor = n2.anchor = n1.anchor;
          const target = n2.target = n1.target;
          const targetAnchor = n2.targetAnchor = n1.targetAnchor;
          const wasDisabled = isTeleportDisabled(n1.props);
          const currentContainer = wasDisabled ? container : target;
          const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
          if (namespace === "svg" || isTargetSVG(target)) {
            namespace = "svg";
          } else if (namespace === "mathml" || isTargetMathML(target)) {
            namespace = "mathml";
          }
          if (dynamicChildren) {
            patchBlockChildren(
              n1.dynamicChildren,
              dynamicChildren,
              currentContainer,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds
            );
            traverseStaticChildren(n1, n2, true);
          } else if (!optimized) {
            patchChildren(
              n1,
              n2,
              currentContainer,
              currentAnchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              false
            );
          }
          if (disabled) {
            if (!wasDisabled) {
              moveTeleport(
                n2,
                container,
                mainAnchor,
                internals,
                1
              );
            } else {
              if (n2.props && n1.props && n2.props.to !== n1.props.to) {
                n2.props.to = n1.props.to;
              }
            }
          } else {
            if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
              const nextTarget = n2.target = resolveTarget(
                n2.props,
                querySelector
              );
              if (nextTarget) {
                moveTeleport(
                  n2,
                  nextTarget,
                  null,
                  internals,
                  0
                );
              }
            } else if (wasDisabled) {
              moveTeleport(
                n2,
                target,
                targetAnchor,
                internals,
                1
              );
            }
          }
        }
        updateCssVars(n2);
      },
      remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
        const { shapeFlag, children, anchor: anchor2, targetAnchor, target, props } = vnode;
        if (target) {
          hostRemove(targetAnchor);
        }
        doRemove && hostRemove(anchor2);
        if (shapeFlag & 16) {
          const shouldRemove = doRemove || !isTeleportDisabled(props);
          for (let i2 = 0; i2 < children.length; i2++) {
            const child2 = children[i2];
            unmount(
              child2,
              parentComponent,
              parentSuspense,
              shouldRemove,
              !!child2.dynamicChildren
            );
          }
        }
      },
      move: moveTeleport,
      hydrate: hydrateTeleport
    };
    function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
      if (moveType === 0) {
        insert(vnode.targetAnchor, container, parentAnchor);
      }
      const { el, anchor: anchor2, shapeFlag, children, props } = vnode;
      const isReorder = moveType === 2;
      if (isReorder) {
        insert(el, container, parentAnchor);
      }
      if (!isReorder || isTeleportDisabled(props)) {
        if (shapeFlag & 16) {
          for (let i2 = 0; i2 < children.length; i2++) {
            move(
              children[i2],
              container,
              parentAnchor,
              2
            );
          }
        }
      }
      if (isReorder) {
        insert(anchor2, container, parentAnchor);
      }
    }
    function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
      o: { nextSibling, parentNode, querySelector }
    }, hydrateChildren) {
      const target = vnode.target = resolveTarget(
        vnode.props,
        querySelector
      );
      if (target) {
        const targetNode = target._lpa || target.firstChild;
        if (vnode.shapeFlag & 16) {
          if (isTeleportDisabled(vnode.props)) {
            vnode.anchor = hydrateChildren(
              nextSibling(node),
              vnode,
              parentNode(node),
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
            vnode.targetAnchor = targetNode;
          } else {
            vnode.anchor = nextSibling(node);
            let targetAnchor = targetNode;
            while (targetAnchor) {
              targetAnchor = nextSibling(targetAnchor);
              if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
                vnode.targetAnchor = targetAnchor;
                target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                break;
              }
            }
            hydrateChildren(
              targetNode,
              vnode,
              target,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
        }
        updateCssVars(vnode);
      }
      return vnode.anchor && nextSibling(vnode.anchor);
    }
    const Teleport = TeleportImpl;
    function updateCssVars(vnode) {
      const ctx = vnode.ctx;
      if (ctx && ctx.ut) {
        let node = vnode.children[0].el;
        while (node && node !== vnode.targetAnchor) {
          if (node.nodeType === 1)
            node.setAttribute("data-v-owner", ctx.uid);
          node = node.nextSibling;
        }
        ctx.ut();
      }
    }
    const Fragment = Symbol.for("v-fgt");
    const Text = Symbol.for("v-txt");
    const Comment = Symbol.for("v-cmt");
    const Static = Symbol.for("v-stc");
    const blockStack = [];
    let currentBlock = null;
    function openBlock(disableTracking = false) {
      blockStack.push(currentBlock = disableTracking ? null : []);
    }
    function closeBlock() {
      blockStack.pop();
      currentBlock = blockStack[blockStack.length - 1] || null;
    }
    let isBlockTreeEnabled = 1;
    function setBlockTracking(value) {
      isBlockTreeEnabled += value;
    }
    function setupBlock(vnode) {
      vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
      closeBlock();
      if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
      return setupBlock(
        createBaseVNode(
          type,
          props,
          children,
          patchFlag,
          dynamicProps,
          shapeFlag,
          true
        )
      );
    }
    function createBlock(type, props, children, patchFlag, dynamicProps) {
      return setupBlock(
        createVNode(
          type,
          props,
          children,
          patchFlag,
          dynamicProps,
          true
        )
      );
    }
    function isVNode$1(value) {
      return value ? value.__v_isVNode === true : false;
    }
    function isSameVNodeType(n1, n2) {
      return n1.type === n2.type && n1.key === n2.key;
    }
    function transformVNodeArgs(transformer) {
    }
    const normalizeKey = ({ key: key2 }) => key2 != null ? key2 : null;
    const normalizeRef = ({
      ref: ref3,
      ref_key,
      ref_for
    }) => {
      if (typeof ref3 === "number") {
        ref3 = "" + ref3;
      }
      return ref3 != null ? isString$2(ref3) || isRef(ref3) || isFunction$3(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
    };
    function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
      const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null,
        ctx: currentRenderingInstance
      };
      if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children);
        if (shapeFlag & 128) {
          type.normalize(vnode);
        }
      } else if (children) {
        vnode.shapeFlag |= isString$2(children) ? 8 : 16;
      }
      if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
      !isBlockNode && // has current parent block
      currentBlock && // presence of a patch flag indicates this node needs patching on updates.
      // component nodes also should always be patched, because even if the
      // component doesn't need to update, it needs to persist the instance on to
      // the next vnode so that it can be properly unmounted later.
      (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
      // vnode should not be considered dynamic due to handler caching.
      vnode.patchFlag !== 32) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    const createVNode = _createVNode;
    function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
      if (!type || type === NULL_DYNAMIC_COMPONENT) {
        type = Comment;
      }
      if (isVNode$1(type)) {
        const cloned = cloneVNode(
          type,
          props,
          true
          /* mergeRef: true */
        );
        if (children) {
          normalizeChildren(cloned, children);
        }
        if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
          if (cloned.shapeFlag & 6) {
            currentBlock[currentBlock.indexOf(type)] = cloned;
          } else {
            currentBlock.push(cloned);
          }
        }
        cloned.patchFlag |= -2;
        return cloned;
      }
      if (isClassComponent(type)) {
        type = type.__vccOpts;
      }
      if (props) {
        props = guardReactiveProps(props);
        let { class: klass, style } = props;
        if (klass && !isString$2(klass)) {
          props.class = normalizeClass(klass);
        }
        if (isObject$6(style)) {
          if (isProxy(style) && !isArray$4(style)) {
            style = extend$1({}, style);
          }
          props.style = normalizeStyle(style);
        }
      }
      const shapeFlag = isString$2(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$6(type) ? 4 : isFunction$3(type) ? 2 : 0;
      return createBaseVNode(
        type,
        props,
        children,
        patchFlag,
        dynamicProps,
        shapeFlag,
        isBlockNode,
        true
      );
    }
    function guardReactiveProps(props) {
      if (!props)
        return null;
      return isProxy(props) || isInternalObject(props) ? extend$1({}, props) : props;
    }
    function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
      const { props, ref: ref3, patchFlag, children, transition } = vnode;
      const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
      const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref ? (
          // #2078 in the case of <component :is="vnode" ref="extra"/>
          // if the vnode itself already has a ref, cloneVNode will need to merge
          // the refs so the single vnode can be set on multiple refs
          mergeRef && ref3 ? isArray$4(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
        ) : ref3,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children,
        target: vnode.target,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
        // note: preserve flag for fragments since they use the flag for children
        // fast paths only.
        patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor,
        ctx: vnode.ctx,
        ce: vnode.ce
      };
      if (transition && cloneTransition) {
        cloned.transition = transition.clone(cloned);
      }
      return cloned;
    }
    function createTextVNode(text = " ", flag = 0) {
      return createVNode(Text, null, text, flag);
    }
    function createStaticVNode(content, numberOfNodes) {
      const vnode = createVNode(Static, null, content);
      vnode.staticCount = numberOfNodes;
      return vnode;
    }
    function createCommentVNode(text = "", asBlock = false) {
      return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
    }
    function normalizeVNode(child2) {
      if (child2 == null || typeof child2 === "boolean") {
        return createVNode(Comment);
      } else if (isArray$4(child2)) {
        return createVNode(
          Fragment,
          null,
          // #3666, avoid reference pollution when reusing vnode
          child2.slice()
        );
      } else if (typeof child2 === "object") {
        return cloneIfMounted(child2);
      } else {
        return createVNode(Text, null, String(child2));
      }
    }
    function cloneIfMounted(child2) {
      return child2.el === null && child2.patchFlag !== -1 || child2.memo ? child2 : cloneVNode(child2);
    }
    function normalizeChildren(vnode, children) {
      let type = 0;
      const { shapeFlag } = vnode;
      if (children == null) {
        children = null;
      } else if (isArray$4(children)) {
        type = 16;
      } else if (typeof children === "object") {
        if (shapeFlag & (1 | 64)) {
          const slot = children.default;
          if (slot) {
            slot._c && (slot._d = false);
            normalizeChildren(vnode, slot());
            slot._c && (slot._d = true);
          }
          return;
        } else {
          type = 32;
          const slotFlag = children._;
          if (!slotFlag && !isInternalObject(children)) {
            children._ctx = currentRenderingInstance;
          } else if (slotFlag === 3 && currentRenderingInstance) {
            if (currentRenderingInstance.slots._ === 1) {
              children._ = 1;
            } else {
              children._ = 2;
              vnode.patchFlag |= 1024;
            }
          }
        }
      } else if (isFunction$3(children)) {
        children = { default: children, _ctx: currentRenderingInstance };
        type = 32;
      } else {
        children = String(children);
        if (shapeFlag & 64) {
          type = 16;
          children = [createTextVNode(children)];
        } else {
          type = 8;
        }
      }
      vnode.children = children;
      vnode.shapeFlag |= type;
    }
    function mergeProps(...args) {
      const ret = {};
      for (let i2 = 0; i2 < args.length; i2++) {
        const toMerge = args[i2];
        for (const key2 in toMerge) {
          if (key2 === "class") {
            if (ret.class !== toMerge.class) {
              ret.class = normalizeClass([ret.class, toMerge.class]);
            }
          } else if (key2 === "style") {
            ret.style = normalizeStyle([ret.style, toMerge.style]);
          } else if (isOn(key2)) {
            const existing = ret[key2];
            const incoming = toMerge[key2];
            if (incoming && existing !== incoming && !(isArray$4(existing) && existing.includes(incoming))) {
              ret[key2] = existing ? [].concat(existing, incoming) : incoming;
            }
          } else if (key2 !== "") {
            ret[key2] = toMerge[key2];
          }
        }
      }
      return ret;
    }
    function invokeVNodeHook(hook2, instance, vnode, prevVNode = null) {
      callWithAsyncErrorHandling(hook2, instance, 7, [
        vnode,
        prevVNode
      ]);
    }
    const emptyAppContext = createAppContext();
    let uid = 0;
    function createComponentInstance(vnode, parent, suspense) {
      const type = vnode.type;
      const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
      const instance = {
        uid: uid++,
        vnode,
        type,
        parent,
        appContext,
        root: null,
        // to be immediately set
        next: null,
        subTree: null,
        // will be set synchronously right after creation
        effect: null,
        update: null,
        // will be set synchronously right after creation
        scope: new EffectScope(
          true
          /* detached */
        ),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        accessCache: null,
        renderCache: [],
        // local resolved assets
        components: null,
        directives: null,
        // resolved props and emits options
        propsOptions: normalizePropsOptions(type, appContext),
        emitsOptions: normalizeEmitsOptions(type, appContext),
        // emit
        emit: null,
        // to be set immediately
        emitted: null,
        // props default value
        propsDefaults: EMPTY_OBJ,
        // inheritAttrs
        inheritAttrs: type.inheritAttrs,
        // state
        ctx: EMPTY_OBJ,
        data: EMPTY_OBJ,
        props: EMPTY_OBJ,
        attrs: EMPTY_OBJ,
        slots: EMPTY_OBJ,
        refs: EMPTY_OBJ,
        setupState: EMPTY_OBJ,
        setupContext: null,
        attrsProxy: null,
        slotsProxy: null,
        // suspense related
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
      };
      {
        instance.ctx = { _: instance };
      }
      instance.root = parent ? parent.root : instance;
      instance.emit = emit.bind(null, instance);
      if (vnode.ce) {
        vnode.ce(instance);
      }
      return instance;
    }
    let currentInstance = null;
    const getCurrentInstance = () => currentInstance || currentRenderingInstance;
    let internalSetCurrentInstance;
    let setInSSRSetupState;
    {
      const g2 = getGlobalThis$1();
      const registerGlobalSetter = (key2, setter) => {
        let setters;
        if (!(setters = g2[key2]))
          setters = g2[key2] = [];
        setters.push(setter);
        return (v2) => {
          if (setters.length > 1)
            setters.forEach((set2) => set2(v2));
          else
            setters[0](v2);
        };
      };
      internalSetCurrentInstance = registerGlobalSetter(
        `__VUE_INSTANCE_SETTERS__`,
        (v2) => currentInstance = v2
      );
      setInSSRSetupState = registerGlobalSetter(
        `__VUE_SSR_SETTERS__`,
        (v2) => isInSSRComponentSetup = v2
      );
    }
    const setCurrentInstance = (instance) => {
      const prev = currentInstance;
      internalSetCurrentInstance(instance);
      instance.scope.on();
      return () => {
        instance.scope.off();
        internalSetCurrentInstance(prev);
      };
    };
    const unsetCurrentInstance = () => {
      currentInstance && currentInstance.scope.off();
      internalSetCurrentInstance(null);
    };
    function isStatefulComponent(instance) {
      return instance.vnode.shapeFlag & 4;
    }
    let isInSSRComponentSetup = false;
    function setupComponent(instance, isSSR = false) {
      isSSR && setInSSRSetupState(isSSR);
      const { props, children } = instance.vnode;
      const isStateful = isStatefulComponent(instance);
      initProps(instance, props, isStateful, isSSR);
      initSlots(instance, children);
      const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
      isSSR && setInSSRSetupState(false);
      return setupResult;
    }
    function setupStatefulComponent(instance, isSSR) {
      const Component = instance.type;
      instance.accessCache = /* @__PURE__ */ Object.create(null);
      instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
      const { setup } = Component;
      if (setup) {
        const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
        const reset = setCurrentInstance(instance);
        pauseTracking();
        const setupResult = callWithErrorHandling(
          setup,
          instance,
          0,
          [
            instance.props,
            setupContext
          ]
        );
        resetTracking();
        reset();
        if (isPromise$2(setupResult)) {
          setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
          if (isSSR) {
            return setupResult.then((resolvedResult) => {
              handleSetupResult(instance, resolvedResult, isSSR);
            }).catch((e2) => {
              handleError(e2, instance, 0);
            });
          } else {
            instance.asyncDep = setupResult;
          }
        } else {
          handleSetupResult(instance, setupResult, isSSR);
        }
      } else {
        finishComponentSetup(instance, isSSR);
      }
    }
    function handleSetupResult(instance, setupResult, isSSR) {
      if (isFunction$3(setupResult)) {
        if (instance.type.__ssrInlineRender) {
          instance.ssrRender = setupResult;
        } else {
          instance.render = setupResult;
        }
      } else if (isObject$6(setupResult)) {
        instance.setupState = proxyRefs(setupResult);
      } else
        ;
      finishComponentSetup(instance, isSSR);
    }
    let compile$3;
    let installWithProxy;
    function registerRuntimeCompiler(_compile) {
      compile$3 = _compile;
      installWithProxy = (i2) => {
        if (i2.render._rc) {
          i2.withProxy = new Proxy(i2.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
        }
      };
    }
    const isRuntimeOnly = () => !compile$3;
    function finishComponentSetup(instance, isSSR, skipOptions) {
      const Component = instance.type;
      if (!instance.render) {
        if (!isSSR && compile$3 && !Component.render) {
          const template = Component.template || resolveMergedOptions(instance).template;
          if (template) {
            const { isCustomElement, compilerOptions } = instance.appContext.config;
            const { delimiters, compilerOptions: componentCompilerOptions } = Component;
            const finalCompilerOptions = extend$1(
              extend$1(
                {
                  isCustomElement,
                  delimiters
                },
                compilerOptions
              ),
              componentCompilerOptions
            );
            Component.render = compile$3(template, finalCompilerOptions);
          }
        }
        instance.render = Component.render || NOOP;
        if (installWithProxy) {
          installWithProxy(instance);
        }
      }
      {
        const reset = setCurrentInstance(instance);
        pauseTracking();
        try {
          applyOptions(instance);
        } finally {
          resetTracking();
          reset();
        }
      }
    }
    const attrsProxyHandlers = {
      get(target, key2) {
        track(target, "get", "");
        return target[key2];
      }
    };
    function createSetupContext(instance) {
      const expose = (exposed) => {
        instance.exposed = exposed || {};
      };
      {
        return {
          attrs: new Proxy(instance.attrs, attrsProxyHandlers),
          slots: instance.slots,
          emit: instance.emit,
          expose
        };
      }
    }
    function getExposeProxy(instance) {
      if (instance.exposed) {
        return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
          get(target, key2) {
            if (key2 in target) {
              return target[key2];
            } else if (key2 in publicPropertiesMap) {
              return publicPropertiesMap[key2](instance);
            }
          },
          has(target, key2) {
            return key2 in target || key2 in publicPropertiesMap;
          }
        }));
      }
    }
    const classifyRE = /(?:^|[-_])(\w)/g;
    const classify = (str) => str.replace(classifyRE, (c2) => c2.toUpperCase()).replace(/[-_]/g, "");
    function getComponentName(Component, includeInferred = true) {
      return isFunction$3(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
    }
    function formatComponentName(instance, Component, isRoot = false) {
      let name = getComponentName(Component);
      if (!name && Component.__file) {
        const match = Component.__file.match(/([^/\\]+)\.\w+$/);
        if (match) {
          name = match[1];
        }
      }
      if (!name && instance && instance.parent) {
        const inferFromRegistry = (registry) => {
          for (const key2 in registry) {
            if (registry[key2] === Component) {
              return key2;
            }
          }
        };
        name = inferFromRegistry(
          instance.components || instance.parent.type.components
        ) || inferFromRegistry(instance.appContext.components);
      }
      return name ? classify(name) : isRoot ? `App` : `Anonymous`;
    }
    function isClassComponent(value) {
      return isFunction$3(value) && "__vccOpts" in value;
    }
    const computed = (getterOrOptions, debugOptions) => {
      const c2 = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
      return c2;
    };
    function useModel(props, name, options = EMPTY_OBJ) {
      const i2 = getCurrentInstance();
      const camelizedName = camelize(name);
      const hyphenatedName = hyphenate(name);
      const res = customRef((track2, trigger2) => {
        let localValue;
        watchSyncEffect(() => {
          const propValue = props[name];
          if (hasChanged(localValue, propValue)) {
            localValue = propValue;
            trigger2();
          }
        });
        return {
          get() {
            track2();
            return options.get ? options.get(localValue) : localValue;
          },
          set(value) {
            const rawProps = i2.vnode.props;
            if (!(rawProps && // check if parent has passed v-model
            (name in rawProps || camelizedName in rawProps || hyphenatedName in rawProps) && (`onUpdate:${name}` in rawProps || `onUpdate:${camelizedName}` in rawProps || `onUpdate:${hyphenatedName}` in rawProps)) && hasChanged(value, localValue)) {
              localValue = value;
              trigger2();
            }
            i2.emit(`update:${name}`, options.set ? options.set(value) : value);
          }
        };
      });
      const modifierKey = name === "modelValue" ? "modelModifiers" : `${name}Modifiers`;
      res[Symbol.iterator] = () => {
        let i22 = 0;
        return {
          next() {
            if (i22 < 2) {
              return { value: i22++ ? props[modifierKey] || {} : res, done: false };
            } else {
              return { done: true };
            }
          }
        };
      };
      return res;
    }
    function h$4(type, propsOrChildren, children) {
      const l2 = arguments.length;
      if (l2 === 2) {
        if (isObject$6(propsOrChildren) && !isArray$4(propsOrChildren)) {
          if (isVNode$1(propsOrChildren)) {
            return createVNode(type, null, [propsOrChildren]);
          }
          return createVNode(type, propsOrChildren);
        } else {
          return createVNode(type, null, propsOrChildren);
        }
      } else {
        if (l2 > 3) {
          children = Array.prototype.slice.call(arguments, 2);
        } else if (l2 === 3 && isVNode$1(children)) {
          children = [children];
        }
        return createVNode(type, propsOrChildren, children);
      }
    }
    function initCustomFormatter() {
      {
        return;
      }
    }
    function withMemo(memo2, render2, cache2, index2) {
      const cached = cache2[index2];
      if (cached && isMemoSame(cached, memo2)) {
        return cached;
      }
      const ret = render2();
      ret.memo = memo2.slice();
      return cache2[index2] = ret;
    }
    function isMemoSame(cached, memo2) {
      const prev = cached.memo;
      if (prev.length != memo2.length) {
        return false;
      }
      for (let i2 = 0; i2 < prev.length; i2++) {
        if (hasChanged(prev[i2], memo2[i2])) {
          return false;
        }
      }
      if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(cached);
      }
      return true;
    }
    const version$2 = "3.4.27";
    const warn$2 = NOOP;
    const ErrorTypeStrings = ErrorTypeStrings$1;
    const devtools$2 = devtools$1;
    const setDevtoolsHook = setDevtoolsHook$1;
    const _ssrUtils = {
      createComponentInstance,
      setupComponent,
      renderComponentRoot,
      setCurrentRenderingInstance,
      isVNode: isVNode$1,
      normalizeVNode
    };
    const ssrUtils = _ssrUtils;
    const resolveFilter = null;
    const compatUtils = null;
    const DeprecationTypes = null;
    /**
    * @vue/runtime-dom v3.4.27
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    const svgNS = "http://www.w3.org/2000/svg";
    const mathmlNS = "http://www.w3.org/1998/Math/MathML";
    const doc = typeof document !== "undefined" ? document : null;
    const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
    const nodeOps = {
      insert: (child2, parent, anchor2) => {
        parent.insertBefore(child2, anchor2 || null);
      },
      remove: (child2) => {
        const parent = child2.parentNode;
        if (parent) {
          parent.removeChild(child2);
        }
      },
      createElement: (tag, namespace, is, props) => {
        const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : doc.createElement(tag, is ? { is } : void 0);
        if (tag === "select" && props && props.multiple != null) {
          el.setAttribute("multiple", props.multiple);
        }
        return el;
      },
      createText: (text) => doc.createTextNode(text),
      createComment: (text) => doc.createComment(text),
      setText: (node, text) => {
        node.nodeValue = text;
      },
      setElementText: (el, text) => {
        el.textContent = text;
      },
      parentNode: (node) => node.parentNode,
      nextSibling: (node) => node.nextSibling,
      querySelector: (selector) => doc.querySelector(selector),
      setScopeId(el, id2) {
        el.setAttribute(id2, "");
      },
      // __UNSAFE__
      // Reason: innerHTML.
      // Static content here can only come from compiled templates.
      // As long as the user only uses trusted templates, this is safe.
      insertStaticContent(content, parent, anchor2, namespace, start2, end2) {
        const before = anchor2 ? anchor2.previousSibling : parent.lastChild;
        if (start2 && (start2 === end2 || start2.nextSibling)) {
          while (true) {
            parent.insertBefore(start2.cloneNode(true), anchor2);
            if (start2 === end2 || !(start2 = start2.nextSibling))
              break;
          }
        } else {
          templateContainer.innerHTML = namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content;
          const template = templateContainer.content;
          if (namespace === "svg" || namespace === "mathml") {
            const wrapper = template.firstChild;
            while (wrapper.firstChild) {
              template.appendChild(wrapper.firstChild);
            }
            template.removeChild(wrapper);
          }
          parent.insertBefore(template, anchor2);
        }
        return [
          // first
          before ? before.nextSibling : parent.firstChild,
          // last
          anchor2 ? anchor2.previousSibling : parent.lastChild
        ];
      }
    };
    const TRANSITION = "transition";
    const ANIMATION = "animation";
    const vtcKey = Symbol("_vtc");
    const Transition = (props, { slots }) => h$4(BaseTransition, resolveTransitionProps(props), slots);
    Transition.displayName = "Transition";
    const DOMTransitionPropsValidators = {
      name: String,
      type: String,
      css: {
        type: Boolean,
        default: true
      },
      duration: [String, Number, Object],
      enterFromClass: String,
      enterActiveClass: String,
      enterToClass: String,
      appearFromClass: String,
      appearActiveClass: String,
      appearToClass: String,
      leaveFromClass: String,
      leaveActiveClass: String,
      leaveToClass: String
    };
    const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend$1(
      {},
      BaseTransitionPropsValidators,
      DOMTransitionPropsValidators
    );
    const callHook = (hook2, args = []) => {
      if (isArray$4(hook2)) {
        hook2.forEach((h2) => h2(...args));
      } else if (hook2) {
        hook2(...args);
      }
    };
    const hasExplicitCallback = (hook2) => {
      return hook2 ? isArray$4(hook2) ? hook2.some((h2) => h2.length > 1) : hook2.length > 1 : false;
    };
    function resolveTransitionProps(rawProps) {
      const baseProps = {};
      for (const key2 in rawProps) {
        if (!(key2 in DOMTransitionPropsValidators)) {
          baseProps[key2] = rawProps[key2];
        }
      }
      if (rawProps.css === false) {
        return baseProps;
      }
      const {
        name = "v",
        type,
        duration,
        enterFromClass = `${name}-enter-from`,
        enterActiveClass = `${name}-enter-active`,
        enterToClass = `${name}-enter-to`,
        appearFromClass = enterFromClass,
        appearActiveClass = enterActiveClass,
        appearToClass = enterToClass,
        leaveFromClass = `${name}-leave-from`,
        leaveActiveClass = `${name}-leave-active`,
        leaveToClass = `${name}-leave-to`
      } = rawProps;
      const durations = normalizeDuration(duration);
      const enterDuration = durations && durations[0];
      const leaveDuration = durations && durations[1];
      const {
        onBeforeEnter,
        onEnter,
        onEnterCancelled,
        onLeave,
        onLeaveCancelled,
        onBeforeAppear = onBeforeEnter,
        onAppear = onEnter,
        onAppearCancelled = onEnterCancelled
      } = baseProps;
      const finishEnter = (el, isAppear, done) => {
        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
        done && done();
      };
      const finishLeave = (el, done) => {
        el._isLeaving = false;
        removeTransitionClass(el, leaveFromClass);
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
        done && done();
      };
      const makeEnterHook = (isAppear) => {
        return (el, done) => {
          const hook2 = isAppear ? onAppear : onEnter;
          const resolve2 = () => finishEnter(el, isAppear, done);
          callHook(hook2, [el, resolve2]);
          nextFrame(() => {
            removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
            addTransitionClass(el, isAppear ? appearToClass : enterToClass);
            if (!hasExplicitCallback(hook2)) {
              whenTransitionEnds(el, type, enterDuration, resolve2);
            }
          });
        };
      };
      return extend$1(baseProps, {
        onBeforeEnter(el) {
          callHook(onBeforeEnter, [el]);
          addTransitionClass(el, enterFromClass);
          addTransitionClass(el, enterActiveClass);
        },
        onBeforeAppear(el) {
          callHook(onBeforeAppear, [el]);
          addTransitionClass(el, appearFromClass);
          addTransitionClass(el, appearActiveClass);
        },
        onEnter: makeEnterHook(false),
        onAppear: makeEnterHook(true),
        onLeave(el, done) {
          el._isLeaving = true;
          const resolve2 = () => finishLeave(el, done);
          addTransitionClass(el, leaveFromClass);
          addTransitionClass(el, leaveActiveClass);
          forceReflow();
          nextFrame(() => {
            if (!el._isLeaving) {
              return;
            }
            removeTransitionClass(el, leaveFromClass);
            addTransitionClass(el, leaveToClass);
            if (!hasExplicitCallback(onLeave)) {
              whenTransitionEnds(el, type, leaveDuration, resolve2);
            }
          });
          callHook(onLeave, [el, resolve2]);
        },
        onEnterCancelled(el) {
          finishEnter(el, false);
          callHook(onEnterCancelled, [el]);
        },
        onAppearCancelled(el) {
          finishEnter(el, true);
          callHook(onAppearCancelled, [el]);
        },
        onLeaveCancelled(el) {
          finishLeave(el);
          callHook(onLeaveCancelled, [el]);
        }
      });
    }
    function normalizeDuration(duration) {
      if (duration == null) {
        return null;
      } else if (isObject$6(duration)) {
        return [NumberOf(duration.enter), NumberOf(duration.leave)];
      } else {
        const n2 = NumberOf(duration);
        return [n2, n2];
      }
    }
    function NumberOf(val) {
      const res = toNumber(val);
      return res;
    }
    function addTransitionClass(el, cls) {
      cls.split(/\s+/).forEach((c2) => c2 && el.classList.add(c2));
      (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
    }
    function removeTransitionClass(el, cls) {
      cls.split(/\s+/).forEach((c2) => c2 && el.classList.remove(c2));
      const _vtc = el[vtcKey];
      if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) {
          el[vtcKey] = void 0;
        }
      }
    }
    function nextFrame(cb) {
      requestAnimationFrame(() => {
        requestAnimationFrame(cb);
      });
    }
    let endId = 0;
    function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
      const id2 = el._endId = ++endId;
      const resolveIfNotStale = () => {
        if (id2 === el._endId) {
          resolve2();
        }
      };
      if (explicitTimeout) {
        return setTimeout(resolveIfNotStale, explicitTimeout);
      }
      const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
      if (!type) {
        return resolve2();
      }
      const endEvent = type + "end";
      let ended = 0;
      const end2 = () => {
        el.removeEventListener(endEvent, onEnd);
        resolveIfNotStale();
      };
      const onEnd = (e2) => {
        if (e2.target === el && ++ended >= propCount) {
          end2();
        }
      };
      setTimeout(() => {
        if (ended < propCount) {
          end2();
        }
      }, timeout + 1);
      el.addEventListener(endEvent, onEnd);
    }
    function getTransitionInfo(el, expectedType) {
      const styles = window.getComputedStyle(el);
      const getStyleProperties = (key2) => (styles[key2] || "").split(", ");
      const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
      const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
      const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
      const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
      const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
      const animationTimeout = getTimeout(animationDelays, animationDurations);
      let type = null;
      let timeout = 0;
      let propCount = 0;
      if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
          type = TRANSITION;
          timeout = transitionTimeout;
          propCount = transitionDurations.length;
        }
      } else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
          type = ANIMATION;
          timeout = animationTimeout;
          propCount = animationDurations.length;
        }
      } else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
        propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
      }
      const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
        getStyleProperties(`${TRANSITION}Property`).toString()
      );
      return {
        type,
        timeout,
        propCount,
        hasTransform
      };
    }
    function getTimeout(delays, durations) {
      while (delays.length < durations.length) {
        delays = delays.concat(delays);
      }
      return Math.max(...durations.map((d2, i2) => toMs(d2) + toMs(delays[i2])));
    }
    function toMs(s2) {
      if (s2 === "auto")
        return 0;
      return Number(s2.slice(0, -1).replace(",", ".")) * 1e3;
    }
    function forceReflow() {
      return document.body.offsetHeight;
    }
    function patchClass(el, value, isSVG) {
      const transitionClasses = el[vtcKey];
      if (transitionClasses) {
        value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
      }
      if (value == null) {
        el.removeAttribute("class");
      } else if (isSVG) {
        el.setAttribute("class", value);
      } else {
        el.className = value;
      }
    }
    const vShowOriginalDisplay = Symbol("_vod");
    const vShowHidden = Symbol("_vsh");
    const vShow = {
      beforeMount(el, { value }, { transition }) {
        el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
        if (transition && value) {
          transition.beforeEnter(el);
        } else {
          setDisplay(el, value);
        }
      },
      mounted(el, { value }, { transition }) {
        if (transition && value) {
          transition.enter(el);
        }
      },
      updated(el, { value, oldValue }, { transition }) {
        if (!value === !oldValue)
          return;
        if (transition) {
          if (value) {
            transition.beforeEnter(el);
            setDisplay(el, true);
            transition.enter(el);
          } else {
            transition.leave(el, () => {
              setDisplay(el, false);
            });
          }
        } else {
          setDisplay(el, value);
        }
      },
      beforeUnmount(el, { value }) {
        setDisplay(el, value);
      }
    };
    function setDisplay(el, value) {
      el.style.display = value ? el[vShowOriginalDisplay] : "none";
      el[vShowHidden] = !value;
    }
    function initVShowForSSR() {
      vShow.getSSRProps = ({ value }) => {
        if (!value) {
          return { style: { display: "none" } };
        }
      };
    }
    const CSS_VAR_TEXT = Symbol("");
    function useCssVars(getter) {
      const instance = getCurrentInstance();
      if (!instance) {
        return;
      }
      const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {
        Array.from(
          document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)
        ).forEach((node) => setVarsOnNode(node, vars));
      };
      const setVars = () => {
        const vars = getter(instance.proxy);
        setVarsOnVNode(instance.subTree, vars);
        updateTeleports(vars);
      };
      onMounted(() => {
        watchPostEffect(setVars);
        const ob = new MutationObserver(setVars);
        ob.observe(instance.subTree.el.parentNode, { childList: true });
        onUnmounted(() => ob.disconnect());
      });
    }
    function setVarsOnVNode(vnode, vars) {
      if (vnode.shapeFlag & 128) {
        const suspense = vnode.suspense;
        vnode = suspense.activeBranch;
        if (suspense.pendingBranch && !suspense.isHydrating) {
          suspense.effects.push(() => {
            setVarsOnVNode(suspense.activeBranch, vars);
          });
        }
      }
      while (vnode.component) {
        vnode = vnode.component.subTree;
      }
      if (vnode.shapeFlag & 1 && vnode.el) {
        setVarsOnNode(vnode.el, vars);
      } else if (vnode.type === Fragment) {
        vnode.children.forEach((c2) => setVarsOnVNode(c2, vars));
      } else if (vnode.type === Static) {
        let { el, anchor: anchor2 } = vnode;
        while (el) {
          setVarsOnNode(el, vars);
          if (el === anchor2)
            break;
          el = el.nextSibling;
        }
      }
    }
    function setVarsOnNode(el, vars) {
      if (el.nodeType === 1) {
        const style = el.style;
        let cssText = "";
        for (const key2 in vars) {
          style.setProperty(`--${key2}`, vars[key2]);
          cssText += `--${key2}: ${vars[key2]};`;
        }
        style[CSS_VAR_TEXT] = cssText;
      }
    }
    const displayRE = /(^|;)\s*display\s*:/;
    function patchStyle(el, prev, next) {
      const style = el.style;
      const isCssString = isString$2(next);
      let hasControlledDisplay = false;
      if (next && !isCssString) {
        if (prev) {
          if (!isString$2(prev)) {
            for (const key2 in prev) {
              if (next[key2] == null) {
                setStyle(style, key2, "");
              }
            }
          } else {
            for (const prevStyle of prev.split(";")) {
              const key2 = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
              if (next[key2] == null) {
                setStyle(style, key2, "");
              }
            }
          }
        }
        for (const key2 in next) {
          if (key2 === "display") {
            hasControlledDisplay = true;
          }
          setStyle(style, key2, next[key2]);
        }
      } else {
        if (isCssString) {
          if (prev !== next) {
            const cssVarText = style[CSS_VAR_TEXT];
            if (cssVarText) {
              next += ";" + cssVarText;
            }
            style.cssText = next;
            hasControlledDisplay = displayRE.test(next);
          }
        } else if (prev) {
          el.removeAttribute("style");
        }
      }
      if (vShowOriginalDisplay in el) {
        el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
        if (el[vShowHidden]) {
          style.display = "none";
        }
      }
    }
    const importantRE = /\s*!important$/;
    function setStyle(style, name, val) {
      if (isArray$4(val)) {
        val.forEach((v2) => setStyle(style, name, v2));
      } else {
        if (val == null)
          val = "";
        if (name.startsWith("--")) {
          style.setProperty(name, val);
        } else {
          const prefixed = autoPrefix(style, name);
          if (importantRE.test(val)) {
            style.setProperty(
              hyphenate(prefixed),
              val.replace(importantRE, ""),
              "important"
            );
          } else {
            style[prefixed] = val;
          }
        }
      }
    }
    const prefixes = ["Webkit", "Moz", "ms"];
    const prefixCache = {};
    function autoPrefix(style, rawName) {
      const cached = prefixCache[rawName];
      if (cached) {
        return cached;
      }
      let name = camelize(rawName);
      if (name !== "filter" && name in style) {
        return prefixCache[rawName] = name;
      }
      name = capitalize$1(name);
      for (let i2 = 0; i2 < prefixes.length; i2++) {
        const prefixed = prefixes[i2] + name;
        if (prefixed in style) {
          return prefixCache[rawName] = prefixed;
        }
      }
      return rawName;
    }
    const xlinkNS = "http://www.w3.org/1999/xlink";
    function patchAttr(el, key2, value, isSVG, instance) {
      if (isSVG && key2.startsWith("xlink:")) {
        if (value == null) {
          el.removeAttributeNS(xlinkNS, key2.slice(6, key2.length));
        } else {
          el.setAttributeNS(xlinkNS, key2, value);
        }
      } else {
        const isBoolean2 = isSpecialBooleanAttr(key2);
        if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
          el.removeAttribute(key2);
        } else {
          el.setAttribute(key2, isBoolean2 ? "" : value);
        }
      }
    }
    function patchDOMProp(el, key2, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
      if (key2 === "innerHTML" || key2 === "textContent") {
        if (prevChildren) {
          unmountChildren(prevChildren, parentComponent, parentSuspense);
        }
        el[key2] = value == null ? "" : value;
        return;
      }
      const tag = el.tagName;
      if (key2 === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
      !tag.includes("-")) {
        const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
        const newValue = value == null ? "" : value;
        if (oldValue !== newValue || !("_value" in el)) {
          el.value = newValue;
        }
        if (value == null) {
          el.removeAttribute(key2);
        }
        el._value = value;
        return;
      }
      let needRemove = false;
      if (value === "" || value == null) {
        const type = typeof el[key2];
        if (type === "boolean") {
          value = includeBooleanAttr(value);
        } else if (value == null && type === "string") {
          value = "";
          needRemove = true;
        } else if (type === "number") {
          value = 0;
          needRemove = true;
        }
      }
      try {
        el[key2] = value;
      } catch (e2) {
      }
      needRemove && el.removeAttribute(key2);
    }
    function addEventListener(el, event2, handler, options) {
      el.addEventListener(event2, handler, options);
    }
    function removeEventListener(el, event2, handler, options) {
      el.removeEventListener(event2, handler, options);
    }
    const veiKey = Symbol("_vei");
    function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
      const invokers = el[veiKey] || (el[veiKey] = {});
      const existingInvoker = invokers[rawName];
      if (nextValue && existingInvoker) {
        existingInvoker.value = nextValue;
      } else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
          const invoker = invokers[rawName] = createInvoker(
            nextValue,
            instance
          );
          addEventListener(el, name, invoker, options);
        } else if (existingInvoker) {
          removeEventListener(el, name, existingInvoker, options);
          invokers[rawName] = void 0;
        }
      }
    }
    const optionsModifierRE = /(?:Once|Passive|Capture)$/;
    function parseName(name) {
      let options;
      if (optionsModifierRE.test(name)) {
        options = {};
        let m2;
        while (m2 = name.match(optionsModifierRE)) {
          name = name.slice(0, name.length - m2[0].length);
          options[m2[0].toLowerCase()] = true;
        }
      }
      const event2 = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
      return [event2, options];
    }
    let cachedNow = 0;
    const p$4 = /* @__PURE__ */ Promise.resolve();
    const getNow = () => cachedNow || (p$4.then(() => cachedNow = 0), cachedNow = Date.now());
    function createInvoker(initialValue, instance) {
      const invoker = (e2) => {
        if (!e2._vts) {
          e2._vts = Date.now();
        } else if (e2._vts <= invoker.attached) {
          return;
        }
        callWithAsyncErrorHandling(
          patchStopImmediatePropagation(e2, invoker.value),
          instance,
          5,
          [e2]
        );
      };
      invoker.value = initialValue;
      invoker.attached = getNow();
      return invoker;
    }
    function patchStopImmediatePropagation(e2, value) {
      if (isArray$4(value)) {
        const originalStop = e2.stopImmediatePropagation;
        e2.stopImmediatePropagation = () => {
          originalStop.call(e2);
          e2._stopped = true;
        };
        return value.map(
          (fn2) => (e22) => !e22._stopped && fn2 && fn2(e22)
        );
      } else {
        return value;
      }
    }
    const isNativeOn = (key2) => key2.charCodeAt(0) === 111 && key2.charCodeAt(1) === 110 && // lowercase letter
    key2.charCodeAt(2) > 96 && key2.charCodeAt(2) < 123;
    const patchProp = (el, key2, prevValue, nextValue, namespace, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
      const isSVG = namespace === "svg";
      if (key2 === "class") {
        patchClass(el, nextValue, isSVG);
      } else if (key2 === "style") {
        patchStyle(el, prevValue, nextValue);
      } else if (isOn(key2)) {
        if (!isModelListener(key2)) {
          patchEvent(el, key2, prevValue, nextValue, parentComponent);
        }
      } else if (key2[0] === "." ? (key2 = key2.slice(1), true) : key2[0] === "^" ? (key2 = key2.slice(1), false) : shouldSetAsProp(el, key2, nextValue, isSVG)) {
        patchDOMProp(
          el,
          key2,
          nextValue,
          prevChildren,
          parentComponent,
          parentSuspense,
          unmountChildren
        );
      } else {
        if (key2 === "true-value") {
          el._trueValue = nextValue;
        } else if (key2 === "false-value") {
          el._falseValue = nextValue;
        }
        patchAttr(el, key2, nextValue, isSVG);
      }
    };
    function shouldSetAsProp(el, key2, value, isSVG) {
      if (isSVG) {
        if (key2 === "innerHTML" || key2 === "textContent") {
          return true;
        }
        if (key2 in el && isNativeOn(key2) && isFunction$3(value)) {
          return true;
        }
        return false;
      }
      if (key2 === "spellcheck" || key2 === "draggable" || key2 === "translate") {
        return false;
      }
      if (key2 === "form") {
        return false;
      }
      if (key2 === "list" && el.tagName === "INPUT") {
        return false;
      }
      if (key2 === "type" && el.tagName === "TEXTAREA") {
        return false;
      }
      if (key2 === "width" || key2 === "height") {
        const tag = el.tagName;
        if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
          return false;
        }
      }
      if (isNativeOn(key2) && isString$2(value)) {
        return false;
      }
      return key2 in el;
    }
    /*! #__NO_SIDE_EFFECTS__ */
    // @__NO_SIDE_EFFECTS__
    function defineCustomElement(options, hydrate2) {
      const Comp = /* @__PURE__ */ defineComponent(options);
      class VueCustomElement extends VueElement {
        constructor(initialProps) {
          super(Comp, initialProps, hydrate2);
        }
      }
      VueCustomElement.def = Comp;
      return VueCustomElement;
    }
    /*! #__NO_SIDE_EFFECTS__ */
    const defineSSRCustomElement = /* @__NO_SIDE_EFFECTS__ */ (options) => {
      return /* @__PURE__ */ defineCustomElement(options, hydrate);
    };
    const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
    };
    class VueElement extends BaseClass {
      constructor(_def, _props = {}, hydrate2) {
        super();
        this._def = _def;
        this._props = _props;
        this._instance = null;
        this._connected = false;
        this._resolved = false;
        this._numberProps = null;
        this._ob = null;
        if (this.shadowRoot && hydrate2) {
          hydrate2(this._createVNode(), this.shadowRoot);
        } else {
          this.attachShadow({ mode: "open" });
          if (!this._def.__asyncLoader) {
            this._resolveProps(this._def);
          }
        }
      }
      connectedCallback() {
        this._connected = true;
        if (!this._instance) {
          if (this._resolved) {
            this._update();
          } else {
            this._resolveDef();
          }
        }
      }
      disconnectedCallback() {
        this._connected = false;
        if (this._ob) {
          this._ob.disconnect();
          this._ob = null;
        }
        nextTick(() => {
          if (!this._connected) {
            render$e(null, this.shadowRoot);
            this._instance = null;
          }
        });
      }
      /**
       * resolve inner component definition (handle possible async component)
       */
      _resolveDef() {
        this._resolved = true;
        for (let i2 = 0; i2 < this.attributes.length; i2++) {
          this._setAttr(this.attributes[i2].name);
        }
        this._ob = new MutationObserver((mutations) => {
          for (const m2 of mutations) {
            this._setAttr(m2.attributeName);
          }
        });
        this._ob.observe(this, { attributes: true });
        const resolve2 = (def2, isAsync = false) => {
          const { props, styles } = def2;
          let numberProps;
          if (props && !isArray$4(props)) {
            for (const key2 in props) {
              const opt = props[key2];
              if (opt === Number || opt && opt.type === Number) {
                if (key2 in this._props) {
                  this._props[key2] = toNumber(this._props[key2]);
                }
                (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[camelize(key2)] = true;
              }
            }
          }
          this._numberProps = numberProps;
          if (isAsync) {
            this._resolveProps(def2);
          }
          this._applyStyles(styles);
          this._update();
        };
        const asyncDef = this._def.__asyncLoader;
        if (asyncDef) {
          asyncDef().then((def2) => resolve2(def2, true));
        } else {
          resolve2(this._def);
        }
      }
      _resolveProps(def2) {
        const { props } = def2;
        const declaredPropKeys = isArray$4(props) ? props : Object.keys(props || {});
        for (const key2 of Object.keys(this)) {
          if (key2[0] !== "_" && declaredPropKeys.includes(key2)) {
            this._setProp(key2, this[key2], true, false);
          }
        }
        for (const key2 of declaredPropKeys.map(camelize)) {
          Object.defineProperty(this, key2, {
            get() {
              return this._getProp(key2);
            },
            set(val) {
              this._setProp(key2, val);
            }
          });
        }
      }
      _setAttr(key2) {
        let value = this.hasAttribute(key2) ? this.getAttribute(key2) : void 0;
        const camelKey = camelize(key2);
        if (this._numberProps && this._numberProps[camelKey]) {
          value = toNumber(value);
        }
        this._setProp(camelKey, value, false);
      }
      /**
       * @internal
       */
      _getProp(key2) {
        return this._props[key2];
      }
      /**
       * @internal
       */
      _setProp(key2, val, shouldReflect = true, shouldUpdate = true) {
        if (val !== this._props[key2]) {
          this._props[key2] = val;
          if (shouldUpdate && this._instance) {
            this._update();
          }
          if (shouldReflect) {
            if (val === true) {
              this.setAttribute(hyphenate(key2), "");
            } else if (typeof val === "string" || typeof val === "number") {
              this.setAttribute(hyphenate(key2), val + "");
            } else if (!val) {
              this.removeAttribute(hyphenate(key2));
            }
          }
        }
      }
      _update() {
        render$e(this._createVNode(), this.shadowRoot);
      }
      _createVNode() {
        const vnode = createVNode(this._def, extend$1({}, this._props));
        if (!this._instance) {
          vnode.ce = (instance) => {
            this._instance = instance;
            instance.isCE = true;
            const dispatch2 = (event2, args) => {
              this.dispatchEvent(
                new CustomEvent(event2, {
                  detail: args
                })
              );
            };
            instance.emit = (event2, ...args) => {
              dispatch2(event2, args);
              if (hyphenate(event2) !== event2) {
                dispatch2(hyphenate(event2), args);
              }
            };
            let parent = this;
            while (parent = parent && (parent.parentNode || parent.host)) {
              if (parent instanceof VueElement) {
                instance.parent = parent._instance;
                instance.provides = parent._instance.provides;
                break;
              }
            }
          };
        }
        return vnode;
      }
      _applyStyles(styles) {
        if (styles) {
          styles.forEach((css2) => {
            const s2 = document.createElement("style");
            s2.textContent = css2;
            this.shadowRoot.appendChild(s2);
          });
        }
      }
    }
    function useCssModule(name = "$style") {
      {
        const instance = getCurrentInstance();
        if (!instance) {
          return EMPTY_OBJ;
        }
        const modules = instance.type.__cssModules;
        if (!modules) {
          return EMPTY_OBJ;
        }
        const mod = modules[name];
        if (!mod) {
          return EMPTY_OBJ;
        }
        return mod;
      }
    }
    const positionMap = /* @__PURE__ */ new WeakMap();
    const newPositionMap = /* @__PURE__ */ new WeakMap();
    const moveCbKey = Symbol("_moveCb");
    const enterCbKey = Symbol("_enterCb");
    const TransitionGroupImpl = {
      name: "TransitionGroup",
      props: /* @__PURE__ */ extend$1({}, TransitionPropsValidators, {
        tag: String,
        moveClass: String
      }),
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevChildren;
        let children;
        onUpdated(() => {
          if (!prevChildren.length) {
            return;
          }
          const moveClass = props.moveClass || `${props.name || "v"}-move`;
          if (!hasCSSTransform(
            prevChildren[0].el,
            instance.vnode.el,
            moveClass
          )) {
            return;
          }
          prevChildren.forEach(callPendingCbs);
          prevChildren.forEach(recordPosition);
          const movedChildren = prevChildren.filter(applyTranslation);
          forceReflow();
          movedChildren.forEach((c2) => {
            const el = c2.el;
            const style = el.style;
            addTransitionClass(el, moveClass);
            style.transform = style.webkitTransform = style.transitionDuration = "";
            const cb = el[moveCbKey] = (e2) => {
              if (e2 && e2.target !== el) {
                return;
              }
              if (!e2 || /transform$/.test(e2.propertyName)) {
                el.removeEventListener("transitionend", cb);
                el[moveCbKey] = null;
                removeTransitionClass(el, moveClass);
              }
            };
            el.addEventListener("transitionend", cb);
          });
        });
        return () => {
          const rawProps = toRaw(props);
          const cssTransitionProps = resolveTransitionProps(rawProps);
          let tag = rawProps.tag || Fragment;
          prevChildren = [];
          if (children) {
            for (let i2 = 0; i2 < children.length; i2++) {
              const child2 = children[i2];
              if (child2.el && child2.el instanceof Element) {
                prevChildren.push(child2);
                setTransitionHooks(
                  child2,
                  resolveTransitionHooks(
                    child2,
                    cssTransitionProps,
                    state,
                    instance
                  )
                );
                positionMap.set(
                  child2,
                  child2.el.getBoundingClientRect()
                );
              }
            }
          }
          children = slots.default ? getTransitionRawChildren(slots.default()) : [];
          for (let i2 = 0; i2 < children.length; i2++) {
            const child2 = children[i2];
            if (child2.key != null) {
              setTransitionHooks(
                child2,
                resolveTransitionHooks(child2, cssTransitionProps, state, instance)
              );
            }
          }
          return createVNode(tag, null, children);
        };
      }
    };
    const removeMode = (props) => delete props.mode;
    /* @__PURE__ */ removeMode(TransitionGroupImpl.props);
    const TransitionGroup = TransitionGroupImpl;
    function callPendingCbs(c2) {
      const el = c2.el;
      if (el[moveCbKey]) {
        el[moveCbKey]();
      }
      if (el[enterCbKey]) {
        el[enterCbKey]();
      }
    }
    function recordPosition(c2) {
      newPositionMap.set(c2, c2.el.getBoundingClientRect());
    }
    function applyTranslation(c2) {
      const oldPos = positionMap.get(c2);
      const newPos = newPositionMap.get(c2);
      const dx = oldPos.left - newPos.left;
      const dy = oldPos.top - newPos.top;
      if (dx || dy) {
        const s2 = c2.el.style;
        s2.transform = s2.webkitTransform = `translate(${dx}px,${dy}px)`;
        s2.transitionDuration = "0s";
        return c2;
      }
    }
    function hasCSSTransform(el, root2, moveClass) {
      const clone2 = el.cloneNode();
      const _vtc = el[vtcKey];
      if (_vtc) {
        _vtc.forEach((cls) => {
          cls.split(/\s+/).forEach((c2) => c2 && clone2.classList.remove(c2));
        });
      }
      moveClass.split(/\s+/).forEach((c2) => c2 && clone2.classList.add(c2));
      clone2.style.display = "none";
      const container = root2.nodeType === 1 ? root2 : root2.parentNode;
      container.appendChild(clone2);
      const { hasTransform } = getTransitionInfo(clone2);
      container.removeChild(clone2);
      return hasTransform;
    }
    const getModelAssigner = (vnode) => {
      const fn2 = vnode.props["onUpdate:modelValue"] || false;
      return isArray$4(fn2) ? (value) => invokeArrayFns(fn2, value) : fn2;
    };
    function onCompositionStart(e2) {
      e2.target.composing = true;
    }
    function onCompositionEnd(e2) {
      const target = e2.target;
      if (target.composing) {
        target.composing = false;
        target.dispatchEvent(new Event("input"));
      }
    }
    const assignKey = Symbol("_assign");
    const vModelText = {
      created(el, { modifiers: { lazy, trim, number: number2 } }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        const castToNumber = number2 || vnode.props && vnode.props.type === "number";
        addEventListener(el, lazy ? "change" : "input", (e2) => {
          if (e2.target.composing)
            return;
          let domValue = el.value;
          if (trim) {
            domValue = domValue.trim();
          }
          if (castToNumber) {
            domValue = looseToNumber(domValue);
          }
          el[assignKey](domValue);
        });
        if (trim) {
          addEventListener(el, "change", () => {
            el.value = el.value.trim();
          });
        }
        if (!lazy) {
          addEventListener(el, "compositionstart", onCompositionStart);
          addEventListener(el, "compositionend", onCompositionEnd);
          addEventListener(el, "change", onCompositionEnd);
        }
      },
      // set value on mounted so it's after min/max for type="range"
      mounted(el, { value }) {
        el.value = value == null ? "" : value;
      },
      beforeUpdate(el, { value, modifiers: { lazy, trim, number: number2 } }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        if (el.composing)
          return;
        const elValue = (number2 || el.type === "number") && !/^0\d/.test(el.value) ? looseToNumber(el.value) : el.value;
        const newValue = value == null ? "" : value;
        if (elValue === newValue) {
          return;
        }
        if (document.activeElement === el && el.type !== "range") {
          if (lazy) {
            return;
          }
          if (trim && el.value.trim() === newValue) {
            return;
          }
        }
        el.value = newValue;
      }
    };
    const vModelCheckbox = {
      // #4096 array checkboxes need to be deep traversed
      deep: true,
      created(el, _2, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        addEventListener(el, "change", () => {
          const modelValue = el._modelValue;
          const elementValue = getValue$1(el);
          const checked = el.checked;
          const assign2 = el[assignKey];
          if (isArray$4(modelValue)) {
            const index2 = looseIndexOf(modelValue, elementValue);
            const found = index2 !== -1;
            if (checked && !found) {
              assign2(modelValue.concat(elementValue));
            } else if (!checked && found) {
              const filtered = [...modelValue];
              filtered.splice(index2, 1);
              assign2(filtered);
            }
          } else if (isSet(modelValue)) {
            const cloned = new Set(modelValue);
            if (checked) {
              cloned.add(elementValue);
            } else {
              cloned.delete(elementValue);
            }
            assign2(cloned);
          } else {
            assign2(getCheckboxValue(el, checked));
          }
        });
      },
      // set initial checked on mount to wait for true-value/false-value
      mounted: setChecked,
      beforeUpdate(el, binding, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        setChecked(el, binding, vnode);
      }
    };
    function setChecked(el, { value, oldValue }, vnode) {
      el._modelValue = value;
      if (isArray$4(value)) {
        el.checked = looseIndexOf(value, vnode.props.value) > -1;
      } else if (isSet(value)) {
        el.checked = value.has(vnode.props.value);
      } else if (value !== oldValue) {
        el.checked = looseEqual(value, getCheckboxValue(el, true));
      }
    }
    const vModelRadio = {
      created(el, { value }, vnode) {
        el.checked = looseEqual(value, vnode.props.value);
        el[assignKey] = getModelAssigner(vnode);
        addEventListener(el, "change", () => {
          el[assignKey](getValue$1(el));
        });
      },
      beforeUpdate(el, { value, oldValue }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        if (value !== oldValue) {
          el.checked = looseEqual(value, vnode.props.value);
        }
      }
    };
    const vModelSelect = {
      // <select multiple> value need to be deep traversed
      deep: true,
      created(el, { value, modifiers: { number: number2 } }, vnode) {
        const isSetModel = isSet(value);
        addEventListener(el, "change", () => {
          const selectedVal = Array.prototype.filter.call(el.options, (o3) => o3.selected).map(
            (o3) => number2 ? looseToNumber(getValue$1(o3)) : getValue$1(o3)
          );
          el[assignKey](
            el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
          );
          el._assigning = true;
          nextTick(() => {
            el._assigning = false;
          });
        });
        el[assignKey] = getModelAssigner(vnode);
      },
      // set value in mounted & updated because <select> relies on its children
      // <option>s.
      mounted(el, { value, modifiers: { number: number2 } }) {
        setSelected(el, value);
      },
      beforeUpdate(el, _binding, vnode) {
        el[assignKey] = getModelAssigner(vnode);
      },
      updated(el, { value, modifiers: { number: number2 } }) {
        if (!el._assigning) {
          setSelected(el, value);
        }
      }
    };
    function setSelected(el, value, number2) {
      const isMultiple = el.multiple;
      const isArrayValue = isArray$4(value);
      if (isMultiple && !isArrayValue && !isSet(value)) {
        return;
      }
      for (let i2 = 0, l2 = el.options.length; i2 < l2; i2++) {
        const option = el.options[i2];
        const optionValue = getValue$1(option);
        if (isMultiple) {
          if (isArrayValue) {
            const optionType = typeof optionValue;
            if (optionType === "string" || optionType === "number") {
              option.selected = value.some((v2) => String(v2) === String(optionValue));
            } else {
              option.selected = looseIndexOf(value, optionValue) > -1;
            }
          } else {
            option.selected = value.has(optionValue);
          }
        } else if (looseEqual(getValue$1(option), value)) {
          if (el.selectedIndex !== i2)
            el.selectedIndex = i2;
          return;
        }
      }
      if (!isMultiple && el.selectedIndex !== -1) {
        el.selectedIndex = -1;
      }
    }
    function getValue$1(el) {
      return "_value" in el ? el._value : el.value;
    }
    function getCheckboxValue(el, checked) {
      const key2 = checked ? "_trueValue" : "_falseValue";
      return key2 in el ? el[key2] : checked;
    }
    const vModelDynamic = {
      created(el, binding, vnode) {
        callModelHook(el, binding, vnode, null, "created");
      },
      mounted(el, binding, vnode) {
        callModelHook(el, binding, vnode, null, "mounted");
      },
      beforeUpdate(el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
      },
      updated(el, binding, vnode, prevVNode) {
        callModelHook(el, binding, vnode, prevVNode, "updated");
      }
    };
    function resolveDynamicModel(tagName, type) {
      switch (tagName) {
        case "SELECT":
          return vModelSelect;
        case "TEXTAREA":
          return vModelText;
        default:
          switch (type) {
            case "checkbox":
              return vModelCheckbox;
            case "radio":
              return vModelRadio;
            default:
              return vModelText;
          }
      }
    }
    function callModelHook(el, binding, vnode, prevVNode, hook2) {
      const modelToUse = resolveDynamicModel(
        el.tagName,
        vnode.props && vnode.props.type
      );
      const fn2 = modelToUse[hook2];
      fn2 && fn2(el, binding, vnode, prevVNode);
    }
    function initVModelForSSR() {
      vModelText.getSSRProps = ({ value }) => ({ value });
      vModelRadio.getSSRProps = ({ value }, vnode) => {
        if (vnode.props && looseEqual(vnode.props.value, value)) {
          return { checked: true };
        }
      };
      vModelCheckbox.getSSRProps = ({ value }, vnode) => {
        if (isArray$4(value)) {
          if (vnode.props && looseIndexOf(value, vnode.props.value) > -1) {
            return { checked: true };
          }
        } else if (isSet(value)) {
          if (vnode.props && value.has(vnode.props.value)) {
            return { checked: true };
          }
        } else if (value) {
          return { checked: true };
        }
      };
      vModelDynamic.getSSRProps = (binding, vnode) => {
        if (typeof vnode.type !== "string") {
          return;
        }
        const modelToUse = resolveDynamicModel(
          // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
          vnode.type.toUpperCase(),
          vnode.props && vnode.props.type
        );
        if (modelToUse.getSSRProps) {
          return modelToUse.getSSRProps(binding, vnode);
        }
      };
    }
    const systemModifiers = ["ctrl", "shift", "alt", "meta"];
    const modifierGuards = {
      stop: (e2) => e2.stopPropagation(),
      prevent: (e2) => e2.preventDefault(),
      self: (e2) => e2.target !== e2.currentTarget,
      ctrl: (e2) => !e2.ctrlKey,
      shift: (e2) => !e2.shiftKey,
      alt: (e2) => !e2.altKey,
      meta: (e2) => !e2.metaKey,
      left: (e2) => "button" in e2 && e2.button !== 0,
      middle: (e2) => "button" in e2 && e2.button !== 1,
      right: (e2) => "button" in e2 && e2.button !== 2,
      exact: (e2, modifiers) => systemModifiers.some((m2) => e2[`${m2}Key`] && !modifiers.includes(m2))
    };
    const withModifiers = (fn2, modifiers) => {
      const cache2 = fn2._withMods || (fn2._withMods = {});
      const cacheKey = modifiers.join(".");
      return cache2[cacheKey] || (cache2[cacheKey] = (event2, ...args) => {
        for (let i2 = 0; i2 < modifiers.length; i2++) {
          const guard = modifierGuards[modifiers[i2]];
          if (guard && guard(event2, modifiers))
            return;
        }
        return fn2(event2, ...args);
      });
    };
    const keyNames = {
      esc: "escape",
      space: " ",
      up: "arrow-up",
      left: "arrow-left",
      right: "arrow-right",
      down: "arrow-down",
      delete: "backspace"
    };
    const withKeys = (fn2, modifiers) => {
      const cache2 = fn2._withKeys || (fn2._withKeys = {});
      const cacheKey = modifiers.join(".");
      return cache2[cacheKey] || (cache2[cacheKey] = (event2) => {
        if (!("key" in event2)) {
          return;
        }
        const eventKey = hyphenate(event2.key);
        if (modifiers.some((k2) => k2 === eventKey || keyNames[k2] === eventKey)) {
          return fn2(event2);
        }
      });
    };
    const rendererOptions = /* @__PURE__ */ extend$1({ patchProp }, nodeOps);
    let renderer;
    let enabledHydration = false;
    function ensureRenderer() {
      return renderer || (renderer = createRenderer(rendererOptions));
    }
    function ensureHydrationRenderer() {
      renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions);
      enabledHydration = true;
      return renderer;
    }
    const render$e = (...args) => {
      ensureRenderer().render(...args);
    };
    const hydrate = (...args) => {
      ensureHydrationRenderer().hydrate(...args);
    };
    const createApp = (...args) => {
      const app2 = ensureRenderer().createApp(...args);
      const { mount } = app2;
      app2.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (!container)
          return;
        const component = app2._component;
        if (!isFunction$3(component) && !component.render && !component.template) {
          component.template = container.innerHTML;
        }
        container.innerHTML = "";
        const proxy = mount(container, false, resolveRootNamespace(container));
        if (container instanceof Element) {
          container.removeAttribute("v-cloak");
          container.setAttribute("data-v-app", "");
        }
        return proxy;
      };
      return app2;
    };
    const createSSRApp = (...args) => {
      const app2 = ensureHydrationRenderer().createApp(...args);
      const { mount } = app2;
      app2.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (container) {
          return mount(container, true, resolveRootNamespace(container));
        }
      };
      return app2;
    };
    function resolveRootNamespace(container) {
      if (container instanceof SVGElement) {
        return "svg";
      }
      if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
        return "mathml";
      }
    }
    function normalizeContainer(container) {
      if (isString$2(container)) {
        const res = document.querySelector(container);
        return res;
      }
      return container;
    }
    let ssrDirectiveInitialized = false;
    const initDirectivesForSSR = () => {
      if (!ssrDirectiveInitialized) {
        ssrDirectiveInitialized = true;
        initVModelForSSR();
        initVShowForSSR();
      }
    };
    /**
    * vue v3.4.27
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    const compile$2 = () => {
    };
    const vue_runtime_esmBundler = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      BaseTransition,
      BaseTransitionPropsValidators,
      Comment,
      DeprecationTypes,
      EffectScope,
      ErrorCodes,
      ErrorTypeStrings,
      Fragment,
      KeepAlive,
      ReactiveEffect,
      Static,
      Suspense,
      Teleport,
      Text,
      TrackOpTypes,
      Transition,
      TransitionGroup,
      TriggerOpTypes,
      VueElement,
      assertNumber,
      callWithAsyncErrorHandling,
      callWithErrorHandling,
      camelize,
      capitalize: capitalize$1,
      cloneVNode,
      compatUtils,
      compile: compile$2,
      computed,
      createApp,
      createBlock,
      createCommentVNode,
      createElementBlock,
      createElementVNode: createBaseVNode,
      createHydrationRenderer,
      createPropsRestProxy,
      createRenderer,
      createSSRApp,
      createSlots,
      createStaticVNode,
      createTextVNode,
      createVNode,
      customRef,
      defineAsyncComponent,
      defineComponent,
      defineCustomElement,
      defineEmits,
      defineExpose,
      defineModel,
      defineOptions,
      defineProps,
      defineSSRCustomElement,
      defineSlots,
      devtools: devtools$2,
      effect: effect$3,
      effectScope,
      getCurrentInstance,
      getCurrentScope,
      getTransitionRawChildren,
      guardReactiveProps,
      h: h$4,
      handleError,
      hasInjectionContext,
      hydrate,
      initCustomFormatter,
      initDirectivesForSSR,
      inject,
      isMemoSame,
      isProxy,
      isReactive,
      isReadonly,
      isRef,
      isRuntimeOnly,
      isShallow,
      isVNode: isVNode$1,
      markRaw,
      mergeDefaults,
      mergeModels,
      mergeProps,
      nextTick,
      normalizeClass,
      normalizeProps,
      normalizeStyle,
      onActivated,
      onBeforeMount,
      onBeforeUnmount,
      onBeforeUpdate,
      onDeactivated,
      onErrorCaptured,
      onMounted,
      onRenderTracked,
      onRenderTriggered,
      onScopeDispose,
      onServerPrefetch,
      onUnmounted,
      onUpdated,
      openBlock,
      popScopeId,
      provide,
      proxyRefs,
      pushScopeId,
      queuePostFlushCb,
      reactive,
      readonly,
      ref,
      registerRuntimeCompiler,
      render: render$e,
      renderList,
      renderSlot,
      resolveComponent,
      resolveDirective,
      resolveDynamicComponent,
      resolveFilter,
      resolveTransitionHooks,
      setBlockTracking,
      setDevtoolsHook,
      setTransitionHooks,
      shallowReactive,
      shallowReadonly,
      shallowRef,
      ssrContextKey,
      ssrUtils,
      stop,
      toDisplayString: toDisplayString$2,
      toHandlerKey,
      toHandlers,
      toRaw,
      toRef,
      toRefs,
      toValue: toValue$1,
      transformVNodeArgs,
      triggerRef,
      unref,
      useAttrs,
      useCssModule,
      useCssVars,
      useModel,
      useSSRContext,
      useSlots,
      useTransitionState,
      vModelCheckbox,
      vModelDynamic,
      vModelRadio,
      vModelSelect,
      vModelText,
      vShow,
      version: version$2,
      warn: warn$2,
      watch: watch$1,
      watchEffect,
      watchPostEffect,
      watchSyncEffect,
      withAsyncContext,
      withCtx,
      withDefaults,
      withDirectives,
      withKeys,
      withMemo,
      withModifiers,
      withScopeId
    }, Symbol.toStringTag, { value: "Module" }));
    var isVue2 = false;
    /*!
     * pinia v2.1.7
     * (c) 2023 Eduardo San Martin Morote
     * @license MIT
     */
    let activePinia;
    const setActivePinia = (pinia) => activePinia = pinia;
    const piniaSymbol = (
      /* istanbul ignore next */
      Symbol()
    );
    function isPlainObject$4(o3) {
      return o3 && typeof o3 === "object" && Object.prototype.toString.call(o3) === "[object Object]" && typeof o3.toJSON !== "function";
    }
    var MutationType;
    (function(MutationType2) {
      MutationType2["direct"] = "direct";
      MutationType2["patchObject"] = "patch object";
      MutationType2["patchFunction"] = "patch function";
    })(MutationType || (MutationType = {}));
    function createPinia() {
      const scope = effectScope(true);
      const state = scope.run(() => ref({}));
      let _p = [];
      let toBeInstalled = [];
      const pinia = markRaw({
        install(app2) {
          setActivePinia(pinia);
          {
            pinia._a = app2;
            app2.provide(piniaSymbol, pinia);
            app2.config.globalProperties.$pinia = pinia;
            toBeInstalled.forEach((plugin) => _p.push(plugin));
            toBeInstalled = [];
          }
        },
        use(plugin) {
          if (!this._a && !isVue2) {
            toBeInstalled.push(plugin);
          } else {
            _p.push(plugin);
          }
          return this;
        },
        _p,
        // it's actually undefined here
        // @ts-expect-error
        _a: null,
        _e: scope,
        _s: /* @__PURE__ */ new Map(),
        state
      });
      return pinia;
    }
    const noop$2 = () => {
    };
    function addSubscription(subscriptions, callback, detached, onCleanup = noop$2) {
      subscriptions.push(callback);
      const removeSubscription = () => {
        const idx = subscriptions.indexOf(callback);
        if (idx > -1) {
          subscriptions.splice(idx, 1);
          onCleanup();
        }
      };
      if (!detached && getCurrentScope()) {
        onScopeDispose(removeSubscription);
      }
      return removeSubscription;
    }
    function triggerSubscriptions(subscriptions, ...args) {
      subscriptions.slice().forEach((callback) => {
        callback(...args);
      });
    }
    const fallbackRunWithContext = (fn2) => fn2();
    function mergeReactiveObjects(target, patchToApply) {
      if (target instanceof Map && patchToApply instanceof Map) {
        patchToApply.forEach((value, key2) => target.set(key2, value));
      }
      if (target instanceof Set && patchToApply instanceof Set) {
        patchToApply.forEach(target.add, target);
      }
      for (const key2 in patchToApply) {
        if (!patchToApply.hasOwnProperty(key2))
          continue;
        const subPatch = patchToApply[key2];
        const targetValue = target[key2];
        if (isPlainObject$4(targetValue) && isPlainObject$4(subPatch) && target.hasOwnProperty(key2) && !isRef(subPatch) && !isReactive(subPatch)) {
          target[key2] = mergeReactiveObjects(targetValue, subPatch);
        } else {
          target[key2] = subPatch;
        }
      }
      return target;
    }
    const skipHydrateSymbol = (
      /* istanbul ignore next */
      Symbol()
    );
    function shouldHydrate(obj) {
      return !isPlainObject$4(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
    }
    const { assign: assign$3 } = Object;
    function isComputed(o3) {
      return !!(isRef(o3) && o3.effect);
    }
    function createOptionsStore(id2, options, pinia, hot) {
      const { state, actions, getters } = options;
      const initialState = pinia.state.value[id2];
      let store;
      function setup() {
        if (!initialState && true) {
          {
            pinia.state.value[id2] = state ? state() : {};
          }
        }
        const localState = toRefs(pinia.state.value[id2]);
        return assign$3(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
          computedGetters[name] = markRaw(computed(() => {
            setActivePinia(pinia);
            const store2 = pinia._s.get(id2);
            return getters[name].call(store2, store2);
          }));
          return computedGetters;
        }, {}));
      }
      store = createSetupStore(id2, setup, options, pinia, hot, true);
      return store;
    }
    function createSetupStore($id, setup, options = {}, pinia, hot, isOptionsStore) {
      let scope;
      const optionsForPlugin = assign$3({ actions: {} }, options);
      const $subscribeOptions = {
        deep: true
        // flush: 'post',
      };
      let isListening;
      let isSyncListening;
      let subscriptions = [];
      let actionSubscriptions = [];
      let debuggerEvents;
      const initialState = pinia.state.value[$id];
      if (!isOptionsStore && !initialState && true) {
        {
          pinia.state.value[$id] = {};
        }
      }
      ref({});
      let activeListener;
      function $patch(partialStateOrMutator) {
        let subscriptionMutation;
        isListening = isSyncListening = false;
        if (typeof partialStateOrMutator === "function") {
          partialStateOrMutator(pinia.state.value[$id]);
          subscriptionMutation = {
            type: MutationType.patchFunction,
            storeId: $id,
            events: debuggerEvents
          };
        } else {
          mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);
          subscriptionMutation = {
            type: MutationType.patchObject,
            payload: partialStateOrMutator,
            storeId: $id,
            events: debuggerEvents
          };
        }
        const myListenerId = activeListener = Symbol();
        nextTick().then(() => {
          if (activeListener === myListenerId) {
            isListening = true;
          }
        });
        isSyncListening = true;
        triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);
      }
      const $reset = isOptionsStore ? function $reset2() {
        const { state } = options;
        const newState = state ? state() : {};
        this.$patch(($state) => {
          assign$3($state, newState);
        });
      } : (
        /* istanbul ignore next */
        noop$2
      );
      function $dispose() {
        scope.stop();
        subscriptions = [];
        actionSubscriptions = [];
        pinia._s.delete($id);
      }
      function wrapAction(name, action) {
        return function() {
          setActivePinia(pinia);
          const args = Array.from(arguments);
          const afterCallbackList = [];
          const onErrorCallbackList = [];
          function after(callback) {
            afterCallbackList.push(callback);
          }
          function onError(callback) {
            onErrorCallbackList.push(callback);
          }
          triggerSubscriptions(actionSubscriptions, {
            args,
            name,
            store,
            after,
            onError
          });
          let ret;
          try {
            ret = action.apply(this && this.$id === $id ? this : store, args);
          } catch (error) {
            triggerSubscriptions(onErrorCallbackList, error);
            throw error;
          }
          if (ret instanceof Promise) {
            return ret.then((value) => {
              triggerSubscriptions(afterCallbackList, value);
              return value;
            }).catch((error) => {
              triggerSubscriptions(onErrorCallbackList, error);
              return Promise.reject(error);
            });
          }
          triggerSubscriptions(afterCallbackList, ret);
          return ret;
        };
      }
      const partialStore = {
        _p: pinia,
        // _s: scope,
        $id,
        $onAction: addSubscription.bind(null, actionSubscriptions),
        $patch,
        $reset,
        $subscribe(callback, options2 = {}) {
          const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
          const stopWatcher = scope.run(() => watch$1(() => pinia.state.value[$id], (state) => {
            if (options2.flush === "sync" ? isSyncListening : isListening) {
              callback({
                storeId: $id,
                type: MutationType.direct,
                events: debuggerEvents
              }, state);
            }
          }, assign$3({}, $subscribeOptions, options2)));
          return removeSubscription;
        },
        $dispose
      };
      const store = reactive(partialStore);
      pinia._s.set($id, store);
      const runWithContext = pinia._a && pinia._a.runWithContext || fallbackRunWithContext;
      const setupStore = runWithContext(() => pinia._e.run(() => (scope = effectScope()).run(setup)));
      for (const key2 in setupStore) {
        const prop = setupStore[key2];
        if (isRef(prop) && !isComputed(prop) || isReactive(prop)) {
          if (!isOptionsStore) {
            if (initialState && shouldHydrate(prop)) {
              if (isRef(prop)) {
                prop.value = initialState[key2];
              } else {
                mergeReactiveObjects(prop, initialState[key2]);
              }
            }
            {
              pinia.state.value[$id][key2] = prop;
            }
          }
        } else if (typeof prop === "function") {
          const actionValue = wrapAction(key2, prop);
          {
            setupStore[key2] = actionValue;
          }
          optionsForPlugin.actions[key2] = prop;
        } else
          ;
      }
      {
        assign$3(store, setupStore);
        assign$3(toRaw(store), setupStore);
      }
      Object.defineProperty(store, "$state", {
        get: () => pinia.state.value[$id],
        set: (state) => {
          $patch(($state) => {
            assign$3($state, state);
          });
        }
      });
      pinia._p.forEach((extender) => {
        {
          assign$3(store, scope.run(() => extender({
            store,
            app: pinia._a,
            pinia,
            options: optionsForPlugin
          })));
        }
      });
      if (initialState && isOptionsStore && options.hydrate) {
        options.hydrate(store.$state, initialState);
      }
      isListening = true;
      isSyncListening = true;
      return store;
    }
    function defineStore(idOrOptions, setup, setupOptions) {
      let id2;
      let options;
      const isSetupStore = typeof setup === "function";
      if (typeof idOrOptions === "string") {
        id2 = idOrOptions;
        options = isSetupStore ? setupOptions : setup;
      } else {
        options = idOrOptions;
        id2 = idOrOptions.id;
      }
      function useStore(pinia, hot) {
        const hasContext = hasInjectionContext();
        pinia = // in test mode, ignore the argument provided as we can always retrieve a
        // pinia instance with getActivePinia()
        pinia || (hasContext ? inject(piniaSymbol, null) : null);
        if (pinia)
          setActivePinia(pinia);
        pinia = activePinia;
        if (!pinia._s.has(id2)) {
          if (isSetupStore) {
            createSetupStore(id2, setup, options, pinia);
          } else {
            createOptionsStore(id2, options, pinia);
          }
        }
        const store = pinia._s.get(id2);
        return store;
      }
      useStore.$id = id2;
      return useStore;
    }
    let mapStoreSuffix = "Store";
    function mapStores(...stores) {
      return stores.reduce((reduced, useStore) => {
        reduced[useStore.$id + mapStoreSuffix] = function() {
          return useStore(this.$pinia);
        };
        return reduced;
      }, {});
    }
    function mapState(useStore, keysOrMapper) {
      return Array.isArray(keysOrMapper) ? keysOrMapper.reduce((reduced, key2) => {
        reduced[key2] = function() {
          return useStore(this.$pinia)[key2];
        };
        return reduced;
      }, {}) : Object.keys(keysOrMapper).reduce((reduced, key2) => {
        reduced[key2] = function() {
          const store = useStore(this.$pinia);
          const storeKey = keysOrMapper[key2];
          return typeof storeKey === "function" ? storeKey.call(this, store) : store[storeKey];
        };
        return reduced;
      }, {});
    }
    function mapWritableState(useStore, keysOrMapper) {
      return Array.isArray(keysOrMapper) ? keysOrMapper.reduce((reduced, key2) => {
        reduced[key2] = {
          get() {
            return useStore(this.$pinia)[key2];
          },
          set(value) {
            return useStore(this.$pinia)[key2] = value;
          }
        };
        return reduced;
      }, {}) : Object.keys(keysOrMapper).reduce((reduced, key2) => {
        reduced[key2] = {
          get() {
            return useStore(this.$pinia)[keysOrMapper[key2]];
          },
          set(value) {
            return useStore(this.$pinia)[keysOrMapper[key2]] = value;
          }
        };
        return reduced;
      }, {});
    }
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function getDefaultExportFromCjs(x2) {
      return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
    }
    function getAugmentedNamespace(n2) {
      if (n2.__esModule)
        return n2;
      var f2 = n2.default;
      if (typeof f2 == "function") {
        var a2 = function a3() {
          if (this instanceof a3) {
            return Reflect.construct(f2, arguments, this.constructor);
          }
          return f2.apply(this, arguments);
        };
        a2.prototype = f2.prototype;
      } else
        a2 = {};
      Object.defineProperty(a2, "__esModule", { value: true });
      Object.keys(n2).forEach(function(k2) {
        var d2 = Object.getOwnPropertyDescriptor(n2, k2);
        Object.defineProperty(a2, k2, d2.get ? d2 : {
          enumerable: true,
          get: function() {
            return n2[k2];
          }
        });
      });
      return a2;
    }
    var vueI18n = {};
    /*!
      * shared v9.13.1
      * (c) 2024 kazuya kawaguchi
      * Released under the MIT License.
      */
    const inBrowser$1 = typeof window !== "undefined";
    let mark$1;
    let measure$1;
    {
      const perf = inBrowser$1 && window.performance;
      if (perf && perf.mark && perf.measure && perf.clearMarks && // @ts-ignore browser compat
      perf.clearMeasures) {
        mark$1 = (tag) => {
          perf.mark(tag);
        };
        measure$1 = (name, startTag, endTag) => {
          perf.measure(name, startTag, endTag);
          perf.clearMarks(startTag);
          perf.clearMarks(endTag);
        };
      }
    }
    const RE_ARGS$1 = /\{([0-9a-zA-Z]+)\}/g;
    function format$2(message, ...args) {
      if (args.length === 1 && isObject$5(args[0])) {
        args = args[0];
      }
      if (!args || !args.hasOwnProperty) {
        args = {};
      }
      return message.replace(RE_ARGS$1, (match, identifier) => {
        return args.hasOwnProperty(identifier) ? args[identifier] : "";
      });
    }
    const makeSymbol = (name, shareable = false) => !shareable ? Symbol(name) : Symbol.for(name);
    const generateFormatCacheKey$1 = (locale, key2, source) => friendlyJSONstringify$1({ l: locale, k: key2, s: source });
    const friendlyJSONstringify$1 = (json) => JSON.stringify(json).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027");
    const isNumber$1 = (val) => typeof val === "number" && isFinite(val);
    const isDate$1 = (val) => toTypeString$1(val) === "[object Date]";
    const isRegExp$1 = (val) => toTypeString$1(val) === "[object RegExp]";
    const isEmptyObject$1 = (val) => isPlainObject$3(val) && Object.keys(val).length === 0;
    const assign$2 = Object.assign;
    let _globalThis;
    const getGlobalThis = () => {
      return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    };
    function escapeHtml$1(rawText) {
      return rawText.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
    }
    const hasOwnProperty$8 = Object.prototype.hasOwnProperty;
    function hasOwn(obj, key2) {
      return hasOwnProperty$8.call(obj, key2);
    }
    const isArray$3 = Array.isArray;
    const isFunction$2 = (val) => typeof val === "function";
    const isString$1 = (val) => typeof val === "string";
    const isBoolean$1 = (val) => typeof val === "boolean";
    const isSymbol = (val) => typeof val === "symbol";
    const isObject$5 = (val) => val !== null && typeof val === "object";
    const isPromise$1 = (val) => {
      return isObject$5(val) && isFunction$2(val.then) && isFunction$2(val.catch);
    };
    const objectToString$2 = Object.prototype.toString;
    const toTypeString$1 = (value) => objectToString$2.call(value);
    const isPlainObject$3 = (val) => {
      if (!isObject$5(val))
        return false;
      const proto = Object.getPrototypeOf(val);
      return proto === null || proto.constructor === Object;
    };
    const toDisplayString$1 = (val) => {
      return val == null ? "" : isArray$3(val) || isPlainObject$3(val) && val.toString === objectToString$2 ? JSON.stringify(val, null, 2) : String(val);
    };
    function join$1(items, separator = "") {
      return items.reduce((str, item, index2) => index2 === 0 ? str + item : str + separator + item, "");
    }
    const RANGE$1 = 2;
    function generateCodeFrame$1(source, start2 = 0, end2 = source.length) {
      const lines = source.split(/\r?\n/);
      let count = 0;
      const res = [];
      for (let i2 = 0; i2 < lines.length; i2++) {
        count += lines[i2].length + 1;
        if (count >= start2) {
          for (let j2 = i2 - RANGE$1; j2 <= i2 + RANGE$1 || end2 > count; j2++) {
            if (j2 < 0 || j2 >= lines.length)
              continue;
            const line = j2 + 1;
            res.push(`${line}${" ".repeat(3 - String(line).length)}|  ${lines[j2]}`);
            const lineLength = lines[j2].length;
            if (j2 === i2) {
              const pad = start2 - (count - lineLength) + 1;
              const length = Math.max(1, end2 > count ? lineLength - pad : end2 - start2);
              res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
            } else if (j2 > i2) {
              if (end2 > count) {
                const length = Math.max(Math.min(end2 - count, lineLength), 1);
                res.push(`   |  ` + "^".repeat(length));
              }
              count += lineLength + 1;
            }
          }
          break;
        }
      }
      return res.join("\n");
    }
    function incrementer$1(code2) {
      let current = code2;
      return () => ++current;
    }
    function warn$1(msg, err) {
      if (typeof console !== "undefined") {
        console.warn(`[intlify] ` + msg);
        if (err) {
          console.warn(err.stack);
        }
      }
    }
    const hasWarned$1 = {};
    function warnOnce$1(msg) {
      if (!hasWarned$1[msg]) {
        hasWarned$1[msg] = true;
        warn$1(msg);
      }
    }
    function createEmitter() {
      const events = /* @__PURE__ */ new Map();
      const emitter = {
        events,
        on(event2, handler) {
          const handlers2 = events.get(event2);
          const added = handlers2 && handlers2.push(handler);
          if (!added) {
            events.set(event2, [handler]);
          }
        },
        off(event2, handler) {
          const handlers2 = events.get(event2);
          if (handlers2) {
            handlers2.splice(handlers2.indexOf(handler) >>> 0, 1);
          }
        },
        emit(event2, payload) {
          (events.get(event2) || []).slice().map((handler) => handler(payload));
          (events.get("*") || []).slice().map((handler) => handler(event2, payload));
        }
      };
      return emitter;
    }
    const isNotObjectOrIsArray = (val) => !isObject$5(val) || isArray$3(val);
    function deepCopy(src, des) {
      if (isNotObjectOrIsArray(src) || isNotObjectOrIsArray(des)) {
        throw new Error("Invalid value");
      }
      const stack2 = [{ src, des }];
      while (stack2.length) {
        const { src: src2, des: des2 } = stack2.pop();
        Object.keys(src2).forEach((key2) => {
          if (isNotObjectOrIsArray(src2[key2]) || isNotObjectOrIsArray(des2[key2])) {
            des2[key2] = src2[key2];
          } else {
            stack2.push({ src: src2[key2], des: des2[key2] });
          }
        });
      }
    }
    const shared_esmBrowser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      assign: assign$2,
      createEmitter,
      deepCopy,
      escapeHtml: escapeHtml$1,
      format: format$2,
      friendlyJSONstringify: friendlyJSONstringify$1,
      generateCodeFrame: generateCodeFrame$1,
      generateFormatCacheKey: generateFormatCacheKey$1,
      getGlobalThis,
      hasOwn,
      inBrowser: inBrowser$1,
      incrementer: incrementer$1,
      isArray: isArray$3,
      isBoolean: isBoolean$1,
      isDate: isDate$1,
      isEmptyObject: isEmptyObject$1,
      isFunction: isFunction$2,
      isNumber: isNumber$1,
      isObject: isObject$5,
      isPlainObject: isPlainObject$3,
      isPromise: isPromise$1,
      isRegExp: isRegExp$1,
      isString: isString$1,
      isSymbol,
      join: join$1,
      makeSymbol,
      get mark() {
        return mark$1;
      },
      get measure() {
        return measure$1;
      },
      objectToString: objectToString$2,
      toDisplayString: toDisplayString$1,
      toTypeString: toTypeString$1,
      warn: warn$1,
      warnOnce: warnOnce$1
    }, Symbol.toStringTag, { value: "Module" }));
    const require$$0$2 = /* @__PURE__ */ getAugmentedNamespace(shared_esmBrowser);
    /*!
      * core-base v9.13.1
      * (c) 2024 kazuya kawaguchi
      * Released under the MIT License.
      */
    const inBrowser = typeof window !== "undefined";
    let mark;
    let measure;
    {
      const perf = inBrowser && window.performance;
      if (perf && perf.mark && perf.measure && perf.clearMarks && // @ts-ignore browser compat
      perf.clearMeasures) {
        mark = (tag) => {
          perf.mark(tag);
        };
        measure = (name, startTag, endTag) => {
          perf.measure(name, startTag, endTag);
          perf.clearMarks(startTag);
          perf.clearMarks(endTag);
        };
      }
    }
    const RE_ARGS = /\{([0-9a-zA-Z]+)\}/g;
    function format$1(message, ...args) {
      if (args.length === 1 && isObject$4(args[0])) {
        args = args[0];
      }
      if (!args || !args.hasOwnProperty) {
        args = {};
      }
      return message.replace(RE_ARGS, (match, identifier) => {
        return args.hasOwnProperty(identifier) ? args[identifier] : "";
      });
    }
    const generateFormatCacheKey = (locale, key2, source) => friendlyJSONstringify({ l: locale, k: key2, s: source });
    const friendlyJSONstringify = (json) => JSON.stringify(json).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027");
    const isNumber = (val) => typeof val === "number" && isFinite(val);
    const isDate = (val) => toTypeString(val) === "[object Date]";
    const isRegExp = (val) => toTypeString(val) === "[object RegExp]";
    const isEmptyObject = (val) => isPlainObject$2(val) && Object.keys(val).length === 0;
    const assign$1 = Object.assign;
    function escapeHtml(rawText) {
      return rawText.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
    }
    const isArray$2 = Array.isArray;
    const isFunction$1 = (val) => typeof val === "function";
    const isString = (val) => typeof val === "string";
    const isBoolean = (val) => typeof val === "boolean";
    const isObject$4 = (val) => val !== null && typeof val === "object";
    const isPromise = (val) => {
      return isObject$4(val) && isFunction$1(val.then) && isFunction$1(val.catch);
    };
    const objectToString$1 = Object.prototype.toString;
    const toTypeString = (value) => objectToString$1.call(value);
    const isPlainObject$2 = (val) => {
      if (!isObject$4(val))
        return false;
      const proto = Object.getPrototypeOf(val);
      return proto === null || proto.constructor === Object;
    };
    const toDisplayString = (val) => {
      return val == null ? "" : isArray$2(val) || isPlainObject$2(val) && val.toString === objectToString$1 ? JSON.stringify(val, null, 2) : String(val);
    };
    function join(items, separator = "") {
      return items.reduce((str, item, index2) => index2 === 0 ? str + item : str + separator + item, "");
    }
    const RANGE = 2;
    function generateCodeFrame(source, start2 = 0, end2 = source.length) {
      const lines = source.split(/\r?\n/);
      let count = 0;
      const res = [];
      for (let i2 = 0; i2 < lines.length; i2++) {
        count += lines[i2].length + 1;
        if (count >= start2) {
          for (let j2 = i2 - RANGE; j2 <= i2 + RANGE || end2 > count; j2++) {
            if (j2 < 0 || j2 >= lines.length)
              continue;
            const line = j2 + 1;
            res.push(`${line}${" ".repeat(3 - String(line).length)}|  ${lines[j2]}`);
            const lineLength = lines[j2].length;
            if (j2 === i2) {
              const pad = start2 - (count - lineLength) + 1;
              const length = Math.max(1, end2 > count ? lineLength - pad : end2 - start2);
              res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
            } else if (j2 > i2) {
              if (end2 > count) {
                const length = Math.max(Math.min(end2 - count, lineLength), 1);
                res.push(`   |  ` + "^".repeat(length));
              }
              count += lineLength + 1;
            }
          }
          break;
        }
      }
      return res.join("\n");
    }
    function incrementer(code2) {
      let current = code2;
      return () => ++current;
    }
    function warn(msg, err) {
      if (typeof console !== "undefined") {
        console.warn(`[intlify] ` + msg);
        if (err) {
          console.warn(err.stack);
        }
      }
    }
    const hasWarned = {};
    function warnOnce(msg) {
      if (!hasWarned[msg]) {
        hasWarned[msg] = true;
        warn(msg);
      }
    }
    function createPosition(line, column, offset2) {
      return { line, column, offset: offset2 };
    }
    function createLocation(start2, end2, source) {
      const loc = { start: start2, end: end2 };
      return loc;
    }
    const CompileWarnCodes = {
      USE_MODULO_SYNTAX: 1,
      __EXTEND_POINT__: 2
    };
    const warnMessages$1 = {
      [CompileWarnCodes.USE_MODULO_SYNTAX]: `Use modulo before '{{0}}'.`
    };
    function createCompileWarn(code2, loc, ...args) {
      const msg = format$1(warnMessages$1[code2], ...args || []);
      const message = { message: String(msg), code: code2 };
      if (loc) {
        message.location = loc;
      }
      return message;
    }
    const CompileErrorCodes = {
      // tokenizer error codes
      EXPECTED_TOKEN: 1,
      INVALID_TOKEN_IN_PLACEHOLDER: 2,
      UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
      UNKNOWN_ESCAPE_SEQUENCE: 4,
      INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
      UNBALANCED_CLOSING_BRACE: 6,
      UNTERMINATED_CLOSING_BRACE: 7,
      EMPTY_PLACEHOLDER: 8,
      NOT_ALLOW_NEST_PLACEHOLDER: 9,
      INVALID_LINKED_FORMAT: 10,
      // parser error codes
      MUST_HAVE_MESSAGES_IN_PLURAL: 11,
      UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
      UNEXPECTED_EMPTY_LINKED_KEY: 13,
      UNEXPECTED_LEXICAL_ANALYSIS: 14,
      // generator error codes
      UNHANDLED_CODEGEN_NODE_TYPE: 15,
      // minifier error codes
      UNHANDLED_MINIFIER_NODE_TYPE: 16,
      // Special value for higher-order compilers to pick up the last code
      // to avoid collision of error codes. This should always be kept as the last
      // item.
      __EXTEND_POINT__: 17
    };
    const errorMessages$1 = {
      // tokenizer error messages
      [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,
      [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,
      [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,
      [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\{0}`,
      [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,
      [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,
      [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,
      [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,
      [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,
      [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,
      // parser error messages
      [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,
      [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,
      [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,
      [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`,
      // generator error messages
      [CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE]: `unhandled codegen node type: '{0}'`,
      // minimizer error messages
      [CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE]: `unhandled mimifier node type: '{0}'`
    };
    function createCompileError(code2, loc, options = {}) {
      const { domain, messages, args } = options;
      const msg = format$1((messages || errorMessages$1)[code2] || "", ...args || []);
      const error = new SyntaxError(String(msg));
      error.code = code2;
      if (loc) {
        error.location = loc;
      }
      error.domain = domain;
      return error;
    }
    function defaultOnError(error) {
      throw error;
    }
    const RE_HTML_TAG = /<\/?[\w\s="/.':;#-\/]+>/;
    const detectHtmlTag = (source) => RE_HTML_TAG.test(source);
    const CHAR_SP = " ";
    const CHAR_CR = "\r";
    const CHAR_LF = "\n";
    const CHAR_LS = String.fromCharCode(8232);
    const CHAR_PS = String.fromCharCode(8233);
    function createScanner(str) {
      const _buf = str;
      let _index = 0;
      let _line = 1;
      let _column = 1;
      let _peekOffset = 0;
      const isCRLF = (index3) => _buf[index3] === CHAR_CR && _buf[index3 + 1] === CHAR_LF;
      const isLF = (index3) => _buf[index3] === CHAR_LF;
      const isPS = (index3) => _buf[index3] === CHAR_PS;
      const isLS = (index3) => _buf[index3] === CHAR_LS;
      const isLineEnd = (index3) => isCRLF(index3) || isLF(index3) || isPS(index3) || isLS(index3);
      const index2 = () => _index;
      const line = () => _line;
      const column = () => _column;
      const peekOffset = () => _peekOffset;
      const charAt = (offset2) => isCRLF(offset2) || isPS(offset2) || isLS(offset2) ? CHAR_LF : _buf[offset2];
      const currentChar = () => charAt(_index);
      const currentPeek = () => charAt(_index + _peekOffset);
      function next() {
        _peekOffset = 0;
        if (isLineEnd(_index)) {
          _line++;
          _column = 0;
        }
        if (isCRLF(_index)) {
          _index++;
        }
        _index++;
        _column++;
        return _buf[_index];
      }
      function peek() {
        if (isCRLF(_index + _peekOffset)) {
          _peekOffset++;
        }
        _peekOffset++;
        return _buf[_index + _peekOffset];
      }
      function reset() {
        _index = 0;
        _line = 1;
        _column = 1;
        _peekOffset = 0;
      }
      function resetPeek(offset2 = 0) {
        _peekOffset = offset2;
      }
      function skipToPeek() {
        const target = _index + _peekOffset;
        while (target !== _index) {
          next();
        }
        _peekOffset = 0;
      }
      return {
        index: index2,
        line,
        column,
        peekOffset,
        charAt,
        currentChar,
        currentPeek,
        next,
        peek,
        reset,
        resetPeek,
        skipToPeek
      };
    }
    const EOF = void 0;
    const DOT = ".";
    const LITERAL_DELIMITER = "'";
    const ERROR_DOMAIN$3 = "tokenizer";
    function createTokenizer(source, options = {}) {
      const location2 = options.location !== false;
      const _scnr = createScanner(source);
      const currentOffset = () => _scnr.index();
      const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());
      const _initLoc = currentPosition();
      const _initOffset = currentOffset();
      const _context = {
        currentType: 14,
        offset: _initOffset,
        startLoc: _initLoc,
        endLoc: _initLoc,
        lastType: 14,
        lastOffset: _initOffset,
        lastStartLoc: _initLoc,
        lastEndLoc: _initLoc,
        braceNest: 0,
        inLinked: false,
        text: ""
      };
      const context = () => _context;
      const { onError } = options;
      function emitError(code2, pos, offset2, ...args) {
        const ctx = context();
        pos.column += offset2;
        pos.offset += offset2;
        if (onError) {
          const loc = location2 ? createLocation(ctx.startLoc, pos) : null;
          const err = createCompileError(code2, loc, {
            domain: ERROR_DOMAIN$3,
            args
          });
          onError(err);
        }
      }
      function getToken(context2, type, value) {
        context2.endLoc = currentPosition();
        context2.currentType = type;
        const token = { type };
        if (location2) {
          token.loc = createLocation(context2.startLoc, context2.endLoc);
        }
        if (value != null) {
          token.value = value;
        }
        return token;
      }
      const getEndToken = (context2) => getToken(
        context2,
        14
        /* TokenTypes.EOF */
      );
      function eat(scnr, ch) {
        if (scnr.currentChar() === ch) {
          scnr.next();
          return ch;
        } else {
          emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
          return "";
        }
      }
      function peekSpaces(scnr) {
        let buf = "";
        while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {
          buf += scnr.currentPeek();
          scnr.peek();
        }
        return buf;
      }
      function skipSpaces(scnr) {
        const buf = peekSpaces(scnr);
        scnr.skipToPeek();
        return buf;
      }
      function isIdentifierStart(ch) {
        if (ch === EOF) {
          return false;
        }
        const cc = ch.charCodeAt(0);
        return cc >= 97 && cc <= 122 || // a-z
        cc >= 65 && cc <= 90 || // A-Z
        cc === 95;
      }
      function isNumberStart(ch) {
        if (ch === EOF) {
          return false;
        }
        const cc = ch.charCodeAt(0);
        return cc >= 48 && cc <= 57;
      }
      function isNamedIdentifierStart(scnr, context2) {
        const { currentType } = context2;
        if (currentType !== 2) {
          return false;
        }
        peekSpaces(scnr);
        const ret = isIdentifierStart(scnr.currentPeek());
        scnr.resetPeek();
        return ret;
      }
      function isListIdentifierStart(scnr, context2) {
        const { currentType } = context2;
        if (currentType !== 2) {
          return false;
        }
        peekSpaces(scnr);
        const ch = scnr.currentPeek() === "-" ? scnr.peek() : scnr.currentPeek();
        const ret = isNumberStart(ch);
        scnr.resetPeek();
        return ret;
      }
      function isLiteralStart(scnr, context2) {
        const { currentType } = context2;
        if (currentType !== 2) {
          return false;
        }
        peekSpaces(scnr);
        const ret = scnr.currentPeek() === LITERAL_DELIMITER;
        scnr.resetPeek();
        return ret;
      }
      function isLinkedDotStart(scnr, context2) {
        const { currentType } = context2;
        if (currentType !== 8) {
          return false;
        }
        peekSpaces(scnr);
        const ret = scnr.currentPeek() === ".";
        scnr.resetPeek();
        return ret;
      }
      function isLinkedModifierStart(scnr, context2) {
        const { currentType } = context2;
        if (currentType !== 9) {
          return false;
        }
        peekSpaces(scnr);
        const ret = isIdentifierStart(scnr.currentPeek());
        scnr.resetPeek();
        return ret;
      }
      function isLinkedDelimiterStart(scnr, context2) {
        const { currentType } = context2;
        if (!(currentType === 8 || currentType === 12)) {
          return false;
        }
        peekSpaces(scnr);
        const ret = scnr.currentPeek() === ":";
        scnr.resetPeek();
        return ret;
      }
      function isLinkedReferStart(scnr, context2) {
        const { currentType } = context2;
        if (currentType !== 10) {
          return false;
        }
        const fn2 = () => {
          const ch = scnr.currentPeek();
          if (ch === "{") {
            return isIdentifierStart(scnr.peek());
          } else if (ch === "@" || ch === "%" || ch === "|" || ch === ":" || ch === "." || ch === CHAR_SP || !ch) {
            return false;
          } else if (ch === CHAR_LF) {
            scnr.peek();
            return fn2();
          } else {
            return isTextStart(scnr, false);
          }
        };
        const ret = fn2();
        scnr.resetPeek();
        return ret;
      }
      function isPluralStart(scnr) {
        peekSpaces(scnr);
        const ret = scnr.currentPeek() === "|";
        scnr.resetPeek();
        return ret;
      }
      function detectModuloStart(scnr) {
        const spaces = peekSpaces(scnr);
        const ret = scnr.currentPeek() === "%" && scnr.peek() === "{";
        scnr.resetPeek();
        return {
          isModulo: ret,
          hasSpace: spaces.length > 0
        };
      }
      function isTextStart(scnr, reset = true) {
        const fn2 = (hasSpace = false, prev = "", detectModulo = false) => {
          const ch = scnr.currentPeek();
          if (ch === "{") {
            return prev === "%" ? false : hasSpace;
          } else if (ch === "@" || !ch) {
            return prev === "%" ? true : hasSpace;
          } else if (ch === "%") {
            scnr.peek();
            return fn2(hasSpace, "%", true);
          } else if (ch === "|") {
            return prev === "%" || detectModulo ? true : !(prev === CHAR_SP || prev === CHAR_LF);
          } else if (ch === CHAR_SP) {
            scnr.peek();
            return fn2(true, CHAR_SP, detectModulo);
          } else if (ch === CHAR_LF) {
            scnr.peek();
            return fn2(true, CHAR_LF, detectModulo);
          } else {
            return true;
          }
        };
        const ret = fn2();
        reset && scnr.resetPeek();
        return ret;
      }
      function takeChar(scnr, fn2) {
        const ch = scnr.currentChar();
        if (ch === EOF) {
          return EOF;
        }
        if (fn2(ch)) {
          scnr.next();
          return ch;
        }
        return null;
      }
      function isIdentifier(ch) {
        const cc = ch.charCodeAt(0);
        return cc >= 97 && cc <= 122 || // a-z
        cc >= 65 && cc <= 90 || // A-Z
        cc >= 48 && cc <= 57 || // 0-9
        cc === 95 || // _
        cc === 36;
      }
      function takeIdentifierChar(scnr) {
        return takeChar(scnr, isIdentifier);
      }
      function isNamedIdentifier(ch) {
        const cc = ch.charCodeAt(0);
        return cc >= 97 && cc <= 122 || // a-z
        cc >= 65 && cc <= 90 || // A-Z
        cc >= 48 && cc <= 57 || // 0-9
        cc === 95 || // _
        cc === 36 || // $
        cc === 45;
      }
      function takeNamedIdentifierChar(scnr) {
        return takeChar(scnr, isNamedIdentifier);
      }
      function isDigit(ch) {
        const cc = ch.charCodeAt(0);
        return cc >= 48 && cc <= 57;
      }
      function takeDigit(scnr) {
        return takeChar(scnr, isDigit);
      }
      function isHexDigit(ch) {
        const cc = ch.charCodeAt(0);
        return cc >= 48 && cc <= 57 || // 0-9
        cc >= 65 && cc <= 70 || // A-F
        cc >= 97 && cc <= 102;
      }
      function takeHexDigit(scnr) {
        return takeChar(scnr, isHexDigit);
      }
      function getDigits(scnr) {
        let ch = "";
        let num = "";
        while (ch = takeDigit(scnr)) {
          num += ch;
        }
        return num;
      }
      function readModulo(scnr) {
        skipSpaces(scnr);
        const ch = scnr.currentChar();
        if (ch !== "%") {
          emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
        }
        scnr.next();
        return "%";
      }
      function readText(scnr) {
        let buf = "";
        while (true) {
          const ch = scnr.currentChar();
          if (ch === "{" || ch === "}" || ch === "@" || ch === "|" || !ch) {
            break;
          } else if (ch === "%") {
            if (isTextStart(scnr)) {
              buf += ch;
              scnr.next();
            } else {
              break;
            }
          } else if (ch === CHAR_SP || ch === CHAR_LF) {
            if (isTextStart(scnr)) {
              buf += ch;
              scnr.next();
            } else if (isPluralStart(scnr)) {
              break;
            } else {
              buf += ch;
              scnr.next();
            }
          } else {
            buf += ch;
            scnr.next();
          }
        }
        return buf;
      }
      function readNamedIdentifier(scnr) {
        skipSpaces(scnr);
        let ch = "";
        let name = "";
        while (ch = takeNamedIdentifierChar(scnr)) {
          name += ch;
        }
        if (scnr.currentChar() === EOF) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
        }
        return name;
      }
      function readListIdentifier(scnr) {
        skipSpaces(scnr);
        let value = "";
        if (scnr.currentChar() === "-") {
          scnr.next();
          value += `-${getDigits(scnr)}`;
        } else {
          value += getDigits(scnr);
        }
        if (scnr.currentChar() === EOF) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
        }
        return value;
      }
      function isLiteral2(ch) {
        return ch !== LITERAL_DELIMITER && ch !== CHAR_LF;
      }
      function readLiteral(scnr) {
        skipSpaces(scnr);
        eat(scnr, `'`);
        let ch = "";
        let literal = "";
        while (ch = takeChar(scnr, isLiteral2)) {
          if (ch === "\\") {
            literal += readEscapeSequence(scnr);
          } else {
            literal += ch;
          }
        }
        const current = scnr.currentChar();
        if (current === CHAR_LF || current === EOF) {
          emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);
          if (current === CHAR_LF) {
            scnr.next();
            eat(scnr, `'`);
          }
          return literal;
        }
        eat(scnr, `'`);
        return literal;
      }
      function readEscapeSequence(scnr) {
        const ch = scnr.currentChar();
        switch (ch) {
          case "\\":
          case `'`:
            scnr.next();
            return `\\${ch}`;
          case "u":
            return readUnicodeEscapeSequence(scnr, ch, 4);
          case "U":
            return readUnicodeEscapeSequence(scnr, ch, 6);
          default:
            emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);
            return "";
        }
      }
      function readUnicodeEscapeSequence(scnr, unicode, digits) {
        eat(scnr, unicode);
        let sequence = "";
        for (let i2 = 0; i2 < digits; i2++) {
          const ch = takeHexDigit(scnr);
          if (!ch) {
            emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\${unicode}${sequence}${scnr.currentChar()}`);
            break;
          }
          sequence += ch;
        }
        return `\\${unicode}${sequence}`;
      }
      function isInvalidIdentifier(ch) {
        return ch !== "{" && ch !== "}" && ch !== CHAR_SP && ch !== CHAR_LF;
      }
      function readInvalidIdentifier(scnr) {
        skipSpaces(scnr);
        let ch = "";
        let identifiers = "";
        while (ch = takeChar(scnr, isInvalidIdentifier)) {
          identifiers += ch;
        }
        return identifiers;
      }
      function readLinkedModifier(scnr) {
        let ch = "";
        let name = "";
        while (ch = takeIdentifierChar(scnr)) {
          name += ch;
        }
        return name;
      }
      function readLinkedRefer(scnr) {
        const fn2 = (buf) => {
          const ch = scnr.currentChar();
          if (ch === "{" || ch === "%" || ch === "@" || ch === "|" || ch === "(" || ch === ")" || !ch) {
            return buf;
          } else if (ch === CHAR_SP) {
            return buf;
          } else if (ch === CHAR_LF || ch === DOT) {
            buf += ch;
            scnr.next();
            return fn2(buf);
          } else {
            buf += ch;
            scnr.next();
            return fn2(buf);
          }
        };
        return fn2("");
      }
      function readPlural(scnr) {
        skipSpaces(scnr);
        const plural = eat(
          scnr,
          "|"
          /* TokenChars.Pipe */
        );
        skipSpaces(scnr);
        return plural;
      }
      function readTokenInPlaceholder(scnr, context2) {
        let token = null;
        const ch = scnr.currentChar();
        switch (ch) {
          case "{":
            if (context2.braceNest >= 1) {
              emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);
            }
            scnr.next();
            token = getToken(
              context2,
              2,
              "{"
              /* TokenChars.BraceLeft */
            );
            skipSpaces(scnr);
            context2.braceNest++;
            return token;
          case "}":
            if (context2.braceNest > 0 && context2.currentType === 2) {
              emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);
            }
            scnr.next();
            token = getToken(
              context2,
              3,
              "}"
              /* TokenChars.BraceRight */
            );
            context2.braceNest--;
            context2.braceNest > 0 && skipSpaces(scnr);
            if (context2.inLinked && context2.braceNest === 0) {
              context2.inLinked = false;
            }
            return token;
          case "@":
            if (context2.braceNest > 0) {
              emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
            }
            token = readTokenInLinked(scnr, context2) || getEndToken(context2);
            context2.braceNest = 0;
            return token;
          default: {
            let validNamedIdentifier = true;
            let validListIdentifier = true;
            let validLiteral = true;
            if (isPluralStart(scnr)) {
              if (context2.braceNest > 0) {
                emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
              }
              token = getToken(context2, 1, readPlural(scnr));
              context2.braceNest = 0;
              context2.inLinked = false;
              return token;
            }
            if (context2.braceNest > 0 && (context2.currentType === 5 || context2.currentType === 6 || context2.currentType === 7)) {
              emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
              context2.braceNest = 0;
              return readToken(scnr, context2);
            }
            if (validNamedIdentifier = isNamedIdentifierStart(scnr, context2)) {
              token = getToken(context2, 5, readNamedIdentifier(scnr));
              skipSpaces(scnr);
              return token;
            }
            if (validListIdentifier = isListIdentifierStart(scnr, context2)) {
              token = getToken(context2, 6, readListIdentifier(scnr));
              skipSpaces(scnr);
              return token;
            }
            if (validLiteral = isLiteralStart(scnr, context2)) {
              token = getToken(context2, 7, readLiteral(scnr));
              skipSpaces(scnr);
              return token;
            }
            if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {
              token = getToken(context2, 13, readInvalidIdentifier(scnr));
              emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);
              skipSpaces(scnr);
              return token;
            }
            break;
          }
        }
        return token;
      }
      function readTokenInLinked(scnr, context2) {
        const { currentType } = context2;
        let token = null;
        const ch = scnr.currentChar();
        if ((currentType === 8 || currentType === 9 || currentType === 12 || currentType === 10) && (ch === CHAR_LF || ch === CHAR_SP)) {
          emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
        }
        switch (ch) {
          case "@":
            scnr.next();
            token = getToken(
              context2,
              8,
              "@"
              /* TokenChars.LinkedAlias */
            );
            context2.inLinked = true;
            return token;
          case ".":
            skipSpaces(scnr);
            scnr.next();
            return getToken(
              context2,
              9,
              "."
              /* TokenChars.LinkedDot */
            );
          case ":":
            skipSpaces(scnr);
            scnr.next();
            return getToken(
              context2,
              10,
              ":"
              /* TokenChars.LinkedDelimiter */
            );
          default:
            if (isPluralStart(scnr)) {
              token = getToken(context2, 1, readPlural(scnr));
              context2.braceNest = 0;
              context2.inLinked = false;
              return token;
            }
            if (isLinkedDotStart(scnr, context2) || isLinkedDelimiterStart(scnr, context2)) {
              skipSpaces(scnr);
              return readTokenInLinked(scnr, context2);
            }
            if (isLinkedModifierStart(scnr, context2)) {
              skipSpaces(scnr);
              return getToken(context2, 12, readLinkedModifier(scnr));
            }
            if (isLinkedReferStart(scnr, context2)) {
              skipSpaces(scnr);
              if (ch === "{") {
                return readTokenInPlaceholder(scnr, context2) || token;
              } else {
                return getToken(context2, 11, readLinkedRefer(scnr));
              }
            }
            if (currentType === 8) {
              emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
            }
            context2.braceNest = 0;
            context2.inLinked = false;
            return readToken(scnr, context2);
        }
      }
      function readToken(scnr, context2) {
        let token = {
          type: 14
          /* TokenTypes.EOF */
        };
        if (context2.braceNest > 0) {
          return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
        }
        if (context2.inLinked) {
          return readTokenInLinked(scnr, context2) || getEndToken(context2);
        }
        const ch = scnr.currentChar();
        switch (ch) {
          case "{":
            return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
          case "}":
            emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);
            scnr.next();
            return getToken(
              context2,
              3,
              "}"
              /* TokenChars.BraceRight */
            );
          case "@":
            return readTokenInLinked(scnr, context2) || getEndToken(context2);
          default: {
            if (isPluralStart(scnr)) {
              token = getToken(context2, 1, readPlural(scnr));
              context2.braceNest = 0;
              context2.inLinked = false;
              return token;
            }
            const { isModulo, hasSpace } = detectModuloStart(scnr);
            if (isModulo) {
              return hasSpace ? getToken(context2, 0, readText(scnr)) : getToken(context2, 4, readModulo(scnr));
            }
            if (isTextStart(scnr)) {
              return getToken(context2, 0, readText(scnr));
            }
            break;
          }
        }
        return token;
      }
      function nextToken() {
        const { currentType, offset: offset2, startLoc, endLoc } = _context;
        _context.lastType = currentType;
        _context.lastOffset = offset2;
        _context.lastStartLoc = startLoc;
        _context.lastEndLoc = endLoc;
        _context.offset = currentOffset();
        _context.startLoc = currentPosition();
        if (_scnr.currentChar() === EOF) {
          return getToken(
            _context,
            14
            /* TokenTypes.EOF */
          );
        }
        return readToken(_scnr, _context);
      }
      return {
        nextToken,
        currentOffset,
        currentPosition,
        context
      };
    }
    const ERROR_DOMAIN$2 = "parser";
    const KNOWN_ESCAPES = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
    function fromEscapeSequence(match, codePoint4, codePoint6) {
      switch (match) {
        case `\\\\`:
          return `\\`;
        case `\\'`:
          return `'`;
        default: {
          const codePoint = parseInt(codePoint4 || codePoint6, 16);
          if (codePoint <= 55295 || codePoint >= 57344) {
            return String.fromCodePoint(codePoint);
          }
          return "�";
        }
      }
    }
    function createParser(options = {}) {
      const location2 = options.location !== false;
      const { onError, onWarn } = options;
      function emitError(tokenzer, code2, start2, offset2, ...args) {
        const end2 = tokenzer.currentPosition();
        end2.offset += offset2;
        end2.column += offset2;
        if (onError) {
          const loc = location2 ? createLocation(start2, end2) : null;
          const err = createCompileError(code2, loc, {
            domain: ERROR_DOMAIN$2,
            args
          });
          onError(err);
        }
      }
      function emitWarn(tokenzer, code2, start2, offset2, ...args) {
        const end2 = tokenzer.currentPosition();
        end2.offset += offset2;
        end2.column += offset2;
        if (onWarn) {
          const loc = location2 ? createLocation(start2, end2) : null;
          onWarn(createCompileWarn(code2, loc, args));
        }
      }
      function startNode(type, offset2, loc) {
        const node = { type };
        if (location2) {
          node.start = offset2;
          node.end = offset2;
          node.loc = { start: loc, end: loc };
        }
        return node;
      }
      function endNode(node, offset2, pos, type) {
        if (location2) {
          node.end = offset2;
          if (node.loc) {
            node.loc.end = pos;
          }
        }
      }
      function parseText(tokenizer, value) {
        const context = tokenizer.context();
        const node = startNode(3, context.offset, context.startLoc);
        node.value = value;
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
      }
      function parseList(tokenizer, index2) {
        const context = tokenizer.context();
        const { lastOffset: offset2, lastStartLoc: loc } = context;
        const node = startNode(5, offset2, loc);
        node.index = parseInt(index2, 10);
        tokenizer.nextToken();
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
      }
      function parseNamed(tokenizer, key2, modulo) {
        const context = tokenizer.context();
        const { lastOffset: offset2, lastStartLoc: loc } = context;
        const node = startNode(4, offset2, loc);
        node.key = key2;
        if (modulo === true) {
          node.modulo = true;
        }
        tokenizer.nextToken();
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
      }
      function parseLiteral(tokenizer, value) {
        const context = tokenizer.context();
        const { lastOffset: offset2, lastStartLoc: loc } = context;
        const node = startNode(9, offset2, loc);
        node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);
        tokenizer.nextToken();
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
      }
      function parseLinkedModifier(tokenizer) {
        const token = tokenizer.nextToken();
        const context = tokenizer.context();
        const { lastOffset: offset2, lastStartLoc: loc } = context;
        const node = startNode(8, offset2, loc);
        if (token.type !== 12) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);
          node.value = "";
          endNode(node, offset2, loc);
          return {
            nextConsumeToken: token,
            node
          };
        }
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        node.value = token.value || "";
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return {
          node
        };
      }
      function parseLinkedKey(tokenizer, value) {
        const context = tokenizer.context();
        const node = startNode(7, context.offset, context.startLoc);
        node.value = value;
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
      }
      function parseLinked(tokenizer) {
        const context = tokenizer.context();
        const linkedNode = startNode(6, context.offset, context.startLoc);
        let token = tokenizer.nextToken();
        if (token.type === 9) {
          const parsed = parseLinkedModifier(tokenizer);
          linkedNode.modifier = parsed.node;
          token = parsed.nextConsumeToken || tokenizer.nextToken();
        }
        if (token.type !== 10) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        token = tokenizer.nextToken();
        if (token.type === 2) {
          token = tokenizer.nextToken();
        }
        switch (token.type) {
          case 11:
            if (token.value == null) {
              emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
            }
            linkedNode.key = parseLinkedKey(tokenizer, token.value || "");
            break;
          case 5:
            if (token.value == null) {
              emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
            }
            linkedNode.key = parseNamed(tokenizer, token.value || "");
            break;
          case 6:
            if (token.value == null) {
              emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
            }
            linkedNode.key = parseList(tokenizer, token.value || "");
            break;
          case 7:
            if (token.value == null) {
              emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
            }
            linkedNode.key = parseLiteral(tokenizer, token.value || "");
            break;
          default: {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);
            const nextContext = tokenizer.context();
            const emptyLinkedKeyNode = startNode(7, nextContext.offset, nextContext.startLoc);
            emptyLinkedKeyNode.value = "";
            endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);
            linkedNode.key = emptyLinkedKeyNode;
            endNode(linkedNode, nextContext.offset, nextContext.startLoc);
            return {
              nextConsumeToken: token,
              node: linkedNode
            };
          }
        }
        endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());
        return {
          node: linkedNode
        };
      }
      function parseMessage(tokenizer) {
        const context = tokenizer.context();
        const startOffset = context.currentType === 1 ? tokenizer.currentOffset() : context.offset;
        const startLoc = context.currentType === 1 ? context.endLoc : context.startLoc;
        const node = startNode(2, startOffset, startLoc);
        node.items = [];
        let nextToken = null;
        let modulo = null;
        do {
          const token = nextToken || tokenizer.nextToken();
          nextToken = null;
          switch (token.type) {
            case 0:
              if (token.value == null) {
                emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
              }
              node.items.push(parseText(tokenizer, token.value || ""));
              break;
            case 6:
              if (token.value == null) {
                emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
              }
              node.items.push(parseList(tokenizer, token.value || ""));
              break;
            case 4:
              modulo = true;
              break;
            case 5:
              if (token.value == null) {
                emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
              }
              node.items.push(parseNamed(tokenizer, token.value || "", !!modulo));
              if (modulo) {
                emitWarn(tokenizer, CompileWarnCodes.USE_MODULO_SYNTAX, context.lastStartLoc, 0, getTokenCaption(token));
                modulo = null;
              }
              break;
            case 7:
              if (token.value == null) {
                emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
              }
              node.items.push(parseLiteral(tokenizer, token.value || ""));
              break;
            case 8: {
              const parsed = parseLinked(tokenizer);
              node.items.push(parsed.node);
              nextToken = parsed.nextConsumeToken || null;
              break;
            }
          }
        } while (context.currentType !== 14 && context.currentType !== 1);
        const endOffset = context.currentType === 1 ? context.lastOffset : tokenizer.currentOffset();
        const endLoc = context.currentType === 1 ? context.lastEndLoc : tokenizer.currentPosition();
        endNode(node, endOffset, endLoc);
        return node;
      }
      function parsePlural(tokenizer, offset2, loc, msgNode) {
        const context = tokenizer.context();
        let hasEmptyMessage = msgNode.items.length === 0;
        const node = startNode(1, offset2, loc);
        node.cases = [];
        node.cases.push(msgNode);
        do {
          const msg = parseMessage(tokenizer);
          if (!hasEmptyMessage) {
            hasEmptyMessage = msg.items.length === 0;
          }
          node.cases.push(msg);
        } while (context.currentType !== 14);
        if (hasEmptyMessage) {
          emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);
        }
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
      }
      function parseResource(tokenizer) {
        const context = tokenizer.context();
        const { offset: offset2, startLoc } = context;
        const msgNode = parseMessage(tokenizer);
        if (context.currentType === 14) {
          return msgNode;
        } else {
          return parsePlural(tokenizer, offset2, startLoc, msgNode);
        }
      }
      function parse2(source) {
        const tokenizer = createTokenizer(source, assign$1({}, options));
        const context = tokenizer.context();
        const node = startNode(0, context.offset, context.startLoc);
        if (location2 && node.loc) {
          node.loc.source = source;
        }
        node.body = parseResource(tokenizer);
        if (options.onCacheKey) {
          node.cacheKey = options.onCacheKey(source);
        }
        if (context.currentType !== 14) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || "");
        }
        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
        return node;
      }
      return { parse: parse2 };
    }
    function getTokenCaption(token) {
      if (token.type === 14) {
        return "EOF";
      }
      const name = (token.value || "").replace(/\r?\n/gu, "\\n");
      return name.length > 10 ? name.slice(0, 9) + "…" : name;
    }
    function createTransformer(ast, options = {}) {
      const _context = {
        ast,
        helpers: /* @__PURE__ */ new Set()
      };
      const context = () => _context;
      const helper = (name) => {
        _context.helpers.add(name);
        return name;
      };
      return { context, helper };
    }
    function traverseNodes(nodes, transformer) {
      for (let i2 = 0; i2 < nodes.length; i2++) {
        traverseNode(nodes[i2], transformer);
      }
    }
    function traverseNode(node, transformer) {
      switch (node.type) {
        case 1:
          traverseNodes(node.cases, transformer);
          transformer.helper(
            "plural"
            /* HelperNameMap.PLURAL */
          );
          break;
        case 2:
          traverseNodes(node.items, transformer);
          break;
        case 6: {
          const linked = node;
          traverseNode(linked.key, transformer);
          transformer.helper(
            "linked"
            /* HelperNameMap.LINKED */
          );
          transformer.helper(
            "type"
            /* HelperNameMap.TYPE */
          );
          break;
        }
        case 5:
          transformer.helper(
            "interpolate"
            /* HelperNameMap.INTERPOLATE */
          );
          transformer.helper(
            "list"
            /* HelperNameMap.LIST */
          );
          break;
        case 4:
          transformer.helper(
            "interpolate"
            /* HelperNameMap.INTERPOLATE */
          );
          transformer.helper(
            "named"
            /* HelperNameMap.NAMED */
          );
          break;
      }
    }
    function transform(ast, options = {}) {
      const transformer = createTransformer(ast);
      transformer.helper(
        "normalize"
        /* HelperNameMap.NORMALIZE */
      );
      ast.body && traverseNode(ast.body, transformer);
      const context = transformer.context();
      ast.helpers = Array.from(context.helpers);
    }
    function optimize(ast) {
      const body = ast.body;
      if (body.type === 2) {
        optimizeMessageNode(body);
      } else {
        body.cases.forEach((c2) => optimizeMessageNode(c2));
      }
      return ast;
    }
    function optimizeMessageNode(message) {
      if (message.items.length === 1) {
        const item = message.items[0];
        if (item.type === 3 || item.type === 9) {
          message.static = item.value;
          delete item.value;
        }
      } else {
        const values = [];
        for (let i2 = 0; i2 < message.items.length; i2++) {
          const item = message.items[i2];
          if (!(item.type === 3 || item.type === 9)) {
            break;
          }
          if (item.value == null) {
            break;
          }
          values.push(item.value);
        }
        if (values.length === message.items.length) {
          message.static = join(values);
          for (let i2 = 0; i2 < message.items.length; i2++) {
            const item = message.items[i2];
            if (item.type === 3 || item.type === 9) {
              delete item.value;
            }
          }
        }
      }
    }
    const ERROR_DOMAIN$1 = "minifier";
    function minify(node) {
      node.t = node.type;
      switch (node.type) {
        case 0: {
          const resource = node;
          minify(resource.body);
          resource.b = resource.body;
          delete resource.body;
          break;
        }
        case 1: {
          const plural = node;
          const cases = plural.cases;
          for (let i2 = 0; i2 < cases.length; i2++) {
            minify(cases[i2]);
          }
          plural.c = cases;
          delete plural.cases;
          break;
        }
        case 2: {
          const message = node;
          const items = message.items;
          for (let i2 = 0; i2 < items.length; i2++) {
            minify(items[i2]);
          }
          message.i = items;
          delete message.items;
          if (message.static) {
            message.s = message.static;
            delete message.static;
          }
          break;
        }
        case 3:
        case 9:
        case 8:
        case 7: {
          const valueNode = node;
          if (valueNode.value) {
            valueNode.v = valueNode.value;
            delete valueNode.value;
          }
          break;
        }
        case 6: {
          const linked = node;
          minify(linked.key);
          linked.k = linked.key;
          delete linked.key;
          if (linked.modifier) {
            minify(linked.modifier);
            linked.m = linked.modifier;
            delete linked.modifier;
          }
          break;
        }
        case 5: {
          const list = node;
          list.i = list.index;
          delete list.index;
          break;
        }
        case 4: {
          const named = node;
          named.k = named.key;
          delete named.key;
          break;
        }
        default: {
          throw createCompileError(CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE, null, {
            domain: ERROR_DOMAIN$1,
            args: [node.type]
          });
        }
      }
      delete node.type;
    }
    const ERROR_DOMAIN = "parser";
    function createCodeGenerator(ast, options) {
      const { sourceMap, filename, breakLineCode, needIndent: _needIndent } = options;
      const location2 = options.location !== false;
      const _context = {
        filename,
        code: "",
        column: 1,
        line: 1,
        offset: 0,
        map: void 0,
        breakLineCode,
        needIndent: _needIndent,
        indentLevel: 0
      };
      if (location2 && ast.loc) {
        _context.source = ast.loc.source;
      }
      const context = () => _context;
      function push(code2, node) {
        _context.code += code2;
      }
      function _newline(n2, withBreakLine = true) {
        const _breakLineCode = withBreakLine ? breakLineCode : "";
        push(_needIndent ? _breakLineCode + `  `.repeat(n2) : _breakLineCode);
      }
      function indent(withNewLine = true) {
        const level = ++_context.indentLevel;
        withNewLine && _newline(level);
      }
      function deindent(withNewLine = true) {
        const level = --_context.indentLevel;
        withNewLine && _newline(level);
      }
      function newline() {
        _newline(_context.indentLevel);
      }
      const helper = (key2) => `_${key2}`;
      const needIndent = () => _context.needIndent;
      return {
        context,
        push,
        indent,
        deindent,
        newline,
        helper,
        needIndent
      };
    }
    function generateLinkedNode(generator, node) {
      const { helper } = generator;
      generator.push(`${helper(
        "linked"
        /* HelperNameMap.LINKED */
      )}(`);
      generateNode(generator, node.key);
      if (node.modifier) {
        generator.push(`, `);
        generateNode(generator, node.modifier);
        generator.push(`, _type`);
      } else {
        generator.push(`, undefined, _type`);
      }
      generator.push(`)`);
    }
    function generateMessageNode(generator, node) {
      const { helper, needIndent } = generator;
      generator.push(`${helper(
        "normalize"
        /* HelperNameMap.NORMALIZE */
      )}([`);
      generator.indent(needIndent());
      const length = node.items.length;
      for (let i2 = 0; i2 < length; i2++) {
        generateNode(generator, node.items[i2]);
        if (i2 === length - 1) {
          break;
        }
        generator.push(", ");
      }
      generator.deindent(needIndent());
      generator.push("])");
    }
    function generatePluralNode(generator, node) {
      const { helper, needIndent } = generator;
      if (node.cases.length > 1) {
        generator.push(`${helper(
          "plural"
          /* HelperNameMap.PLURAL */
        )}([`);
        generator.indent(needIndent());
        const length = node.cases.length;
        for (let i2 = 0; i2 < length; i2++) {
          generateNode(generator, node.cases[i2]);
          if (i2 === length - 1) {
            break;
          }
          generator.push(", ");
        }
        generator.deindent(needIndent());
        generator.push(`])`);
      }
    }
    function generateResource(generator, node) {
      if (node.body) {
        generateNode(generator, node.body);
      } else {
        generator.push("null");
      }
    }
    function generateNode(generator, node) {
      const { helper } = generator;
      switch (node.type) {
        case 0:
          generateResource(generator, node);
          break;
        case 1:
          generatePluralNode(generator, node);
          break;
        case 2:
          generateMessageNode(generator, node);
          break;
        case 6:
          generateLinkedNode(generator, node);
          break;
        case 8:
          generator.push(JSON.stringify(node.value), node);
          break;
        case 7:
          generator.push(JSON.stringify(node.value), node);
          break;
        case 5:
          generator.push(`${helper(
            "interpolate"
            /* HelperNameMap.INTERPOLATE */
          )}(${helper(
            "list"
            /* HelperNameMap.LIST */
          )}(${node.index}))`, node);
          break;
        case 4:
          generator.push(`${helper(
            "interpolate"
            /* HelperNameMap.INTERPOLATE */
          )}(${helper(
            "named"
            /* HelperNameMap.NAMED */
          )}(${JSON.stringify(node.key)}))`, node);
          break;
        case 9:
          generator.push(JSON.stringify(node.value), node);
          break;
        case 3:
          generator.push(JSON.stringify(node.value), node);
          break;
        default: {
          throw createCompileError(CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE, null, {
            domain: ERROR_DOMAIN,
            args: [node.type]
          });
        }
      }
    }
    const generate = (ast, options = {}) => {
      const mode = isString(options.mode) ? options.mode : "normal";
      const filename = isString(options.filename) ? options.filename : "message.intl";
      const sourceMap = !!options.sourceMap;
      const breakLineCode = options.breakLineCode != null ? options.breakLineCode : mode === "arrow" ? ";" : "\n";
      const needIndent = options.needIndent ? options.needIndent : mode !== "arrow";
      const helpers = ast.helpers || [];
      const generator = createCodeGenerator(ast, {
        mode,
        filename,
        sourceMap,
        breakLineCode,
        needIndent
      });
      generator.push(mode === "normal" ? `function __msg__ (ctx) {` : `(ctx) => {`);
      generator.indent(needIndent);
      if (helpers.length > 0) {
        generator.push(`const { ${join(helpers.map((s2) => `${s2}: _${s2}`), ", ")} } = ctx`);
        generator.newline();
      }
      generator.push(`return `);
      generateNode(generator, ast);
      generator.deindent(needIndent);
      generator.push(`}`);
      delete ast.helpers;
      const { code: code2, map } = generator.context();
      return {
        ast,
        code: code2,
        map: map ? map.toJSON() : void 0
        // eslint-disable-line @typescript-eslint/no-explicit-any
      };
    };
    function baseCompile$1(source, options = {}) {
      const assignedOptions = assign$1({}, options);
      const jit = !!assignedOptions.jit;
      const enalbeMinify = !!assignedOptions.minify;
      const enambeOptimize = assignedOptions.optimize == null ? true : assignedOptions.optimize;
      const parser2 = createParser(assignedOptions);
      const ast = parser2.parse(source);
      if (!jit) {
        transform(ast, assignedOptions);
        return generate(ast, assignedOptions);
      } else {
        enambeOptimize && optimize(ast);
        enalbeMinify && minify(ast);
        return { ast, code: "" };
      }
    }
    const pathStateMachine = [];
    pathStateMachine[
      0
      /* States.BEFORE_PATH */
    ] = {
      [
        "w"
        /* PathCharTypes.WORKSPACE */
      ]: [
        0
        /* States.BEFORE_PATH */
      ],
      [
        "i"
        /* PathCharTypes.IDENT */
      ]: [
        3,
        0
        /* Actions.APPEND */
      ],
      [
        "["
        /* PathCharTypes.LEFT_BRACKET */
      ]: [
        4
        /* States.IN_SUB_PATH */
      ],
      [
        "o"
        /* PathCharTypes.END_OF_FAIL */
      ]: [
        7
        /* States.AFTER_PATH */
      ]
    };
    pathStateMachine[
      1
      /* States.IN_PATH */
    ] = {
      [
        "w"
        /* PathCharTypes.WORKSPACE */
      ]: [
        1
        /* States.IN_PATH */
      ],
      [
        "."
        /* PathCharTypes.DOT */
      ]: [
        2
        /* States.BEFORE_IDENT */
      ],
      [
        "["
        /* PathCharTypes.LEFT_BRACKET */
      ]: [
        4
        /* States.IN_SUB_PATH */
      ],
      [
        "o"
        /* PathCharTypes.END_OF_FAIL */
      ]: [
        7
        /* States.AFTER_PATH */
      ]
    };
    pathStateMachine[
      2
      /* States.BEFORE_IDENT */
    ] = {
      [
        "w"
        /* PathCharTypes.WORKSPACE */
      ]: [
        2
        /* States.BEFORE_IDENT */
      ],
      [
        "i"
        /* PathCharTypes.IDENT */
      ]: [
        3,
        0
        /* Actions.APPEND */
      ],
      [
        "0"
        /* PathCharTypes.ZERO */
      ]: [
        3,
        0
        /* Actions.APPEND */
      ]
    };
    pathStateMachine[
      3
      /* States.IN_IDENT */
    ] = {
      [
        "i"
        /* PathCharTypes.IDENT */
      ]: [
        3,
        0
        /* Actions.APPEND */
      ],
      [
        "0"
        /* PathCharTypes.ZERO */
      ]: [
        3,
        0
        /* Actions.APPEND */
      ],
      [
        "w"
        /* PathCharTypes.WORKSPACE */
      ]: [
        1,
        1
        /* Actions.PUSH */
      ],
      [
        "."
        /* PathCharTypes.DOT */
      ]: [
        2,
        1
        /* Actions.PUSH */
      ],
      [
        "["
        /* PathCharTypes.LEFT_BRACKET */
      ]: [
        4,
        1
        /* Actions.PUSH */
      ],
      [
        "o"
        /* PathCharTypes.END_OF_FAIL */
      ]: [
        7,
        1
        /* Actions.PUSH */
      ]
    };
    pathStateMachine[
      4
      /* States.IN_SUB_PATH */
    ] = {
      [
        "'"
        /* PathCharTypes.SINGLE_QUOTE */
      ]: [
        5,
        0
        /* Actions.APPEND */
      ],
      [
        '"'
        /* PathCharTypes.DOUBLE_QUOTE */
      ]: [
        6,
        0
        /* Actions.APPEND */
      ],
      [
        "["
        /* PathCharTypes.LEFT_BRACKET */
      ]: [
        4,
        2
        /* Actions.INC_SUB_PATH_DEPTH */
      ],
      [
        "]"
        /* PathCharTypes.RIGHT_BRACKET */
      ]: [
        1,
        3
        /* Actions.PUSH_SUB_PATH */
      ],
      [
        "o"
        /* PathCharTypes.END_OF_FAIL */
      ]: 8,
      [
        "l"
        /* PathCharTypes.ELSE */
      ]: [
        4,
        0
        /* Actions.APPEND */
      ]
    };
    pathStateMachine[
      5
      /* States.IN_SINGLE_QUOTE */
    ] = {
      [
        "'"
        /* PathCharTypes.SINGLE_QUOTE */
      ]: [
        4,
        0
        /* Actions.APPEND */
      ],
      [
        "o"
        /* PathCharTypes.END_OF_FAIL */
      ]: 8,
      [
        "l"
        /* PathCharTypes.ELSE */
      ]: [
        5,
        0
        /* Actions.APPEND */
      ]
    };
    pathStateMachine[
      6
      /* States.IN_DOUBLE_QUOTE */
    ] = {
      [
        '"'
        /* PathCharTypes.DOUBLE_QUOTE */
      ]: [
        4,
        0
        /* Actions.APPEND */
      ],
      [
        "o"
        /* PathCharTypes.END_OF_FAIL */
      ]: 8,
      [
        "l"
        /* PathCharTypes.ELSE */
      ]: [
        6,
        0
        /* Actions.APPEND */
      ]
    };
    const literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
    function isLiteral(exp) {
      return literalValueRE.test(exp);
    }
    function stripQuotes(str) {
      const a2 = str.charCodeAt(0);
      const b2 = str.charCodeAt(str.length - 1);
      return a2 === b2 && (a2 === 34 || a2 === 39) ? str.slice(1, -1) : str;
    }
    function getPathCharType(ch) {
      if (ch === void 0 || ch === null) {
        return "o";
      }
      const code2 = ch.charCodeAt(0);
      switch (code2) {
        case 91:
        case 93:
        case 46:
        case 34:
        case 39:
          return ch;
        case 95:
        case 36:
        case 45:
          return "i";
        case 9:
        case 10:
        case 13:
        case 160:
        case 65279:
        case 8232:
        case 8233:
          return "w";
      }
      return "i";
    }
    function formatSubPath(path) {
      const trimmed = path.trim();
      if (path.charAt(0) === "0" && isNaN(parseInt(path))) {
        return false;
      }
      return isLiteral(trimmed) ? stripQuotes(trimmed) : "*" + trimmed;
    }
    function parse$3(path) {
      const keys = [];
      let index2 = -1;
      let mode = 0;
      let subPathDepth = 0;
      let c2;
      let key2;
      let newChar;
      let type;
      let transition;
      let action;
      let typeMap;
      const actions = [];
      actions[
        0
        /* Actions.APPEND */
      ] = () => {
        if (key2 === void 0) {
          key2 = newChar;
        } else {
          key2 += newChar;
        }
      };
      actions[
        1
        /* Actions.PUSH */
      ] = () => {
        if (key2 !== void 0) {
          keys.push(key2);
          key2 = void 0;
        }
      };
      actions[
        2
        /* Actions.INC_SUB_PATH_DEPTH */
      ] = () => {
        actions[
          0
          /* Actions.APPEND */
        ]();
        subPathDepth++;
      };
      actions[
        3
        /* Actions.PUSH_SUB_PATH */
      ] = () => {
        if (subPathDepth > 0) {
          subPathDepth--;
          mode = 4;
          actions[
            0
            /* Actions.APPEND */
          ]();
        } else {
          subPathDepth = 0;
          if (key2 === void 0) {
            return false;
          }
          key2 = formatSubPath(key2);
          if (key2 === false) {
            return false;
          } else {
            actions[
              1
              /* Actions.PUSH */
            ]();
          }
        }
      };
      function maybeUnescapeQuote() {
        const nextChar = path[index2 + 1];
        if (mode === 5 && nextChar === "'" || mode === 6 && nextChar === '"') {
          index2++;
          newChar = "\\" + nextChar;
          actions[
            0
            /* Actions.APPEND */
          ]();
          return true;
        }
      }
      while (mode !== null) {
        index2++;
        c2 = path[index2];
        if (c2 === "\\" && maybeUnescapeQuote()) {
          continue;
        }
        type = getPathCharType(c2);
        typeMap = pathStateMachine[mode];
        transition = typeMap[type] || typeMap[
          "l"
          /* PathCharTypes.ELSE */
        ] || 8;
        if (transition === 8) {
          return;
        }
        mode = transition[0];
        if (transition[1] !== void 0) {
          action = actions[transition[1]];
          if (action) {
            newChar = c2;
            if (action() === false) {
              return;
            }
          }
        }
        if (mode === 7) {
          return keys;
        }
      }
    }
    const cache = /* @__PURE__ */ new Map();
    function resolveWithKeyValue(obj, path) {
      return isObject$4(obj) ? obj[path] : null;
    }
    function resolveValue(obj, path) {
      if (!isObject$4(obj)) {
        return null;
      }
      let hit = cache.get(path);
      if (!hit) {
        hit = parse$3(path);
        if (hit) {
          cache.set(path, hit);
        }
      }
      if (!hit) {
        return null;
      }
      const len = hit.length;
      let last = obj;
      let i2 = 0;
      while (i2 < len) {
        const val = last[hit[i2]];
        if (val === void 0) {
          return null;
        }
        if (isFunction$1(last)) {
          return null;
        }
        last = val;
        i2++;
      }
      return last;
    }
    const DEFAULT_MODIFIER = (str) => str;
    const DEFAULT_MESSAGE = (ctx) => "";
    const DEFAULT_MESSAGE_DATA_TYPE = "text";
    const DEFAULT_NORMALIZE = (values) => values.length === 0 ? "" : join(values);
    const DEFAULT_INTERPOLATE = toDisplayString;
    function pluralDefault(choice, choicesLength) {
      choice = Math.abs(choice);
      if (choicesLength === 2) {
        return choice ? choice > 1 ? 1 : 0 : 1;
      }
      return choice ? Math.min(choice, 2) : 0;
    }
    function getPluralIndex(options) {
      const index2 = isNumber(options.pluralIndex) ? options.pluralIndex : -1;
      return options.named && (isNumber(options.named.count) || isNumber(options.named.n)) ? isNumber(options.named.count) ? options.named.count : isNumber(options.named.n) ? options.named.n : index2 : index2;
    }
    function normalizeNamed(pluralIndex, props) {
      if (!props.count) {
        props.count = pluralIndex;
      }
      if (!props.n) {
        props.n = pluralIndex;
      }
    }
    function createMessageContext(options = {}) {
      const locale = options.locale;
      const pluralIndex = getPluralIndex(options);
      const pluralRule = isObject$4(options.pluralRules) && isString(locale) && isFunction$1(options.pluralRules[locale]) ? options.pluralRules[locale] : pluralDefault;
      const orgPluralRule = isObject$4(options.pluralRules) && isString(locale) && isFunction$1(options.pluralRules[locale]) ? pluralDefault : void 0;
      const plural = (messages) => {
        return messages[pluralRule(pluralIndex, messages.length, orgPluralRule)];
      };
      const _list = options.list || [];
      const list = (index2) => _list[index2];
      const _named = options.named || {};
      isNumber(options.pluralIndex) && normalizeNamed(pluralIndex, _named);
      const named = (key2) => _named[key2];
      function message(key2) {
        const msg = isFunction$1(options.messages) ? options.messages(key2) : isObject$4(options.messages) ? options.messages[key2] : false;
        return !msg ? options.parent ? options.parent.message(key2) : DEFAULT_MESSAGE : msg;
      }
      const _modifier2 = (name) => options.modifiers ? options.modifiers[name] : DEFAULT_MODIFIER;
      const normalize = isPlainObject$2(options.processor) && isFunction$1(options.processor.normalize) ? options.processor.normalize : DEFAULT_NORMALIZE;
      const interpolate = isPlainObject$2(options.processor) && isFunction$1(options.processor.interpolate) ? options.processor.interpolate : DEFAULT_INTERPOLATE;
      const type = isPlainObject$2(options.processor) && isString(options.processor.type) ? options.processor.type : DEFAULT_MESSAGE_DATA_TYPE;
      const linked = (key2, ...args) => {
        const [arg1, arg2] = args;
        let type2 = "text";
        let modifier = "";
        if (args.length === 1) {
          if (isObject$4(arg1)) {
            modifier = arg1.modifier || modifier;
            type2 = arg1.type || type2;
          } else if (isString(arg1)) {
            modifier = arg1 || modifier;
          }
        } else if (args.length === 2) {
          if (isString(arg1)) {
            modifier = arg1 || modifier;
          }
          if (isString(arg2)) {
            type2 = arg2 || type2;
          }
        }
        const ret = message(key2)(ctx);
        const msg = (
          // The message in vnode resolved with linked are returned as an array by processor.nomalize
          type2 === "vnode" && isArray$2(ret) && modifier ? ret[0] : ret
        );
        return modifier ? _modifier2(modifier)(msg, type2) : msg;
      };
      const ctx = {
        [
          "list"
          /* HelperNameMap.LIST */
        ]: list,
        [
          "named"
          /* HelperNameMap.NAMED */
        ]: named,
        [
          "plural"
          /* HelperNameMap.PLURAL */
        ]: plural,
        [
          "linked"
          /* HelperNameMap.LINKED */
        ]: linked,
        [
          "message"
          /* HelperNameMap.MESSAGE */
        ]: message,
        [
          "type"
          /* HelperNameMap.TYPE */
        ]: type,
        [
          "interpolate"
          /* HelperNameMap.INTERPOLATE */
        ]: interpolate,
        [
          "normalize"
          /* HelperNameMap.NORMALIZE */
        ]: normalize,
        [
          "values"
          /* HelperNameMap.VALUES */
        ]: assign$1({}, _list, _named)
      };
      return ctx;
    }
    let devtools = null;
    function setDevToolsHook(hook2) {
      devtools = hook2;
    }
    function getDevToolsHook() {
      return devtools;
    }
    function initI18nDevTools(i18n2, version2, meta) {
      devtools && devtools.emit("i18n:init", {
        timestamp: Date.now(),
        i18n: i18n2,
        version: version2,
        meta
      });
    }
    const translateDevTools = /* @__PURE__ */ createDevToolsHook(
      "function:translate"
      /* IntlifyDevToolsHooks.FunctionTranslate */
    );
    function createDevToolsHook(hook2) {
      return (payloads) => devtools && devtools.emit(hook2, payloads);
    }
    const code$1$1 = CompileWarnCodes.__EXTEND_POINT__;
    const inc$1$1 = incrementer(code$1$1);
    const CoreWarnCodes = {
      NOT_FOUND_KEY: code$1$1,
      // 2
      FALLBACK_TO_TRANSLATE: inc$1$1(),
      // 3
      CANNOT_FORMAT_NUMBER: inc$1$1(),
      // 4
      FALLBACK_TO_NUMBER_FORMAT: inc$1$1(),
      // 5
      CANNOT_FORMAT_DATE: inc$1$1(),
      // 6
      FALLBACK_TO_DATE_FORMAT: inc$1$1(),
      // 7
      EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: inc$1$1(),
      // 8
      __EXTEND_POINT__: inc$1$1()
      // 9
    };
    const warnMessages$2 = {
      [CoreWarnCodes.NOT_FOUND_KEY]: `Not found '{key}' key in '{locale}' locale messages.`,
      [CoreWarnCodes.FALLBACK_TO_TRANSLATE]: `Fall back to translate '{key}' key with '{target}' locale.`,
      [CoreWarnCodes.CANNOT_FORMAT_NUMBER]: `Cannot format a number value due to not supported Intl.NumberFormat.`,
      [CoreWarnCodes.FALLBACK_TO_NUMBER_FORMAT]: `Fall back to number format '{key}' key with '{target}' locale.`,
      [CoreWarnCodes.CANNOT_FORMAT_DATE]: `Cannot format a date value due to not supported Intl.DateTimeFormat.`,
      [CoreWarnCodes.FALLBACK_TO_DATE_FORMAT]: `Fall back to datetime format '{key}' key with '{target}' locale.`,
      [CoreWarnCodes.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER]: `This project is using Custom Message Compiler, which is an experimental feature. It may receive breaking changes or be removed in the future.`
    };
    function getWarnMessage$1(code2, ...args) {
      return format$1(warnMessages$2[code2], ...args);
    }
    const code$3 = CompileErrorCodes.__EXTEND_POINT__;
    const inc$2 = incrementer(code$3);
    const CoreErrorCodes = {
      INVALID_ARGUMENT: code$3,
      // 17
      INVALID_DATE_ARGUMENT: inc$2(),
      // 18
      INVALID_ISO_DATE_ARGUMENT: inc$2(),
      // 19
      NOT_SUPPORT_NON_STRING_MESSAGE: inc$2(),
      // 20
      NOT_SUPPORT_LOCALE_PROMISE_VALUE: inc$2(),
      // 21
      NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: inc$2(),
      // 22
      NOT_SUPPORT_LOCALE_TYPE: inc$2(),
      // 23
      __EXTEND_POINT__: inc$2()
      // 24
    };
    function createCoreError(code2) {
      return createCompileError(code2, null, { messages: errorMessages$2 });
    }
    const errorMessages$2 = {
      [CoreErrorCodes.INVALID_ARGUMENT]: "Invalid arguments",
      [CoreErrorCodes.INVALID_DATE_ARGUMENT]: "The date provided is an invalid Date object.Make sure your Date represents a valid date.",
      [CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT]: "The argument provided is not a valid ISO date string",
      [CoreErrorCodes.NOT_SUPPORT_NON_STRING_MESSAGE]: "Not support non-string message",
      [CoreErrorCodes.NOT_SUPPORT_LOCALE_PROMISE_VALUE]: "cannot support promise value",
      [CoreErrorCodes.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION]: "cannot support async function",
      [CoreErrorCodes.NOT_SUPPORT_LOCALE_TYPE]: "cannot support locale type"
    };
    function getLocale(context, options) {
      return options.locale != null ? resolveLocale$2(options.locale) : resolveLocale$2(context.locale);
    }
    let _resolveLocale;
    function resolveLocale$2(locale) {
      if (isString(locale)) {
        return locale;
      } else {
        if (isFunction$1(locale)) {
          if (locale.resolvedOnce && _resolveLocale != null) {
            return _resolveLocale;
          } else if (locale.constructor.name === "Function") {
            const resolve2 = locale();
            if (isPromise(resolve2)) {
              throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
            }
            return _resolveLocale = resolve2;
          } else {
            throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
          }
        } else {
          throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_TYPE);
        }
      }
    }
    function fallbackWithSimple(ctx, fallback, start2) {
      return [.../* @__PURE__ */ new Set([
        start2,
        ...isArray$2(fallback) ? fallback : isObject$4(fallback) ? Object.keys(fallback) : isString(fallback) ? [fallback] : [start2]
      ])];
    }
    function fallbackWithLocaleChain(ctx, fallback, start2) {
      const startLocale = isString(start2) ? start2 : DEFAULT_LOCALE;
      const context = ctx;
      if (!context.__localeChainCache) {
        context.__localeChainCache = /* @__PURE__ */ new Map();
      }
      let chain = context.__localeChainCache.get(startLocale);
      if (!chain) {
        chain = [];
        let block = [start2];
        while (isArray$2(block)) {
          block = appendBlockToChain(chain, block, fallback);
        }
        const defaults2 = isArray$2(fallback) || !isPlainObject$2(fallback) ? fallback : fallback["default"] ? fallback["default"] : null;
        block = isString(defaults2) ? [defaults2] : defaults2;
        if (isArray$2(block)) {
          appendBlockToChain(chain, block, false);
        }
        context.__localeChainCache.set(startLocale, chain);
      }
      return chain;
    }
    function appendBlockToChain(chain, block, blocks) {
      let follow = true;
      for (let i2 = 0; i2 < block.length && isBoolean(follow); i2++) {
        const locale = block[i2];
        if (isString(locale)) {
          follow = appendLocaleToChain(chain, block[i2], blocks);
        }
      }
      return follow;
    }
    function appendLocaleToChain(chain, locale, blocks) {
      let follow;
      const tokens = locale.split("-");
      do {
        const target = tokens.join("-");
        follow = appendItemToChain(chain, target, blocks);
        tokens.splice(-1, 1);
      } while (tokens.length && follow === true);
      return follow;
    }
    function appendItemToChain(chain, target, blocks) {
      let follow = false;
      if (!chain.includes(target)) {
        follow = true;
        if (target) {
          follow = target[target.length - 1] !== "!";
          const locale = target.replace(/!/g, "");
          chain.push(locale);
          if ((isArray$2(blocks) || isPlainObject$2(blocks)) && blocks[locale]) {
            follow = blocks[locale];
          }
        }
      }
      return follow;
    }
    const VERSION$1 = "9.13.1";
    const NOT_REOSLVED = -1;
    const DEFAULT_LOCALE = "en-US";
    const MISSING_RESOLVE_VALUE = "";
    const capitalize = (str) => `${str.charAt(0).toLocaleUpperCase()}${str.substr(1)}`;
    function getDefaultLinkedModifiers() {
      return {
        upper: (val, type) => {
          return type === "text" && isString(val) ? val.toUpperCase() : type === "vnode" && isObject$4(val) && "__v_isVNode" in val ? val.children.toUpperCase() : val;
        },
        lower: (val, type) => {
          return type === "text" && isString(val) ? val.toLowerCase() : type === "vnode" && isObject$4(val) && "__v_isVNode" in val ? val.children.toLowerCase() : val;
        },
        capitalize: (val, type) => {
          return type === "text" && isString(val) ? capitalize(val) : type === "vnode" && isObject$4(val) && "__v_isVNode" in val ? capitalize(val.children) : val;
        }
      };
    }
    let _compiler;
    function registerMessageCompiler(compiler) {
      _compiler = compiler;
    }
    let _resolver;
    function registerMessageResolver(resolver) {
      _resolver = resolver;
    }
    let _fallbacker;
    function registerLocaleFallbacker(fallbacker) {
      _fallbacker = fallbacker;
    }
    let _additionalMeta = null;
    const setAdditionalMeta = /* @__NO_SIDE_EFFECTS__ */ (meta) => {
      _additionalMeta = meta;
    };
    const getAdditionalMeta = /* @__NO_SIDE_EFFECTS__ */ () => _additionalMeta;
    let _fallbackContext = null;
    const setFallbackContext = (context) => {
      _fallbackContext = context;
    };
    const getFallbackContext = () => _fallbackContext;
    let _cid = 0;
    function createCoreContext(options = {}) {
      const onWarn = isFunction$1(options.onWarn) ? options.onWarn : warn;
      const version2 = isString(options.version) ? options.version : VERSION$1;
      const locale = isString(options.locale) || isFunction$1(options.locale) ? options.locale : DEFAULT_LOCALE;
      const _locale = isFunction$1(locale) ? DEFAULT_LOCALE : locale;
      const fallbackLocale = isArray$2(options.fallbackLocale) || isPlainObject$2(options.fallbackLocale) || isString(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale;
      const messages = isPlainObject$2(options.messages) ? options.messages : { [_locale]: {} };
      const datetimeFormats = isPlainObject$2(options.datetimeFormats) ? options.datetimeFormats : { [_locale]: {} };
      const numberFormats = isPlainObject$2(options.numberFormats) ? options.numberFormats : { [_locale]: {} };
      const modifiers = assign$1({}, options.modifiers || {}, getDefaultLinkedModifiers());
      const pluralRules = options.pluralRules || {};
      const missing = isFunction$1(options.missing) ? options.missing : null;
      const missingWarn = isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
      const fallbackWarn = isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
      const fallbackFormat = !!options.fallbackFormat;
      const unresolving = !!options.unresolving;
      const postTranslation = isFunction$1(options.postTranslation) ? options.postTranslation : null;
      const processor = isPlainObject$2(options.processor) ? options.processor : null;
      const warnHtmlMessage = isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
      const escapeParameter = !!options.escapeParameter;
      const messageCompiler = isFunction$1(options.messageCompiler) ? options.messageCompiler : _compiler;
      if (isFunction$1(options.messageCompiler)) {
        warnOnce(getWarnMessage$1(CoreWarnCodes.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER));
      }
      const messageResolver = isFunction$1(options.messageResolver) ? options.messageResolver : _resolver || resolveWithKeyValue;
      const localeFallbacker = isFunction$1(options.localeFallbacker) ? options.localeFallbacker : _fallbacker || fallbackWithSimple;
      const fallbackContext = isObject$4(options.fallbackContext) ? options.fallbackContext : void 0;
      const internalOptions = options;
      const __datetimeFormatters = isObject$4(internalOptions.__datetimeFormatters) ? internalOptions.__datetimeFormatters : /* @__PURE__ */ new Map();
      const __numberFormatters = isObject$4(internalOptions.__numberFormatters) ? internalOptions.__numberFormatters : /* @__PURE__ */ new Map();
      const __meta = isObject$4(internalOptions.__meta) ? internalOptions.__meta : {};
      _cid++;
      const context = {
        version: version2,
        cid: _cid,
        locale,
        fallbackLocale,
        messages,
        modifiers,
        pluralRules,
        missing,
        missingWarn,
        fallbackWarn,
        fallbackFormat,
        unresolving,
        postTranslation,
        processor,
        warnHtmlMessage,
        escapeParameter,
        messageCompiler,
        messageResolver,
        localeFallbacker,
        fallbackContext,
        onWarn,
        __meta
      };
      {
        context.datetimeFormats = datetimeFormats;
        context.numberFormats = numberFormats;
        context.__datetimeFormatters = __datetimeFormatters;
        context.__numberFormatters = __numberFormatters;
      }
      {
        context.__v_emitter = internalOptions.__v_emitter != null ? internalOptions.__v_emitter : void 0;
      }
      {
        initI18nDevTools(context, version2, __meta);
      }
      return context;
    }
    function isTranslateFallbackWarn(fallback, key2) {
      return fallback instanceof RegExp ? fallback.test(key2) : fallback;
    }
    function isTranslateMissingWarn(missing, key2) {
      return missing instanceof RegExp ? missing.test(key2) : missing;
    }
    function handleMissing(context, key2, locale, missingWarn, type) {
      const { missing, onWarn } = context;
      {
        const emitter = context.__v_emitter;
        if (emitter) {
          emitter.emit("missing", {
            locale,
            key: key2,
            type,
            groupId: `${type}:${key2}`
          });
        }
      }
      if (missing !== null) {
        const ret = missing(context, locale, key2, type);
        return isString(ret) ? ret : key2;
      } else {
        if (isTranslateMissingWarn(missingWarn, key2)) {
          onWarn(getWarnMessage$1(CoreWarnCodes.NOT_FOUND_KEY, { key: key2, locale }));
        }
        return key2;
      }
    }
    function updateFallbackLocale(ctx, locale, fallback) {
      const context = ctx;
      context.__localeChainCache = /* @__PURE__ */ new Map();
      ctx.localeFallbacker(ctx, fallback, locale);
    }
    function isAlmostSameLocale(locale, compareLocale) {
      if (locale === compareLocale)
        return false;
      return locale.split("-")[0] === compareLocale.split("-")[0];
    }
    function isImplicitFallback(targetLocale, locales) {
      const index2 = locales.indexOf(targetLocale);
      if (index2 === -1) {
        return false;
      }
      for (let i2 = index2 + 1; i2 < locales.length; i2++) {
        if (isAlmostSameLocale(targetLocale, locales[i2])) {
          return true;
        }
      }
      return false;
    }
    function format(ast) {
      const msg = (ctx) => formatParts(ctx, ast);
      return msg;
    }
    function formatParts(ctx, ast) {
      const body = ast.b || ast.body;
      if ((body.t || body.type) === 1) {
        const plural = body;
        const cases = plural.c || plural.cases;
        return ctx.plural(cases.reduce((messages, c2) => [
          ...messages,
          formatMessageParts(ctx, c2)
        ], []));
      } else {
        return formatMessageParts(ctx, body);
      }
    }
    function formatMessageParts(ctx, node) {
      const _static = node.s || node.static;
      if (_static) {
        return ctx.type === "text" ? _static : ctx.normalize([_static]);
      } else {
        const messages = (node.i || node.items).reduce((acm, c2) => [...acm, formatMessagePart(ctx, c2)], []);
        return ctx.normalize(messages);
      }
    }
    function formatMessagePart(ctx, node) {
      const type = node.t || node.type;
      switch (type) {
        case 3: {
          const text = node;
          return text.v || text.value;
        }
        case 9: {
          const literal = node;
          return literal.v || literal.value;
        }
        case 4: {
          const named = node;
          return ctx.interpolate(ctx.named(named.k || named.key));
        }
        case 5: {
          const list = node;
          return ctx.interpolate(ctx.list(list.i != null ? list.i : list.index));
        }
        case 6: {
          const linked = node;
          const modifier = linked.m || linked.modifier;
          return ctx.linked(formatMessagePart(ctx, linked.k || linked.key), modifier ? formatMessagePart(ctx, modifier) : void 0, ctx.type);
        }
        case 7: {
          const linkedKey = node;
          return linkedKey.v || linkedKey.value;
        }
        case 8: {
          const linkedModifier = node;
          return linkedModifier.v || linkedModifier.value;
        }
        default:
          throw new Error(`unhandled node type on format message part: ${type}`);
      }
    }
    const WARN_MESSAGE = `Detected HTML in '{source}' message. Recommend not using HTML messages to avoid XSS.`;
    function checkHtmlMessage(source, warnHtmlMessage) {
      if (warnHtmlMessage && detectHtmlTag(source)) {
        warn(format$1(WARN_MESSAGE, { source }));
      }
    }
    const defaultOnCacheKey = (message) => message;
    let compileCache = /* @__PURE__ */ Object.create(null);
    function onCompileWarn(_warn) {
      if (_warn.code === CompileWarnCodes.USE_MODULO_SYNTAX) {
        warn(`The use of named interpolation with modulo syntax is deprecated. It will be removed in v10.
reference: https://vue-i18n.intlify.dev/guide/essentials/syntax#rails-i18n-format 
(message compiler warning message: ${_warn.message})`);
      }
    }
    function clearCompileCache() {
      compileCache = /* @__PURE__ */ Object.create(null);
    }
    const isMessageAST = (val) => isObject$4(val) && (val.t === 0 || val.type === 0) && ("b" in val || "body" in val);
    function baseCompile(message, options = {}) {
      let detectError = false;
      const onError = options.onError || defaultOnError;
      options.onError = (err) => {
        detectError = true;
        onError(err);
      };
      return { ...baseCompile$1(message, options), detectError };
    }
    const compileToFunction = /* @__NO_SIDE_EFFECTS__ */ (message, context) => {
      if (!isString(message)) {
        throw createCoreError(CoreErrorCodes.NOT_SUPPORT_NON_STRING_MESSAGE);
      }
      {
        context.onWarn = onCompileWarn;
      }
      {
        const warnHtmlMessage = isBoolean(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
        checkHtmlMessage(message, warnHtmlMessage);
        const onCacheKey = context.onCacheKey || defaultOnCacheKey;
        const cacheKey = onCacheKey(message);
        const cached = compileCache[cacheKey];
        if (cached) {
          return cached;
        }
        const { code: code2, detectError } = baseCompile(message, context);
        const msg = new Function(`return ${code2}`)();
        return !detectError ? compileCache[cacheKey] = msg : msg;
      }
    };
    function compile$1(message, context) {
      {
        context.onWarn = onCompileWarn;
      }
      if (isString(message)) {
        const warnHtmlMessage = isBoolean(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
        checkHtmlMessage(message, warnHtmlMessage);
        const onCacheKey = context.onCacheKey || defaultOnCacheKey;
        const cacheKey = onCacheKey(message);
        const cached = compileCache[cacheKey];
        if (cached) {
          return cached;
        }
        const { ast, detectError } = baseCompile(message, {
          ...context,
          location: true,
          jit: true
        });
        const msg = format(ast);
        return !detectError ? compileCache[cacheKey] = msg : msg;
      } else {
        if (!isMessageAST(message)) {
          warn(`the message that is resolve with key '${context.key}' is not supported for jit compilation`);
          return () => message;
        }
        const cacheKey = message.cacheKey;
        if (cacheKey) {
          const cached = compileCache[cacheKey];
          if (cached) {
            return cached;
          }
          return compileCache[cacheKey] = format(message);
        } else {
          return format(message);
        }
      }
    }
    const NOOP_MESSAGE_FUNCTION = () => "";
    const isMessageFunction = (val) => isFunction$1(val);
    function translate(context, ...args) {
      const { fallbackFormat, postTranslation, unresolving, messageCompiler, fallbackLocale, messages } = context;
      const [key2, options] = parseTranslateArgs(...args);
      const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
      const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
      const escapeParameter = isBoolean(options.escapeParameter) ? options.escapeParameter : context.escapeParameter;
      const resolvedMessage = !!options.resolvedMessage;
      const defaultMsgOrKey = isString(options.default) || isBoolean(options.default) ? !isBoolean(options.default) ? options.default : !messageCompiler ? () => key2 : key2 : fallbackFormat ? !messageCompiler ? () => key2 : key2 : "";
      const enableDefaultMsg = fallbackFormat || defaultMsgOrKey !== "";
      const locale = getLocale(context, options);
      escapeParameter && escapeParams(options);
      let [formatScope, targetLocale, message] = !resolvedMessage ? resolveMessageFormat(context, key2, locale, fallbackLocale, fallbackWarn, missingWarn) : [
        key2,
        locale,
        messages[locale] || {}
      ];
      let format2 = formatScope;
      let cacheBaseKey = key2;
      if (!resolvedMessage && !(isString(format2) || isMessageAST(format2) || isMessageFunction(format2))) {
        if (enableDefaultMsg) {
          format2 = defaultMsgOrKey;
          cacheBaseKey = format2;
        }
      }
      if (!resolvedMessage && (!(isString(format2) || isMessageAST(format2) || isMessageFunction(format2)) || !isString(targetLocale))) {
        return unresolving ? NOT_REOSLVED : key2;
      }
      if (isString(format2) && context.messageCompiler == null) {
        warn(`The message format compilation is not supported in this build. Because message compiler isn't included. You need to pre-compilation all message format. So translate function return '${key2}'.`);
        return key2;
      }
      let occurred = false;
      const onError = () => {
        occurred = true;
      };
      const msg = !isMessageFunction(format2) ? compileMessageFormat(context, key2, targetLocale, format2, cacheBaseKey, onError) : format2;
      if (occurred) {
        return format2;
      }
      const ctxOptions = getMessageContextOptions(context, targetLocale, message, options);
      const msgContext = createMessageContext(ctxOptions);
      const messaged = evaluateMessage(context, msg, msgContext);
      const ret = postTranslation ? postTranslation(messaged, key2) : messaged;
      {
        const payloads = {
          timestamp: Date.now(),
          key: isString(key2) ? key2 : isMessageFunction(format2) ? format2.key : "",
          locale: targetLocale || (isMessageFunction(format2) ? format2.locale : ""),
          format: isString(format2) ? format2 : isMessageFunction(format2) ? format2.source : "",
          message: ret
        };
        payloads.meta = assign$1({}, context.__meta, /* @__PURE__ */ getAdditionalMeta() || {});
        translateDevTools(payloads);
      }
      return ret;
    }
    function escapeParams(options) {
      if (isArray$2(options.list)) {
        options.list = options.list.map((item) => isString(item) ? escapeHtml(item) : item);
      } else if (isObject$4(options.named)) {
        Object.keys(options.named).forEach((key2) => {
          if (isString(options.named[key2])) {
            options.named[key2] = escapeHtml(options.named[key2]);
          }
        });
      }
    }
    function resolveMessageFormat(context, key2, locale, fallbackLocale, fallbackWarn, missingWarn) {
      const { messages, onWarn, messageResolver: resolveValue2, localeFallbacker } = context;
      const locales = localeFallbacker(context, fallbackLocale, locale);
      let message = {};
      let targetLocale;
      let format2 = null;
      let from = locale;
      let to2 = null;
      const type = "translate";
      for (let i2 = 0; i2 < locales.length; i2++) {
        targetLocale = to2 = locales[i2];
        if (locale !== targetLocale && !isAlmostSameLocale(locale, targetLocale) && isTranslateFallbackWarn(fallbackWarn, key2)) {
          onWarn(getWarnMessage$1(CoreWarnCodes.FALLBACK_TO_TRANSLATE, {
            key: key2,
            target: targetLocale
          }));
        }
        if (locale !== targetLocale) {
          const emitter = context.__v_emitter;
          if (emitter) {
            emitter.emit("fallback", {
              type,
              key: key2,
              from,
              to: to2,
              groupId: `${type}:${key2}`
            });
          }
        }
        message = messages[targetLocale] || {};
        let start2 = null;
        let startTag;
        let endTag;
        if (inBrowser) {
          start2 = window.performance.now();
          startTag = "intlify-message-resolve-start";
          endTag = "intlify-message-resolve-end";
          mark && mark(startTag);
        }
        if ((format2 = resolveValue2(message, key2)) === null) {
          format2 = message[key2];
        }
        if (inBrowser) {
          const end2 = window.performance.now();
          const emitter = context.__v_emitter;
          if (emitter && start2 && format2) {
            emitter.emit("message-resolve", {
              type: "message-resolve",
              key: key2,
              message: format2,
              time: end2 - start2,
              groupId: `${type}:${key2}`
            });
          }
          if (startTag && endTag && mark && measure) {
            mark(endTag);
            measure("intlify message resolve", startTag, endTag);
          }
        }
        if (isString(format2) || isMessageAST(format2) || isMessageFunction(format2)) {
          break;
        }
        if (!isImplicitFallback(targetLocale, locales)) {
          const missingRet = handleMissing(
            context,
            // eslint-disable-line @typescript-eslint/no-explicit-any
            key2,
            targetLocale,
            missingWarn,
            type
          );
          if (missingRet !== key2) {
            format2 = missingRet;
          }
        }
        from = to2;
      }
      return [format2, targetLocale, message];
    }
    function compileMessageFormat(context, key2, targetLocale, format2, cacheBaseKey, onError) {
      const { messageCompiler, warnHtmlMessage } = context;
      if (isMessageFunction(format2)) {
        const msg2 = format2;
        msg2.locale = msg2.locale || targetLocale;
        msg2.key = msg2.key || key2;
        return msg2;
      }
      if (messageCompiler == null) {
        const msg2 = () => format2;
        msg2.locale = targetLocale;
        msg2.key = key2;
        return msg2;
      }
      let start2 = null;
      let startTag;
      let endTag;
      if (inBrowser) {
        start2 = window.performance.now();
        startTag = "intlify-message-compilation-start";
        endTag = "intlify-message-compilation-end";
        mark && mark(startTag);
      }
      const msg = messageCompiler(format2, getCompileContext(context, targetLocale, cacheBaseKey, format2, warnHtmlMessage, onError));
      if (inBrowser) {
        const end2 = window.performance.now();
        const emitter = context.__v_emitter;
        if (emitter && start2) {
          emitter.emit("message-compilation", {
            type: "message-compilation",
            message: format2,
            time: end2 - start2,
            groupId: `${"translate"}:${key2}`
          });
        }
        if (startTag && endTag && mark && measure) {
          mark(endTag);
          measure("intlify message compilation", startTag, endTag);
        }
      }
      msg.locale = targetLocale;
      msg.key = key2;
      msg.source = format2;
      return msg;
    }
    function evaluateMessage(context, msg, msgCtx) {
      let start2 = null;
      let startTag;
      let endTag;
      if (inBrowser) {
        start2 = window.performance.now();
        startTag = "intlify-message-evaluation-start";
        endTag = "intlify-message-evaluation-end";
        mark && mark(startTag);
      }
      const messaged = msg(msgCtx);
      if (inBrowser) {
        const end2 = window.performance.now();
        const emitter = context.__v_emitter;
        if (emitter && start2) {
          emitter.emit("message-evaluation", {
            type: "message-evaluation",
            value: messaged,
            time: end2 - start2,
            groupId: `${"translate"}:${msg.key}`
          });
        }
        if (startTag && endTag && mark && measure) {
          mark(endTag);
          measure("intlify message evaluation", startTag, endTag);
        }
      }
      return messaged;
    }
    function parseTranslateArgs(...args) {
      const [arg1, arg2, arg3] = args;
      const options = {};
      if (!isString(arg1) && !isNumber(arg1) && !isMessageFunction(arg1) && !isMessageAST(arg1)) {
        throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
      }
      const key2 = isNumber(arg1) ? String(arg1) : isMessageFunction(arg1) ? arg1 : arg1;
      if (isNumber(arg2)) {
        options.plural = arg2;
      } else if (isString(arg2)) {
        options.default = arg2;
      } else if (isPlainObject$2(arg2) && !isEmptyObject(arg2)) {
        options.named = arg2;
      } else if (isArray$2(arg2)) {
        options.list = arg2;
      }
      if (isNumber(arg3)) {
        options.plural = arg3;
      } else if (isString(arg3)) {
        options.default = arg3;
      } else if (isPlainObject$2(arg3)) {
        assign$1(options, arg3);
      }
      return [key2, options];
    }
    function getCompileContext(context, locale, key2, source, warnHtmlMessage, onError) {
      return {
        locale,
        key: key2,
        warnHtmlMessage,
        onError: (err) => {
          onError && onError(err);
          {
            const _source = getSourceForCodeFrame(source);
            const message = `Message compilation error: ${err.message}`;
            const codeFrame = err.location && _source && generateCodeFrame(_source, err.location.start.offset, err.location.end.offset);
            const emitter = context.__v_emitter;
            if (emitter && _source) {
              emitter.emit("compile-error", {
                message: _source,
                error: err.message,
                start: err.location && err.location.start.offset,
                end: err.location && err.location.end.offset,
                groupId: `${"translate"}:${key2}`
              });
            }
            console.error(codeFrame ? `${message}
${codeFrame}` : message);
          }
        },
        onCacheKey: (source2) => generateFormatCacheKey(locale, key2, source2)
      };
    }
    function getSourceForCodeFrame(source) {
      if (isString(source)) {
        return source;
      } else {
        if (source.loc && source.loc.source) {
          return source.loc.source;
        }
      }
    }
    function getMessageContextOptions(context, locale, message, options) {
      const { modifiers, pluralRules, messageResolver: resolveValue2, fallbackLocale, fallbackWarn, missingWarn, fallbackContext } = context;
      const resolveMessage = (key2) => {
        let val = resolveValue2(message, key2);
        if (val == null && fallbackContext) {
          const [, , message2] = resolveMessageFormat(fallbackContext, key2, locale, fallbackLocale, fallbackWarn, missingWarn);
          val = resolveValue2(message2, key2);
        }
        if (isString(val) || isMessageAST(val)) {
          let occurred = false;
          const onError = () => {
            occurred = true;
          };
          const msg = compileMessageFormat(context, key2, locale, val, key2, onError);
          return !occurred ? msg : NOOP_MESSAGE_FUNCTION;
        } else if (isMessageFunction(val)) {
          return val;
        } else {
          return NOOP_MESSAGE_FUNCTION;
        }
      };
      const ctxOptions = {
        locale,
        modifiers,
        pluralRules,
        messages: resolveMessage
      };
      if (context.processor) {
        ctxOptions.processor = context.processor;
      }
      if (options.list) {
        ctxOptions.list = options.list;
      }
      if (options.named) {
        ctxOptions.named = options.named;
      }
      if (isNumber(options.plural)) {
        ctxOptions.pluralIndex = options.plural;
      }
      return ctxOptions;
    }
    const intlDefined = typeof Intl !== "undefined";
    const Availabilities = {
      dateTimeFormat: intlDefined && typeof Intl.DateTimeFormat !== "undefined",
      numberFormat: intlDefined && typeof Intl.NumberFormat !== "undefined"
    };
    function datetime(context, ...args) {
      const { datetimeFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
      const { __datetimeFormatters } = context;
      if (!Availabilities.dateTimeFormat) {
        onWarn(getWarnMessage$1(CoreWarnCodes.CANNOT_FORMAT_DATE));
        return MISSING_RESOLVE_VALUE;
      }
      const [key2, value, options, overrides] = parseDateTimeArgs(...args);
      const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
      const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
      const part = !!options.part;
      const locale = getLocale(context, options);
      const locales = localeFallbacker(
        context,
        // eslint-disable-line @typescript-eslint/no-explicit-any
        fallbackLocale,
        locale
      );
      if (!isString(key2) || key2 === "") {
        return new Intl.DateTimeFormat(locale, overrides).format(value);
      }
      let datetimeFormat = {};
      let targetLocale;
      let format2 = null;
      let from = locale;
      let to2 = null;
      const type = "datetime format";
      for (let i2 = 0; i2 < locales.length; i2++) {
        targetLocale = to2 = locales[i2];
        if (locale !== targetLocale && isTranslateFallbackWarn(fallbackWarn, key2)) {
          onWarn(getWarnMessage$1(CoreWarnCodes.FALLBACK_TO_DATE_FORMAT, {
            key: key2,
            target: targetLocale
          }));
        }
        if (locale !== targetLocale) {
          const emitter = context.__v_emitter;
          if (emitter) {
            emitter.emit("fallback", {
              type,
              key: key2,
              from,
              to: to2,
              groupId: `${type}:${key2}`
            });
          }
        }
        datetimeFormat = datetimeFormats[targetLocale] || {};
        format2 = datetimeFormat[key2];
        if (isPlainObject$2(format2))
          break;
        handleMissing(context, key2, targetLocale, missingWarn, type);
        from = to2;
      }
      if (!isPlainObject$2(format2) || !isString(targetLocale)) {
        return unresolving ? NOT_REOSLVED : key2;
      }
      let id2 = `${targetLocale}__${key2}`;
      if (!isEmptyObject(overrides)) {
        id2 = `${id2}__${JSON.stringify(overrides)}`;
      }
      let formatter = __datetimeFormatters.get(id2);
      if (!formatter) {
        formatter = new Intl.DateTimeFormat(targetLocale, assign$1({}, format2, overrides));
        __datetimeFormatters.set(id2, formatter);
      }
      return !part ? formatter.format(value) : formatter.formatToParts(value);
    }
    const DATETIME_FORMAT_OPTIONS_KEYS = [
      "localeMatcher",
      "weekday",
      "era",
      "year",
      "month",
      "day",
      "hour",
      "minute",
      "second",
      "timeZoneName",
      "formatMatcher",
      "hour12",
      "timeZone",
      "dateStyle",
      "timeStyle",
      "calendar",
      "dayPeriod",
      "numberingSystem",
      "hourCycle",
      "fractionalSecondDigits"
    ];
    function parseDateTimeArgs(...args) {
      const [arg1, arg2, arg3, arg4] = args;
      const options = {};
      let overrides = {};
      let value;
      if (isString(arg1)) {
        const matches2 = arg1.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
        if (!matches2) {
          throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
        }
        const dateTime = matches2[3] ? matches2[3].trim().startsWith("T") ? `${matches2[1].trim()}${matches2[3].trim()}` : `${matches2[1].trim()}T${matches2[3].trim()}` : matches2[1].trim();
        value = new Date(dateTime);
        try {
          value.toISOString();
        } catch (e2) {
          throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
        }
      } else if (isDate(arg1)) {
        if (isNaN(arg1.getTime())) {
          throw createCoreError(CoreErrorCodes.INVALID_DATE_ARGUMENT);
        }
        value = arg1;
      } else if (isNumber(arg1)) {
        value = arg1;
      } else {
        throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
      }
      if (isString(arg2)) {
        options.key = arg2;
      } else if (isPlainObject$2(arg2)) {
        Object.keys(arg2).forEach((key2) => {
          if (DATETIME_FORMAT_OPTIONS_KEYS.includes(key2)) {
            overrides[key2] = arg2[key2];
          } else {
            options[key2] = arg2[key2];
          }
        });
      }
      if (isString(arg3)) {
        options.locale = arg3;
      } else if (isPlainObject$2(arg3)) {
        overrides = arg3;
      }
      if (isPlainObject$2(arg4)) {
        overrides = arg4;
      }
      return [options.key || "", value, options, overrides];
    }
    function clearDateTimeFormat(ctx, locale, format2) {
      const context = ctx;
      for (const key2 in format2) {
        const id2 = `${locale}__${key2}`;
        if (!context.__datetimeFormatters.has(id2)) {
          continue;
        }
        context.__datetimeFormatters.delete(id2);
      }
    }
    function number(context, ...args) {
      const { numberFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
      const { __numberFormatters } = context;
      if (!Availabilities.numberFormat) {
        onWarn(getWarnMessage$1(CoreWarnCodes.CANNOT_FORMAT_NUMBER));
        return MISSING_RESOLVE_VALUE;
      }
      const [key2, value, options, overrides] = parseNumberArgs(...args);
      const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
      const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
      const part = !!options.part;
      const locale = getLocale(context, options);
      const locales = localeFallbacker(
        context,
        // eslint-disable-line @typescript-eslint/no-explicit-any
        fallbackLocale,
        locale
      );
      if (!isString(key2) || key2 === "") {
        return new Intl.NumberFormat(locale, overrides).format(value);
      }
      let numberFormat = {};
      let targetLocale;
      let format2 = null;
      let from = locale;
      let to2 = null;
      const type = "number format";
      for (let i2 = 0; i2 < locales.length; i2++) {
        targetLocale = to2 = locales[i2];
        if (locale !== targetLocale && isTranslateFallbackWarn(fallbackWarn, key2)) {
          onWarn(getWarnMessage$1(CoreWarnCodes.FALLBACK_TO_NUMBER_FORMAT, {
            key: key2,
            target: targetLocale
          }));
        }
        if (locale !== targetLocale) {
          const emitter = context.__v_emitter;
          if (emitter) {
            emitter.emit("fallback", {
              type,
              key: key2,
              from,
              to: to2,
              groupId: `${type}:${key2}`
            });
          }
        }
        numberFormat = numberFormats[targetLocale] || {};
        format2 = numberFormat[key2];
        if (isPlainObject$2(format2))
          break;
        handleMissing(context, key2, targetLocale, missingWarn, type);
        from = to2;
      }
      if (!isPlainObject$2(format2) || !isString(targetLocale)) {
        return unresolving ? NOT_REOSLVED : key2;
      }
      let id2 = `${targetLocale}__${key2}`;
      if (!isEmptyObject(overrides)) {
        id2 = `${id2}__${JSON.stringify(overrides)}`;
      }
      let formatter = __numberFormatters.get(id2);
      if (!formatter) {
        formatter = new Intl.NumberFormat(targetLocale, assign$1({}, format2, overrides));
        __numberFormatters.set(id2, formatter);
      }
      return !part ? formatter.format(value) : formatter.formatToParts(value);
    }
    const NUMBER_FORMAT_OPTIONS_KEYS = [
      "localeMatcher",
      "style",
      "currency",
      "currencyDisplay",
      "currencySign",
      "useGrouping",
      "minimumIntegerDigits",
      "minimumFractionDigits",
      "maximumFractionDigits",
      "minimumSignificantDigits",
      "maximumSignificantDigits",
      "compactDisplay",
      "notation",
      "signDisplay",
      "unit",
      "unitDisplay",
      "roundingMode",
      "roundingPriority",
      "roundingIncrement",
      "trailingZeroDisplay"
    ];
    function parseNumberArgs(...args) {
      const [arg1, arg2, arg3, arg4] = args;
      const options = {};
      let overrides = {};
      if (!isNumber(arg1)) {
        throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
      }
      const value = arg1;
      if (isString(arg2)) {
        options.key = arg2;
      } else if (isPlainObject$2(arg2)) {
        Object.keys(arg2).forEach((key2) => {
          if (NUMBER_FORMAT_OPTIONS_KEYS.includes(key2)) {
            overrides[key2] = arg2[key2];
          } else {
            options[key2] = arg2[key2];
          }
        });
      }
      if (isString(arg3)) {
        options.locale = arg3;
      } else if (isPlainObject$2(arg3)) {
        overrides = arg3;
      }
      if (isPlainObject$2(arg4)) {
        overrides = arg4;
      }
      return [options.key || "", value, options, overrides];
    }
    function clearNumberFormat(ctx, locale, format2) {
      const context = ctx;
      for (const key2 in format2) {
        const id2 = `${locale}__${key2}`;
        if (!context.__numberFormatters.has(id2)) {
          continue;
        }
        context.__numberFormatters.delete(id2);
      }
    }
    const coreBase_esmBrowser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      CompileErrorCodes,
      CoreErrorCodes,
      CoreWarnCodes,
      DATETIME_FORMAT_OPTIONS_KEYS,
      DEFAULT_LOCALE,
      DEFAULT_MESSAGE_DATA_TYPE,
      MISSING_RESOLVE_VALUE,
      NOT_REOSLVED,
      NUMBER_FORMAT_OPTIONS_KEYS,
      VERSION: VERSION$1,
      clearCompileCache,
      clearDateTimeFormat,
      clearNumberFormat,
      compile: compile$1,
      compileToFunction,
      createCompileError,
      createCoreContext,
      createCoreError,
      createMessageContext,
      datetime,
      fallbackWithLocaleChain,
      fallbackWithSimple,
      getAdditionalMeta,
      getDevToolsHook,
      getFallbackContext,
      getLocale,
      getWarnMessage: getWarnMessage$1,
      handleMissing,
      initI18nDevTools,
      isAlmostSameLocale,
      isImplicitFallback,
      isMessageAST,
      isMessageFunction,
      isTranslateFallbackWarn,
      isTranslateMissingWarn,
      number,
      parse: parse$3,
      parseDateTimeArgs,
      parseNumberArgs,
      parseTranslateArgs,
      registerLocaleFallbacker,
      registerMessageCompiler,
      registerMessageResolver,
      resolveLocale: resolveLocale$2,
      resolveValue,
      resolveWithKeyValue,
      setAdditionalMeta,
      setDevToolsHook,
      setFallbackContext,
      translate,
      translateDevTools,
      updateFallbackLocale
    }, Symbol.toStringTag, { value: "Module" }));
    const require$$1$1 = /* @__PURE__ */ getAugmentedNamespace(coreBase_esmBrowser);
    const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(vue_runtime_esmBundler);
    /*!
      * vue-i18n v9.13.1
      * (c) 2024 kazuya kawaguchi
      * Released under the MIT License.
      */
    var shared = require$$0$2;
    var coreBase = require$$1$1;
    var vue = require$$0$1;
    const VERSION = "9.13.1";
    const code$1 = coreBase.CoreWarnCodes.__EXTEND_POINT__;
    const inc$1 = shared.incrementer(code$1);
    const I18nWarnCodes = {
      FALLBACK_TO_ROOT: code$1,
      // 9
      NOT_SUPPORTED_PRESERVE: inc$1(),
      // 10
      NOT_SUPPORTED_FORMATTER: inc$1(),
      // 11
      NOT_SUPPORTED_PRESERVE_DIRECTIVE: inc$1(),
      // 12
      NOT_SUPPORTED_GET_CHOICE_INDEX: inc$1(),
      // 13
      COMPONENT_NAME_LEGACY_COMPATIBLE: inc$1(),
      // 14
      NOT_FOUND_PARENT_SCOPE: inc$1(),
      // 15
      IGNORE_OBJ_FLATTEN: inc$1(),
      // 16
      NOTICE_DROP_ALLOW_COMPOSITION: inc$1(),
      // 17
      NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG: inc$1()
      // 18
    };
    const warnMessages = {
      [I18nWarnCodes.FALLBACK_TO_ROOT]: `Fall back to {type} '{key}' with root locale.`,
      [I18nWarnCodes.NOT_SUPPORTED_PRESERVE]: `Not supported 'preserve'.`,
      [I18nWarnCodes.NOT_SUPPORTED_FORMATTER]: `Not supported 'formatter'.`,
      [I18nWarnCodes.NOT_SUPPORTED_PRESERVE_DIRECTIVE]: `Not supported 'preserveDirectiveContent'.`,
      [I18nWarnCodes.NOT_SUPPORTED_GET_CHOICE_INDEX]: `Not supported 'getChoiceIndex'.`,
      [I18nWarnCodes.COMPONENT_NAME_LEGACY_COMPATIBLE]: `Component name legacy compatible: '{name}' -> 'i18n'`,
      [I18nWarnCodes.NOT_FOUND_PARENT_SCOPE]: `Not found parent scope. use the global scope.`,
      [I18nWarnCodes.IGNORE_OBJ_FLATTEN]: `Ignore object flatten: '{key}' key has an string value`,
      [I18nWarnCodes.NOTICE_DROP_ALLOW_COMPOSITION]: `'allowComposition' option will be dropped in the next major version. For more information, please see 👉 https://tinyurl.com/2p97mcze`,
      [I18nWarnCodes.NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG]: `'translateExistCompatible' option will be dropped in the next major version.`
    };
    function getWarnMessage(code2, ...args) {
      return shared.format(warnMessages[code2], ...args);
    }
    const code$2 = coreBase.CoreErrorCodes.__EXTEND_POINT__;
    const inc = shared.incrementer(code$2);
    const I18nErrorCodes = {
      // composer module errors
      UNEXPECTED_RETURN_TYPE: code$2,
      // 24
      // legacy module errors
      INVALID_ARGUMENT: inc(),
      // 25
      // i18n module errors
      MUST_BE_CALL_SETUP_TOP: inc(),
      // 26
      NOT_INSTALLED: inc(),
      // 27
      NOT_AVAILABLE_IN_LEGACY_MODE: inc(),
      // 28
      // directive module errors
      REQUIRED_VALUE: inc(),
      // 29
      INVALID_VALUE: inc(),
      // 30
      // vue-devtools errors
      CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: inc(),
      // 31
      NOT_INSTALLED_WITH_PROVIDE: inc(),
      // 32
      // unexpected error
      UNEXPECTED_ERROR: inc(),
      // 33
      // not compatible legacy vue-i18n constructor
      NOT_COMPATIBLE_LEGACY_VUE_I18N: inc(),
      // 34
      // bridge support vue 2.x only
      BRIDGE_SUPPORT_VUE_2_ONLY: inc(),
      // 35
      // need to define `i18n` option in `allowComposition: true` and `useScope: 'local' at `useI18n``
      MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: inc(),
      // 36
      // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
      NOT_AVAILABLE_COMPOSITION_IN_LEGACY: inc(),
      // 37
      // for enhancement
      __EXTEND_POINT__: inc()
      // 38
    };
    function createI18nError(code2, ...args) {
      return coreBase.createCompileError(code2, null, { messages: errorMessages, args });
    }
    const errorMessages = {
      [I18nErrorCodes.UNEXPECTED_RETURN_TYPE]: "Unexpected return type in composer",
      [I18nErrorCodes.INVALID_ARGUMENT]: "Invalid argument",
      [I18nErrorCodes.MUST_BE_CALL_SETUP_TOP]: "Must be called at the top of a `setup` function",
      [I18nErrorCodes.NOT_INSTALLED]: "Need to install with `app.use` function",
      [I18nErrorCodes.UNEXPECTED_ERROR]: "Unexpected error",
      [I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE]: "Not available in legacy mode",
      [I18nErrorCodes.REQUIRED_VALUE]: `Required in value: {0}`,
      [I18nErrorCodes.INVALID_VALUE]: `Invalid value`,
      [I18nErrorCodes.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN]: `Cannot setup vue-devtools plugin`,
      [I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE]: "Need to install with `provide` function",
      [I18nErrorCodes.NOT_COMPATIBLE_LEGACY_VUE_I18N]: "Not compatible legacy VueI18n.",
      [I18nErrorCodes.BRIDGE_SUPPORT_VUE_2_ONLY]: "vue-i18n-bridge support Vue 2.x only",
      [I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION]: "Must define ‘i18n’ option or custom block in Composition API with using local scope in Legacy API mode",
      [I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY]: "Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly"
    };
    const TranslateVNodeSymbol = /* @__PURE__ */ shared.makeSymbol("__translateVNode");
    const DatetimePartsSymbol = /* @__PURE__ */ shared.makeSymbol("__datetimeParts");
    const NumberPartsSymbol = /* @__PURE__ */ shared.makeSymbol("__numberParts");
    const EnableEmitter = /* @__PURE__ */ shared.makeSymbol("__enableEmitter");
    const DisableEmitter = /* @__PURE__ */ shared.makeSymbol("__disableEmitter");
    const SetPluralRulesSymbol = shared.makeSymbol("__setPluralRules");
    shared.makeSymbol("__intlifyMeta");
    const InejctWithOptionSymbol = /* @__PURE__ */ shared.makeSymbol("__injectWithOption");
    const DisposeSymbol = /* @__PURE__ */ shared.makeSymbol("__dispose");
    const __VUE_I18N_BRIDGE__ = "__VUE_I18N_BRIDGE__";
    function handleFlatJson(obj) {
      if (!shared.isObject(obj)) {
        return obj;
      }
      for (const key2 in obj) {
        if (!shared.hasOwn(obj, key2)) {
          continue;
        }
        if (!key2.includes(".")) {
          if (shared.isObject(obj[key2])) {
            handleFlatJson(obj[key2]);
          }
        } else {
          const subKeys = key2.split(".");
          const lastIndex = subKeys.length - 1;
          let currentObj = obj;
          let hasStringValue = false;
          for (let i2 = 0; i2 < lastIndex; i2++) {
            if (!(subKeys[i2] in currentObj)) {
              currentObj[subKeys[i2]] = {};
            }
            if (!shared.isObject(currentObj[subKeys[i2]])) {
              shared.warn(getWarnMessage(I18nWarnCodes.IGNORE_OBJ_FLATTEN, {
                key: subKeys[i2]
              }));
              hasStringValue = true;
              break;
            }
            currentObj = currentObj[subKeys[i2]];
          }
          if (!hasStringValue) {
            currentObj[subKeys[lastIndex]] = obj[key2];
            delete obj[key2];
          }
          if (shared.isObject(currentObj[subKeys[lastIndex]])) {
            handleFlatJson(currentObj[subKeys[lastIndex]]);
          }
        }
      }
      return obj;
    }
    function getLocaleMessages(locale, options) {
      const { messages, __i18n, messageResolver, flatJson } = options;
      const ret = shared.isPlainObject(messages) ? messages : shared.isArray(__i18n) ? {} : { [locale]: {} };
      if (shared.isArray(__i18n)) {
        __i18n.forEach((custom) => {
          if ("locale" in custom && "resource" in custom) {
            const { locale: locale2, resource } = custom;
            if (locale2) {
              ret[locale2] = ret[locale2] || {};
              shared.deepCopy(resource, ret[locale2]);
            } else {
              shared.deepCopy(resource, ret);
            }
          } else {
            shared.isString(custom) && shared.deepCopy(JSON.parse(custom), ret);
          }
        });
      }
      if (messageResolver == null && flatJson) {
        for (const key2 in ret) {
          if (shared.hasOwn(ret, key2)) {
            handleFlatJson(ret[key2]);
          }
        }
      }
      return ret;
    }
    function getComponentOptions(instance) {
      return instance.type;
    }
    function adjustI18nResources(gl, options, componentOptions) {
      let messages = shared.isObject(options.messages) ? options.messages : {};
      if ("__i18nGlobal" in componentOptions) {
        messages = getLocaleMessages(gl.locale.value, {
          messages,
          __i18n: componentOptions.__i18nGlobal
        });
      }
      const locales = Object.keys(messages);
      if (locales.length) {
        locales.forEach((locale) => {
          gl.mergeLocaleMessage(locale, messages[locale]);
        });
      }
      {
        if (shared.isObject(options.datetimeFormats)) {
          const locales2 = Object.keys(options.datetimeFormats);
          if (locales2.length) {
            locales2.forEach((locale) => {
              gl.mergeDateTimeFormat(locale, options.datetimeFormats[locale]);
            });
          }
        }
        if (shared.isObject(options.numberFormats)) {
          const locales2 = Object.keys(options.numberFormats);
          if (locales2.length) {
            locales2.forEach((locale) => {
              gl.mergeNumberFormat(locale, options.numberFormats[locale]);
            });
          }
        }
      }
    }
    function createTextNode(key2) {
      return vue.createVNode(vue.Text, null, key2, 0);
    }
    const DEVTOOLS_META = "__INTLIFY_META__";
    const NOOP_RETURN_ARRAY = () => [];
    const NOOP_RETURN_FALSE = () => false;
    let composerID = 0;
    function defineCoreMissingHandler(missing) {
      return (ctx, locale, key2, type) => {
        return missing(locale, key2, vue.getCurrentInstance() || void 0, type);
      };
    }
    const getMetaInfo = /* @__NO_SIDE_EFFECTS__ */ () => {
      const instance = vue.getCurrentInstance();
      let meta = null;
      return instance && (meta = getComponentOptions(instance)[DEVTOOLS_META]) ? { [DEVTOOLS_META]: meta } : null;
    };
    function createComposer(options = {}, VueI18nLegacy) {
      const { __root, __injectWithOption } = options;
      const _isGlobal = __root === void 0;
      const flatJson = options.flatJson;
      const _ref = shared.inBrowser ? vue.ref : vue.shallowRef;
      const translateExistCompatible = !!options.translateExistCompatible;
      {
        if (translateExistCompatible && true) {
          shared.warnOnce(getWarnMessage(I18nWarnCodes.NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG));
        }
      }
      let _inheritLocale = shared.isBoolean(options.inheritLocale) ? options.inheritLocale : true;
      const _locale = _ref(
        // prettier-ignore
        __root && _inheritLocale ? __root.locale.value : shared.isString(options.locale) ? options.locale : coreBase.DEFAULT_LOCALE
      );
      const _fallbackLocale = _ref(
        // prettier-ignore
        __root && _inheritLocale ? __root.fallbackLocale.value : shared.isString(options.fallbackLocale) || shared.isArray(options.fallbackLocale) || shared.isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value
      );
      const _messages = _ref(getLocaleMessages(_locale.value, options));
      const _datetimeFormats = _ref(shared.isPlainObject(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
      const _numberFormats = _ref(shared.isPlainObject(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
      let _missingWarn = __root ? __root.missingWarn : shared.isBoolean(options.missingWarn) || shared.isRegExp(options.missingWarn) ? options.missingWarn : true;
      let _fallbackWarn = __root ? __root.fallbackWarn : shared.isBoolean(options.fallbackWarn) || shared.isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
      let _fallbackRoot = __root ? __root.fallbackRoot : shared.isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
      let _fallbackFormat = !!options.fallbackFormat;
      let _missing = shared.isFunction(options.missing) ? options.missing : null;
      let _runtimeMissing = shared.isFunction(options.missing) ? defineCoreMissingHandler(options.missing) : null;
      let _postTranslation = shared.isFunction(options.postTranslation) ? options.postTranslation : null;
      let _warnHtmlMessage = __root ? __root.warnHtmlMessage : shared.isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
      let _escapeParameter = !!options.escapeParameter;
      const _modifiers = __root ? __root.modifiers : shared.isPlainObject(options.modifiers) ? options.modifiers : {};
      let _pluralRules = options.pluralRules || __root && __root.pluralRules;
      let _context;
      const getCoreContext = () => {
        _isGlobal && coreBase.setFallbackContext(null);
        const ctxOptions = {
          version: VERSION,
          locale: _locale.value,
          fallbackLocale: _fallbackLocale.value,
          messages: _messages.value,
          modifiers: _modifiers,
          pluralRules: _pluralRules,
          missing: _runtimeMissing === null ? void 0 : _runtimeMissing,
          missingWarn: _missingWarn,
          fallbackWarn: _fallbackWarn,
          fallbackFormat: _fallbackFormat,
          unresolving: true,
          postTranslation: _postTranslation === null ? void 0 : _postTranslation,
          warnHtmlMessage: _warnHtmlMessage,
          escapeParameter: _escapeParameter,
          messageResolver: options.messageResolver,
          messageCompiler: options.messageCompiler,
          __meta: { framework: "vue" }
        };
        {
          ctxOptions.datetimeFormats = _datetimeFormats.value;
          ctxOptions.numberFormats = _numberFormats.value;
          ctxOptions.__datetimeFormatters = shared.isPlainObject(_context) ? _context.__datetimeFormatters : void 0;
          ctxOptions.__numberFormatters = shared.isPlainObject(_context) ? _context.__numberFormatters : void 0;
        }
        {
          ctxOptions.__v_emitter = shared.isPlainObject(_context) ? _context.__v_emitter : void 0;
        }
        const ctx = coreBase.createCoreContext(ctxOptions);
        _isGlobal && coreBase.setFallbackContext(ctx);
        return ctx;
      };
      _context = getCoreContext();
      coreBase.updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      function trackReactivityValues() {
        return [
          _locale.value,
          _fallbackLocale.value,
          _messages.value,
          _datetimeFormats.value,
          _numberFormats.value
        ];
      }
      const locale = vue.computed({
        get: () => _locale.value,
        set: (val) => {
          _locale.value = val;
          _context.locale = _locale.value;
        }
      });
      const fallbackLocale = vue.computed({
        get: () => _fallbackLocale.value,
        set: (val) => {
          _fallbackLocale.value = val;
          _context.fallbackLocale = _fallbackLocale.value;
          coreBase.updateFallbackLocale(_context, _locale.value, val);
        }
      });
      const messages = vue.computed(() => _messages.value);
      const datetimeFormats = /* @__PURE__ */ vue.computed(() => _datetimeFormats.value);
      const numberFormats = /* @__PURE__ */ vue.computed(() => _numberFormats.value);
      function getPostTranslationHandler() {
        return shared.isFunction(_postTranslation) ? _postTranslation : null;
      }
      function setPostTranslationHandler(handler) {
        _postTranslation = handler;
        _context.postTranslation = handler;
      }
      function getMissingHandler() {
        return _missing;
      }
      function setMissingHandler(handler) {
        if (handler !== null) {
          _runtimeMissing = defineCoreMissingHandler(handler);
        }
        _missing = handler;
        _context.missing = _runtimeMissing;
      }
      function isResolvedTranslateMessage(type, arg) {
        return type !== "translate" || !arg.resolvedMessage;
      }
      const wrapWithDeps = (fn2, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) => {
        trackReactivityValues();
        let ret;
        try {
          if (true) {
            coreBase.setAdditionalMeta(/* @__PURE__ */ getMetaInfo());
          }
          if (!_isGlobal) {
            _context.fallbackContext = __root ? coreBase.getFallbackContext() : void 0;
          }
          ret = fn2(_context);
        } finally {
          {
            coreBase.setAdditionalMeta(null);
          }
          if (!_isGlobal) {
            _context.fallbackContext = void 0;
          }
        }
        if (warnType !== "translate exists" && // for not `te` (e.g `t`)
        shared.isNumber(ret) && ret === coreBase.NOT_REOSLVED || warnType === "translate exists" && !ret) {
          const [key2, arg2] = argumentParser();
          if (__root && shared.isString(key2) && isResolvedTranslateMessage(warnType, arg2)) {
            if (_fallbackRoot && (coreBase.isTranslateFallbackWarn(_fallbackWarn, key2) || coreBase.isTranslateMissingWarn(_missingWarn, key2))) {
              shared.warn(getWarnMessage(I18nWarnCodes.FALLBACK_TO_ROOT, {
                key: key2,
                type: warnType
              }));
            }
            {
              const { __v_emitter: emitter } = _context;
              if (emitter && _fallbackRoot) {
                emitter.emit("fallback", {
                  type: warnType,
                  key: key2,
                  to: "global",
                  groupId: `${warnType}:${key2}`
                });
              }
            }
          }
          return __root && _fallbackRoot ? fallbackSuccess(__root) : fallbackFail(key2);
        } else if (successCondition(ret)) {
          return ret;
        } else {
          throw createI18nError(I18nErrorCodes.UNEXPECTED_RETURN_TYPE);
        }
      };
      function t2(...args) {
        return wrapWithDeps((context) => Reflect.apply(coreBase.translate, null, [context, ...args]), () => coreBase.parseTranslateArgs(...args), "translate", (root2) => Reflect.apply(root2.t, root2, [...args]), (key2) => key2, (val) => shared.isString(val));
      }
      function rt2(...args) {
        const [arg1, arg2, arg3] = args;
        if (arg3 && !shared.isObject(arg3)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }
        return t2(...[arg1, arg2, shared.assign({ resolvedMessage: true }, arg3 || {})]);
      }
      function d2(...args) {
        return wrapWithDeps((context) => Reflect.apply(coreBase.datetime, null, [context, ...args]), () => coreBase.parseDateTimeArgs(...args), "datetime format", (root2) => Reflect.apply(root2.d, root2, [...args]), () => coreBase.MISSING_RESOLVE_VALUE, (val) => shared.isString(val));
      }
      function n2(...args) {
        return wrapWithDeps((context) => Reflect.apply(coreBase.number, null, [context, ...args]), () => coreBase.parseNumberArgs(...args), "number format", (root2) => Reflect.apply(root2.n, root2, [...args]), () => coreBase.MISSING_RESOLVE_VALUE, (val) => shared.isString(val));
      }
      function normalize(values) {
        return values.map((val) => shared.isString(val) || shared.isNumber(val) || shared.isBoolean(val) ? createTextNode(String(val)) : val);
      }
      const interpolate = (val) => val;
      const processor = {
        normalize,
        interpolate,
        type: "vnode"
      };
      function translateVNode(...args) {
        return wrapWithDeps(
          (context) => {
            let ret;
            const _context2 = context;
            try {
              _context2.processor = processor;
              ret = Reflect.apply(coreBase.translate, null, [_context2, ...args]);
            } finally {
              _context2.processor = null;
            }
            return ret;
          },
          () => coreBase.parseTranslateArgs(...args),
          "translate",
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          (root2) => root2[TranslateVNodeSymbol](...args),
          (key2) => [createTextNode(key2)],
          (val) => shared.isArray(val)
        );
      }
      function numberParts(...args) {
        return wrapWithDeps(
          (context) => Reflect.apply(coreBase.number, null, [context, ...args]),
          () => coreBase.parseNumberArgs(...args),
          "number format",
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          (root2) => root2[NumberPartsSymbol](...args),
          NOOP_RETURN_ARRAY,
          (val) => shared.isString(val) || shared.isArray(val)
        );
      }
      function datetimeParts(...args) {
        return wrapWithDeps(
          (context) => Reflect.apply(coreBase.datetime, null, [context, ...args]),
          () => coreBase.parseDateTimeArgs(...args),
          "datetime format",
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          (root2) => root2[DatetimePartsSymbol](...args),
          NOOP_RETURN_ARRAY,
          (val) => shared.isString(val) || shared.isArray(val)
        );
      }
      function setPluralRules(rules) {
        _pluralRules = rules;
        _context.pluralRules = _pluralRules;
      }
      function te2(key2, locale2) {
        return wrapWithDeps(() => {
          if (!key2) {
            return false;
          }
          const targetLocale = shared.isString(locale2) ? locale2 : _locale.value;
          const message = getLocaleMessage(targetLocale);
          const resolved = _context.messageResolver(message, key2);
          return !translateExistCompatible ? coreBase.isMessageAST(resolved) || coreBase.isMessageFunction(resolved) || shared.isString(resolved) : resolved != null;
        }, () => [key2], "translate exists", (root2) => {
          return Reflect.apply(root2.te, root2, [key2, locale2]);
        }, NOOP_RETURN_FALSE, (val) => shared.isBoolean(val));
      }
      function resolveMessages(key2) {
        let messages2 = null;
        const locales = coreBase.fallbackWithLocaleChain(_context, _fallbackLocale.value, _locale.value);
        for (let i2 = 0; i2 < locales.length; i2++) {
          const targetLocaleMessages = _messages.value[locales[i2]] || {};
          const messageValue = _context.messageResolver(targetLocaleMessages, key2);
          if (messageValue != null) {
            messages2 = messageValue;
            break;
          }
        }
        return messages2;
      }
      function tm2(key2) {
        const messages2 = resolveMessages(key2);
        return messages2 != null ? messages2 : __root ? __root.tm(key2) || {} : {};
      }
      function getLocaleMessage(locale2) {
        return _messages.value[locale2] || {};
      }
      function setLocaleMessage(locale2, message) {
        if (flatJson) {
          const _message = { [locale2]: message };
          for (const key2 in _message) {
            if (shared.hasOwn(_message, key2)) {
              handleFlatJson(_message[key2]);
            }
          }
          message = _message[locale2];
        }
        _messages.value[locale2] = message;
        _context.messages = _messages.value;
      }
      function mergeLocaleMessage(locale2, message) {
        _messages.value[locale2] = _messages.value[locale2] || {};
        const _message = { [locale2]: message };
        if (flatJson) {
          for (const key2 in _message) {
            if (shared.hasOwn(_message, key2)) {
              handleFlatJson(_message[key2]);
            }
          }
        }
        message = _message[locale2];
        shared.deepCopy(message, _messages.value[locale2]);
        _context.messages = _messages.value;
      }
      function getDateTimeFormat(locale2) {
        return _datetimeFormats.value[locale2] || {};
      }
      function setDateTimeFormat(locale2, format2) {
        _datetimeFormats.value[locale2] = format2;
        _context.datetimeFormats = _datetimeFormats.value;
        coreBase.clearDateTimeFormat(_context, locale2, format2);
      }
      function mergeDateTimeFormat(locale2, format2) {
        _datetimeFormats.value[locale2] = shared.assign(_datetimeFormats.value[locale2] || {}, format2);
        _context.datetimeFormats = _datetimeFormats.value;
        coreBase.clearDateTimeFormat(_context, locale2, format2);
      }
      function getNumberFormat(locale2) {
        return _numberFormats.value[locale2] || {};
      }
      function setNumberFormat(locale2, format2) {
        _numberFormats.value[locale2] = format2;
        _context.numberFormats = _numberFormats.value;
        coreBase.clearNumberFormat(_context, locale2, format2);
      }
      function mergeNumberFormat(locale2, format2) {
        _numberFormats.value[locale2] = shared.assign(_numberFormats.value[locale2] || {}, format2);
        _context.numberFormats = _numberFormats.value;
        coreBase.clearNumberFormat(_context, locale2, format2);
      }
      composerID++;
      if (__root && shared.inBrowser) {
        vue.watch(__root.locale, (val) => {
          if (_inheritLocale) {
            _locale.value = val;
            _context.locale = val;
            coreBase.updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
          }
        });
        vue.watch(__root.fallbackLocale, (val) => {
          if (_inheritLocale) {
            _fallbackLocale.value = val;
            _context.fallbackLocale = val;
            coreBase.updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
          }
        });
      }
      const composer = {
        id: composerID,
        locale,
        fallbackLocale,
        get inheritLocale() {
          return _inheritLocale;
        },
        set inheritLocale(val) {
          _inheritLocale = val;
          if (val && __root) {
            _locale.value = __root.locale.value;
            _fallbackLocale.value = __root.fallbackLocale.value;
            coreBase.updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
          }
        },
        get availableLocales() {
          return Object.keys(_messages.value).sort();
        },
        messages,
        get modifiers() {
          return _modifiers;
        },
        get pluralRules() {
          return _pluralRules || {};
        },
        get isGlobal() {
          return _isGlobal;
        },
        get missingWarn() {
          return _missingWarn;
        },
        set missingWarn(val) {
          _missingWarn = val;
          _context.missingWarn = _missingWarn;
        },
        get fallbackWarn() {
          return _fallbackWarn;
        },
        set fallbackWarn(val) {
          _fallbackWarn = val;
          _context.fallbackWarn = _fallbackWarn;
        },
        get fallbackRoot() {
          return _fallbackRoot;
        },
        set fallbackRoot(val) {
          _fallbackRoot = val;
        },
        get fallbackFormat() {
          return _fallbackFormat;
        },
        set fallbackFormat(val) {
          _fallbackFormat = val;
          _context.fallbackFormat = _fallbackFormat;
        },
        get warnHtmlMessage() {
          return _warnHtmlMessage;
        },
        set warnHtmlMessage(val) {
          _warnHtmlMessage = val;
          _context.warnHtmlMessage = val;
        },
        get escapeParameter() {
          return _escapeParameter;
        },
        set escapeParameter(val) {
          _escapeParameter = val;
          _context.escapeParameter = val;
        },
        t: t2,
        getLocaleMessage,
        setLocaleMessage,
        mergeLocaleMessage,
        getPostTranslationHandler,
        setPostTranslationHandler,
        getMissingHandler,
        setMissingHandler,
        [SetPluralRulesSymbol]: setPluralRules
      };
      {
        composer.datetimeFormats = datetimeFormats;
        composer.numberFormats = numberFormats;
        composer.rt = rt2;
        composer.te = te2;
        composer.tm = tm2;
        composer.d = d2;
        composer.n = n2;
        composer.getDateTimeFormat = getDateTimeFormat;
        composer.setDateTimeFormat = setDateTimeFormat;
        composer.mergeDateTimeFormat = mergeDateTimeFormat;
        composer.getNumberFormat = getNumberFormat;
        composer.setNumberFormat = setNumberFormat;
        composer.mergeNumberFormat = mergeNumberFormat;
        composer[InejctWithOptionSymbol] = __injectWithOption;
        composer[TranslateVNodeSymbol] = translateVNode;
        composer[DatetimePartsSymbol] = datetimeParts;
        composer[NumberPartsSymbol] = numberParts;
      }
      {
        composer[EnableEmitter] = (emitter) => {
          _context.__v_emitter = emitter;
        };
        composer[DisableEmitter] = () => {
          _context.__v_emitter = void 0;
        };
      }
      return composer;
    }
    function convertComposerOptions(options) {
      const locale = shared.isString(options.locale) ? options.locale : coreBase.DEFAULT_LOCALE;
      const fallbackLocale = shared.isString(options.fallbackLocale) || shared.isArray(options.fallbackLocale) || shared.isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : locale;
      const missing = shared.isFunction(options.missing) ? options.missing : void 0;
      const missingWarn = shared.isBoolean(options.silentTranslationWarn) || shared.isRegExp(options.silentTranslationWarn) ? !options.silentTranslationWarn : true;
      const fallbackWarn = shared.isBoolean(options.silentFallbackWarn) || shared.isRegExp(options.silentFallbackWarn) ? !options.silentFallbackWarn : true;
      const fallbackRoot = shared.isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
      const fallbackFormat = !!options.formatFallbackMessages;
      const modifiers = shared.isPlainObject(options.modifiers) ? options.modifiers : {};
      const pluralizationRules = options.pluralizationRules;
      const postTranslation = shared.isFunction(options.postTranslation) ? options.postTranslation : void 0;
      const warnHtmlMessage = shared.isString(options.warnHtmlInMessage) ? options.warnHtmlInMessage !== "off" : true;
      const escapeParameter = !!options.escapeParameterHtml;
      const inheritLocale = shared.isBoolean(options.sync) ? options.sync : true;
      if (options.formatter) {
        shared.warn(getWarnMessage(I18nWarnCodes.NOT_SUPPORTED_FORMATTER));
      }
      if (options.preserveDirectiveContent) {
        shared.warn(getWarnMessage(I18nWarnCodes.NOT_SUPPORTED_PRESERVE_DIRECTIVE));
      }
      let messages = options.messages;
      if (shared.isPlainObject(options.sharedMessages)) {
        const sharedMessages = options.sharedMessages;
        const locales = Object.keys(sharedMessages);
        messages = locales.reduce((messages2, locale2) => {
          const message = messages2[locale2] || (messages2[locale2] = {});
          shared.assign(message, sharedMessages[locale2]);
          return messages2;
        }, messages || {});
      }
      const { __i18n, __root, __injectWithOption } = options;
      const datetimeFormats = options.datetimeFormats;
      const numberFormats = options.numberFormats;
      const flatJson = options.flatJson;
      const translateExistCompatible = options.translateExistCompatible;
      return {
        locale,
        fallbackLocale,
        messages,
        flatJson,
        datetimeFormats,
        numberFormats,
        missing,
        missingWarn,
        fallbackWarn,
        fallbackRoot,
        fallbackFormat,
        modifiers,
        pluralRules: pluralizationRules,
        postTranslation,
        warnHtmlMessage,
        escapeParameter,
        messageResolver: options.messageResolver,
        inheritLocale,
        translateExistCompatible,
        __i18n,
        __root,
        __injectWithOption
      };
    }
    function createVueI18n(options = {}, VueI18nLegacy) {
      {
        const composer = createComposer(convertComposerOptions(options));
        const { __extender } = options;
        const vueI18n2 = {
          // id
          id: composer.id,
          // locale
          get locale() {
            return composer.locale.value;
          },
          set locale(val) {
            composer.locale.value = val;
          },
          // fallbackLocale
          get fallbackLocale() {
            return composer.fallbackLocale.value;
          },
          set fallbackLocale(val) {
            composer.fallbackLocale.value = val;
          },
          // messages
          get messages() {
            return composer.messages.value;
          },
          // datetimeFormats
          get datetimeFormats() {
            return composer.datetimeFormats.value;
          },
          // numberFormats
          get numberFormats() {
            return composer.numberFormats.value;
          },
          // availableLocales
          get availableLocales() {
            return composer.availableLocales;
          },
          // formatter
          get formatter() {
            shared.warn(getWarnMessage(I18nWarnCodes.NOT_SUPPORTED_FORMATTER));
            return {
              interpolate() {
                return [];
              }
            };
          },
          set formatter(val) {
            shared.warn(getWarnMessage(I18nWarnCodes.NOT_SUPPORTED_FORMATTER));
          },
          // missing
          get missing() {
            return composer.getMissingHandler();
          },
          set missing(handler) {
            composer.setMissingHandler(handler);
          },
          // silentTranslationWarn
          get silentTranslationWarn() {
            return shared.isBoolean(composer.missingWarn) ? !composer.missingWarn : composer.missingWarn;
          },
          set silentTranslationWarn(val) {
            composer.missingWarn = shared.isBoolean(val) ? !val : val;
          },
          // silentFallbackWarn
          get silentFallbackWarn() {
            return shared.isBoolean(composer.fallbackWarn) ? !composer.fallbackWarn : composer.fallbackWarn;
          },
          set silentFallbackWarn(val) {
            composer.fallbackWarn = shared.isBoolean(val) ? !val : val;
          },
          // modifiers
          get modifiers() {
            return composer.modifiers;
          },
          // formatFallbackMessages
          get formatFallbackMessages() {
            return composer.fallbackFormat;
          },
          set formatFallbackMessages(val) {
            composer.fallbackFormat = val;
          },
          // postTranslation
          get postTranslation() {
            return composer.getPostTranslationHandler();
          },
          set postTranslation(handler) {
            composer.setPostTranslationHandler(handler);
          },
          // sync
          get sync() {
            return composer.inheritLocale;
          },
          set sync(val) {
            composer.inheritLocale = val;
          },
          // warnInHtmlMessage
          get warnHtmlInMessage() {
            return composer.warnHtmlMessage ? "warn" : "off";
          },
          set warnHtmlInMessage(val) {
            composer.warnHtmlMessage = val !== "off";
          },
          // escapeParameterHtml
          get escapeParameterHtml() {
            return composer.escapeParameter;
          },
          set escapeParameterHtml(val) {
            composer.escapeParameter = val;
          },
          // preserveDirectiveContent
          get preserveDirectiveContent() {
            shared.warn(getWarnMessage(I18nWarnCodes.NOT_SUPPORTED_PRESERVE_DIRECTIVE));
            return true;
          },
          set preserveDirectiveContent(val) {
            shared.warn(getWarnMessage(I18nWarnCodes.NOT_SUPPORTED_PRESERVE_DIRECTIVE));
          },
          // pluralizationRules
          get pluralizationRules() {
            return composer.pluralRules || {};
          },
          // for internal
          __composer: composer,
          // t
          t(...args) {
            const [arg1, arg2, arg3] = args;
            const options2 = {};
            let list = null;
            let named = null;
            if (!shared.isString(arg1)) {
              throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
            }
            const key2 = arg1;
            if (shared.isString(arg2)) {
              options2.locale = arg2;
            } else if (shared.isArray(arg2)) {
              list = arg2;
            } else if (shared.isPlainObject(arg2)) {
              named = arg2;
            }
            if (shared.isArray(arg3)) {
              list = arg3;
            } else if (shared.isPlainObject(arg3)) {
              named = arg3;
            }
            return Reflect.apply(composer.t, composer, [
              key2,
              list || named || {},
              options2
            ]);
          },
          rt(...args) {
            return Reflect.apply(composer.rt, composer, [...args]);
          },
          // tc
          tc(...args) {
            const [arg1, arg2, arg3] = args;
            const options2 = { plural: 1 };
            let list = null;
            let named = null;
            if (!shared.isString(arg1)) {
              throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
            }
            const key2 = arg1;
            if (shared.isString(arg2)) {
              options2.locale = arg2;
            } else if (shared.isNumber(arg2)) {
              options2.plural = arg2;
            } else if (shared.isArray(arg2)) {
              list = arg2;
            } else if (shared.isPlainObject(arg2)) {
              named = arg2;
            }
            if (shared.isString(arg3)) {
              options2.locale = arg3;
            } else if (shared.isArray(arg3)) {
              list = arg3;
            } else if (shared.isPlainObject(arg3)) {
              named = arg3;
            }
            return Reflect.apply(composer.t, composer, [
              key2,
              list || named || {},
              options2
            ]);
          },
          // te
          te(key2, locale) {
            return composer.te(key2, locale);
          },
          // tm
          tm(key2) {
            return composer.tm(key2);
          },
          // getLocaleMessage
          getLocaleMessage(locale) {
            return composer.getLocaleMessage(locale);
          },
          // setLocaleMessage
          setLocaleMessage(locale, message) {
            composer.setLocaleMessage(locale, message);
          },
          // mergeLocaleMessage
          mergeLocaleMessage(locale, message) {
            composer.mergeLocaleMessage(locale, message);
          },
          // d
          d(...args) {
            return Reflect.apply(composer.d, composer, [...args]);
          },
          // getDateTimeFormat
          getDateTimeFormat(locale) {
            return composer.getDateTimeFormat(locale);
          },
          // setDateTimeFormat
          setDateTimeFormat(locale, format2) {
            composer.setDateTimeFormat(locale, format2);
          },
          // mergeDateTimeFormat
          mergeDateTimeFormat(locale, format2) {
            composer.mergeDateTimeFormat(locale, format2);
          },
          // n
          n(...args) {
            return Reflect.apply(composer.n, composer, [...args]);
          },
          // getNumberFormat
          getNumberFormat(locale) {
            return composer.getNumberFormat(locale);
          },
          // setNumberFormat
          setNumberFormat(locale, format2) {
            composer.setNumberFormat(locale, format2);
          },
          // mergeNumberFormat
          mergeNumberFormat(locale, format2) {
            composer.mergeNumberFormat(locale, format2);
          },
          // getChoiceIndex
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          getChoiceIndex(choice, choicesLength) {
            shared.warn(getWarnMessage(I18nWarnCodes.NOT_SUPPORTED_GET_CHOICE_INDEX));
            return -1;
          }
        };
        vueI18n2.__extender = __extender;
        {
          vueI18n2.__enableEmitter = (emitter) => {
            const __composer = composer;
            __composer[EnableEmitter] && __composer[EnableEmitter](emitter);
          };
          vueI18n2.__disableEmitter = () => {
            const __composer = composer;
            __composer[DisableEmitter] && __composer[DisableEmitter]();
          };
        }
        return vueI18n2;
      }
    }
    const baseFormatProps = {
      tag: {
        type: [String, Object]
      },
      locale: {
        type: String
      },
      scope: {
        type: String,
        // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
        validator: (val) => val === "parent" || val === "global",
        default: "parent"
        /* ComponentI18nScope */
      },
      i18n: {
        type: Object
      }
    };
    function getInterpolateArg({ slots }, keys) {
      if (keys.length === 1 && keys[0] === "default") {
        const ret = slots.default ? slots.default() : [];
        return ret.reduce((slot, current) => {
          return [
            ...slot,
            // prettier-ignore
            ...current.type === vue.Fragment ? current.children : [current]
          ];
        }, []);
      } else {
        return keys.reduce((arg, key2) => {
          const slot = slots[key2];
          if (slot) {
            arg[key2] = slot();
          }
          return arg;
        }, {});
      }
    }
    function getFragmentableTag(tag) {
      return vue.Fragment;
    }
    const TranslationImpl = /* @__PURE__ */ vue.defineComponent({
      /* eslint-disable */
      name: "i18n-t",
      props: shared.assign({
        keypath: {
          type: String,
          required: true
        },
        plural: {
          type: [Number, String],
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          validator: (val) => shared.isNumber(val) || !isNaN(val)
        }
      }, baseFormatProps),
      /* eslint-enable */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      setup(props, context) {
        const { slots, attrs } = context;
        const i18n2 = props.i18n || useI18n({
          useScope: props.scope,
          __useComponent: true
        });
        return () => {
          const keys = Object.keys(slots).filter((key2) => key2 !== "_");
          const options = {};
          if (props.locale) {
            options.locale = props.locale;
          }
          if (props.plural !== void 0) {
            options.plural = shared.isString(props.plural) ? +props.plural : props.plural;
          }
          const arg = getInterpolateArg(context, keys);
          const children = i18n2[TranslateVNodeSymbol](props.keypath, arg, options);
          const assignedAttrs = shared.assign({}, attrs);
          const tag = shared.isString(props.tag) || shared.isObject(props.tag) ? props.tag : getFragmentableTag();
          return vue.h(tag, assignedAttrs, children);
        };
      }
    });
    const Translation = TranslationImpl;
    const I18nT = Translation;
    function isVNode(target) {
      return shared.isArray(target) && !shared.isString(target[0]);
    }
    function renderFormatter(props, context, slotKeys, partFormatter) {
      const { slots, attrs } = context;
      return () => {
        const options = { part: true };
        let overrides = {};
        if (props.locale) {
          options.locale = props.locale;
        }
        if (shared.isString(props.format)) {
          options.key = props.format;
        } else if (shared.isObject(props.format)) {
          if (shared.isString(props.format.key)) {
            options.key = props.format.key;
          }
          overrides = Object.keys(props.format).reduce((options2, prop) => {
            return slotKeys.includes(prop) ? shared.assign({}, options2, { [prop]: props.format[prop] }) : options2;
          }, {});
        }
        const parts = partFormatter(...[props.value, options, overrides]);
        let children = [options.key];
        if (shared.isArray(parts)) {
          children = parts.map((part, index2) => {
            const slot = slots[part.type];
            const node = slot ? slot({ [part.type]: part.value, index: index2, parts }) : [part.value];
            if (isVNode(node)) {
              node[0].key = `${part.type}-${index2}`;
            }
            return node;
          });
        } else if (shared.isString(parts)) {
          children = [parts];
        }
        const assignedAttrs = shared.assign({}, attrs);
        const tag = shared.isString(props.tag) || shared.isObject(props.tag) ? props.tag : getFragmentableTag();
        return vue.h(tag, assignedAttrs, children);
      };
    }
    const NumberFormatImpl = /* @__PURE__ */ vue.defineComponent({
      /* eslint-disable */
      name: "i18n-n",
      props: shared.assign({
        value: {
          type: Number,
          required: true
        },
        format: {
          type: [String, Object]
        }
      }, baseFormatProps),
      /* eslint-enable */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      setup(props, context) {
        const i18n2 = props.i18n || useI18n({
          useScope: props.scope,
          __useComponent: true
        });
        return renderFormatter(props, context, coreBase.NUMBER_FORMAT_OPTIONS_KEYS, (...args) => (
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          i18n2[NumberPartsSymbol](...args)
        ));
      }
    });
    const NumberFormat = NumberFormatImpl;
    const I18nN = NumberFormat;
    const DatetimeFormatImpl = /* @__PURE__ */ vue.defineComponent({
      /* eslint-disable */
      name: "i18n-d",
      props: shared.assign({
        value: {
          type: [Number, Date],
          required: true
        },
        format: {
          type: [String, Object]
        }
      }, baseFormatProps),
      /* eslint-enable */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      setup(props, context) {
        const i18n2 = props.i18n || useI18n({
          useScope: props.scope,
          __useComponent: true
        });
        return renderFormatter(props, context, coreBase.DATETIME_FORMAT_OPTIONS_KEYS, (...args) => (
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          i18n2[DatetimePartsSymbol](...args)
        ));
      }
    });
    const DatetimeFormat = DatetimeFormatImpl;
    const I18nD = DatetimeFormat;
    function getComposer$1(i18n2, instance) {
      const i18nInternal = i18n2;
      if (i18n2.mode === "composition") {
        return i18nInternal.__getInstance(instance) || i18n2.global;
      } else {
        const vueI18n2 = i18nInternal.__getInstance(instance);
        return vueI18n2 != null ? vueI18n2.__composer : i18n2.global.__composer;
      }
    }
    function vTDirective(i18n2) {
      const _process = (binding) => {
        const { instance, modifiers, value } = binding;
        if (!instance || !instance.$) {
          throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
        }
        const composer = getComposer$1(i18n2, instance.$);
        if (modifiers.preserve) {
          shared.warn(getWarnMessage(I18nWarnCodes.NOT_SUPPORTED_PRESERVE));
        }
        const parsedValue = parseValue$1(value);
        return [
          Reflect.apply(composer.t, composer, [...makeParams(parsedValue)]),
          composer
        ];
      };
      const register = (el, binding) => {
        const [textContent, composer] = _process(binding);
        if (shared.inBrowser && i18n2.global === composer) {
          el.__i18nWatcher = vue.watch(composer.locale, () => {
            binding.instance && binding.instance.$forceUpdate();
          });
        }
        el.__composer = composer;
        el.textContent = textContent;
      };
      const unregister = (el) => {
        if (shared.inBrowser && el.__i18nWatcher) {
          el.__i18nWatcher();
          el.__i18nWatcher = void 0;
          delete el.__i18nWatcher;
        }
        if (el.__composer) {
          el.__composer = void 0;
          delete el.__composer;
        }
      };
      const update = (el, { value }) => {
        if (el.__composer) {
          const composer = el.__composer;
          const parsedValue = parseValue$1(value);
          el.textContent = Reflect.apply(composer.t, composer, [
            ...makeParams(parsedValue)
          ]);
        }
      };
      const getSSRProps = (binding) => {
        const [textContent] = _process(binding);
        return { textContent };
      };
      return {
        created: register,
        unmounted: unregister,
        beforeUpdate: update,
        getSSRProps
      };
    }
    function parseValue$1(value) {
      if (shared.isString(value)) {
        return { path: value };
      } else if (shared.isPlainObject(value)) {
        if (!("path" in value)) {
          throw createI18nError(I18nErrorCodes.REQUIRED_VALUE, "path");
        }
        return value;
      } else {
        throw createI18nError(I18nErrorCodes.INVALID_VALUE);
      }
    }
    function makeParams(value) {
      const { path, locale, args, choice, plural } = value;
      const options = {};
      const named = args || {};
      if (shared.isString(locale)) {
        options.locale = locale;
      }
      if (shared.isNumber(choice)) {
        options.plural = choice;
      }
      if (shared.isNumber(plural)) {
        options.plural = plural;
      }
      return [path, named, options];
    }
    function apply$1(app2, i18n2, ...options) {
      const pluginOptions = shared.isPlainObject(options[0]) ? options[0] : {};
      const useI18nComponentName = !!pluginOptions.useI18nComponentName;
      const globalInstall = shared.isBoolean(pluginOptions.globalInstall) ? pluginOptions.globalInstall : true;
      if (globalInstall && useI18nComponentName) {
        shared.warn(getWarnMessage(I18nWarnCodes.COMPONENT_NAME_LEGACY_COMPATIBLE, {
          name: Translation.name
        }));
      }
      if (globalInstall) {
        [!useI18nComponentName ? Translation.name : "i18n", "I18nT"].forEach((name) => app2.component(name, Translation));
        [NumberFormat.name, "I18nN"].forEach((name) => app2.component(name, NumberFormat));
        [DatetimeFormat.name, "I18nD"].forEach((name) => app2.component(name, DatetimeFormat));
      }
      {
        app2.directive("t", vTDirective(i18n2));
      }
    }
    function defineMixin(vuei18n, composer, i18n2) {
      return {
        beforeCreate() {
          const instance = vue.getCurrentInstance();
          if (!instance) {
            throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
          }
          const options = this.$options;
          if (options.i18n) {
            const optionsI18n = options.i18n;
            if (options.__i18n) {
              optionsI18n.__i18n = options.__i18n;
            }
            optionsI18n.__root = composer;
            if (this === this.$root) {
              this.$i18n = mergeToGlobal(vuei18n, optionsI18n);
            } else {
              optionsI18n.__injectWithOption = true;
              optionsI18n.__extender = i18n2.__vueI18nExtend;
              this.$i18n = createVueI18n(optionsI18n);
              const _vueI18n = this.$i18n;
              if (_vueI18n.__extender) {
                _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
              }
            }
          } else if (options.__i18n) {
            if (this === this.$root) {
              this.$i18n = mergeToGlobal(vuei18n, options);
            } else {
              this.$i18n = createVueI18n({
                __i18n: options.__i18n,
                __injectWithOption: true,
                __extender: i18n2.__vueI18nExtend,
                __root: composer
              });
              const _vueI18n = this.$i18n;
              if (_vueI18n.__extender) {
                _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
              }
            }
          } else {
            this.$i18n = vuei18n;
          }
          if (options.__i18nGlobal) {
            adjustI18nResources(composer, options, options);
          }
          this.$t = (...args) => this.$i18n.t(...args);
          this.$rt = (...args) => this.$i18n.rt(...args);
          this.$tc = (...args) => this.$i18n.tc(...args);
          this.$te = (key2, locale) => this.$i18n.te(key2, locale);
          this.$d = (...args) => this.$i18n.d(...args);
          this.$n = (...args) => this.$i18n.n(...args);
          this.$tm = (key2) => this.$i18n.tm(key2);
          i18n2.__setInstance(instance, this.$i18n);
        },
        mounted() {
        },
        unmounted() {
          const instance = vue.getCurrentInstance();
          if (!instance) {
            throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
          }
          const _vueI18n = this.$i18n;
          delete this.$t;
          delete this.$rt;
          delete this.$tc;
          delete this.$te;
          delete this.$d;
          delete this.$n;
          delete this.$tm;
          if (_vueI18n.__disposer) {
            _vueI18n.__disposer();
            delete _vueI18n.__disposer;
            delete _vueI18n.__extender;
          }
          i18n2.__deleteInstance(instance);
          delete this.$i18n;
        }
      };
    }
    function mergeToGlobal(g2, options) {
      g2.locale = options.locale || g2.locale;
      g2.fallbackLocale = options.fallbackLocale || g2.fallbackLocale;
      g2.missing = options.missing || g2.missing;
      g2.silentTranslationWarn = options.silentTranslationWarn || g2.silentFallbackWarn;
      g2.silentFallbackWarn = options.silentFallbackWarn || g2.silentFallbackWarn;
      g2.formatFallbackMessages = options.formatFallbackMessages || g2.formatFallbackMessages;
      g2.postTranslation = options.postTranslation || g2.postTranslation;
      g2.warnHtmlInMessage = options.warnHtmlInMessage || g2.warnHtmlInMessage;
      g2.escapeParameterHtml = options.escapeParameterHtml || g2.escapeParameterHtml;
      g2.sync = options.sync || g2.sync;
      g2.__composer[SetPluralRulesSymbol](options.pluralizationRules || g2.pluralizationRules);
      const messages = getLocaleMessages(g2.locale, {
        messages: options.messages,
        __i18n: options.__i18n
      });
      Object.keys(messages).forEach((locale) => g2.mergeLocaleMessage(locale, messages[locale]));
      if (options.datetimeFormats) {
        Object.keys(options.datetimeFormats).forEach((locale) => g2.mergeDateTimeFormat(locale, options.datetimeFormats[locale]));
      }
      if (options.numberFormats) {
        Object.keys(options.numberFormats).forEach((locale) => g2.mergeNumberFormat(locale, options.numberFormats[locale]));
      }
      return g2;
    }
    const I18nInjectionKey = /* @__PURE__ */ shared.makeSymbol("global-vue-i18n");
    function createI18n(options = {}, VueI18nLegacy) {
      const __legacyMode = shared.isBoolean(options.legacy) ? options.legacy : true;
      const __globalInjection = shared.isBoolean(options.globalInjection) ? options.globalInjection : true;
      const __allowComposition = __legacyMode ? !!options.allowComposition : true;
      const __instances = /* @__PURE__ */ new Map();
      const [globalScope, __global] = createGlobal(options, __legacyMode);
      const symbol = /* @__PURE__ */ shared.makeSymbol("vue-i18n");
      {
        if (__legacyMode && __allowComposition && true) {
          shared.warn(getWarnMessage(I18nWarnCodes.NOTICE_DROP_ALLOW_COMPOSITION));
        }
      }
      function __getInstance(component) {
        return __instances.get(component) || null;
      }
      function __setInstance(component, instance) {
        __instances.set(component, instance);
      }
      function __deleteInstance(component) {
        __instances.delete(component);
      }
      {
        const i18n2 = {
          // mode
          get mode() {
            return __legacyMode ? "legacy" : "composition";
          },
          // allowComposition
          get allowComposition() {
            return __allowComposition;
          },
          // install plugin
          async install(app2, ...options2) {
            app2.__VUE_I18N_SYMBOL__ = symbol;
            app2.provide(app2.__VUE_I18N_SYMBOL__, i18n2);
            if (shared.isPlainObject(options2[0])) {
              const opts = options2[0];
              i18n2.__composerExtend = opts.__composerExtend;
              i18n2.__vueI18nExtend = opts.__vueI18nExtend;
            }
            let globalReleaseHandler = null;
            if (!__legacyMode && __globalInjection) {
              globalReleaseHandler = injectGlobalFields(app2, i18n2.global);
            }
            {
              apply$1(app2, i18n2, ...options2);
            }
            if (__legacyMode) {
              app2.mixin(defineMixin(__global, __global.__composer, i18n2));
            }
            const unmountApp = app2.unmount;
            app2.unmount = () => {
              globalReleaseHandler && globalReleaseHandler();
              i18n2.dispose();
              unmountApp();
            };
          },
          // global accessor
          get global() {
            return __global;
          },
          dispose() {
            globalScope.stop();
          },
          // @internal
          __instances,
          // @internal
          __getInstance,
          // @internal
          __setInstance,
          // @internal
          __deleteInstance
        };
        return i18n2;
      }
    }
    function useI18n(options = {}) {
      const instance = vue.getCurrentInstance();
      if (instance == null) {
        throw createI18nError(I18nErrorCodes.MUST_BE_CALL_SETUP_TOP);
      }
      if (!instance.isCE && instance.appContext.app != null && !instance.appContext.app.__VUE_I18N_SYMBOL__) {
        throw createI18nError(I18nErrorCodes.NOT_INSTALLED);
      }
      const i18n2 = getI18nInstance(instance);
      const gl = getGlobalComposer(i18n2);
      const componentOptions = getComponentOptions(instance);
      const scope = getScope$1(options, componentOptions);
      {
        if (i18n2.mode === "legacy" && !options.__useComponent) {
          if (!i18n2.allowComposition) {
            throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE);
          }
          return useI18nForLegacy(instance, scope, gl, options);
        }
      }
      if (scope === "global") {
        adjustI18nResources(gl, options, componentOptions);
        return gl;
      }
      if (scope === "parent") {
        let composer2 = getComposer(i18n2, instance, options.__useComponent);
        if (composer2 == null) {
          {
            shared.warn(getWarnMessage(I18nWarnCodes.NOT_FOUND_PARENT_SCOPE));
          }
          composer2 = gl;
        }
        return composer2;
      }
      const i18nInternal = i18n2;
      let composer = i18nInternal.__getInstance(instance);
      if (composer == null) {
        const composerOptions = shared.assign({}, options);
        if ("__i18n" in componentOptions) {
          composerOptions.__i18n = componentOptions.__i18n;
        }
        if (gl) {
          composerOptions.__root = gl;
        }
        composer = createComposer(composerOptions);
        if (i18nInternal.__composerExtend) {
          composer[DisposeSymbol] = i18nInternal.__composerExtend(composer);
        }
        setupLifeCycle(i18nInternal, instance, composer);
        i18nInternal.__setInstance(instance, composer);
      }
      return composer;
    }
    const castToVueI18n = /* @__NO_SIDE_EFFECTS__ */ (i18n2) => {
      if (!(__VUE_I18N_BRIDGE__ in i18n2)) {
        throw createI18nError(I18nErrorCodes.NOT_COMPATIBLE_LEGACY_VUE_I18N);
      }
      return i18n2;
    };
    function createGlobal(options, legacyMode, VueI18nLegacy) {
      const scope = vue.effectScope();
      {
        const obj = legacyMode ? scope.run(() => createVueI18n(options)) : scope.run(() => createComposer(options));
        if (obj == null) {
          throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
        }
        return [scope, obj];
      }
    }
    function getI18nInstance(instance) {
      {
        const i18n2 = vue.inject(!instance.isCE ? instance.appContext.app.__VUE_I18N_SYMBOL__ : I18nInjectionKey);
        if (!i18n2) {
          throw createI18nError(!instance.isCE ? I18nErrorCodes.UNEXPECTED_ERROR : I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE);
        }
        return i18n2;
      }
    }
    function getScope$1(options, componentOptions) {
      return shared.isEmptyObject(options) ? "__i18n" in componentOptions ? "local" : "global" : !options.useScope ? "local" : options.useScope;
    }
    function getGlobalComposer(i18n2) {
      return i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
    }
    function getComposer(i18n2, target, useComponent = false) {
      let composer = null;
      const root2 = target.root;
      let current = getParentComponentInstance(target, useComponent);
      while (current != null) {
        const i18nInternal = i18n2;
        if (i18n2.mode === "composition") {
          composer = i18nInternal.__getInstance(current);
        } else {
          {
            const vueI18n2 = i18nInternal.__getInstance(current);
            if (vueI18n2 != null) {
              composer = vueI18n2.__composer;
              if (useComponent && composer && !composer[InejctWithOptionSymbol]) {
                composer = null;
              }
            }
          }
        }
        if (composer != null) {
          break;
        }
        if (root2 === current) {
          break;
        }
        current = current.parent;
      }
      return composer;
    }
    function getParentComponentInstance(target, useComponent = false) {
      if (target == null) {
        return null;
      }
      {
        return !useComponent ? target.parent : target.vnode.ctx || target.parent;
      }
    }
    function setupLifeCycle(i18n2, target, composer) {
      {
        vue.onMounted(() => {
        }, target);
        vue.onUnmounted(() => {
          const _composer = composer;
          i18n2.__deleteInstance(target);
          const dispose = _composer[DisposeSymbol];
          if (dispose) {
            dispose();
            delete _composer[DisposeSymbol];
          }
        }, target);
      }
    }
    function useI18nForLegacy(instance, scope, root2, options = {}) {
      const isLocalScope = scope === "local";
      const _composer = vue.shallowRef(null);
      if (isLocalScope && instance.proxy && !(instance.proxy.$options.i18n || instance.proxy.$options.__i18n)) {
        throw createI18nError(I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
      }
      const _inheritLocale = shared.isBoolean(options.inheritLocale) ? options.inheritLocale : !shared.isString(options.locale);
      const _locale = vue.ref(
        // prettier-ignore
        !isLocalScope || _inheritLocale ? root2.locale.value : shared.isString(options.locale) ? options.locale : coreBase.DEFAULT_LOCALE
      );
      const _fallbackLocale = vue.ref(
        // prettier-ignore
        !isLocalScope || _inheritLocale ? root2.fallbackLocale.value : shared.isString(options.fallbackLocale) || shared.isArray(options.fallbackLocale) || shared.isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value
      );
      const _messages = vue.ref(getLocaleMessages(_locale.value, options));
      const _datetimeFormats = vue.ref(shared.isPlainObject(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
      const _numberFormats = vue.ref(shared.isPlainObject(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
      const _missingWarn = isLocalScope ? root2.missingWarn : shared.isBoolean(options.missingWarn) || shared.isRegExp(options.missingWarn) ? options.missingWarn : true;
      const _fallbackWarn = isLocalScope ? root2.fallbackWarn : shared.isBoolean(options.fallbackWarn) || shared.isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
      const _fallbackRoot = isLocalScope ? root2.fallbackRoot : shared.isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
      const _fallbackFormat = !!options.fallbackFormat;
      const _missing = shared.isFunction(options.missing) ? options.missing : null;
      const _postTranslation = shared.isFunction(options.postTranslation) ? options.postTranslation : null;
      const _warnHtmlMessage = isLocalScope ? root2.warnHtmlMessage : shared.isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
      const _escapeParameter = !!options.escapeParameter;
      const _modifiers = isLocalScope ? root2.modifiers : shared.isPlainObject(options.modifiers) ? options.modifiers : {};
      const _pluralRules = options.pluralRules || isLocalScope && root2.pluralRules;
      function trackReactivityValues() {
        return [
          _locale.value,
          _fallbackLocale.value,
          _messages.value,
          _datetimeFormats.value,
          _numberFormats.value
        ];
      }
      const locale = vue.computed({
        get: () => {
          return _composer.value ? _composer.value.locale.value : _locale.value;
        },
        set: (val) => {
          if (_composer.value) {
            _composer.value.locale.value = val;
          }
          _locale.value = val;
        }
      });
      const fallbackLocale = vue.computed({
        get: () => {
          return _composer.value ? _composer.value.fallbackLocale.value : _fallbackLocale.value;
        },
        set: (val) => {
          if (_composer.value) {
            _composer.value.fallbackLocale.value = val;
          }
          _fallbackLocale.value = val;
        }
      });
      const messages = vue.computed(() => {
        if (_composer.value) {
          return _composer.value.messages.value;
        } else {
          return _messages.value;
        }
      });
      const datetimeFormats = vue.computed(() => _datetimeFormats.value);
      const numberFormats = vue.computed(() => _numberFormats.value);
      function getPostTranslationHandler() {
        return _composer.value ? _composer.value.getPostTranslationHandler() : _postTranslation;
      }
      function setPostTranslationHandler(handler) {
        if (_composer.value) {
          _composer.value.setPostTranslationHandler(handler);
        }
      }
      function getMissingHandler() {
        return _composer.value ? _composer.value.getMissingHandler() : _missing;
      }
      function setMissingHandler(handler) {
        if (_composer.value) {
          _composer.value.setMissingHandler(handler);
        }
      }
      function warpWithDeps(fn2) {
        trackReactivityValues();
        return fn2();
      }
      function t2(...args) {
        return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.t, null, [...args])) : warpWithDeps(() => "");
      }
      function rt2(...args) {
        return _composer.value ? Reflect.apply(_composer.value.rt, null, [...args]) : "";
      }
      function d2(...args) {
        return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.d, null, [...args])) : warpWithDeps(() => "");
      }
      function n2(...args) {
        return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.n, null, [...args])) : warpWithDeps(() => "");
      }
      function tm2(key2) {
        return _composer.value ? _composer.value.tm(key2) : {};
      }
      function te2(key2, locale2) {
        return _composer.value ? _composer.value.te(key2, locale2) : false;
      }
      function getLocaleMessage(locale2) {
        return _composer.value ? _composer.value.getLocaleMessage(locale2) : {};
      }
      function setLocaleMessage(locale2, message) {
        if (_composer.value) {
          _composer.value.setLocaleMessage(locale2, message);
          _messages.value[locale2] = message;
        }
      }
      function mergeLocaleMessage(locale2, message) {
        if (_composer.value) {
          _composer.value.mergeLocaleMessage(locale2, message);
        }
      }
      function getDateTimeFormat(locale2) {
        return _composer.value ? _composer.value.getDateTimeFormat(locale2) : {};
      }
      function setDateTimeFormat(locale2, format2) {
        if (_composer.value) {
          _composer.value.setDateTimeFormat(locale2, format2);
          _datetimeFormats.value[locale2] = format2;
        }
      }
      function mergeDateTimeFormat(locale2, format2) {
        if (_composer.value) {
          _composer.value.mergeDateTimeFormat(locale2, format2);
        }
      }
      function getNumberFormat(locale2) {
        return _composer.value ? _composer.value.getNumberFormat(locale2) : {};
      }
      function setNumberFormat(locale2, format2) {
        if (_composer.value) {
          _composer.value.setNumberFormat(locale2, format2);
          _numberFormats.value[locale2] = format2;
        }
      }
      function mergeNumberFormat(locale2, format2) {
        if (_composer.value) {
          _composer.value.mergeNumberFormat(locale2, format2);
        }
      }
      const wrapper = {
        get id() {
          return _composer.value ? _composer.value.id : -1;
        },
        locale,
        fallbackLocale,
        messages,
        datetimeFormats,
        numberFormats,
        get inheritLocale() {
          return _composer.value ? _composer.value.inheritLocale : _inheritLocale;
        },
        set inheritLocale(val) {
          if (_composer.value) {
            _composer.value.inheritLocale = val;
          }
        },
        get availableLocales() {
          return _composer.value ? _composer.value.availableLocales : Object.keys(_messages.value);
        },
        get modifiers() {
          return _composer.value ? _composer.value.modifiers : _modifiers;
        },
        get pluralRules() {
          return _composer.value ? _composer.value.pluralRules : _pluralRules;
        },
        get isGlobal() {
          return _composer.value ? _composer.value.isGlobal : false;
        },
        get missingWarn() {
          return _composer.value ? _composer.value.missingWarn : _missingWarn;
        },
        set missingWarn(val) {
          if (_composer.value) {
            _composer.value.missingWarn = val;
          }
        },
        get fallbackWarn() {
          return _composer.value ? _composer.value.fallbackWarn : _fallbackWarn;
        },
        set fallbackWarn(val) {
          if (_composer.value) {
            _composer.value.missingWarn = val;
          }
        },
        get fallbackRoot() {
          return _composer.value ? _composer.value.fallbackRoot : _fallbackRoot;
        },
        set fallbackRoot(val) {
          if (_composer.value) {
            _composer.value.fallbackRoot = val;
          }
        },
        get fallbackFormat() {
          return _composer.value ? _composer.value.fallbackFormat : _fallbackFormat;
        },
        set fallbackFormat(val) {
          if (_composer.value) {
            _composer.value.fallbackFormat = val;
          }
        },
        get warnHtmlMessage() {
          return _composer.value ? _composer.value.warnHtmlMessage : _warnHtmlMessage;
        },
        set warnHtmlMessage(val) {
          if (_composer.value) {
            _composer.value.warnHtmlMessage = val;
          }
        },
        get escapeParameter() {
          return _composer.value ? _composer.value.escapeParameter : _escapeParameter;
        },
        set escapeParameter(val) {
          if (_composer.value) {
            _composer.value.escapeParameter = val;
          }
        },
        t: t2,
        getPostTranslationHandler,
        setPostTranslationHandler,
        getMissingHandler,
        setMissingHandler,
        rt: rt2,
        d: d2,
        n: n2,
        tm: tm2,
        te: te2,
        getLocaleMessage,
        setLocaleMessage,
        mergeLocaleMessage,
        getDateTimeFormat,
        setDateTimeFormat,
        mergeDateTimeFormat,
        getNumberFormat,
        setNumberFormat,
        mergeNumberFormat
      };
      function sync(composer) {
        composer.locale.value = _locale.value;
        composer.fallbackLocale.value = _fallbackLocale.value;
        Object.keys(_messages.value).forEach((locale2) => {
          composer.mergeLocaleMessage(locale2, _messages.value[locale2]);
        });
        Object.keys(_datetimeFormats.value).forEach((locale2) => {
          composer.mergeDateTimeFormat(locale2, _datetimeFormats.value[locale2]);
        });
        Object.keys(_numberFormats.value).forEach((locale2) => {
          composer.mergeNumberFormat(locale2, _numberFormats.value[locale2]);
        });
        composer.escapeParameter = _escapeParameter;
        composer.fallbackFormat = _fallbackFormat;
        composer.fallbackRoot = _fallbackRoot;
        composer.fallbackWarn = _fallbackWarn;
        composer.missingWarn = _missingWarn;
        composer.warnHtmlMessage = _warnHtmlMessage;
      }
      vue.onBeforeMount(() => {
        if (instance.proxy == null || instance.proxy.$i18n == null) {
          throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
        }
        const composer = _composer.value = instance.proxy.$i18n.__composer;
        if (scope === "global") {
          _locale.value = composer.locale.value;
          _fallbackLocale.value = composer.fallbackLocale.value;
          _messages.value = composer.messages.value;
          _datetimeFormats.value = composer.datetimeFormats.value;
          _numberFormats.value = composer.numberFormats.value;
        } else if (isLocalScope) {
          sync(composer);
        }
      });
      return wrapper;
    }
    const globalExportProps = [
      "locale",
      "fallbackLocale",
      "availableLocales"
    ];
    const globalExportMethods = ["t", "rt", "d", "n", "tm", "te"];
    function injectGlobalFields(app2, composer) {
      const i18n2 = /* @__PURE__ */ Object.create(null);
      globalExportProps.forEach((prop) => {
        const desc = Object.getOwnPropertyDescriptor(composer, prop);
        if (!desc) {
          throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
        }
        const wrap = vue.isRef(desc.value) ? {
          get() {
            return desc.value.value;
          },
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          set(val) {
            desc.value.value = val;
          }
        } : {
          get() {
            return desc.get && desc.get();
          }
        };
        Object.defineProperty(i18n2, prop, wrap);
      });
      app2.config.globalProperties.$i18n = i18n2;
      globalExportMethods.forEach((method) => {
        const desc = Object.getOwnPropertyDescriptor(composer, method);
        if (!desc || !desc.value) {
          throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
        }
        Object.defineProperty(app2.config.globalProperties, `$${method}`, desc);
      });
      const dispose = () => {
        delete app2.config.globalProperties.$i18n;
        globalExportMethods.forEach((method) => {
          delete app2.config.globalProperties[`$${method}`];
        });
      };
      return dispose;
    }
    {
      coreBase.registerMessageCompiler(coreBase.compile);
    }
    coreBase.registerMessageResolver(coreBase.resolveValue);
    coreBase.registerLocaleFallbacker(coreBase.fallbackWithLocaleChain);
    {
      const target = shared.getGlobalThis();
      target.__INTLIFY__ = true;
      coreBase.setDevToolsHook(target.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
    }
    vueI18n.DatetimeFormat = DatetimeFormat;
    vueI18n.I18nD = I18nD;
    vueI18n.I18nInjectionKey = I18nInjectionKey;
    vueI18n.I18nN = I18nN;
    vueI18n.I18nT = I18nT;
    vueI18n.NumberFormat = NumberFormat;
    vueI18n.Translation = Translation;
    vueI18n.VERSION = VERSION;
    vueI18n.castToVueI18n = castToVueI18n;
    vueI18n.createI18n = createI18n;
    vueI18n.useI18n = useI18n;
    vueI18n.vTDirective = vTDirective;
    var vueI18n_cjs = vueI18n;
    /*!
      * vue-router v4.3.2
      * (c) 2024 Eduardo San Martin Morote
      * @license MIT
      */
    const isBrowser = typeof document !== "undefined";
    function isESModule(obj) {
      return obj.__esModule || obj[Symbol.toStringTag] === "Module";
    }
    const assign = Object.assign;
    function applyToParams(fn2, params) {
      const newParams = {};
      for (const key2 in params) {
        const value = params[key2];
        newParams[key2] = isArray$1(value) ? value.map(fn2) : fn2(value);
      }
      return newParams;
    }
    const noop$1 = () => {
    };
    const isArray$1 = Array.isArray;
    const HASH_RE = /#/g;
    const AMPERSAND_RE = /&/g;
    const SLASH_RE = /\//g;
    const EQUAL_RE = /=/g;
    const IM_RE = /\?/g;
    const PLUS_RE = /\+/g;
    const ENC_BRACKET_OPEN_RE = /%5B/g;
    const ENC_BRACKET_CLOSE_RE = /%5D/g;
    const ENC_CARET_RE = /%5E/g;
    const ENC_BACKTICK_RE = /%60/g;
    const ENC_CURLY_OPEN_RE = /%7B/g;
    const ENC_PIPE_RE = /%7C/g;
    const ENC_CURLY_CLOSE_RE = /%7D/g;
    const ENC_SPACE_RE = /%20/g;
    function commonEncode(text) {
      return encodeURI("" + text).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
    }
    function encodeHash(text) {
      return commonEncode(text).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
    }
    function encodeQueryValue(text) {
      return commonEncode(text).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
    }
    function encodeQueryKey(text) {
      return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
    }
    function encodePath(text) {
      return commonEncode(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
    }
    function encodeParam(text) {
      return text == null ? "" : encodePath(text).replace(SLASH_RE, "%2F");
    }
    function decode(text) {
      try {
        return decodeURIComponent("" + text);
      } catch (err) {
      }
      return "" + text;
    }
    const TRAILING_SLASH_RE = /\/$/;
    const removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, "");
    function parseURL(parseQuery2, location2, currentLocation = "/") {
      let path, query = {}, searchString = "", hash2 = "";
      const hashPos = location2.indexOf("#");
      let searchPos = location2.indexOf("?");
      if (hashPos < searchPos && hashPos >= 0) {
        searchPos = -1;
      }
      if (searchPos > -1) {
        path = location2.slice(0, searchPos);
        searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);
        query = parseQuery2(searchString);
      }
      if (hashPos > -1) {
        path = path || location2.slice(0, hashPos);
        hash2 = location2.slice(hashPos, location2.length);
      }
      path = resolveRelativePath(path != null ? path : location2, currentLocation);
      return {
        fullPath: path + (searchString && "?") + searchString + hash2,
        path,
        query,
        hash: decode(hash2)
      };
    }
    function stringifyURL(stringifyQuery2, location2) {
      const query = location2.query ? stringifyQuery2(location2.query) : "";
      return location2.path + (query && "?") + query + (location2.hash || "");
    }
    function stripBase(pathname, base) {
      if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))
        return pathname;
      return pathname.slice(base.length) || "/";
    }
    function isSameRouteLocation(stringifyQuery2, a2, b2) {
      const aLastIndex = a2.matched.length - 1;
      const bLastIndex = b2.matched.length - 1;
      return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a2.matched[aLastIndex], b2.matched[bLastIndex]) && isSameRouteLocationParams(a2.params, b2.params) && stringifyQuery2(a2.query) === stringifyQuery2(b2.query) && a2.hash === b2.hash;
    }
    function isSameRouteRecord(a2, b2) {
      return (a2.aliasOf || a2) === (b2.aliasOf || b2);
    }
    function isSameRouteLocationParams(a2, b2) {
      if (Object.keys(a2).length !== Object.keys(b2).length)
        return false;
      for (const key2 in a2) {
        if (!isSameRouteLocationParamsValue(a2[key2], b2[key2]))
          return false;
      }
      return true;
    }
    function isSameRouteLocationParamsValue(a2, b2) {
      return isArray$1(a2) ? isEquivalentArray(a2, b2) : isArray$1(b2) ? isEquivalentArray(b2, a2) : a2 === b2;
    }
    function isEquivalentArray(a2, b2) {
      return isArray$1(b2) ? a2.length === b2.length && a2.every((value, i2) => value === b2[i2]) : a2.length === 1 && a2[0] === b2;
    }
    function resolveRelativePath(to2, from) {
      if (to2.startsWith("/"))
        return to2;
      if (!to2)
        return from;
      const fromSegments = from.split("/");
      const toSegments = to2.split("/");
      const lastToSegment = toSegments[toSegments.length - 1];
      if (lastToSegment === ".." || lastToSegment === ".") {
        toSegments.push("");
      }
      let position = fromSegments.length - 1;
      let toPosition;
      let segment;
      for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
        segment = toSegments[toPosition];
        if (segment === ".")
          continue;
        if (segment === "..") {
          if (position > 1)
            position--;
        } else
          break;
      }
      return fromSegments.slice(0, position).join("/") + "/" + toSegments.slice(toPosition).join("/");
    }
    var NavigationType;
    (function(NavigationType2) {
      NavigationType2["pop"] = "pop";
      NavigationType2["push"] = "push";
    })(NavigationType || (NavigationType = {}));
    var NavigationDirection;
    (function(NavigationDirection2) {
      NavigationDirection2["back"] = "back";
      NavigationDirection2["forward"] = "forward";
      NavigationDirection2["unknown"] = "";
    })(NavigationDirection || (NavigationDirection = {}));
    function normalizeBase(base) {
      if (!base) {
        if (isBrowser) {
          const baseEl = document.querySelector("base");
          base = baseEl && baseEl.getAttribute("href") || "/";
          base = base.replace(/^\w+:\/\/[^\/]+/, "");
        } else {
          base = "/";
        }
      }
      if (base[0] !== "/" && base[0] !== "#")
        base = "/" + base;
      return removeTrailingSlash(base);
    }
    const BEFORE_HASH_RE = /^[^#]+#/;
    function createHref(base, location2) {
      return base.replace(BEFORE_HASH_RE, "#") + location2;
    }
    function getElementPosition(el, offset2) {
      const docRect = document.documentElement.getBoundingClientRect();
      const elRect = el.getBoundingClientRect();
      return {
        behavior: offset2.behavior,
        left: elRect.left - docRect.left - (offset2.left || 0),
        top: elRect.top - docRect.top - (offset2.top || 0)
      };
    }
    const computeScrollPosition = () => ({
      left: window.scrollX,
      top: window.scrollY
    });
    function scrollToPosition(position) {
      let scrollToOptions;
      if ("el" in position) {
        const positionEl = position.el;
        const isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
        const el = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
        if (!el) {
          return;
        }
        scrollToOptions = getElementPosition(el, position);
      } else {
        scrollToOptions = position;
      }
      if ("scrollBehavior" in document.documentElement.style)
        window.scrollTo(scrollToOptions);
      else {
        window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.scrollX, scrollToOptions.top != null ? scrollToOptions.top : window.scrollY);
      }
    }
    function getScrollKey(path, delta) {
      const position = history.state ? history.state.position - delta : -1;
      return position + path;
    }
    const scrollPositions = /* @__PURE__ */ new Map();
    function saveScrollPosition(key2, scrollPosition) {
      scrollPositions.set(key2, scrollPosition);
    }
    function getSavedScrollPosition(key2) {
      const scroll2 = scrollPositions.get(key2);
      scrollPositions.delete(key2);
      return scroll2;
    }
    let createBaseLocation = () => location.protocol + "//" + location.host;
    function createCurrentLocation(base, location2) {
      const { pathname, search, hash: hash2 } = location2;
      const hashPos = base.indexOf("#");
      if (hashPos > -1) {
        let slicePos = hash2.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;
        let pathFromHash = hash2.slice(slicePos);
        if (pathFromHash[0] !== "/")
          pathFromHash = "/" + pathFromHash;
        return stripBase(pathFromHash, "");
      }
      const path = stripBase(pathname, base);
      return path + search + hash2;
    }
    function useHistoryListeners(base, historyState, currentLocation, replace) {
      let listeners = [];
      let teardowns = [];
      let pauseState = null;
      const popStateHandler = ({ state }) => {
        const to2 = createCurrentLocation(base, location);
        const from = currentLocation.value;
        const fromState = historyState.value;
        let delta = 0;
        if (state) {
          currentLocation.value = to2;
          historyState.value = state;
          if (pauseState && pauseState === from) {
            pauseState = null;
            return;
          }
          delta = fromState ? state.position - fromState.position : 0;
        } else {
          replace(to2);
        }
        listeners.forEach((listener) => {
          listener(currentLocation.value, from, {
            delta,
            type: NavigationType.pop,
            direction: delta ? delta > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
          });
        });
      };
      function pauseListeners() {
        pauseState = currentLocation.value;
      }
      function listen(callback) {
        listeners.push(callback);
        const teardown = () => {
          const index2 = listeners.indexOf(callback);
          if (index2 > -1)
            listeners.splice(index2, 1);
        };
        teardowns.push(teardown);
        return teardown;
      }
      function beforeUnloadListener() {
        const { history: history2 } = window;
        if (!history2.state)
          return;
        history2.replaceState(assign({}, history2.state, { scroll: computeScrollPosition() }), "");
      }
      function destroy() {
        for (const teardown of teardowns)
          teardown();
        teardowns = [];
        window.removeEventListener("popstate", popStateHandler);
        window.removeEventListener("beforeunload", beforeUnloadListener);
      }
      window.addEventListener("popstate", popStateHandler);
      window.addEventListener("beforeunload", beforeUnloadListener, {
        passive: true
      });
      return {
        pauseListeners,
        listen,
        destroy
      };
    }
    function buildState(back2, current, forward, replaced = false, computeScroll = false) {
      return {
        back: back2,
        current,
        forward,
        replaced,
        position: window.history.length,
        scroll: computeScroll ? computeScrollPosition() : null
      };
    }
    function useHistoryStateNavigation(base) {
      const { history: history2, location: location2 } = window;
      const currentLocation = {
        value: createCurrentLocation(base, location2)
      };
      const historyState = { value: history2.state };
      if (!historyState.value) {
        changeLocation(currentLocation.value, {
          back: null,
          current: currentLocation.value,
          forward: null,
          // the length is off by one, we need to decrease it
          position: history2.length - 1,
          replaced: true,
          // don't add a scroll as the user may have an anchor, and we want
          // scrollBehavior to be triggered without a saved position
          scroll: null
        }, true);
      }
      function changeLocation(to2, state, replace2) {
        const hashIndex = base.indexOf("#");
        const url = hashIndex > -1 ? (location2.host && document.querySelector("base") ? base : base.slice(hashIndex)) + to2 : createBaseLocation() + base + to2;
        try {
          history2[replace2 ? "replaceState" : "pushState"](state, "", url);
          historyState.value = state;
        } catch (err) {
          {
            console.error(err);
          }
          location2[replace2 ? "replace" : "assign"](url);
        }
      }
      function replace(to2, data) {
        const state = assign({}, history2.state, buildState(
          historyState.value.back,
          // keep back and forward entries but override current position
          to2,
          historyState.value.forward,
          true
        ), data, { position: historyState.value.position });
        changeLocation(to2, state, true);
        currentLocation.value = to2;
      }
      function push(to2, data) {
        const currentState = assign(
          {},
          // use current history state to gracefully handle a wrong call to
          // history.replaceState
          // https://github.com/vuejs/router/issues/366
          historyState.value,
          history2.state,
          {
            forward: to2,
            scroll: computeScrollPosition()
          }
        );
        changeLocation(currentState.current, currentState, true);
        const state = assign({}, buildState(currentLocation.value, to2, null), { position: currentState.position + 1 }, data);
        changeLocation(to2, state, false);
        currentLocation.value = to2;
      }
      return {
        location: currentLocation,
        state: historyState,
        push,
        replace
      };
    }
    function createWebHistory(base) {
      base = normalizeBase(base);
      const historyNavigation = useHistoryStateNavigation(base);
      const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
      function go2(delta, triggerListeners = true) {
        if (!triggerListeners)
          historyListeners.pauseListeners();
        history.go(delta);
      }
      const routerHistory = assign({
        // it's overridden right after
        location: "",
        base,
        go: go2,
        createHref: createHref.bind(null, base)
      }, historyNavigation, historyListeners);
      Object.defineProperty(routerHistory, "location", {
        enumerable: true,
        get: () => historyNavigation.location.value
      });
      Object.defineProperty(routerHistory, "state", {
        enumerable: true,
        get: () => historyNavigation.state.value
      });
      return routerHistory;
    }
    function isRouteLocation(route) {
      return typeof route === "string" || route && typeof route === "object";
    }
    function isRouteName(name) {
      return typeof name === "string" || typeof name === "symbol";
    }
    const START_LOCATION_NORMALIZED = {
      path: "/",
      name: void 0,
      params: {},
      query: {},
      hash: "",
      fullPath: "/",
      matched: [],
      meta: {},
      redirectedFrom: void 0
    };
    const NavigationFailureSymbol = Symbol("");
    var NavigationFailureType;
    (function(NavigationFailureType2) {
      NavigationFailureType2[NavigationFailureType2["aborted"] = 4] = "aborted";
      NavigationFailureType2[NavigationFailureType2["cancelled"] = 8] = "cancelled";
      NavigationFailureType2[NavigationFailureType2["duplicated"] = 16] = "duplicated";
    })(NavigationFailureType || (NavigationFailureType = {}));
    function createRouterError(type, params) {
      {
        return assign(new Error(), {
          type,
          [NavigationFailureSymbol]: true
        }, params);
      }
    }
    function isNavigationFailure(error, type) {
      return error instanceof Error && NavigationFailureSymbol in error && (type == null || !!(error.type & type));
    }
    const BASE_PARAM_PATTERN = "[^/]+?";
    const BASE_PATH_PARSER_OPTIONS = {
      sensitive: false,
      strict: false,
      start: true,
      end: true
    };
    const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
    function tokensToParser(segments, extraOptions) {
      const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
      const score = [];
      let pattern = options.start ? "^" : "";
      const keys = [];
      for (const segment of segments) {
        const segmentScores = segment.length ? [] : [
          90
          /* PathScore.Root */
        ];
        if (options.strict && !segment.length)
          pattern += "/";
        for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
          const token = segment[tokenIndex];
          let subSegmentScore = 40 + (options.sensitive ? 0.25 : 0);
          if (token.type === 0) {
            if (!tokenIndex)
              pattern += "/";
            pattern += token.value.replace(REGEX_CHARS_RE, "\\$&");
            subSegmentScore += 40;
          } else if (token.type === 1) {
            const { value, repeatable, optional, regexp } = token;
            keys.push({
              name: value,
              repeatable,
              optional
            });
            const re22 = regexp ? regexp : BASE_PARAM_PATTERN;
            if (re22 !== BASE_PARAM_PATTERN) {
              subSegmentScore += 10;
              try {
                new RegExp(`(${re22})`);
              } catch (err) {
                throw new Error(`Invalid custom RegExp for param "${value}" (${re22}): ` + err.message);
              }
            }
            let subPattern = repeatable ? `((?:${re22})(?:/(?:${re22}))*)` : `(${re22})`;
            if (!tokenIndex)
              subPattern = // avoid an optional / if there are more segments e.g. /:p?-static
              // or /:p?-:p2
              optional && segment.length < 2 ? `(?:/${subPattern})` : "/" + subPattern;
            if (optional)
              subPattern += "?";
            pattern += subPattern;
            subSegmentScore += 20;
            if (optional)
              subSegmentScore += -8;
            if (repeatable)
              subSegmentScore += -20;
            if (re22 === ".*")
              subSegmentScore += -50;
          }
          segmentScores.push(subSegmentScore);
        }
        score.push(segmentScores);
      }
      if (options.strict && options.end) {
        const i2 = score.length - 1;
        score[i2][score[i2].length - 1] += 0.7000000000000001;
      }
      if (!options.strict)
        pattern += "/?";
      if (options.end)
        pattern += "$";
      else if (options.strict)
        pattern += "(?:/|$)";
      const re2 = new RegExp(pattern, options.sensitive ? "" : "i");
      function parse2(path) {
        const match = path.match(re2);
        const params = {};
        if (!match)
          return null;
        for (let i2 = 1; i2 < match.length; i2++) {
          const value = match[i2] || "";
          const key2 = keys[i2 - 1];
          params[key2.name] = value && key2.repeatable ? value.split("/") : value;
        }
        return params;
      }
      function stringify2(params) {
        let path = "";
        let avoidDuplicatedSlash = false;
        for (const segment of segments) {
          if (!avoidDuplicatedSlash || !path.endsWith("/"))
            path += "/";
          avoidDuplicatedSlash = false;
          for (const token of segment) {
            if (token.type === 0) {
              path += token.value;
            } else if (token.type === 1) {
              const { value, repeatable, optional } = token;
              const param = value in params ? params[value] : "";
              if (isArray$1(param) && !repeatable) {
                throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);
              }
              const text = isArray$1(param) ? param.join("/") : param;
              if (!text) {
                if (optional) {
                  if (segment.length < 2) {
                    if (path.endsWith("/"))
                      path = path.slice(0, -1);
                    else
                      avoidDuplicatedSlash = true;
                  }
                } else
                  throw new Error(`Missing required param "${value}"`);
              }
              path += text;
            }
          }
        }
        return path || "/";
      }
      return {
        re: re2,
        score,
        keys,
        parse: parse2,
        stringify: stringify2
      };
    }
    function compareScoreArray(a2, b2) {
      let i2 = 0;
      while (i2 < a2.length && i2 < b2.length) {
        const diff = b2[i2] - a2[i2];
        if (diff)
          return diff;
        i2++;
      }
      if (a2.length < b2.length) {
        return a2.length === 1 && a2[0] === 40 + 40 ? -1 : 1;
      } else if (a2.length > b2.length) {
        return b2.length === 1 && b2[0] === 40 + 40 ? 1 : -1;
      }
      return 0;
    }
    function comparePathParserScore(a2, b2) {
      let i2 = 0;
      const aScore = a2.score;
      const bScore = b2.score;
      while (i2 < aScore.length && i2 < bScore.length) {
        const comp = compareScoreArray(aScore[i2], bScore[i2]);
        if (comp)
          return comp;
        i2++;
      }
      if (Math.abs(bScore.length - aScore.length) === 1) {
        if (isLastScoreNegative(aScore))
          return 1;
        if (isLastScoreNegative(bScore))
          return -1;
      }
      return bScore.length - aScore.length;
    }
    function isLastScoreNegative(score) {
      const last = score[score.length - 1];
      return score.length > 0 && last[last.length - 1] < 0;
    }
    const ROOT_TOKEN = {
      type: 0,
      value: ""
    };
    const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
    function tokenizePath(path) {
      if (!path)
        return [[]];
      if (path === "/")
        return [[ROOT_TOKEN]];
      if (!path.startsWith("/")) {
        throw new Error(`Invalid path "${path}"`);
      }
      function crash(message) {
        throw new Error(`ERR (${state})/"${buffer2}": ${message}`);
      }
      let state = 0;
      let previousState = state;
      const tokens = [];
      let segment;
      function finalizeSegment() {
        if (segment)
          tokens.push(segment);
        segment = [];
      }
      let i2 = 0;
      let char;
      let buffer2 = "";
      let customRe = "";
      function consumeBuffer() {
        if (!buffer2)
          return;
        if (state === 0) {
          segment.push({
            type: 0,
            value: buffer2
          });
        } else if (state === 1 || state === 2 || state === 3) {
          if (segment.length > 1 && (char === "*" || char === "+"))
            crash(`A repeatable param (${buffer2}) must be alone in its segment. eg: '/:ids+.`);
          segment.push({
            type: 1,
            value: buffer2,
            regexp: customRe,
            repeatable: char === "*" || char === "+",
            optional: char === "*" || char === "?"
          });
        } else {
          crash("Invalid state to consume buffer");
        }
        buffer2 = "";
      }
      function addCharToBuffer() {
        buffer2 += char;
      }
      while (i2 < path.length) {
        char = path[i2++];
        if (char === "\\" && state !== 2) {
          previousState = state;
          state = 4;
          continue;
        }
        switch (state) {
          case 0:
            if (char === "/") {
              if (buffer2) {
                consumeBuffer();
              }
              finalizeSegment();
            } else if (char === ":") {
              consumeBuffer();
              state = 1;
            } else {
              addCharToBuffer();
            }
            break;
          case 4:
            addCharToBuffer();
            state = previousState;
            break;
          case 1:
            if (char === "(") {
              state = 2;
            } else if (VALID_PARAM_RE.test(char)) {
              addCharToBuffer();
            } else {
              consumeBuffer();
              state = 0;
              if (char !== "*" && char !== "?" && char !== "+")
                i2--;
            }
            break;
          case 2:
            if (char === ")") {
              if (customRe[customRe.length - 1] == "\\")
                customRe = customRe.slice(0, -1) + char;
              else
                state = 3;
            } else {
              customRe += char;
            }
            break;
          case 3:
            consumeBuffer();
            state = 0;
            if (char !== "*" && char !== "?" && char !== "+")
              i2--;
            customRe = "";
            break;
          default:
            crash("Unknown state");
            break;
        }
      }
      if (state === 2)
        crash(`Unfinished custom RegExp for param "${buffer2}"`);
      consumeBuffer();
      finalizeSegment();
      return tokens;
    }
    function createRouteRecordMatcher(record, parent, options) {
      const parser2 = tokensToParser(tokenizePath(record.path), options);
      const matcher = assign(parser2, {
        record,
        parent,
        // these needs to be populated by the parent
        children: [],
        alias: []
      });
      if (parent) {
        if (!matcher.record.aliasOf === !parent.record.aliasOf)
          parent.children.push(matcher);
      }
      return matcher;
    }
    function createRouterMatcher(routes, globalOptions) {
      const matchers2 = [];
      const matcherMap = /* @__PURE__ */ new Map();
      globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);
      function getRecordMatcher(name) {
        return matcherMap.get(name);
      }
      function addRoute(record, parent, originalRecord) {
        const isRootAdd = !originalRecord;
        const mainNormalizedRecord = normalizeRouteRecord(record);
        mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
        const options = mergeOptions(globalOptions, record);
        const normalizedRecords = [
          mainNormalizedRecord
        ];
        if ("alias" in record) {
          const aliases = typeof record.alias === "string" ? [record.alias] : record.alias;
          for (const alias of aliases) {
            normalizedRecords.push(assign({}, mainNormalizedRecord, {
              // this allows us to hold a copy of the `components` option
              // so that async components cache is hold on the original record
              components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
              path: alias,
              // we might be the child of an alias
              aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
              // the aliases are always of the same kind as the original since they
              // are defined on the same record
            }));
          }
        }
        let matcher;
        let originalMatcher;
        for (const normalizedRecord of normalizedRecords) {
          const { path } = normalizedRecord;
          if (parent && path[0] !== "/") {
            const parentPath = parent.record.path;
            const connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
            normalizedRecord.path = parent.record.path + (path && connectingSlash + path);
          }
          matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
          if (originalRecord) {
            originalRecord.alias.push(matcher);
          } else {
            originalMatcher = originalMatcher || matcher;
            if (originalMatcher !== matcher)
              originalMatcher.alias.push(matcher);
            if (isRootAdd && record.name && !isAliasRecord(matcher))
              removeRoute(record.name);
          }
          if (mainNormalizedRecord.children) {
            const children = mainNormalizedRecord.children;
            for (let i2 = 0; i2 < children.length; i2++) {
              addRoute(children[i2], matcher, originalRecord && originalRecord.children[i2]);
            }
          }
          originalRecord = originalRecord || matcher;
          if (matcher.record.components && Object.keys(matcher.record.components).length || matcher.record.name || matcher.record.redirect) {
            insertMatcher(matcher);
          }
        }
        return originalMatcher ? () => {
          removeRoute(originalMatcher);
        } : noop$1;
      }
      function removeRoute(matcherRef) {
        if (isRouteName(matcherRef)) {
          const matcher = matcherMap.get(matcherRef);
          if (matcher) {
            matcherMap.delete(matcherRef);
            matchers2.splice(matchers2.indexOf(matcher), 1);
            matcher.children.forEach(removeRoute);
            matcher.alias.forEach(removeRoute);
          }
        } else {
          const index2 = matchers2.indexOf(matcherRef);
          if (index2 > -1) {
            matchers2.splice(index2, 1);
            if (matcherRef.record.name)
              matcherMap.delete(matcherRef.record.name);
            matcherRef.children.forEach(removeRoute);
            matcherRef.alias.forEach(removeRoute);
          }
        }
      }
      function getRoutes() {
        return matchers2;
      }
      function insertMatcher(matcher) {
        let i2 = 0;
        while (i2 < matchers2.length && comparePathParserScore(matcher, matchers2[i2]) >= 0 && // Adding children with empty path should still appear before the parent
        // https://github.com/vuejs/router/issues/1124
        (matcher.record.path !== matchers2[i2].record.path || !isRecordChildOf(matcher, matchers2[i2])))
          i2++;
        matchers2.splice(i2, 0, matcher);
        if (matcher.record.name && !isAliasRecord(matcher))
          matcherMap.set(matcher.record.name, matcher);
      }
      function resolve2(location2, currentLocation) {
        let matcher;
        let params = {};
        let path;
        let name;
        if ("name" in location2 && location2.name) {
          matcher = matcherMap.get(location2.name);
          if (!matcher)
            throw createRouterError(1, {
              location: location2
            });
          name = matcher.record.name;
          params = assign(
            // paramsFromLocation is a new object
            paramsFromLocation(
              currentLocation.params,
              // only keep params that exist in the resolved location
              // only keep optional params coming from a parent record
              matcher.keys.filter((k2) => !k2.optional).concat(matcher.parent ? matcher.parent.keys.filter((k2) => k2.optional) : []).map((k2) => k2.name)
            ),
            // discard any existing params in the current location that do not exist here
            // #1497 this ensures better active/exact matching
            location2.params && paramsFromLocation(location2.params, matcher.keys.map((k2) => k2.name))
          );
          path = matcher.stringify(params);
        } else if (location2.path != null) {
          path = location2.path;
          matcher = matchers2.find((m2) => m2.re.test(path));
          if (matcher) {
            params = matcher.parse(path);
            name = matcher.record.name;
          }
        } else {
          matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers2.find((m2) => m2.re.test(currentLocation.path));
          if (!matcher)
            throw createRouterError(1, {
              location: location2,
              currentLocation
            });
          name = matcher.record.name;
          params = assign({}, currentLocation.params, location2.params);
          path = matcher.stringify(params);
        }
        const matched = [];
        let parentMatcher = matcher;
        while (parentMatcher) {
          matched.unshift(parentMatcher.record);
          parentMatcher = parentMatcher.parent;
        }
        return {
          name,
          path,
          params,
          matched,
          meta: mergeMetaFields(matched)
        };
      }
      routes.forEach((route) => addRoute(route));
      return { addRoute, resolve: resolve2, removeRoute, getRoutes, getRecordMatcher };
    }
    function paramsFromLocation(params, keys) {
      const newParams = {};
      for (const key2 of keys) {
        if (key2 in params)
          newParams[key2] = params[key2];
      }
      return newParams;
    }
    function normalizeRouteRecord(record) {
      return {
        path: record.path,
        redirect: record.redirect,
        name: record.name,
        meta: record.meta || {},
        aliasOf: void 0,
        beforeEnter: record.beforeEnter,
        props: normalizeRecordProps(record),
        children: record.children || [],
        instances: {},
        leaveGuards: /* @__PURE__ */ new Set(),
        updateGuards: /* @__PURE__ */ new Set(),
        enterCallbacks: {},
        components: "components" in record ? record.components || null : record.component && { default: record.component }
      };
    }
    function normalizeRecordProps(record) {
      const propsObject = {};
      const props = record.props || false;
      if ("component" in record) {
        propsObject.default = props;
      } else {
        for (const name in record.components)
          propsObject[name] = typeof props === "object" ? props[name] : props;
      }
      return propsObject;
    }
    function isAliasRecord(record) {
      while (record) {
        if (record.record.aliasOf)
          return true;
        record = record.parent;
      }
      return false;
    }
    function mergeMetaFields(matched) {
      return matched.reduce((meta, record) => assign(meta, record.meta), {});
    }
    function mergeOptions(defaults2, partialOptions) {
      const options = {};
      for (const key2 in defaults2) {
        options[key2] = key2 in partialOptions ? partialOptions[key2] : defaults2[key2];
      }
      return options;
    }
    function isRecordChildOf(record, parent) {
      return parent.children.some((child2) => child2 === record || isRecordChildOf(record, child2));
    }
    function parseQuery(search) {
      const query = {};
      if (search === "" || search === "?")
        return query;
      const hasLeadingIM = search[0] === "?";
      const searchParams = (hasLeadingIM ? search.slice(1) : search).split("&");
      for (let i2 = 0; i2 < searchParams.length; ++i2) {
        const searchParam = searchParams[i2].replace(PLUS_RE, " ");
        const eqPos = searchParam.indexOf("=");
        const key2 = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
        const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));
        if (key2 in query) {
          let currentValue = query[key2];
          if (!isArray$1(currentValue)) {
            currentValue = query[key2] = [currentValue];
          }
          currentValue.push(value);
        } else {
          query[key2] = value;
        }
      }
      return query;
    }
    function stringifyQuery(query) {
      let search = "";
      for (let key2 in query) {
        const value = query[key2];
        key2 = encodeQueryKey(key2);
        if (value == null) {
          if (value !== void 0) {
            search += (search.length ? "&" : "") + key2;
          }
          continue;
        }
        const values = isArray$1(value) ? value.map((v2) => v2 && encodeQueryValue(v2)) : [value && encodeQueryValue(value)];
        values.forEach((value2) => {
          if (value2 !== void 0) {
            search += (search.length ? "&" : "") + key2;
            if (value2 != null)
              search += "=" + value2;
          }
        });
      }
      return search;
    }
    function normalizeQuery(query) {
      const normalizedQuery = {};
      for (const key2 in query) {
        const value = query[key2];
        if (value !== void 0) {
          normalizedQuery[key2] = isArray$1(value) ? value.map((v2) => v2 == null ? null : "" + v2) : value == null ? value : "" + value;
        }
      }
      return normalizedQuery;
    }
    const matchedRouteKey = Symbol("");
    const viewDepthKey = Symbol("");
    const routerKey = Symbol("");
    const routeLocationKey = Symbol("");
    const routerViewLocationKey = Symbol("");
    function useCallbacks() {
      let handlers2 = [];
      function add2(handler) {
        handlers2.push(handler);
        return () => {
          const i2 = handlers2.indexOf(handler);
          if (i2 > -1)
            handlers2.splice(i2, 1);
        };
      }
      function reset() {
        handlers2 = [];
      }
      return {
        add: add2,
        list: () => handlers2.slice(),
        reset
      };
    }
    function guardToPromiseFn(guard, to2, from, record, name, runWithContext = (fn2) => fn2()) {
      const enterCallbackArray = record && // name is defined if record is because of the function overload
      (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
      return () => new Promise((resolve2, reject) => {
        const next = (valid) => {
          if (valid === false) {
            reject(createRouterError(4, {
              from,
              to: to2
            }));
          } else if (valid instanceof Error) {
            reject(valid);
          } else if (isRouteLocation(valid)) {
            reject(createRouterError(2, {
              from: to2,
              to: valid
            }));
          } else {
            if (enterCallbackArray && // since enterCallbackArray is truthy, both record and name also are
            record.enterCallbacks[name] === enterCallbackArray && typeof valid === "function") {
              enterCallbackArray.push(valid);
            }
            resolve2();
          }
        };
        const guardReturn = runWithContext(() => guard.call(record && record.instances[name], to2, from, next));
        let guardCall = Promise.resolve(guardReturn);
        if (guard.length < 3)
          guardCall = guardCall.then(next);
        guardCall.catch((err) => reject(err));
      });
    }
    function extractComponentsGuards(matched, guardType, to2, from, runWithContext = (fn2) => fn2()) {
      const guards = [];
      for (const record of matched) {
        for (const name in record.components) {
          let rawComponent = record.components[name];
          if (guardType !== "beforeRouteEnter" && !record.instances[name])
            continue;
          if (isRouteComponent(rawComponent)) {
            const options = rawComponent.__vccOpts || rawComponent;
            const guard = options[guardType];
            guard && guards.push(guardToPromiseFn(guard, to2, from, record, name, runWithContext));
          } else {
            let componentPromise = rawComponent();
            guards.push(() => componentPromise.then((resolved) => {
              if (!resolved)
                return Promise.reject(new Error(`Couldn't resolve component "${name}" at "${record.path}"`));
              const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
              record.components[name] = resolvedComponent;
              const options = resolvedComponent.__vccOpts || resolvedComponent;
              const guard = options[guardType];
              return guard && guardToPromiseFn(guard, to2, from, record, name, runWithContext)();
            }));
          }
        }
      }
      return guards;
    }
    function isRouteComponent(component) {
      return typeof component === "object" || "displayName" in component || "props" in component || "__vccOpts" in component;
    }
    function useLink(props) {
      const router2 = inject(routerKey);
      const currentRoute = inject(routeLocationKey);
      const route = computed(() => {
        const to2 = unref(props.to);
        return router2.resolve(to2);
      });
      const activeRecordIndex = computed(() => {
        const { matched } = route.value;
        const { length } = matched;
        const routeMatched = matched[length - 1];
        const currentMatched = currentRoute.matched;
        if (!routeMatched || !currentMatched.length)
          return -1;
        const index2 = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
        if (index2 > -1)
          return index2;
        const parentRecordPath = getOriginalPath(matched[length - 2]);
        return (
          // we are dealing with nested routes
          length > 1 && // if the parent and matched route have the same path, this link is
          // referring to the empty child. Or we currently are on a different
          // child of the same parent
          getOriginalPath(routeMatched) === parentRecordPath && // avoid comparing the child with its parent
          currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index2
        );
      });
      const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));
      const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));
      function navigate(e2 = {}) {
        if (guardEvent(e2)) {
          return router2[unref(props.replace) ? "replace" : "push"](
            unref(props.to)
            // avoid uncaught errors are they are logged anyway
          ).catch(noop$1);
        }
        return Promise.resolve();
      }
      return {
        route,
        href: computed(() => route.value.href),
        isActive,
        isExactActive,
        navigate
      };
    }
    const RouterLinkImpl = /* @__PURE__ */ defineComponent({
      name: "RouterLink",
      compatConfig: { MODE: 3 },
      props: {
        to: {
          type: [String, Object],
          required: true
        },
        replace: Boolean,
        activeClass: String,
        // inactiveClass: String,
        exactActiveClass: String,
        custom: Boolean,
        ariaCurrentValue: {
          type: String,
          default: "page"
        }
      },
      useLink,
      setup(props, { slots }) {
        const link2 = reactive(useLink(props));
        const { options } = inject(routerKey);
        const elClass = computed(() => ({
          [getLinkClass(props.activeClass, options.linkActiveClass, "router-link-active")]: link2.isActive,
          // [getLinkClass(
          //   props.inactiveClass,
          //   options.linkInactiveClass,
          //   'router-link-inactive'
          // )]: !link.isExactActive,
          [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, "router-link-exact-active")]: link2.isExactActive
        }));
        return () => {
          const children = slots.default && slots.default(link2);
          return props.custom ? children : h$4("a", {
            "aria-current": link2.isExactActive ? props.ariaCurrentValue : null,
            href: link2.href,
            // this would override user added attrs but Vue will still add
            // the listener, so we end up triggering both
            onClick: link2.navigate,
            class: elClass.value
          }, children);
        };
      }
    });
    const RouterLink = RouterLinkImpl;
    function guardEvent(e2) {
      if (e2.metaKey || e2.altKey || e2.ctrlKey || e2.shiftKey)
        return;
      if (e2.defaultPrevented)
        return;
      if (e2.button !== void 0 && e2.button !== 0)
        return;
      if (e2.currentTarget && e2.currentTarget.getAttribute) {
        const target = e2.currentTarget.getAttribute("target");
        if (/\b_blank\b/i.test(target))
          return;
      }
      if (e2.preventDefault)
        e2.preventDefault();
      return true;
    }
    function includesParams(outer, inner) {
      for (const key2 in inner) {
        const innerValue = inner[key2];
        const outerValue = outer[key2];
        if (typeof innerValue === "string") {
          if (innerValue !== outerValue)
            return false;
        } else {
          if (!isArray$1(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i2) => value !== outerValue[i2]))
            return false;
        }
      }
      return true;
    }
    function getOriginalPath(record) {
      return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
    }
    const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;
    const RouterViewImpl = /* @__PURE__ */ defineComponent({
      name: "RouterView",
      // #674 we manually inherit them
      inheritAttrs: false,
      props: {
        name: {
          type: String,
          default: "default"
        },
        route: Object
      },
      // Better compat for @vue/compat users
      // https://github.com/vuejs/router/issues/1315
      compatConfig: { MODE: 3 },
      setup(props, { attrs, slots }) {
        const injectedRoute = inject(routerViewLocationKey);
        const routeToDisplay = computed(() => props.route || injectedRoute.value);
        const injectedDepth = inject(viewDepthKey, 0);
        const depth = computed(() => {
          let initialDepth = unref(injectedDepth);
          const { matched } = routeToDisplay.value;
          let matchedRoute;
          while ((matchedRoute = matched[initialDepth]) && !matchedRoute.components) {
            initialDepth++;
          }
          return initialDepth;
        });
        const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth.value]);
        provide(viewDepthKey, computed(() => depth.value + 1));
        provide(matchedRouteKey, matchedRouteRef);
        provide(routerViewLocationKey, routeToDisplay);
        const viewRef = ref();
        watch$1(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to2, name], [oldInstance, from, oldName]) => {
          if (to2) {
            to2.instances[name] = instance;
            if (from && from !== to2 && instance && instance === oldInstance) {
              if (!to2.leaveGuards.size) {
                to2.leaveGuards = from.leaveGuards;
              }
              if (!to2.updateGuards.size) {
                to2.updateGuards = from.updateGuards;
              }
            }
          }
          if (instance && to2 && // if there is no instance but to and from are the same this might be
          // the first visit
          (!from || !isSameRouteRecord(to2, from) || !oldInstance)) {
            (to2.enterCallbacks[name] || []).forEach((callback) => callback(instance));
          }
        }, { flush: "post" });
        return () => {
          const route = routeToDisplay.value;
          const currentName = props.name;
          const matchedRoute = matchedRouteRef.value;
          const ViewComponent = matchedRoute && matchedRoute.components[currentName];
          if (!ViewComponent) {
            return normalizeSlot(slots.default, { Component: ViewComponent, route });
          }
          const routePropsOption = matchedRoute.props[currentName];
          const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
          const onVnodeUnmounted = (vnode) => {
            if (vnode.component.isUnmounted) {
              matchedRoute.instances[currentName] = null;
            }
          };
          const component = h$4(ViewComponent, assign({}, routeProps, attrs, {
            onVnodeUnmounted,
            ref: viewRef
          }));
          return (
            // pass the vnode to the slot as a prop.
            // h and <component :is="..."> both accept vnodes
            normalizeSlot(slots.default, { Component: component, route }) || component
          );
        };
      }
    });
    function normalizeSlot(slot, data) {
      if (!slot)
        return null;
      const slotContent = slot(data);
      return slotContent.length === 1 ? slotContent[0] : slotContent;
    }
    const RouterView = RouterViewImpl;
    function createRouter(options) {
      const matcher = createRouterMatcher(options.routes, options);
      const parseQuery$1 = options.parseQuery || parseQuery;
      const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
      const routerHistory = options.history;
      const beforeGuards = useCallbacks();
      const beforeResolveGuards = useCallbacks();
      const afterGuards = useCallbacks();
      const currentRoute = shallowRef(START_LOCATION_NORMALIZED);
      let pendingLocation = START_LOCATION_NORMALIZED;
      if (isBrowser && options.scrollBehavior && "scrollRestoration" in history) {
        history.scrollRestoration = "manual";
      }
      const normalizeParams = applyToParams.bind(null, (paramValue) => "" + paramValue);
      const encodeParams = applyToParams.bind(null, encodeParam);
      const decodeParams = (
        // @ts-expect-error: intentionally avoid the type check
        applyToParams.bind(null, decode)
      );
      function addRoute(parentOrRoute, route) {
        let parent;
        let record;
        if (isRouteName(parentOrRoute)) {
          parent = matcher.getRecordMatcher(parentOrRoute);
          record = route;
        } else {
          record = parentOrRoute;
        }
        return matcher.addRoute(record, parent);
      }
      function removeRoute(name) {
        const recordMatcher = matcher.getRecordMatcher(name);
        if (recordMatcher) {
          matcher.removeRoute(recordMatcher);
        }
      }
      function getRoutes() {
        return matcher.getRoutes().map((routeMatcher) => routeMatcher.record);
      }
      function hasRoute(name) {
        return !!matcher.getRecordMatcher(name);
      }
      function resolve2(rawLocation, currentLocation) {
        currentLocation = assign({}, currentLocation || currentRoute.value);
        if (typeof rawLocation === "string") {
          const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
          const matchedRoute2 = matcher.resolve({ path: locationNormalized.path }, currentLocation);
          const href2 = routerHistory.createHref(locationNormalized.fullPath);
          return assign(locationNormalized, matchedRoute2, {
            params: decodeParams(matchedRoute2.params),
            hash: decode(locationNormalized.hash),
            redirectedFrom: void 0,
            href: href2
          });
        }
        let matcherLocation;
        if (rawLocation.path != null) {
          matcherLocation = assign({}, rawLocation, {
            path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path
          });
        } else {
          const targetParams = assign({}, rawLocation.params);
          for (const key2 in targetParams) {
            if (targetParams[key2] == null) {
              delete targetParams[key2];
            }
          }
          matcherLocation = assign({}, rawLocation, {
            params: encodeParams(targetParams)
          });
          currentLocation.params = encodeParams(currentLocation.params);
        }
        const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
        const hash2 = rawLocation.hash || "";
        matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
        const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {
          hash: encodeHash(hash2),
          path: matchedRoute.path
        }));
        const href = routerHistory.createHref(fullPath);
        return assign({
          fullPath,
          // keep the hash encoded so fullPath is effectively path + encodedQuery +
          // hash
          hash: hash2,
          query: (
            // if the user is using a custom query lib like qs, we might have
            // nested objects, so we keep the query as is, meaning it can contain
            // numbers at `$route.query`, but at the point, the user will have to
            // use their own type anyway.
            // https://github.com/vuejs/router/issues/328#issuecomment-649481567
            stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
          )
        }, matchedRoute, {
          redirectedFrom: void 0,
          href
        });
      }
      function locationAsObject(to2) {
        return typeof to2 === "string" ? parseURL(parseQuery$1, to2, currentRoute.value.path) : assign({}, to2);
      }
      function checkCanceledNavigation(to2, from) {
        if (pendingLocation !== to2) {
          return createRouterError(8, {
            from,
            to: to2
          });
        }
      }
      function push(to2) {
        return pushWithRedirect(to2);
      }
      function replace(to2) {
        return push(assign(locationAsObject(to2), { replace: true }));
      }
      function handleRedirectRecord(to2) {
        const lastMatched = to2.matched[to2.matched.length - 1];
        if (lastMatched && lastMatched.redirect) {
          const { redirect } = lastMatched;
          let newTargetLocation = typeof redirect === "function" ? redirect(to2) : redirect;
          if (typeof newTargetLocation === "string") {
            newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) : (
              // force empty params
              { path: newTargetLocation }
            );
            newTargetLocation.params = {};
          }
          return assign({
            query: to2.query,
            hash: to2.hash,
            // avoid transferring params if the redirect has a path
            params: newTargetLocation.path != null ? {} : to2.params
          }, newTargetLocation);
        }
      }
      function pushWithRedirect(to2, redirectedFrom) {
        const targetLocation = pendingLocation = resolve2(to2);
        const from = currentRoute.value;
        const data = to2.state;
        const force = to2.force;
        const replace2 = to2.replace === true;
        const shouldRedirect = handleRedirectRecord(targetLocation);
        if (shouldRedirect)
          return pushWithRedirect(
            assign(locationAsObject(shouldRedirect), {
              state: typeof shouldRedirect === "object" ? assign({}, data, shouldRedirect.state) : data,
              force,
              replace: replace2
            }),
            // keep original redirectedFrom if it exists
            redirectedFrom || targetLocation
          );
        const toLocation = targetLocation;
        toLocation.redirectedFrom = redirectedFrom;
        let failure;
        if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {
          failure = createRouterError(16, { to: toLocation, from });
          handleScroll(
            from,
            from,
            // this is a push, the only way for it to be triggered from a
            // history.listen is with a redirect, which makes it become a push
            true,
            // This cannot be the first navigation because the initial location
            // cannot be manually navigated to
            false
          );
        }
        return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch((error) => isNavigationFailure(error) ? (
          // navigation redirects still mark the router as ready
          isNavigationFailure(
            error,
            2
            /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
          ) ? error : markAsReady(error)
        ) : (
          // reject any unknown error
          triggerError(error, toLocation, from)
        )).then((failure2) => {
          if (failure2) {
            if (isNavigationFailure(
              failure2,
              2
              /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
            )) {
              return pushWithRedirect(
                // keep options
                assign({
                  // preserve an existing replacement but allow the redirect to override it
                  replace: replace2
                }, locationAsObject(failure2.to), {
                  state: typeof failure2.to === "object" ? assign({}, data, failure2.to.state) : data,
                  force
                }),
                // preserve the original redirectedFrom if any
                redirectedFrom || toLocation
              );
            }
          } else {
            failure2 = finalizeNavigation(toLocation, from, true, replace2, data);
          }
          triggerAfterEach(toLocation, from, failure2);
          return failure2;
        });
      }
      function checkCanceledNavigationAndReject(to2, from) {
        const error = checkCanceledNavigation(to2, from);
        return error ? Promise.reject(error) : Promise.resolve();
      }
      function runWithContext(fn2) {
        const app2 = installedApps.values().next().value;
        return app2 && typeof app2.runWithContext === "function" ? app2.runWithContext(fn2) : fn2();
      }
      function navigate(to2, from) {
        let guards;
        const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to2, from);
        guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to2, from);
        for (const record of leavingRecords) {
          record.leaveGuards.forEach((guard) => {
            guards.push(guardToPromiseFn(guard, to2, from));
          });
        }
        const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to2, from);
        guards.push(canceledNavigationCheck);
        return runGuardQueue(guards).then(() => {
          guards = [];
          for (const guard of beforeGuards.list()) {
            guards.push(guardToPromiseFn(guard, to2, from));
          }
          guards.push(canceledNavigationCheck);
          return runGuardQueue(guards);
        }).then(() => {
          guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to2, from);
          for (const record of updatingRecords) {
            record.updateGuards.forEach((guard) => {
              guards.push(guardToPromiseFn(guard, to2, from));
            });
          }
          guards.push(canceledNavigationCheck);
          return runGuardQueue(guards);
        }).then(() => {
          guards = [];
          for (const record of enteringRecords) {
            if (record.beforeEnter) {
              if (isArray$1(record.beforeEnter)) {
                for (const beforeEnter of record.beforeEnter)
                  guards.push(guardToPromiseFn(beforeEnter, to2, from));
              } else {
                guards.push(guardToPromiseFn(record.beforeEnter, to2, from));
              }
            }
          }
          guards.push(canceledNavigationCheck);
          return runGuardQueue(guards);
        }).then(() => {
          to2.matched.forEach((record) => record.enterCallbacks = {});
          guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to2, from, runWithContext);
          guards.push(canceledNavigationCheck);
          return runGuardQueue(guards);
        }).then(() => {
          guards = [];
          for (const guard of beforeResolveGuards.list()) {
            guards.push(guardToPromiseFn(guard, to2, from));
          }
          guards.push(canceledNavigationCheck);
          return runGuardQueue(guards);
        }).catch((err) => isNavigationFailure(
          err,
          8
          /* ErrorTypes.NAVIGATION_CANCELLED */
        ) ? err : Promise.reject(err));
      }
      function triggerAfterEach(to2, from, failure) {
        afterGuards.list().forEach((guard) => runWithContext(() => guard(to2, from, failure)));
      }
      function finalizeNavigation(toLocation, from, isPush, replace2, data) {
        const error = checkCanceledNavigation(toLocation, from);
        if (error)
          return error;
        const isFirstNavigation = from === START_LOCATION_NORMALIZED;
        const state = !isBrowser ? {} : history.state;
        if (isPush) {
          if (replace2 || isFirstNavigation)
            routerHistory.replace(toLocation.fullPath, assign({
              scroll: isFirstNavigation && state && state.scroll
            }, data));
          else
            routerHistory.push(toLocation.fullPath, data);
        }
        currentRoute.value = toLocation;
        handleScroll(toLocation, from, isPush, isFirstNavigation);
        markAsReady();
      }
      let removeHistoryListener;
      function setupListeners() {
        if (removeHistoryListener)
          return;
        removeHistoryListener = routerHistory.listen((to2, _from, info) => {
          if (!router2.listening)
            return;
          const toLocation = resolve2(to2);
          const shouldRedirect = handleRedirectRecord(toLocation);
          if (shouldRedirect) {
            pushWithRedirect(assign(shouldRedirect, { replace: true }), toLocation).catch(noop$1);
            return;
          }
          pendingLocation = toLocation;
          const from = currentRoute.value;
          if (isBrowser) {
            saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());
          }
          navigate(toLocation, from).catch((error) => {
            if (isNavigationFailure(
              error,
              4 | 8
              /* ErrorTypes.NAVIGATION_CANCELLED */
            )) {
              return error;
            }
            if (isNavigationFailure(
              error,
              2
              /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
            )) {
              pushWithRedirect(
                error.to,
                toLocation
                // avoid an uncaught rejection, let push call triggerError
              ).then((failure) => {
                if (isNavigationFailure(
                  failure,
                  4 | 16
                  /* ErrorTypes.NAVIGATION_DUPLICATED */
                ) && !info.delta && info.type === NavigationType.pop) {
                  routerHistory.go(-1, false);
                }
              }).catch(noop$1);
              return Promise.reject();
            }
            if (info.delta) {
              routerHistory.go(-info.delta, false);
            }
            return triggerError(error, toLocation, from);
          }).then((failure) => {
            failure = failure || finalizeNavigation(
              // after navigation, all matched components are resolved
              toLocation,
              from,
              false
            );
            if (failure) {
              if (info.delta && // a new navigation has been triggered, so we do not want to revert, that will change the current history
              // entry while a different route is displayed
              !isNavigationFailure(
                failure,
                8
                /* ErrorTypes.NAVIGATION_CANCELLED */
              )) {
                routerHistory.go(-info.delta, false);
              } else if (info.type === NavigationType.pop && isNavigationFailure(
                failure,
                4 | 16
                /* ErrorTypes.NAVIGATION_DUPLICATED */
              )) {
                routerHistory.go(-1, false);
              }
            }
            triggerAfterEach(toLocation, from, failure);
          }).catch(noop$1);
        });
      }
      let readyHandlers = useCallbacks();
      let errorListeners = useCallbacks();
      let ready;
      function triggerError(error, to2, from) {
        markAsReady(error);
        const list = errorListeners.list();
        if (list.length) {
          list.forEach((handler) => handler(error, to2, from));
        } else {
          console.error(error);
        }
        return Promise.reject(error);
      }
      function isReady() {
        if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
          return Promise.resolve();
        return new Promise((resolve22, reject) => {
          readyHandlers.add([resolve22, reject]);
        });
      }
      function markAsReady(err) {
        if (!ready) {
          ready = !err;
          setupListeners();
          readyHandlers.list().forEach(([resolve22, reject]) => err ? reject(err) : resolve22());
          readyHandlers.reset();
        }
        return err;
      }
      function handleScroll(to2, from, isPush, isFirstNavigation) {
        const { scrollBehavior } = options;
        if (!isBrowser || !scrollBehavior)
          return Promise.resolve();
        const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to2.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
        return nextTick().then(() => scrollBehavior(to2, from, scrollPosition)).then((position) => position && scrollToPosition(position)).catch((err) => triggerError(err, to2, from));
      }
      const go2 = (delta) => routerHistory.go(delta);
      let started;
      const installedApps = /* @__PURE__ */ new Set();
      const router2 = {
        currentRoute,
        listening: true,
        addRoute,
        removeRoute,
        hasRoute,
        getRoutes,
        resolve: resolve2,
        options,
        push,
        replace,
        go: go2,
        back: () => go2(-1),
        forward: () => go2(1),
        beforeEach: beforeGuards.add,
        beforeResolve: beforeResolveGuards.add,
        afterEach: afterGuards.add,
        onError: errorListeners.add,
        isReady,
        install(app2) {
          const router22 = this;
          app2.component("RouterLink", RouterLink);
          app2.component("RouterView", RouterView);
          app2.config.globalProperties.$router = router22;
          Object.defineProperty(app2.config.globalProperties, "$route", {
            enumerable: true,
            get: () => unref(currentRoute)
          });
          if (isBrowser && // used for the initial navigation client side to avoid pushing
          // multiple times when the router is used in multiple apps
          !started && currentRoute.value === START_LOCATION_NORMALIZED) {
            started = true;
            push(routerHistory.location).catch((err) => {
            });
          }
          const reactiveRoute = {};
          for (const key2 in START_LOCATION_NORMALIZED) {
            Object.defineProperty(reactiveRoute, key2, {
              get: () => currentRoute.value[key2],
              enumerable: true
            });
          }
          app2.provide(routerKey, router22);
          app2.provide(routeLocationKey, shallowReactive(reactiveRoute));
          app2.provide(routerViewLocationKey, currentRoute);
          const unmountApp = app2.unmount;
          installedApps.add(app2);
          app2.unmount = function() {
            installedApps.delete(app2);
            if (installedApps.size < 1) {
              pendingLocation = START_LOCATION_NORMALIZED;
              removeHistoryListener && removeHistoryListener();
              removeHistoryListener = null;
              currentRoute.value = START_LOCATION_NORMALIZED;
              started = false;
              ready = false;
            }
            unmountApp();
          };
        }
      };
      function runGuardQueue(guards) {
        return guards.reduce((promise, guard) => promise.then(() => runWithContext(guard)), Promise.resolve());
      }
      return router2;
    }
    function extractChangingRecords(to2, from) {
      const leavingRecords = [];
      const updatingRecords = [];
      const enteringRecords = [];
      const len = Math.max(from.matched.length, to2.matched.length);
      for (let i2 = 0; i2 < len; i2++) {
        const recordFrom = from.matched[i2];
        if (recordFrom) {
          if (to2.matched.find((record) => isSameRouteRecord(record, recordFrom)))
            updatingRecords.push(recordFrom);
          else
            leavingRecords.push(recordFrom);
        }
        const recordTo = to2.matched[i2];
        if (recordTo) {
          if (!from.matched.find((record) => isSameRouteRecord(record, recordTo))) {
            enteringRecords.push(recordTo);
          }
        }
      }
      return [leavingRecords, updatingRecords, enteringRecords];
    }
    const useConfigStore = defineStore("config", {
      state: () => ({
        versionMajor: 0,
        versionMinor: 13,
        versionPatch: 12,
        regionUrls: {
          dev: {
            ldpjs: "http://localhost:9401/api-staging/",
            util: "http://localhost:9401/util/",
            utilLang: "http://localhost:9401/util-lang/",
            scriptshifter: "http://localhost:9401/scriptshifter/",
            publish: "http://localhost:9401/util/publish/staging",
            bfdb: "https://preprod-8230.id.loc.gov/",
            profiles: "http://localhost:9401/util/profiles/profile/prod",
            starting: "http://localhost:9401/util/profiles/starting/prod",
            profiles: "https://raw.githubusercontent.com/lcnetdev/bfe-profiles/main/profile-prod/data.json",
            starting: "https://raw.githubusercontent.com/lcnetdev/bfe-profiles/main/starting-prod/data.json",
            id: "https://id.loc.gov/",
            env: "staging",
            dev: true,
            displayLCOnlyFeatures: true
          },
          staging: {
            ldpjs: "https://preprod-3001.id.loc.gov/bfe2/api-staging/",
            util: "https://preprod-3001.id.loc.gov/bfe2/util/",
            utilLang: "https://editor.id.loc.gov/bfe2/util-lang/",
            scriptshifter: "https://editor.id.loc.gov/bfe2/scriptshifter/",
            publish: "https://preprod-3001.id.loc.gov/bfe2/util/publish/staging",
            bfdb: "https://preprod-8230.id.loc.gov/",
            profiles: "/bfe2/util/profiles/profile/stage",
            // profiles: 'https://preprod-3001.id.loc.gov/api/listconfigs?where=index.resourceType:profile',
            starting: "/bfe2/util/profiles/starting/stage",
            id: "https://preprod-8080.id.loc.gov/",
            env: "staging",
            displayLCOnlyFeatures: true
          },
          production: {
            ldpjs: "https://editor.id.loc.gov/bfe2/api-production/",
            util: "https://editor.id.loc.gov/bfe2/util/",
            utilLang: "https://editor.id.loc.gov/bfe2/util-lang/",
            scriptshifter: "https://editor.id.loc.gov/bfe2/scriptshifter/",
            publish: "https://editor.id.loc.gov/bfe2/util/publish/production",
            bfdb: "https://preprod-8230.id.loc.gov/",
            bfdbGPO: "https://preprod-8210.id.loc.gov/",
            // profiles : 'https://editor.id.loc.gov/api/listconfigs?where=index.resourceType:profile',
            // starting : 'https://editor.id.loc.gov/api/listconfigs?where=index.resourceType:startingPoints&where=index.label:config',
            profiles: "/bfe2/util/profiles/profile/prod",
            starting: "/bfe2/util/profiles/starting/prod",
            id: "https://preprod-8080.id.loc.gov/",
            env: "production",
            displayLCOnlyFeatures: true
          },
          bibframeDotOrg: {
            ldpjs: "https://bibframe.org/marva/api-production/",
            util: "https://bibframe.org/marva/util/",
            utilLang: "https://bibframe.org/marva/util-lang/",
            scriptshifter: "https://bibframe.org/marva/scriptshifter/",
            publish: "https://bibframe.org/marva/util/publish/production",
            bfdb: "https://id.loc.gov/",
            profiles: "https://bibframe.org/marva/util/profiles/profile/prod",
            starting: "https://bibframe.org/marva/util/profiles/starting/prod",
            id: "https://preprod-8080.id.loc.gov/",
            env: "production",
            publicEndpoints: true,
            displayLCOnlyFeatures: false
          }
        },
        postUsingAlmaXmlFormat: false,
        // used in the profile store, if the profle name ends with one of these it is a top level resource template
        validTopLevelProfileSufixes: [":Work", ":Item", ":Instance", ":Hub"],
        validTopLevelWork: ":Work",
        validTopLevelItem: ":Item",
        validTopLevelInstance: ":Instance",
        validTopLevelHub: ":Hub",
        // the base URLS, used when building URIs for new resources
        baseURIWork: "http://id.loc.gov/resources/works/",
        baseURIInstance: "http://id.loc.gov/resources/instances/",
        baseURIItem: "http://id.loc.gov/resources/items/",
        baseURIHub: "http://id.loc.gov/resources/hubs/",
        // this value goes into the admin metadata to tell BFDB what type of action to take, this value is when a new work instance is being created
        procInfoNewWorkInstance: "create work",
        profileHacks: {
          // UI display flags
          agentsHideManualRDFLabelIfURIProvided: { enabled: true, desc: "If the <agent> has a URI don't populate the manual label field, only if there is no URI in the node populate" },
          // Parsing the profile flags
          profileParseFixLowerCaseContribution: { enabled: true, desc: " someplaces lc:RT:bf2:Agents:Contribution is set to lc:RT:bf2:Agents:contribution (lowercase C) change it when lowercase to 'lc:RT:bf2:Agents:Contribution'" },
          profileParseFixPropertyURIWhenUpperCase: { enabled: true, desc: "Sometimes a class is used in the propertyURI field? /Role instead of /role for example, change them to camel case when not lowercase" },
          removeExtraFieldsInContributor: { enabled: true, desc: "Remove things like bflc:name00MatchKey bflc:primaryContributorName00MatchKey bflc:name00MarcKey fron contributor tags" }
        },
        // this is a list of properties that will be ignored in the literal language model box
        literalLangOptions: {
          ignorePtURIs: [
            "http://id.loc.gov/ontologies/bibframe/provisionActivity",
            "http://id.loc.gov/ontologies/bibframe/supplementaryContent",
            "http://id.loc.gov/ontologies/bibframe/subject",
            "http://id.loc.gov/ontologies/bflc/aap-normalized",
            "http://id.loc.gov/ontologies/bflc/aap",
            "http://id.loc.gov/ontologies/bibframe/shelfMark",
            "http://id.loc.gov/ontologies/bibframe/classification",
            "http://id.loc.gov/ontologies/bibframe/dimensions",
            "http://id.loc.gov/ontologies/bibframe/extent",
            "http://id.loc.gov/ontologies/bibframe/notation"
          ]
        },
        checkForRepeatedLiterals: [
          "http://id.loc.gov/ontologies/bibframe/mainTitle",
          "http://id.loc.gov/ontologies/bibframe/subtitle",
          "http://www.w3.org/2000/01/rdf-schema#label",
          "http://id.loc.gov/ontologies/bibframe/date"
        ],
        // these are the predicate fields that allow you to add another literal value
        // for the literals in the component if the proifle has literal-lang somewhere in it
        allowLiteralRepeatForNonRomain: [
          "http://id.loc.gov/ontologies/bibframe/title",
          "http://id.loc.gov/ontologies/bibframe/provisionActivity",
          "http://id.loc.gov/ontologies/bibframe/agent"
        ],
        // these are properties that aren't allowed to be both when merging data with template
        templatesDataFlowCantBeBoth: [
          "id.loc.gov/ontologies/bibframe/adminMetadata"
        ],
        // these are not template-able properties
        templatesDataFlowHide: [
          "id.loc.gov/ontologies/bibframe/instanceOf",
          "http://id.loc.gov/ontologies/bibframe/hasInstance"
        ],
        // use the subject editor not the complex lookup modal when it has this propertyURI value
        useSubjectEditor: [
          "http://www.loc.gov/mads/rdf/v1#Topic",
          "http://www.loc.gov/mads/rdf/v1#componentList"
        ],
        lookupConfig: {
          "http://id.loc.gov/authorities/childrensSubjects": { "name": "childrensSubjects", "type": "complex", "modes": [] },
          "http://id.loc.gov/authorities/demographicTerms": { "name": "demographicTerms", "type": "complex", "modes": [] },
          "http://id.loc.gov/authorities/genreForms": {
            "name": "genreForms",
            "type": "complex",
            "processor": "lcAuthorities",
            "modes": [
              {
                "LCGFT All": { "url": "https://id.loc.gov/authorities/genreForms/suggest2/?q=<QUERY>&count=25", "all": true }
              }
            ]
          },
          "http://id.loc.gov/authorities/names": {
            "name": "names",
            "type": "complex",
            "processor": "lcAuthorities",
            "modes": [
              {
                "NAF All": { "url": "https://id.loc.gov/authorities/names/suggest2/?q=<QUERY>&count=25", "all": true },
                "NAF Personal Names": { "url": "https://id.loc.gov/authorities/names/suggest2/?q=<QUERY>&rdftype=PersonalName&count=25" },
                "NAF Corporate Name": { "url": "https://id.loc.gov/authorities/names/suggest2/?q=<QUERY>&rdftype=CorporateName&count=25" },
                "NAF Name/Title": { "url": "https://id.loc.gov/authorities/names/suggest2/?q=<QUERY>&rdftype=NameTitle&count=25" },
                "NAF Title": { "url": "https://id.loc.gov/authorities/names/suggest2/?q=<QUERY>&rdftype=Title&count=25" },
                "NAF Geographic": { "url": "https://id.loc.gov/authorities/names/suggest2/?q=<QUERY>&rdftype=Geographic&count=25" },
                "NAF Conference Name": { "url": "https://id.loc.gov/authorities/names/suggest2/?q=<QUERY>&rdftype=ConferenceName&count=25" }
              }
            ]
          },
          "http://preprod.id.loc.gov/authorities/names": {
            "name": "names",
            "type": "complex",
            "processor": "lcAuthorities",
            "modes": [
              {
                "NAF All": { "url": "http://preprod.id.loc.gov/authorities/names/suggest2/?q=<QUERY>&count=25", "all": true },
                "NAF Personal Names": { "url": "http://preprod.id.loc.gov/authorities/names/suggest2/?q=<QUERY>&rdftype=PersonalName&count=25" },
                "NAF Corporate Name": { "url": "http://preprod.id.loc.gov/authorities/names/suggest2/?q=<QUERY>&rdftype=CorporateName&count=25" },
                "NAF Name/Title": { "url": "http://preprod.id.loc.gov/authorities/names/suggest2/?q=<QUERY>&rdftype=NameTitle&count=25" },
                "NAF Title": { "url": "http://preprod.id.loc.gov/authorities/names/suggest2/?q=<QUERY>&rdftype=Title&count=25" },
                "NAF Geographic": { "url": "http://preprod.id.loc.gov/authorities/names/suggest2/?q=<QUERY>&rdftype=Geographic&count=25" },
                "NAF Conference Name": { "url": "http://preprod.id.loc.gov/authorities/names/suggest2/?q=<QUERY>&rdftype=ConferenceName&count=25" }
              }
            ]
          },
          "http://id.loc.gov/authorities/performanceMediums": { "name": "Works", "processor": "lcAuthorities", "type": "complex", "modes": [
            {
              "All": { "url": "http://id.loc.gov/authorities/performanceMediums/suggest2/?q=<QUERY>&count=25", "all": true }
            }
          ] },
          "http://id.loc.gov/authorities/subjects": {
            "name": "subjects",
            "type": "complex",
            "processor": "lcAuthorities",
            "modes": [
              {
                "LCSH All": { "url": "https://id.loc.gov/authorities/subjects/suggest2/?q=<QUERY>&count=25", "all": true },
                "LCSH Topics": { "url": "https://id.loc.gov/authorities/subjects/suggest2/?q=<QUERY>&rdftype=Topic&count=25" },
                "LCSH Geographic": { "url": "https://id.loc.gov/authorities/subjects/suggest2/?q=<QUERY>&rdftype=Geographic&count=25" },
                "LCSH Name": { "url": "https://id.loc.gov/authorities/subjects/suggest2/?q=<QUERY>&rdftype=Name&count=25" },
                "LCSH FamilyName": { "url": "https://id.loc.gov/authorities/subjects/suggest2/?q=<QUERY>&rdftype=FamilyName&count=25" },
                "LCSH CorporateName": { "url": "https://id.loc.gov/authorities/subjects/suggest2/?q=<QUERY>&rdftype=CorporateName&count=25" },
                "LCSH GenreForm": { "url": "https://id.loc.gov/authorities/subjects/suggest2/?q=<QUERY>&rdftype=GenreForm&count=25" },
                "LCSH Simple Type": { "url": "https://id.loc.gov/authorities/subjects/suggest2/?q=<QUERY>&rdftype=SimpleType&count=25" },
                "LCSH Complex Subject": { "url": "https://id.loc.gov/authorities/subjects/suggest2/?q=<QUERY>&rdftype=ComplexSubject&count=25" },
                "LCSH Temporal": { "url": "https://id.loc.gov/authorities/subjects/suggest2/?q=<QUERY>&rdftype=Temporal&count=25" }
              }
            ]
          },
          "HierarchicalGeographic": {
            "name": "names",
            "type": "complex",
            "processor": "lcAuthorities",
            "modes": [
              {
                "All": { "url": "https://preprod-8288.id.loc.gov/authorities/names/suggest2/?q=<QUERY>&count=25&rdftype=HierarchicalGeographic", "all": true }
              }
            ]
          },
          "http://id.loc.gov/entities/providers": { "name": "providers", "type": "complex", "modes": [] },
          "http://id.loc.gov/entities/relationships": { "name": "relationships", "processor": "lcAuthorities", "type": "complex", "modes": [
            {
              "All": { "url": "https://id.loc.gov/entities/relationships/suggest2/?q=<QUERY>&count=25", "all": true }
            }
          ] },
          "http://id.loc.gov/vocabulary/geographicAreas": { "name": "geographicAreas", "processor": "lcAuthorities", "type": "complex", "minCharBeforeSearch": 2, "modes": [
            {
              "All": { "url": "https://id.loc.gov/vocabulary/geographicAreas/suggest2/?q=<QUERY>&count=25", "all": true }
            }
          ] },
          "https://preprod-8230.id.loc.gov/resources/works": { "name": "Works", "processor": "lcAuthorities", "type": "complex", "modes": [
            {
              "Works - Keyword": { "url": "https://preprod-8080.id.loc.gov/resources/works/suggest2/?q=?<QUERY>&count=25", "all": true },
              "Works - Left Anchored": { "url": "https://preprod-8080.id.loc.gov/resources/works/suggest2/?q=<QUERY>&count=25" },
              "Hubs - Keyword": { "url": "https://preprod-8080.id.loc.gov/resources/hubs/suggest2/?q=?<QUERY>&count=25" },
              "Hubs - Left Anchored": { "url": "https://preprod-8080.id.loc.gov/resources/hubs/suggest2/?q=<QUERY>&count=25" }
            }
          ] },
          "https://preprod-8295.id.loc.gov/resources/works": { "name": "Works", "processor": "lcAuthorities", "type": "complex", "modes": [
            {
              "Works - Keyword": { "url": "https://preprod-8295.id.loc.gov/resources/works/suggest2/?q=?<QUERY>&count=25", "all": true },
              "Works - Left Anchored": { "url": "https://preprod-8295.id.loc.gov/resources/works/suggest2/?q=<QUERY>&count=25" },
              "Hubs - Keyword": { "url": "https://preprod-8295.id.loc.gov/resources/hubs/suggest2/?q=?<QUERY>&count=25" },
              "Hubs - Left Anchored": { "url": "https://preprod-8295.id.loc.gov/resources/hubs/suggest2/?q=<QUERY>&count=25" }
            }
          ] },
          "https://preprod-8210.id.loc.gov/resources/works/": { "name": "Works", "processor": "lcAuthorities", "type": "complex", "modes": [
            {
              "Works - Keyword": { "url": "https://preprod-8295.id.loc.gov/resources/works/suggest2/?q=?<QUERY>&count=25", "all": true },
              "Works - Left Anchored": { "url": "https://preprod-8295.id.loc.gov/resources/works/suggest2/?q=<QUERY>&count=25" },
              "Hubs - Keyword": { "url": "https://preprod-8295.id.loc.gov/resources/hubs/suggest2/?q=?<QUERY>&count=25" },
              "Hubs - Left Anchored": { "url": "https://preprod-8295.id.loc.gov/resources/hubs/suggest2/?q=<QUERY>&count=25" }
            }
          ] },
          "https://preprod-8295.id.loc.gov/resources/works/": { "name": "Works", "processor": "lcAuthorities", "type": "complex", "modes": [
            {
              "Works - Keyword": { "url": "https://preprod-8295.id.loc.gov/resources/works/suggest2/?q=?<QUERY>&count=25", "all": true },
              "Works - Left Anchored": { "url": "https://preprod-8295.id.loc.gov/resources/works/suggest2/?q=<QUERY>&count=25" },
              "Hubs - Keyword": { "url": "https://preprod-8295.id.loc.gov/resources/hubs/suggest2/?q=?<QUERY>&count=25" },
              "Hubs - Left Anchored": { "url": "https://preprod-8295.id.loc.gov/resources/hubs/suggest2/?q=<QUERY>&count=25" }
            }
          ] },
          "https://preprod-8080.id.loc.gov/resources/works": { "name": "Works", "processor": "lcAuthorities", "type": "complex", "modes": [
            {
              "Works - Keyword": { "url": "https://preprod-8080.id.loc.gov/resources/works/suggest2/?q=?<QUERY>&count=25", "all": true },
              "Works - Left Anchored": { "url": "https://preprod-8080.id.loc.gov/resources/works/suggest2/?q=<QUERY>&count=25" },
              "Hubs - Keyword": { "url": "https://preprod-8080.id.loc.gov/resources/hubs/suggest2/?q=?<QUERY>&count=25" },
              "Hubs - Left Anchored": { "url": "https://preprod-8080.id.loc.gov/resources/hubs/suggest2/?q=<QUERY>&count=25" }
            }
          ] },
          "https://preprod-8080.id.loc.gov/resources/works/": { "name": "Works", "processor": "lcAuthorities", "type": "complex", "modes": [
            {
              "Works - Keyword": { "url": "https://preprod-8080.id.loc.gov/resources/works/suggest2/?q=?<QUERY>&count=25", "all": true },
              "Works - Left Anchored": { "url": "https://preprod-8080.id.loc.gov/resources/works/suggest2/?q=<QUERY>&count=25" },
              "Hubs - Keyword": { "url": "https://preprod-8080.id.loc.gov/resources/hubs/suggest2/?q=?<QUERY>&count=25" },
              "Hubs - Left Anchored": { "url": "https://preprod-8080.id.loc.gov/resources/hubs/suggest2/?q=<QUERY>&count=25" }
            }
          ] },
          "https://id.loc.gov/resources/hubs": { "name": "Works", "processor": "lcAuthorities", "type": "complex", "modes": [
            {
              "Hubs - Keyword": { "url": "https://preprod-8080.id.loc.gov/resources/hubs/suggest2/?q=?<QUERY>&count=25", "all": true },
              "Hubs - Left Anchored": { "url": "https://preprod-8080.id.loc.gov/resources/hubs/suggest2/?q=<QUERY>&count=25" }
            }
          ] },
          "https://preprod-8080.id.loc.gov/resources/hubs": { "name": "Hubs", "processor": "lcAuthorities", "type": "complex", "modes": [
            {
              "Hubs - Keyword": { "url": "https://preprod-8080.id.loc.gov/resources/hubs/suggest2/?q=?<QUERY>&count=25", "all": true },
              "Hubs - Left Anchored": { "url": "https://preprod-8080.id.loc.gov/resources/hubs/suggest2/?q=<QUERY>&count=25" }
            }
          ] },
          "https://preprod-8080.id.loc.gov/resources/instances": { "name": "Instances", "processor": "lcAuthorities", "type": "complex", "modes": [
            {
              "All": { "url": "https://preprod-8080.id.loc.gov/resources/instances/suggest2/?q=<QUERY>&count=25", "all": true }
            }
          ] },
          "https://preprod-8230.id.loc.gov/resources/instances": { "name": "Instances", "processor": "lcAuthorities", "type": "complex", "modes": [
            {
              "All": { "url": "https://preprod-8080.id.loc.gov/resources/instances/suggest2/?q=<QUERY>&count=25", "all": true }
            }
          ] },
          "http://id.loc.gov/entities/roles": { "name": "roles", "type": "complex", "modes": [] },
          "http://id.loc.gov/resources/works": { "name": "works", "type": "complex", "modes": [] },
          "http://id.loc.gov/rwo/agents": { "name": "agents", "type": "complex", "modes": [] },
          "http://id.loc.gov/vocabulary/carriers": { "name": "carriers", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/classSchemes": { "name": "classSchemes", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/contentTypes": { "name": "contentTypes", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/countries": { "name": "countries", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/descriptionConventions": { "name": "descriptionConventions", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/frequencies": { "name": "frequencies", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/genreFormSchemes": { "name": "genreFormSchemes", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/graphicMaterials": { "name": "graphicMaterials", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/issuance": { "name": "issuance", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/languages": { "name": "languages", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/marcauthen": { "name": "marcauthen", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/marcgt": { "name": "marcgt", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/maspect": { "name": "maspect", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/maudience": { "name": "maudience", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/mbroadstd": { "name": "mbroadstd", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/mcapturestorage": { "name": "mcapturestorage", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/mcolor": { "name": "mcolor", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/mediaTypes": { "name": "mediaTypes", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/menclvl": { "name": "menclvl", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/mfiletype": { "name": "mfiletype", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/mgeneration": { "name": "mgeneration", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/mgroove": { "name": "mgroove", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/millus": { "name": "millus", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/mlayout": { "name": "mlayout", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/mmaterial": { "name": "mmaterial", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/mmusicformat": { "name": "mmusicformat", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/mmusnotation": { "name": "mmusnotation", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/mplayback": { "name": "mplayback", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/mpolarity": { "name": "mpolarity", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/mpresformat": { "name": "mpresformat", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/mproduction": { "name": "mproduction", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/mrecmedium": { "name": "mrecmedium", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/mrectype": { "name": "mrectype", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/mregencoding": { "name": "mregencoding", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/mrelief": { "name": "mrelief", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/mscale": { "name": "mscale", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/mscript": { "name": "mscript", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/msoundcontent": { "name": "msoundcontent", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/mspecplayback": { "name": "mspecplayback", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/mstatus": { "name": "mstatus", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/msupplcont": { "name": "msupplcont", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/mtechnique": { "name": "mtechnique", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/organizations": { "name": "organizations", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/relators": { "name": "relators", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/resourceComponents": { "name": "resourceComponents", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/resourceTypes": { "name": "resourceTypes", "type": "simple", "modes": [] },
          "http://id.loc.gov/vocabulary/subjectSchemes": { "name": "subjectSchemes", "type": "simple", "modes": [] },
          "http://mlvlp04.loc.gov:3000/verso/api/configs?filter[where][configType]=noteTypes&filter[fields][json]=true": { "name": "true", "type": "simple", "modes": [] },
          "http://mlvlp04.loc.gov:8080/authorities/classification/G": { "name": "G", "type": "simple", "modes": [] },
          "http://mlvlp04.loc.gov:8230/resources/instances": { "name": "instances", "type": "simple", "modes": [] },
          "http://mlvlp04.loc.gov:8230/resources/works": { "name": "works", "type": "simple", "modes": [] },
          "http://mlvlp06.loc.gov:8288/resources/hubs": { "name": "hubs", "type": "simple", "modes": [] },
          "http://mlvlp06.loc.gov:8288/resources/works": { "name": "works", "type": "simple", "modes": [] },
          "http://rdaregistry.info/termList/RDAContentType/": { "name": "RDAContentType/", "type": "simple", "modes": [] },
          "http://www.rdaregistry.info/termList/RDAColourContent/": { "name": "RDAColourContent/", "type": "simple", "modes": [] },
          "https://lookup.ld4l.org/authorities/search/linked_data/dbpedia_ld4l_cache": { "name": "dbpedia_ld4l_cache", "type": "simple", "modes": [] },
          "https://lookup.ld4l.org/authorities/search/linked_data/getty_aat_ld4l_cache": { "name": "getty_aat_ld4l_cache", "type": "simple", "modes": [] },
          "https://www.wikidata.org/w/api.php": {
            "name": "wikidata",
            "type": "complex",
            "processor": "wikidataAPI",
            "modes": [
              {
                "Wikidata": { "url": "https://www.wikidata.org/w/api.php?action=wbsearchentities&search=<QUERY>&format=json&errorformat=plaintext&language=en&uselang=en&type=item&origin=*", "all": true }
              }
            ]
          }
        },
        testData: [
          {
            filename: "21890923.convertedit-pkg.xml",
            desc: "monograph - Michelle Obama, Becoming"
          },
          {
            filename: "19768691.editor-pkg.xml",
            desc: "periodical - Tax administration and procedure"
          },
          {
            filename: "22835043.convertedit-pkg.xml",
            desc: "moving image - Nostradamus effect"
          }
        ]
      }),
      getters: {
        /**
        * Returns the part of the config based on the current URL (or enviornment)
        * @return {object} - The url config object
        */
        returnUrls: (state) => {
          if (typeof window !== "undefined") {
            if (window && (window.location.href.startsWith("http://localhost") || window.location.href.startsWith("http://127.0.0.1"))) {
              return state.regionUrls.dev;
            } else if (window && window.location.href.startsWith("https://preprod-3001")) {
              return state.regionUrls.staging;
            } else if (window && window.location.href.startsWith("https://editor.id")) {
              return state.regionUrls.production;
            } else if (window && window.location.href.includes("bibframe.org/marva")) {
              return state.regionUrls.bibframeDotOrg;
            } else {
              return state.regionUrls.dev;
            }
          } else {
            return state.regionUrls.dev;
          }
        }
      },
      actions: {
        /**
        * Take a url and rewrites it to match the url pattern of the current enviornment
        * @param {string} url - the url to modfidfy
        * @return {string} - the url modified to the match the env
        */
        convertToRegionUrl(url) {
          let urls = this.returnUrls;
          if ((url.includes("/works/") || url.includes("/instances/") || url.includes("/items/") || url.includes("/hubs/")) && url.includes("http://id.loc.gov")) {
            url = url.replace("http://id.loc.gov/", urls.bfdb);
          }
          return url;
        }
      }
    });
    const usePreferenceStore = defineStore("preference", {
      state: () => ({
        // controls showing the modal that is parked in the App.vue
        showPrefModal: false,
        // which group to display in the modal
        showPrefModalGroup: "Sidebars - Property",
        showDebugModal: false,
        debugModalData: {},
        showScriptshifterConfigModal: false,
        scriptShifterOptions: {},
        // the cataloger initals, like abcd, often the username/email
        catInitals: null,
        // in LC we also have a secondary id that gets put into the distributed record
        // catRequireCode: false,
        catCode: null,
        // show the login box
        showLoginModal: false,
        fontFamilies: ["Avenir, Helvetica, Arial, sans-serif", "serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "ui-serif", "ui-sans-serif", "ui-monospace", "ui-rounded"],
        panelDisplay: {
          properties: true,
          dualEdit: false,
          opac: true,
          xml: false,
          marc: false
        },
        styleDefault: {
          // the left properties panel
          "--c-edit-main-splitpane-properties-background-color": {
            value: "#2a2a2a",
            desc: "The background color of the properties side bar on the edit screen.",
            descShort: "Background Color",
            type: "color",
            group: "Sidebars - Property",
            range: null
          },
          "--c-edit-main-splitpane-properties-highlight-background-color": {
            value: "#6f6f6f",
            desc: "The background color of the field when selected or hovered.",
            descShort: "Highlight Color",
            type: "color",
            group: "Sidebars - Property",
            range: null
          },
          "--n-edit-main-splitpane-properties-width": {
            desc: "The width of the property side bar on the edit screen.",
            descShort: "Sidebar width",
            value: 5,
            type: "number",
            step: 1,
            group: "Sidebars - Property",
            range: [5, 100]
          },
          "--n-edit-main-splitpane-properties-font-size": {
            desc: "The fontsize of the text in the property list side bar.",
            descShort: "Font Size",
            value: 1,
            step: 0.01,
            type: "number",
            unit: "em",
            group: "Sidebars - Property",
            range: [1, 2]
          },
          "--c-edit-main-splitpane-properties-font-family": {
            value: "Avenir, Helvetica, Arial, sans-serif",
            desc: "The font of the text in the property list.",
            descShort: "Font",
            type: "font",
            group: "Sidebars - Property",
            range: null
          },
          "--c-edit-main-splitpane-properties-font-color": {
            value: "#fff",
            desc: "The font color of the text in the property list.",
            descShort: "Text Color",
            type: "color",
            group: "Sidebars - Property",
            range: null
          },
          "--c-edit-main-splitpane-properties-empty-indicator-color": {
            value: "#6f6f6f",
            desc: "Color of the dot indicating the field is empty.",
            descShort: "Empty indicator color",
            type: "color",
            group: "Sidebars - Property",
            range: null
          },
          "--c-edit-main-splitpane-properties-populated-indicator-color": {
            value: "green",
            desc: "Color of the checkmark indicating the field is populated.",
            descShort: "Populated indicator color",
            type: "color",
            group: "Sidebars - Property",
            range: null
          },
          "--c-edit-main-splitpane-properties-populated-indicator-color": {
            value: "green",
            desc: "Color of the checkmark indicating the field is populated.",
            descShort: "Populated indicator color",
            type: "color",
            group: "Sidebars - Property",
            range: null
          },
          "--b-edit-main-splitpane-properties-no-scrollbar": {
            desc: "Do not display a scroll bar in the property side panel.",
            descShort: "No Scrollbar",
            value: true,
            type: "boolean",
            unit: null,
            group: "Sidebars - Property",
            range: [true, false]
          },
          "--b-edit-main-splitpane-properties-show-types": {
            desc: 'Show all type labels, such as "Variant Title" under "Title".',
            descShort: "Type Labels",
            value: false,
            type: "boolean",
            unit: null,
            group: "Sidebars - Property",
            range: [true, false]
          },
          "--b-edit-main-splitpane-properties-number-labels": {
            desc: "Add a number to the labels of the properties",
            descShort: "Number Labels",
            value: false,
            type: "boolean",
            unit: null,
            group: "Sidebars - Property",
            range: [true, false]
          },
          "--b-edit-main-splitpane-properties-accordion": {
            desc: "The property list expands and contracts.",
            descShort: "Accordion List",
            value: true,
            type: "boolean",
            unit: null,
            group: "Sidebars - Property",
            range: [true, false]
          },
          // not implemented
          // '--b-edit-main-splitpane-properties-accordion-autoclose' : {
          //     desc: 'The accordion closes by itself.',
          //     descShort: 'Accordion List - Autoclose',
          //     value: true,
          //     type: 'boolean',
          //     unit: null,
          //     group: 'Sidebars - Property',
          //     range: [true,false]
          // },
          // preview - opac
          "--c-edit-main-splitpane-opac-background-color": {
            value: "#f2f2f2",
            desc: "The background color of the opac side bar on the edit screen.",
            descShort: "Background Color",
            type: "color",
            group: "Sidebars - OPAC",
            range: null
          },
          "--c-edit-main-splitpane-opac-highlight-background-color": {
            value: "#6f6f6f",
            desc: "The background color of the field when selected or hovered.",
            descShort: "Highlight Color",
            type: "color",
            group: "Sidebars - OPAC",
            range: null
          },
          "--n-edit-main-splitpane-opac-width": {
            desc: "The width of the property side bar on the edit screen.",
            descShort: "Sidebar width",
            value: 5,
            type: "number",
            step: 1,
            group: "Sidebars - OPAC",
            range: [5, 100]
          },
          "--n-edit-main-splitpane-opac-font-size": {
            desc: "The fontsize of the text in the property list side bar.",
            descShort: "Font Size",
            value: 1,
            step: 0.01,
            type: "number",
            unit: "em",
            group: "Sidebars - OPAC",
            range: [1, 2]
          },
          "--c-edit-main-splitpane-opac-font-family": {
            value: "Avenir, Helvetica, Arial, sans-serif",
            desc: "The font of the text in the property list.",
            descShort: "Font",
            type: "font",
            group: "Sidebars - OPAC",
            range: null
          },
          "--c-edit-main-splitpane-opac-font-color": {
            value: "#202124",
            desc: "The font color of the text in the property list.",
            descShort: "Text Color",
            type: "color",
            group: "Sidebars - OPAC",
            range: null
          },
          "--b-edit-main-splitpane-opac-no-scrollbar": {
            desc: "Do not display a scroll bar in the opac preview side panel.",
            descShort: "No Scrollbar",
            value: true,
            type: "boolean",
            unit: null,
            group: "Sidebars - OPAC",
            range: [true, false]
          },
          // the edit panel
          "--n-edit-main-splitpane-edit-width": {
            desc: "The width of the edit screen panel.",
            descShort: "Edit panel width",
            value: 50,
            step: 1,
            type: "number",
            group: "Edit Panel",
            range: [5, 100]
          },
          "--b-edit-main-splitpane-edit-no-scrollbar": {
            desc: "Do not display a scroll bar in the edit panel.",
            descShort: "No Scrollbar",
            value: true,
            type: "boolean",
            unit: null,
            group: "Edit Panel",
            range: [true, false]
          },
          "--c-edit-main-splitpane-edit-background-color-work": {
            value: "#deeaea",
            desc: "The background color of the work on edit screen panel.",
            descShort: "Work Background Color",
            type: "color",
            group: "Edit Panel",
            range: null
          },
          "--c-edit-main-splitpane-edit-background-color-instance": {
            value: "#8b588ba3",
            desc: "The background color of the instance on edit screen panel.",
            descShort: "Instance Background Color",
            type: "color",
            group: "Edit Panel",
            range: null
          },
          "--c-edit-main-splitpane-edit-focused-field-color": {
            value: "#f2f6f6",
            desc: "The background color of the field when it has the focus.",
            descShort: "Field Focus Background Color",
            type: "color",
            group: "Edit Panel",
            range: null
          },
          "--b-edit-main-splitpane-edit-show-field-labels": {
            desc: "Display  labels in the field.",
            descShort: "Display field labels",
            value: true,
            type: "boolean",
            unit: null,
            group: "Edit Panel",
            range: [true, false]
          },
          "--n-edit-main-splitpane-edit-show-field-labels-size": {
            desc: "Field Label font size.",
            descShort: "Field Label font size",
            value: 0.65,
            step: 0.01,
            type: "number",
            unit: "em",
            group: "Edit Panel",
            range: [0, 1]
          },
          "--b-edit-main-splitpane-edit-shortcode-display-mode": {
            desc: "Display abbrivated BF tags instead of natural language labels.",
            descShort: "BF display tags",
            value: false,
            type: "boolean",
            unit: null,
            group: "Edit Panel",
            range: [true, false]
          },
          "--b-edit-main-splitpane-edit-inline-mode": {
            desc: "One line edit mode via bf short code tags.",
            descShort: "Inline edit mode",
            value: false,
            type: "boolean",
            unit: null,
            group: "Edit Panel",
            range: [true, false]
          },
          "--b-edit-main-splitpane-edit-adhoc-mode": {
            desc: "Add properties as needed using a drop down list.",
            descShort: "Properties adhoc",
            value: false,
            type: "boolean",
            unit: null,
            group: "Edit Panel",
            range: [true, false]
          },
          "--b-edit-main-splitpane-edit-switch-between-resource-button": {
            desc: "Lets you switch displaying work and instances in the edit panel.",
            descShort: "Resource switch button",
            value: false,
            type: "boolean",
            unit: null,
            group: "Edit Panel",
            range: [true, false]
          },
          "--b-edit-main-splitpane-edit-scroll-x": {
            desc: "The edit fields display does not wrap, a scroll bar appears at the bottom",
            descShort: "Horizontal Edit Panel scroll",
            value: false,
            type: "boolean",
            unit: null,
            group: "Edit Panel",
            range: [true, false]
          },
          // the NAV panel
          "--n-edit-main-splitpane-nav-height": {
            desc: "The default height of the nav menu",
            descShort: "Height",
            value: 35,
            type: "number",
            unit: "px",
            group: "Nav Bar",
            range: [5, 50]
          },
          "--n-edit-main-splitpane-nav-font-size": {
            desc: "The fontsize of the text in the nav menu",
            descShort: "Font Size",
            value: 1,
            step: 0.1,
            type: "number",
            unit: "em",
            group: "Nav Bar",
            range: [1, 2]
          },
          "--c-edit-main-splitpane-nav-background-color": {
            desc: "The background color of the nav menu",
            descShort: "Background Color",
            value: "white",
            type: "color",
            unit: null,
            group: "Nav Bar",
            range: null
          },
          "--c-edit-main-splitpane-nav-font-color": {
            value: "#202124",
            desc: "The font color of the text in the nav bar",
            descShort: "Text Color",
            type: "color",
            group: "Nav Bar",
            range: null
          },
          // the LITERAL field
          "--n-edit-main-literal-font-size": {
            desc: "The fontsize of the text in the literal field",
            descShort: "Font Size",
            value: 1,
            step: 0.1,
            type: "number",
            unit: "em",
            group: "Literal Field",
            range: [1, 2]
          },
          // General Edit things
          "--s-edit-general-action-button-icon": {
            desc: 'What icon to use on the field action button, such as "bolt" look up the Material Icon name (https://marella.me/material-icons/demo/)',
            descShort: "Action button icon",
            value: "bolt",
            type: "string",
            unit: null,
            group: "Action Button",
            range: [1, 2]
          },
          "--c-edit-general-action-button-color": {
            value: "#202124",
            desc: "The color of the icon on the action button.",
            descShort: "Action button color",
            type: "color",
            group: "Action Button",
            range: null
          },
          "--c-edit-general-action-button-background-color": {
            value: "#fff",
            desc: "The color of background on the action button.",
            descShort: "Action Button background color",
            type: "color",
            group: "Action Button",
            range: null
          },
          "--n-edit-general-action-button-size": {
            desc: "The size of the icon on the action button",
            descShort: "Button Icon Size",
            value: 1.25,
            step: 0.1,
            type: "number",
            unit: "em",
            group: "Action Button",
            range: [1, 2]
          },
          "--n-edit-general-action-button-border-width": {
            desc: "The width of the button border",
            descShort: "Button Border width",
            value: 1,
            step: 0.1,
            type: "number",
            unit: "px",
            group: "Action Button",
            range: [0, 10]
          },
          "--c-edit-general-action-button-border-color": {
            value: "#202124",
            desc: "The color of background on the action button.",
            descShort: "Action background color",
            type: "color",
            group: "Action Button",
            range: null
          },
          "--n-edit-general-action-button-border-radius": {
            desc: "The radius of the button border",
            descShort: "Button Border radius",
            value: 5,
            step: 0.1,
            type: "number",
            unit: "px",
            group: "Action Button",
            range: [0, 10]
          },
          "--n-edit-general-action-button-continer-background-color": {
            value: "#fff",
            desc: "Background color of the action button menu.",
            descShort: "Action btn menu color",
            type: "color",
            group: "Action Button",
            range: null
          },
          "--n-edit-general-action-button-continer-font-size": {
            desc: "The size of the text in the action button menu",
            descShort: "Icon Size",
            value: 1.25,
            step: 0.1,
            type: "number",
            unit: "em",
            group: "Action Button",
            range: [1, 2]
          },
          "--n-edit-general-action-button-continer-border-width": {
            desc: "The width of the action button menu border",
            descShort: "Action btn menu Border width",
            value: 1,
            type: "number",
            step: 0.1,
            unit: "px",
            group: "Action Button",
            range: [0, 10]
          },
          "--c-edit-general-action-button-continer-border-color": {
            value: "#202124",
            desc: "The color of background on the action button.",
            descShort: "Action btn menu border color",
            type: "color",
            group: "Action Button",
            range: null
          },
          "--n-edit-general-action-button-continer-border-radius": {
            desc: "The radius of the button menu border",
            descShort: "Action btn menu Border radius",
            value: 5,
            step: 0.1,
            type: "number",
            unit: "px",
            group: "Action Button",
            range: [0, 10]
          },
          "--c-edit-general-action-button-continer-color": {
            value: "#202124",
            desc: "The color of the text in the action button menu.",
            descShort: "Action btn menu font color",
            type: "color",
            group: "Action Button",
            range: null
          },
          "--n-edit-general-action-button-continer-background-highlight-color": {
            value: "whitesmoke",
            desc: "Background color of the action button menu item when selected.",
            descShort: "Action btn menu highlight color",
            type: "color",
            group: "Action Button",
            range: null
          },
          "--b-edit-general-action-button-display": {
            desc: "Display action button.",
            descShort: "Display Button",
            value: true,
            type: "boolean",
            unit: null,
            group: "Action Button",
            range: [true, false]
          },
          // COMPLEX LOOKUP
          "--b-edit-complex-use-select-dropdown": {
            desc: "Use dropdown select instead of buttons.",
            descShort: "Use lookup dropdown",
            value: false,
            type: "boolean",
            unit: null,
            group: "Complex Lookup",
            range: [true, false]
          },
          "--c-general-icon-instance-color": {
            desc: "The color of the instance icon.",
            descShort: "Instance icon color",
            value: "#8b588b",
            type: "color",
            unit: null,
            group: "General",
            range: null
          },
          "--c-general-icon-work-color": {
            desc: "The color of the instance icon.",
            descShort: "Instance icon color",
            value: "#7badad",
            type: "color",
            unit: null,
            group: "General",
            range: null
          },
          "--c-general-icon-item-color": {
            desc: "The color of the item icon.",
            descShort: "Item icon color",
            value: "#eaeaea",
            type: "color",
            unit: null,
            group: "General",
            range: null
          }
        }
      }),
      // catInitals: null,
      // // in LC we also have a secondary id that gets put into the distributed record
      // // catRequireCode: false,
      // catCode:
      getters: {
        returnUserNameForSaving: function() {
          return `${this.catInitals} (${this.catCode})`;
        },
        returnUserNameForPosting: function() {
          return this.catCode;
        }
        // /**
        // * Returns the part of the config based on the current URL (or enviornment)
        // * @return {object} - The url config object
        // */       
        // returnUrls: (state) => {
        //   // testing for window here because of running unit tests in node
        //   if (typeof window !== 'undefined'){
        //     if (window && (window.location.href.startsWith('http://localhost') || window.location.href.startsWith('http://127.0.0.1'))){
        //       return state.regionUrls.dev
        //     }else if (window && window.location.href.startsWith('https://preprod-3001')){
        //       return state.regionUrls.staging
        //     }else if (window && window.location.href.startsWith('https://editor.id')){
        //       return state.regionUrls.production
        //     }else if (window && window.location.href.includes('bibframe.org/marva')){
        //       return state.regionUrls.bibframeDotOrg
        //     }
        //   }else{
        //     return state.regionUrls.dev
        //   }
        // }
      },
      actions: {
        /**
        * Setup the preference store, access settings stored in localstorage, etc.
        * @return {void} - 
        */
        initalize: function() {
          if (window.localStorage.getItem("marva-catInitals")) {
            this.catInitals = window.localStorage.getItem("marva-catInitals");
          }
          if (window.localStorage.getItem("marva-catCode")) {
            this.catCode = window.localStorage.getItem("marva-catCode");
          }
          if (window.localStorage.getItem("marva-scriptShifterOptions")) {
            this.scriptShifterOptions = JSON.parse(window.localStorage.getItem("marva-scriptShifterOptions"));
          }
        },
        /**
        * returns the value of the preference property requested
        * @param {string} propertyName - the name of the styleDefault to send
        * @param {boolean} excludeUnitType - if true do not include the unit in the reply if present
        * @return {string|number} - The value of the property
        */
        returnValue: function(propertyName, excludeUnitType) {
          if (!this.styleDefault[propertyName]) {
            console.warn("Trying to return", propertyName, " but does not exist.");
            return "";
          }
          if (this.styleDefault[propertyName].unit && excludeUnitType) {
            return this.styleDefault[propertyName].value;
          } else if (this.styleDefault[propertyName].unit) {
            return this.styleDefault[propertyName].value + this.styleDefault[propertyName].unit;
          } else {
            return this.styleDefault[propertyName].value;
          }
        },
        /**
        * sets the value preference property requested
        * @param {string} propertyName - the name of the styleDefault to send
        * @param {string|number} value - the value to use
        * @return {boolean} - Did it work
        */
        setValue: function(propertyName, value) {
          if (!this.styleDefault[propertyName]) {
            console.warn("Trying to return", propertyName, " but does not exist.");
            return false;
          }
          this.styleDefault[propertyName].value = value;
          return true;
        },
        /**
        * Dispalys the debug modal
        * @return {void}
        */
        togglePrefModal: function() {
          if (this.showDebugModal) {
            this.showDebugModal = false;
          } else {
            this.showDebugModal = true;
          }
        },
        /**
        * Dispalys the preference modal
        * @param {string} group - the name of option group to dispay in the preference modal    
        * @return {void}
        */
        togglePrefModal: function(group) {
          if (this.showPrefModal) {
            this.showPrefModal = false;
          } else {
            if (group) {
              this.showPrefModalGroup = group;
            }
            this.showPrefModal = true;
          }
        },
        /**
        * Set showPrefModalGroup
        * @param {string} group - the name of option group to dispay in the preference modal    
        * @return {void}
        */
        setShowPrefModalGroup: function(group) {
          this.showPrefModalGroup = group;
        },
        /**
        * Truns a panel on or off
        * @param {string} panel - the name of the panel to toggle
        * @return {void}
        */
        togglePanel: function(panel) {
          var _a;
          if (this.panelDisplay[panel]) {
            this.panelDisplay[panel] = false;
          } else {
            this.panelDisplay[panel] = true;
          }
          console.log(this.panelDisplay);
          console.log(this.panelDisplay.properties);
          const instance = getCurrentInstance();
          (_a = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a.$forceUpdate();
        }
        /**
        * Take a url and rewrites it to match the url pattern of the current enviornment
        * @param {string} url - the url to modfidfy
        * @return {string} - the url modified to the match the env
        */
        // convertToRegionUrl(url) {
        //   let urls = this.returnUrls
        //   if ((url.includes('/works/') || url.includes('/instances/') || url.includes('/items/') || url.includes('/hubs/') ) && url.includes('http://id.loc.gov') ){
        //     url = url.replace('http://id.loc.gov/',urls.bfdb)
        //   }    
        //   return url
        // }
      }
    });
    var getRandomValues;
    var rnds8 = new Uint8Array(16);
    function rng() {
      if (!getRandomValues) {
        getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
        if (!getRandomValues) {
          throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        }
      }
      return getRandomValues(rnds8);
    }
    const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    function validate(uuid) {
      return typeof uuid === "string" && REGEX.test(uuid);
    }
    var byteToHex = [];
    for (var i$4 = 0; i$4 < 256; ++i$4) {
      byteToHex.push((i$4 + 256).toString(16).substr(1));
    }
    function stringify$1(arr) {
      var offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var uuid = (byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]]).toLowerCase();
      if (!validate(uuid)) {
        throw TypeError("Stringified UUID is invalid");
      }
      return uuid;
    }
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v1(options, buf, offset2) {
      var i2 = buf && offset2 || 0;
      var b2 = buf || new Array(16);
      options = options || {};
      var node = options.node || _nodeId;
      var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        var seedBytes = options.random || (options.rng || rng)();
        if (node == null) {
          node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      var msecs = options.msecs !== void 0 ? options.msecs : Date.now();
      var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      var dt2 = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt2 < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt2 < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b2[i2++] = tl >>> 24 & 255;
      b2[i2++] = tl >>> 16 & 255;
      b2[i2++] = tl >>> 8 & 255;
      b2[i2++] = tl & 255;
      var tmh = msecs / 4294967296 * 1e4 & 268435455;
      b2[i2++] = tmh >>> 8 & 255;
      b2[i2++] = tmh & 255;
      b2[i2++] = tmh >>> 24 & 15 | 16;
      b2[i2++] = tmh >>> 16 & 255;
      b2[i2++] = clockseq >>> 8 | 128;
      b2[i2++] = clockseq & 255;
      for (var n2 = 0; n2 < 6; ++n2) {
        b2[i2 + n2] = node[n2];
      }
      return buf || stringify$1(b2);
    }
    function parse$2(uuid) {
      if (!validate(uuid)) {
        throw TypeError("Invalid UUID");
      }
      var v2;
      var arr = new Uint8Array(16);
      arr[0] = (v2 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
      arr[1] = v2 >>> 16 & 255;
      arr[2] = v2 >>> 8 & 255;
      arr[3] = v2 & 255;
      arr[4] = (v2 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
      arr[5] = v2 & 255;
      arr[6] = (v2 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
      arr[7] = v2 & 255;
      arr[8] = (v2 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
      arr[9] = v2 & 255;
      arr[10] = (v2 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
      arr[11] = v2 / 4294967296 & 255;
      arr[12] = v2 >>> 24 & 255;
      arr[13] = v2 >>> 16 & 255;
      arr[14] = v2 >>> 8 & 255;
      arr[15] = v2 & 255;
      return arr;
    }
    function stringToBytes(str) {
      str = unescape(encodeURIComponent(str));
      var bytes = [];
      for (var i2 = 0; i2 < str.length; ++i2) {
        bytes.push(str.charCodeAt(i2));
      }
      return bytes;
    }
    var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    var URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    function v35(name, version2, hashfunc) {
      function generateUUID(value, namespace, buf, offset2) {
        if (typeof value === "string") {
          value = stringToBytes(value);
        }
        if (typeof namespace === "string") {
          namespace = parse$2(namespace);
        }
        if (namespace.length !== 16) {
          throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        }
        var bytes = new Uint8Array(16 + value.length);
        bytes.set(namespace);
        bytes.set(value, namespace.length);
        bytes = hashfunc(bytes);
        bytes[6] = bytes[6] & 15 | version2;
        bytes[8] = bytes[8] & 63 | 128;
        if (buf) {
          offset2 = offset2 || 0;
          for (var i2 = 0; i2 < 16; ++i2) {
            buf[offset2 + i2] = bytes[i2];
          }
          return buf;
        }
        return stringify$1(bytes);
      }
      try {
        generateUUID.name = name;
      } catch (err) {
      }
      generateUUID.DNS = DNS;
      generateUUID.URL = URL;
      return generateUUID;
    }
    function md5(bytes) {
      if (typeof bytes === "string") {
        var msg = unescape(encodeURIComponent(bytes));
        bytes = new Uint8Array(msg.length);
        for (var i2 = 0; i2 < msg.length; ++i2) {
          bytes[i2] = msg.charCodeAt(i2);
        }
      }
      return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
    }
    function md5ToHexEncodedArray(input) {
      var output = [];
      var length32 = input.length * 32;
      var hexTab = "0123456789abcdef";
      for (var i2 = 0; i2 < length32; i2 += 8) {
        var x2 = input[i2 >> 5] >>> i2 % 32 & 255;
        var hex = parseInt(hexTab.charAt(x2 >>> 4 & 15) + hexTab.charAt(x2 & 15), 16);
        output.push(hex);
      }
      return output;
    }
    function getOutputLength(inputLength8) {
      return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
    }
    function wordsToMd5(x2, len) {
      x2[len >> 5] |= 128 << len % 32;
      x2[getOutputLength(len) - 1] = len;
      var a2 = 1732584193;
      var b2 = -271733879;
      var c2 = -1732584194;
      var d2 = 271733878;
      for (var i2 = 0; i2 < x2.length; i2 += 16) {
        var olda = a2;
        var oldb = b2;
        var oldc = c2;
        var oldd = d2;
        a2 = md5ff(a2, b2, c2, d2, x2[i2], 7, -680876936);
        d2 = md5ff(d2, a2, b2, c2, x2[i2 + 1], 12, -389564586);
        c2 = md5ff(c2, d2, a2, b2, x2[i2 + 2], 17, 606105819);
        b2 = md5ff(b2, c2, d2, a2, x2[i2 + 3], 22, -1044525330);
        a2 = md5ff(a2, b2, c2, d2, x2[i2 + 4], 7, -176418897);
        d2 = md5ff(d2, a2, b2, c2, x2[i2 + 5], 12, 1200080426);
        c2 = md5ff(c2, d2, a2, b2, x2[i2 + 6], 17, -1473231341);
        b2 = md5ff(b2, c2, d2, a2, x2[i2 + 7], 22, -45705983);
        a2 = md5ff(a2, b2, c2, d2, x2[i2 + 8], 7, 1770035416);
        d2 = md5ff(d2, a2, b2, c2, x2[i2 + 9], 12, -1958414417);
        c2 = md5ff(c2, d2, a2, b2, x2[i2 + 10], 17, -42063);
        b2 = md5ff(b2, c2, d2, a2, x2[i2 + 11], 22, -1990404162);
        a2 = md5ff(a2, b2, c2, d2, x2[i2 + 12], 7, 1804603682);
        d2 = md5ff(d2, a2, b2, c2, x2[i2 + 13], 12, -40341101);
        c2 = md5ff(c2, d2, a2, b2, x2[i2 + 14], 17, -1502002290);
        b2 = md5ff(b2, c2, d2, a2, x2[i2 + 15], 22, 1236535329);
        a2 = md5gg(a2, b2, c2, d2, x2[i2 + 1], 5, -165796510);
        d2 = md5gg(d2, a2, b2, c2, x2[i2 + 6], 9, -1069501632);
        c2 = md5gg(c2, d2, a2, b2, x2[i2 + 11], 14, 643717713);
        b2 = md5gg(b2, c2, d2, a2, x2[i2], 20, -373897302);
        a2 = md5gg(a2, b2, c2, d2, x2[i2 + 5], 5, -701558691);
        d2 = md5gg(d2, a2, b2, c2, x2[i2 + 10], 9, 38016083);
        c2 = md5gg(c2, d2, a2, b2, x2[i2 + 15], 14, -660478335);
        b2 = md5gg(b2, c2, d2, a2, x2[i2 + 4], 20, -405537848);
        a2 = md5gg(a2, b2, c2, d2, x2[i2 + 9], 5, 568446438);
        d2 = md5gg(d2, a2, b2, c2, x2[i2 + 14], 9, -1019803690);
        c2 = md5gg(c2, d2, a2, b2, x2[i2 + 3], 14, -187363961);
        b2 = md5gg(b2, c2, d2, a2, x2[i2 + 8], 20, 1163531501);
        a2 = md5gg(a2, b2, c2, d2, x2[i2 + 13], 5, -1444681467);
        d2 = md5gg(d2, a2, b2, c2, x2[i2 + 2], 9, -51403784);
        c2 = md5gg(c2, d2, a2, b2, x2[i2 + 7], 14, 1735328473);
        b2 = md5gg(b2, c2, d2, a2, x2[i2 + 12], 20, -1926607734);
        a2 = md5hh(a2, b2, c2, d2, x2[i2 + 5], 4, -378558);
        d2 = md5hh(d2, a2, b2, c2, x2[i2 + 8], 11, -2022574463);
        c2 = md5hh(c2, d2, a2, b2, x2[i2 + 11], 16, 1839030562);
        b2 = md5hh(b2, c2, d2, a2, x2[i2 + 14], 23, -35309556);
        a2 = md5hh(a2, b2, c2, d2, x2[i2 + 1], 4, -1530992060);
        d2 = md5hh(d2, a2, b2, c2, x2[i2 + 4], 11, 1272893353);
        c2 = md5hh(c2, d2, a2, b2, x2[i2 + 7], 16, -155497632);
        b2 = md5hh(b2, c2, d2, a2, x2[i2 + 10], 23, -1094730640);
        a2 = md5hh(a2, b2, c2, d2, x2[i2 + 13], 4, 681279174);
        d2 = md5hh(d2, a2, b2, c2, x2[i2], 11, -358537222);
        c2 = md5hh(c2, d2, a2, b2, x2[i2 + 3], 16, -722521979);
        b2 = md5hh(b2, c2, d2, a2, x2[i2 + 6], 23, 76029189);
        a2 = md5hh(a2, b2, c2, d2, x2[i2 + 9], 4, -640364487);
        d2 = md5hh(d2, a2, b2, c2, x2[i2 + 12], 11, -421815835);
        c2 = md5hh(c2, d2, a2, b2, x2[i2 + 15], 16, 530742520);
        b2 = md5hh(b2, c2, d2, a2, x2[i2 + 2], 23, -995338651);
        a2 = md5ii(a2, b2, c2, d2, x2[i2], 6, -198630844);
        d2 = md5ii(d2, a2, b2, c2, x2[i2 + 7], 10, 1126891415);
        c2 = md5ii(c2, d2, a2, b2, x2[i2 + 14], 15, -1416354905);
        b2 = md5ii(b2, c2, d2, a2, x2[i2 + 5], 21, -57434055);
        a2 = md5ii(a2, b2, c2, d2, x2[i2 + 12], 6, 1700485571);
        d2 = md5ii(d2, a2, b2, c2, x2[i2 + 3], 10, -1894986606);
        c2 = md5ii(c2, d2, a2, b2, x2[i2 + 10], 15, -1051523);
        b2 = md5ii(b2, c2, d2, a2, x2[i2 + 1], 21, -2054922799);
        a2 = md5ii(a2, b2, c2, d2, x2[i2 + 8], 6, 1873313359);
        d2 = md5ii(d2, a2, b2, c2, x2[i2 + 15], 10, -30611744);
        c2 = md5ii(c2, d2, a2, b2, x2[i2 + 6], 15, -1560198380);
        b2 = md5ii(b2, c2, d2, a2, x2[i2 + 13], 21, 1309151649);
        a2 = md5ii(a2, b2, c2, d2, x2[i2 + 4], 6, -145523070);
        d2 = md5ii(d2, a2, b2, c2, x2[i2 + 11], 10, -1120210379);
        c2 = md5ii(c2, d2, a2, b2, x2[i2 + 2], 15, 718787259);
        b2 = md5ii(b2, c2, d2, a2, x2[i2 + 9], 21, -343485551);
        a2 = safeAdd(a2, olda);
        b2 = safeAdd(b2, oldb);
        c2 = safeAdd(c2, oldc);
        d2 = safeAdd(d2, oldd);
      }
      return [a2, b2, c2, d2];
    }
    function bytesToWords(input) {
      if (input.length === 0) {
        return [];
      }
      var length8 = input.length * 8;
      var output = new Uint32Array(getOutputLength(length8));
      for (var i2 = 0; i2 < length8; i2 += 8) {
        output[i2 >> 5] |= (input[i2 / 8] & 255) << i2 % 32;
      }
      return output;
    }
    function safeAdd(x2, y2) {
      var lsw = (x2 & 65535) + (y2 & 65535);
      var msw = (x2 >> 16) + (y2 >> 16) + (lsw >> 16);
      return msw << 16 | lsw & 65535;
    }
    function bitRotateLeft(num, cnt) {
      return num << cnt | num >>> 32 - cnt;
    }
    function md5cmn(q2, a2, b2, x2, s2, t2) {
      return safeAdd(bitRotateLeft(safeAdd(safeAdd(a2, q2), safeAdd(x2, t2)), s2), b2);
    }
    function md5ff(a2, b2, c2, d2, x2, s2, t2) {
      return md5cmn(b2 & c2 | ~b2 & d2, a2, b2, x2, s2, t2);
    }
    function md5gg(a2, b2, c2, d2, x2, s2, t2) {
      return md5cmn(b2 & d2 | c2 & ~d2, a2, b2, x2, s2, t2);
    }
    function md5hh(a2, b2, c2, d2, x2, s2, t2) {
      return md5cmn(b2 ^ c2 ^ d2, a2, b2, x2, s2, t2);
    }
    function md5ii(a2, b2, c2, d2, x2, s2, t2) {
      return md5cmn(c2 ^ (b2 | ~d2), a2, b2, x2, s2, t2);
    }
    var v3 = v35("v3", 48, md5);
    const v3$1 = v3;
    function v4(options, buf, offset2) {
      options = options || {};
      var rnds = options.random || (options.rng || rng)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        offset2 = offset2 || 0;
        for (var i2 = 0; i2 < 16; ++i2) {
          buf[offset2 + i2] = rnds[i2];
        }
        return buf;
      }
      return stringify$1(rnds);
    }
    function f$4(s2, x2, y2, z2) {
      switch (s2) {
        case 0:
          return x2 & y2 ^ ~x2 & z2;
        case 1:
          return x2 ^ y2 ^ z2;
        case 2:
          return x2 & y2 ^ x2 & z2 ^ y2 & z2;
        case 3:
          return x2 ^ y2 ^ z2;
      }
    }
    function ROTL(x2, n2) {
      return x2 << n2 | x2 >>> 32 - n2;
    }
    function sha1(bytes) {
      var K2 = [1518500249, 1859775393, 2400959708, 3395469782];
      var H2 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      if (typeof bytes === "string") {
        var msg = unescape(encodeURIComponent(bytes));
        bytes = [];
        for (var i2 = 0; i2 < msg.length; ++i2) {
          bytes.push(msg.charCodeAt(i2));
        }
      } else if (!Array.isArray(bytes)) {
        bytes = Array.prototype.slice.call(bytes);
      }
      bytes.push(128);
      var l2 = bytes.length / 4 + 2;
      var N2 = Math.ceil(l2 / 16);
      var M2 = new Array(N2);
      for (var _i = 0; _i < N2; ++_i) {
        var arr = new Uint32Array(16);
        for (var j2 = 0; j2 < 16; ++j2) {
          arr[j2] = bytes[_i * 64 + j2 * 4] << 24 | bytes[_i * 64 + j2 * 4 + 1] << 16 | bytes[_i * 64 + j2 * 4 + 2] << 8 | bytes[_i * 64 + j2 * 4 + 3];
        }
        M2[_i] = arr;
      }
      M2[N2 - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
      M2[N2 - 1][14] = Math.floor(M2[N2 - 1][14]);
      M2[N2 - 1][15] = (bytes.length - 1) * 8 & 4294967295;
      for (var _i2 = 0; _i2 < N2; ++_i2) {
        var W2 = new Uint32Array(80);
        for (var t2 = 0; t2 < 16; ++t2) {
          W2[t2] = M2[_i2][t2];
        }
        for (var _t2 = 16; _t2 < 80; ++_t2) {
          W2[_t2] = ROTL(W2[_t2 - 3] ^ W2[_t2 - 8] ^ W2[_t2 - 14] ^ W2[_t2 - 16], 1);
        }
        var a2 = H2[0];
        var b2 = H2[1];
        var c2 = H2[2];
        var d2 = H2[3];
        var e2 = H2[4];
        for (var _t22 = 0; _t22 < 80; ++_t22) {
          var s2 = Math.floor(_t22 / 20);
          var T2 = ROTL(a2, 5) + f$4(s2, b2, c2, d2) + e2 + K2[s2] + W2[_t22] >>> 0;
          e2 = d2;
          d2 = c2;
          c2 = ROTL(b2, 30) >>> 0;
          b2 = a2;
          a2 = T2;
        }
        H2[0] = H2[0] + a2 >>> 0;
        H2[1] = H2[1] + b2 >>> 0;
        H2[2] = H2[2] + c2 >>> 0;
        H2[3] = H2[3] + d2 >>> 0;
        H2[4] = H2[4] + e2 >>> 0;
      }
      return [H2[0] >> 24 & 255, H2[0] >> 16 & 255, H2[0] >> 8 & 255, H2[0] & 255, H2[1] >> 24 & 255, H2[1] >> 16 & 255, H2[1] >> 8 & 255, H2[1] & 255, H2[2] >> 24 & 255, H2[2] >> 16 & 255, H2[2] >> 8 & 255, H2[2] & 255, H2[3] >> 24 & 255, H2[3] >> 16 & 255, H2[3] >> 8 & 255, H2[3] & 255, H2[4] >> 24 & 255, H2[4] >> 16 & 255, H2[4] >> 8 & 255, H2[4] & 255];
    }
    var v5 = v35("v5", 80, sha1);
    const v5$1 = v5;
    const nil = "00000000-0000-0000-0000-000000000000";
    function version$1(uuid) {
      if (!validate(uuid)) {
        throw TypeError("Invalid UUID");
      }
      return parseInt(uuid.substr(14, 1), 16);
    }
    const esmBrowser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      NIL: nil,
      parse: parse$2,
      stringify: stringify$1,
      v1,
      v3: v3$1,
      v4,
      v5: v5$1,
      validate,
      version: version$1
    }, Symbol.toStringTag, { value: "Module" }));
    const require$$0 = /* @__PURE__ */ getAugmentedNamespace(esmBrowser);
    function Converter$1(srcAlphabet, dstAlphabet) {
      if (!srcAlphabet || !dstAlphabet || !srcAlphabet.length || !dstAlphabet.length) {
        throw new Error("Bad alphabet");
      }
      this.srcAlphabet = srcAlphabet;
      this.dstAlphabet = dstAlphabet;
    }
    Converter$1.prototype.convert = function(number2) {
      var i2, divide, newlen, numberMap = {}, fromBase = this.srcAlphabet.length, toBase = this.dstAlphabet.length, length = number2.length, result = typeof number2 === "string" ? "" : [];
      if (!this.isValid(number2)) {
        throw new Error('Number "' + number2 + '" contains of non-alphabetic digits (' + this.srcAlphabet + ")");
      }
      if (this.srcAlphabet === this.dstAlphabet) {
        return number2;
      }
      for (i2 = 0; i2 < length; i2++) {
        numberMap[i2] = this.srcAlphabet.indexOf(number2[i2]);
      }
      do {
        divide = 0;
        newlen = 0;
        for (i2 = 0; i2 < length; i2++) {
          divide = divide * fromBase + numberMap[i2];
          if (divide >= toBase) {
            numberMap[newlen++] = parseInt(divide / toBase, 10);
            divide = divide % toBase;
          } else if (newlen > 0) {
            numberMap[newlen++] = 0;
          }
        }
        length = newlen;
        result = this.dstAlphabet.slice(divide, divide + 1).concat(result);
      } while (newlen !== 0);
      return result;
    };
    Converter$1.prototype.isValid = function(number2) {
      var i2 = 0;
      for (; i2 < number2.length; ++i2) {
        if (this.srcAlphabet.indexOf(number2[i2]) === -1) {
          return false;
        }
      }
      return true;
    };
    var converter = Converter$1;
    var Converter = converter;
    function anyBase$1(srcAlphabet, dstAlphabet) {
      var converter2 = new Converter(srcAlphabet, dstAlphabet);
      return function(number2) {
        return converter2.convert(number2);
      };
    }
    anyBase$1.BIN = "01";
    anyBase$1.OCT = "01234567";
    anyBase$1.DEC = "0123456789";
    anyBase$1.HEX = "0123456789abcdef";
    var anyBase_1 = anyBase$1;
    const { v4: uuidv4 } = require$$0;
    const anyBase = anyBase_1;
    const flickrBase58 = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ";
    const cookieBase90 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%&'()*+-./:<=>?@[]^_`{|}~";
    const baseOptions = {
      consistentLength: true
    };
    let toFlickr;
    const shortenUUID = (longId, translator2, paddingParams) => {
      const translated = translator2(longId.toLowerCase().replace(/-/g, ""));
      if (!paddingParams || !paddingParams.consistentLength)
        return translated;
      return translated.padStart(
        paddingParams.shortIdLength,
        paddingParams.paddingChar
      );
    };
    const enlargeUUID = (shortId, translator2) => {
      const uu1 = translator2(shortId).padStart(32, "0");
      const m2 = uu1.match(/(\w{8})(\w{4})(\w{4})(\w{4})(\w{12})/);
      return [m2[1], m2[2], m2[3], m2[4], m2[5]].join("-");
    };
    const getShortIdLength = (alphabetLength) => Math.ceil(Math.log(2 ** 128) / Math.log(alphabetLength));
    var shortUuid = (() => {
      const makeConvertor = (toAlphabet, options) => {
        const useAlphabet = toAlphabet || flickrBase58;
        const selectedOptions = { ...baseOptions, ...options };
        if ([...new Set(Array.from(useAlphabet))].length !== useAlphabet.length) {
          throw new Error("The provided Alphabet has duplicate characters resulting in unreliable results");
        }
        const shortIdLength = getShortIdLength(useAlphabet.length);
        const paddingParams = {
          shortIdLength,
          consistentLength: selectedOptions.consistentLength,
          paddingChar: useAlphabet[0]
        };
        const fromHex = anyBase(anyBase.HEX, useAlphabet);
        const toHex = anyBase(useAlphabet, anyBase.HEX);
        const generate2 = () => shortenUUID(uuidv4(), fromHex, paddingParams);
        const translator2 = {
          new: generate2,
          generate: generate2,
          uuid: uuidv4,
          fromUUID: (uuid) => shortenUUID(uuid, fromHex, paddingParams),
          toUUID: (shortUuid2) => enlargeUUID(shortUuid2, toHex),
          alphabet: useAlphabet,
          maxLength: shortIdLength
        };
        Object.freeze(translator2);
        return translator2;
      };
      makeConvertor.constants = {
        flickrBase58,
        cookieBase90
      };
      makeConvertor.uuid = uuidv4;
      makeConvertor.generate = () => {
        if (!toFlickr) {
          toFlickr = makeConvertor(flickrBase58).generate;
        }
        return toFlickr();
      };
      return makeConvertor;
    })();
    const short = /* @__PURE__ */ getDefaultExportFromCjs(shortUuid);
    const translator$1 = short();
    const utilsNetwork = {
      // where to look for the string
      possibleLabelURIs: [
        "http://www.loc.gov/mads/rdf/v1#authoritativeLabel",
        "http://www.w3.org/2004/02/skos/core#prefLabel",
        "http://www.w3.org/2000/01/rdf-schema#label"
      ],
      // a cache to keep previosuly requested vocabularies and lookups in memory for use again
      lookupLibrary: {},
      /**
      * processes the data returned from id vocabularies
      * 
      * @async
      * @param {array} uris - the id vocabulary to query
      * @return {object} - returns the results processing
      */
      loadSimpleLookup: async function(uris) {
        if (!Array.isArray(uris)) {
          uris = [uris];
        }
        for (let uri of uris) {
          let url = uri;
          if (!uri.includes(".json")) {
            url = url + ".json";
          }
          if (!this.lookupLibrary[uri]) {
            let data = await this.fetchSimpleLookup(url);
            data = this.simpleLookupProcess(data, uri);
            this.lookupLibrary[uri] = data;
            return data;
          } else {
            return this.lookupLibrary[uri];
          }
        }
      },
      /**
      * processes the data returned
      * 
      * @async
      * @param {array} data - the results from the vocabulary data endpoint
      * @param {boolean} parentURI - the URI to look for in extacting the values
      * @return {object} - returns the results processing
      */
      simpleLookupProcess: function(data, parentURI) {
        let dataProcessed = {
          // all the URIs will live here but also the metadata obj about the uris
          metadata: {
            uri: parentURI,
            values: {}
          }
        };
        if (Array.isArray(data)) {
          data.forEach((d2) => {
            let label2 = null;
            let labelData = null;
            if (d2["@id"] && d2["@id"] != parentURI && !d2["@id"].includes("_:")) {
              this.possibleLabelURIs.forEach((labelURI) => {
                if (d2[labelURI] && !dataProcessed[d2["@id"]]) {
                  label2 = this.returnValue(d2[labelURI]);
                  let labelWithCode = [];
                  let metadata = { uri: d2["@id"], label: [], code: [], displayLabel: [] };
                  label2.forEach((l2) => {
                    labelWithCode.push(`${l2} (${d2["@id"].split("/").pop()})`);
                    metadata.displayLabel.push(`${l2.trim()} (${d2["@id"].split("/").pop()})`);
                    metadata.label.push(l2.trim());
                    metadata.code.push(d2["@id"].split("/").pop());
                  });
                  labelData = metadata;
                  label2 = labelWithCode;
                }
              });
            } else if (d2["http://id.loc.gov/ontologies/RecordInfo#recordStatus"]) {
              return false;
            } else {
              return false;
            }
            if (label2 === null) {
              console.error("lookupUtility: Was expecting this to have a label", d2);
              return false;
            }
            dataProcessed[d2["@id"]] = label2;
            dataProcessed.metadata.values[d2["@id"]] = labelData;
          });
        } else {
          dataProcessed = data;
        }
        return dataProcessed;
      },
      /**
      * Does a suggest2 lookup against ID provided the vocabulary to look into
      * 
      * @async
      * @param {string} uris - the uri(s) to the ID vocabulary to search
      * @param {boolean} keyword - the query term
      * @return {object} - returns the result of the suggest search
      */
      loadSimpleLookupKeyword: async function(uris, keyword) {
        if (!Array.isArray(uris)) {
          uris = [uris];
        }
        let results = { metadata: { uri: uris[0] + "KEYWORD", values: {} } };
        console.log("results", results);
        for (let uri of uris) {
          if (uri.at(-1) == "/") {
            uri[-1] = "";
          }
          let url = `${uri}/suggest2/?q=${keyword}&count=25`;
          let r2 = await this.fetchSimpleLookup(url);
          if (r2.hits && r2.hits.length == 0) {
            url = `${uri}/suggest2/?q=${keyword}&count=25&searchtype=keyword`;
            r2 = await this.fetchSimpleLookup(url);
          }
          if (r2.hits && r2.hits.length > 0) {
            for (let hit of r2.hits) {
              results.metadata.values[hit.uri] = { uri: hit.uri, label: [hit.suggestLabel], authLabel: hit.aLabel, code: [], displayLabel: [hit.suggestLabel] };
              results[hit.uri] = [hit.suggestLabel];
            }
          }
        }
        this.lookupLibrary[uris[0] + "KEYWORD"] = results;
        return results;
      },
      /**
      * The lower level function used by a lot of other fuctions to make fetch calls to pull in data
      * 
      * fetches the profile data from supplied URL or from the config URL if empty
      * @async
      * @param {string} url - the URL to ask for, if left blank it just pulls in the profiles
      * @param {boolean} json - if defined and true will treat the call as a json request, addding some headers to ask for json
      * @return {object|string} - returns the JSON object parsed into JS Object or the text body of the response depending if it is json or not
      */
      fetchSimpleLookup: async function(url, json) {
        url = url || config.profileUrl;
        if (url.includes("id.loc.gov")) {
          url = url.replace("http://", "https://");
        }
        url = url.replace("memberOf=https://id.loc.gov/", "memberOf=http://id.loc.gov/");
        let options = {};
        if (json) {
          options = { headers: { "Content-Type": "application/json", "Accept": "application/json" }, mode: "cors" };
        }
        try {
          let response = await fetch(url, options);
          let data = null;
          if (url.includes(".rdf") || url.includes(".xml")) {
            data = await response.text();
          } else {
            data = await response.json();
          }
          return data;
        } catch (err) {
          console.error(err);
          return false;
        }
      },
      // returns the literal value based on the jsonld structure
      returnValue: function(input) {
        let value = [];
        if (Array.isArray(input)) {
          input.forEach((v2) => {
            if (typeof v2 === "object") {
              if (v2["@value"]) {
                value.push(v2["@value"]);
              } else {
                console.warn("lookupUtility: lookup parse error, Was expecting a @value in this object:", v2);
              }
            } else if (typeof v2 === "string" || typeof v2 === "number") {
              value.push(v2);
            } else {
              console.warn("lookupUtility: lookup parse error, Was expecting some sort of value here:", v2);
            }
          });
        }
        return value;
      },
      /**
      * Payload to pass to searchComplex
      * @typedef {searchPayload} searchPayload
      * @property {string} processor - flag to tell how to process the results, can be "lcAuthorities" or "wikidataAPI"
      * @property {string} searchValue - the search value being searched for
      * @property {array} url - array of urls to use 
      */
      /**
      * A single result from searchComplex
      * @typedef {searchComplexResult} searchComplexResult
      * @property {string} label - the authorative label
      * @property {string} suggestLabel - the suggest label
      * @property {string} uri - the URI to the resource
      * @property {boolean} literal - if its a literal response or not, the literal is often added in there as an option
      * @property {boolean} depreciated - if true the term is depreciated according to the service
      * @property {string} extra - any other extra info to make available in the interface
      */
      /**
      * Looks for instances by LCCN against ID, returns into for them to be displayed and load the resource
      * @param {searchPayload} searchPayload - the {@link searchPayload} to look for
      * @return {array} - An array of {@link searchComplexResult} results
      */
      searchComplex: async function(searchPayload) {
        let returnUrls = useConfigStore().returnUrls;
        let urlTemplate = searchPayload.url;
        if (!Array.isArray(urlTemplate)) {
          urlTemplate = [urlTemplate];
        }
        if (searchPayload.processor == "lcAuthorities") {
          for (let idx in urlTemplate) {
            if (urlTemplate[idx].includes("q=?")) {
              urlTemplate[idx] = urlTemplate[idx].replace("q=?", "q=") + "&searchtype=keyword";
            }
          }
        }
        let results = [];
        for (let url of urlTemplate) {
          if (returnUrls.dev || returnUrls.publicEndpoints) {
            url = url.replace("http://preprod.id.", "https://id.");
            url = url.replace("https://preprod-8230.id.loc.gov", "https://id.loc.gov");
            url = url.replace("https://test-8080.id.lctl.gov", "https://id.loc.gov");
            url = url.replace("https://preprod-8080.id.loc.gov", "https://id.loc.gov");
            url = url.replace("https://preprod-8288.id.loc.gov", "https://id.loc.gov");
          }
          url = url + "&blastdacache=" + Date.now();
          if (url.includes("searchtype=keyword") && url.includes("q=?")) {
            url = url.replace("q=?", "q=");
          }
          let r2 = await this.fetchSimpleLookup(url);
          if (searchPayload.processor == "lcAuthorities") {
            for (let hit of r2.hits) {
              let hitAdd = {
                label: hit.aLabel,
                vlabel: hit.vLabel,
                suggestLabel: hit.suggestLabel,
                uri: hit.uri,
                literal: false,
                depreciated: false,
                extra: ""
              };
              if (hitAdd.label == "" && hitAdd.suggestLabel.includes("DEPRECATED")) {
                hitAdd.label = hitAdd.suggestLabel.split("(DEPRECATED")[0] + " DEPRECATED";
                hitAdd.depreciated = true;
              }
              results.push(hitAdd);
            }
          } else if (searchPayload.processor == "wikidataAPI") {
            for (let hit of r2.search) {
              results.push({
                label: hit.label,
                uri: hit.concepturi,
                literal: false,
                extra: ""
              });
            }
          }
        }
        if (!searchPayload.url[0].includes("/works/") && !searchPayload.url[0].includes("/hubs/")) {
          results.push({
            label: searchPayload.searchValue,
            uri: null,
            literal: true,
            extra: ""
          });
        }
        return results;
      },
      /**
      * What is returned from the context request 
      * @typedef {contextResult} contextResult
      * @property {boolean} contextValue - xxxxxxxxx
      * @property {array} source - xxxxxxxxx
      * @property {string} type - xxxxxxxxx
      * @property {string} typeFull - xxxxxxxxx
      * @property {string} aap - xxxxxxxxx
      * @property {array} variant - xxxxxxxxx
      * @property {string} uri - xxxxxxxxx
      * @property {string} title - xxxxxxxxx
      * @property {array} contributor - xxxxxxxxx
      * @property {string} date - xxxxxxxxx
      * @property {string} genreForm - xxxxxxxxx
      * @property {object} nodeMap - xxxxxxxxx
      */
      /**
      * Kicks off the main process to return details about a URI, this is used in the 
      * complex lookup modal 
      * @param {string} uri - The URI to use, probably a id.loc.gov link
      * @return {array} - An array of {@link contextResult} results
      */
      returnContext: async function(uri) {
        let d2 = await this.fetchContextData(uri);
        d2.uri = uri;
        let results;
        if (uri.includes("resources/works/") || uri.includes("resources/hubs/")) {
          results = await this.extractContextDataWorksHubs(d2);
        } else {
          results = this.extractContextData(d2);
        }
        return results;
      },
      /**
      * Talks to the server, a lot of ID logic
      * @param {string} uri  - The URI to use, probably a id.loc.gov link
      * @return {object} - the data response
      */
      fetchContextData: async function(uri) {
        let returnUrls = useConfigStore().returnUrls;
        if ((uri.startsWith("http://id.loc.gov") || uri.startsWith("https://id.loc.gov")) && uri.match(/(authorities|vocabularies)/)) {
          var jsonuri = uri + ".madsrdf_raw.jsonld";
        } else if (uri.includes("resources/works/") || uri.includes("resources/hubs/")) {
          jsonuri = uri + ".bibframe.json";
        } else if (uri.includes("http://www.wikidata.org/entity/")) {
          jsonuri = uri.replace("http://www.wikidata.org/entity/", "https://www.wikidata.org/wiki/Special:EntityData/");
          jsonuri = jsonuri + ".json";
        } else {
          jsonuri = uri + ".jsonld";
        }
        if (returnUrls.env == "production" || returnUrls.env == "staging") {
          jsonuri = jsonuri.replace("http://id.", "https://preprod-8080.id.");
          jsonuri = jsonuri.replace("https://id.", "https://preprod-8080.id.");
        }
        if (returnUrls.dev || returnUrls.publicEndpoints) {
          jsonuri = jsonuri.replace("http://preprod.id.", "https://id.");
          jsonuri = jsonuri.replace("https://preprod-8230.id.loc.gov", "https://id.loc.gov");
          jsonuri = jsonuri.replace("https://test-8080.id.lctl.gov", "https://id.loc.gov");
          jsonuri = jsonuri.replace("https://preprod-8080.id.loc.gov", "https://id.loc.gov");
          jsonuri = jsonuri.replace("https://preprod-8288.id.loc.gov", "https://id.loc.gov");
        }
        if (jsonuri.includes("gpo_") && jsonuri.includes("preprod")) {
          jsonuri = jsonuri.replace("8080", "8295");
          jsonuri = jsonuri.replace("8230", "8295");
          jsonuri = jsonuri.replace("https://id.", "https://preprod-8295.id.");
        }
        jsonuri = jsonuri.replace("http://id.loc.gov", "https://id.loc.gov");
        try {
          let response = await fetch(jsonuri);
          let data = await response.json();
          return data;
        } catch (err) {
          console.error(err);
        }
      },
      /**
      * Extract data from the data for hubs     
      * @param {object} data - The URI to use, probably a id.loc.gov link
      * @return {array} - An array of {@link contextResult} results
      */
      extractContextDataWorksHubs: async function(data) {
        let returnUrls = useConfigStore().returnUrls;
        var results = { contextValue: true, source: [], type: null, typeFull: null, aap: null, variant: [], uri: data.uri, title: null, contributor: [], date: null, genreForm: null, nodeMap: {} };
        if (data.uri.includes("/works/")) {
          results.type = "Work";
          results.typeFull = "http://id.loc.gov/ontologies/bibframe/Work";
        } else {
          results.type = "Hub";
          results.typeFull = "http://id.loc.gov/ontologies/bibframe/Hub";
        }
        let instances = [];
        for (let val of data) {
          if (val["@id"]) {
            if (val["@id"] == data.uri) {
              for (let k2 in val) {
                if (k2 == "http://www.w3.org/2000/01/rdf-schema#label") {
                  results.title = val[k2][0]["@value"];
                }
                if (k2 == "http://id.loc.gov/ontologies/bflc/aap") {
                  results.aap = val[k2][0]["@value"];
                }
                if (k2 == "http://id.loc.gov/ontologies/bibframe/hasInstance") {
                  let counter = 1;
                  for (let i2 of val["http://id.loc.gov/ontologies/bibframe/hasInstance"]) {
                    if (counter > 4) {
                      break;
                    }
                    counter++;
                    let url = i2["@id"];
                    if (url.includes("gpo_")) {
                      url = url.replace("https://id.", "https://preprod-8295.id.");
                      url = url.replace("http://id.", "http://preprod-8295.id.");
                    }
                    if (url.includes("/instances/") || url.includes("/works/") || url.includes("/hubs/")) {
                      if (returnUrls.env === "production") {
                        url = url.replace("https://id.", "https://preprod-8080.id.");
                        url = url.replace("http://id.", "http://preprod-8080.id.");
                      }
                    }
                    if (returnUrls.dev || returnUrls.publicEndpoints) {
                      url = url.replace("http://preprod.id.", "https://id.");
                      url = url.replace("https://preprod-8230.id.loc.gov", "https://id.loc.gov");
                      url = url.replace("https://test-8080.id.lctl.gov", "https://id.loc.gov");
                      url = url.replace("https://preprod-8080.id.loc.gov", "https://id.loc.gov");
                      url = url.replace("http://preprod-8080.id.loc.gov", "https://id.loc.gov");
                      url = url.replace("https://preprod-8288.id.loc.gov", "https://id.loc.gov");
                    }
                    console.log("URL is", url);
                    let response = await fetch(url.replace("http://", "https://") + ".nt");
                    let text = await response.text();
                    let instanceText = "";
                    for (let line of text.split("\n")) {
                      if (line.includes(`<${i2["@id"]}> <http://www.w3.org/2000/01/rdf-schema#label>`)) {
                        let t2 = line.split(">")[2];
                        t2 = t2.split("@")[0];
                        t2 = t2.replaceAll('"', "");
                        t2 = t2.replace(" .", "");
                        instanceText = instanceText + t2;
                      }
                      if (line.includes(`<${i2["@id"]}> <http://id.loc.gov/ontologies/bibframe/provisionActivityStatement>`)) {
                        let t2 = line.split(">")[2];
                        t2 = t2.split("@")[0];
                        t2 = t2.replaceAll('"', "");
                        t2 = t2.replace(" .", "");
                        instanceText = instanceText + t2;
                      }
                    }
                    instances.push(instanceText);
                  }
                }
              }
            }
            if (val["http://www.loc.gov/mads/rdf/v1#isMemberOfMADSScheme"]) {
              if (!results.nodeMap["Subjects"]) {
                results.nodeMap["Subjects"] = [];
              }
              if (val["http://www.loc.gov/mads/rdf/v1#authoritativeLabel"]) {
                results.nodeMap["Subjects"].push(val["http://www.loc.gov/mads/rdf/v1#authoritativeLabel"][0]["@value"]);
              }
            }
          }
        }
        if (!results.title) {
          results.title = results.aap;
        }
        if (instances.length > 0) {
          results.nodeMap["Instances"] = instances;
        }
        return results;
      },
      /**
      * Extract data from the data not hubs   
      * @param {object} data - The URI to use, probably a id.loc.gov link
      * @return {array} - An array of {@link contextResult} results
      */
      extractContextData: function(data) {
        var results = { contextValue: true, source: [], type: null, typeFull: null, variant: [], uri: data.uri, title: null, contributor: [], date: null, genreForm: null, nodeMap: {} };
        if (data.uri.includes("wikidata.org")) {
          if (data.entities) {
            let qid = Object.keys(data.entities)[0];
            if (data.entities[qid].labels.en) {
              results.title = data.entities[qid].labels.en.value;
            }
            if (data.entities[qid].descriptions.en) {
              results.nodeMap["Description"] = [data.entities[qid].descriptions.en.value];
            }
            if (data.entities[qid].aliases.en) {
              data.entities[qid].aliases.en.forEach((v2) => {
                results.variant.push(v2.value);
              });
            }
            results.type = "http://www.loc.gov/mads/rdf/v1#PersonalName";
            results.typeFull = "http://www.loc.gov/mads/rdf/v1#PersonalName";
            if (data.entities[qid].claims.P31) {
              if (data.entities[qid].claims.P31[0].mainsnak) {
                if (data.entities[qid].claims.P31[0].mainsnak.datavalue) {
                  if (data.entities[qid].claims.P31[0].mainsnak.datavalue.value) {
                    results.type = this.rdfType(data.entities[qid].claims.P31[0].mainsnak.datavalue.value.id);
                  }
                }
              }
            }
          }
        } else if (data.uri.includes("id.loc.gov/resources/works/") || data.uri.includes("id.loc.gov/resources/instances/") || data.uri.includes("id.loc.gov/resources/hubs/")) {
          let uriIdPart = data.uri.split("/").slice(-1)[0];
          for (let g2 of data) {
            if (g2 && g2["@id"] && (g2["@id"].endsWith(`/works/${uriIdPart}`) || g2["@id"].endsWith(`/instances/${uriIdPart}`) || g2["@id"].endsWith(`/hubs/${uriIdPart}`))) {
              if (g2["@id"].endsWith(`/works/${uriIdPart}`) && data.uri.includes("id.loc.gov/resources/works/") || g2["@id"].endsWith(`/instances/${uriIdPart}`) && data.uri.includes("id.loc.gov/resources/instances/") || g2["@id"].endsWith(`/hubs/${uriIdPart}`) && data.uri.includes("id.loc.gov/resources/hubs/")) {
                if (g2["http://www.w3.org/2000/01/rdf-schema#label"] && g2["http://www.w3.org/2000/01/rdf-schema#label"][0]) {
                  results.title = g2["http://www.w3.org/2000/01/rdf-schema#label"][0]["@value"];
                } else if (g2["http://id.loc.gov/ontologies/bflc/aap"] && g2["http://id.loc.gov/ontologies/bflc/aap"][0]) {
                  results.title = g2["http://id.loc.gov/ontologies/bflc/aap"][0]["@value"];
                }
                if (g2["@type"] && g2["@type"][0]) {
                  results.type = this.rdfType(g2["@type"][0]);
                  results.typeFull = g2["@type"][0];
                }
              }
            }
          }
        } else {
          if (data["@graph"]) {
            data = data["@graph"];
          }
          var nodeMap = {};
          data.forEach(function(n2) {
            if (n2["http://www.loc.gov/mads/rdf/v1#birthDate"]) {
              nodeMap["Birth Date"] = n2["http://www.loc.gov/mads/rdf/v1#birthDate"].map(function(d2) {
                return d2["@value"];
              });
            }
            if (n2["http://www.loc.gov/mads/rdf/v1#birthPlace"]) {
              nodeMap["Birth Place"] = n2["http://www.loc.gov/mads/rdf/v1#birthPlace"].map(function(d2) {
                return d2["@id"];
              });
            }
            if (n2["http://www.loc.gov/mads/rdf/v1#associatedLocale"]) {
              nodeMap["Associated Locale"] = n2["http://www.loc.gov/mads/rdf/v1#associatedLocale"].map(function(d2) {
                return d2["@id"];
              });
            }
            if (n2["http://www.loc.gov/mads/rdf/v1#fieldOfActivity"]) {
              nodeMap["Field of Activity"] = n2["http://www.loc.gov/mads/rdf/v1#fieldOfActivity"].map(function(d2) {
                return d2["@id"];
              });
            }
            if (n2["http://www.loc.gov/mads/rdf/v1#gender"]) {
              nodeMap["Gender"] = n2["http://www.loc.gov/mads/rdf/v1#gender"].map(function(d2) {
                return d2["@id"];
              });
            }
            if (n2["http://www.loc.gov/mads/rdf/v1#occupation"]) {
              nodeMap["Occupation"] = n2["http://www.loc.gov/mads/rdf/v1#occupation"].map(function(d2) {
                return d2["@id"];
              });
            }
            if (n2["http://www.loc.gov/mads/rdf/v1#associatedLanguage"]) {
              nodeMap["Associated Language"] = n2["http://www.loc.gov/mads/rdf/v1#associatedLanguage"].map(function(d2) {
                return d2["@id"];
              });
            }
            if (n2["http://www.loc.gov/mads/rdf/v1#deathDate"]) {
              nodeMap["Death Date"] = n2["http://www.loc.gov/mads/rdf/v1#deathDate"].map(function(d2) {
                return d2["@value"];
              });
            }
            if (n2["http://www.loc.gov/mads/rdf/v1#hasBroaderAuthority"]) {
              nodeMap["Has Broader Authority"] = n2["http://www.loc.gov/mads/rdf/v1#hasBroaderAuthority"].map(function(d2) {
                return d2["@id"];
              });
            }
            if (n2["http://www.loc.gov/mads/rdf/v1#hasNarrowerAuthority"]) {
              nodeMap["Has Narrower Authority"] = n2["http://www.loc.gov/mads/rdf/v1#hasNarrowerAuthority"].map(function(d2) {
                return d2["@id"];
              });
            }
            if (n2["http://www.loc.gov/mads/rdf/v1#isMemberOfMADSCollection"]) {
              nodeMap["MADS Collection"] = n2["http://www.loc.gov/mads/rdf/v1#isMemberOfMADSCollection"].map(function(d2) {
                return d2["@id"];
              });
            }
            if (n2["http://www.loc.gov/mads/rdf/v1#code"] && n2["http://www.loc.gov/mads/rdf/v1#code"][0]["@type"] == "http://id.loc.gov/datatypes/codes/gac") {
              nodeMap["GAC(s)"] = n2["http://www.loc.gov/mads/rdf/v1#code"].map(function(d2) {
                if (d2["@type"] == "http://id.loc.gov/datatypes/codes/gac") {
                  return d2["@value"];
                }
              });
            }
            if (n2["@type"].includes("http://id.loc.gov/ontologies/lcc#ClassNumber") !== false) {
              if (!nodeMap["LC Classification"]) {
                nodeMap["LC Classification"] = [];
              }
              if (n2["http://www.loc.gov/mads/rdf/v1#code"] && n2["http://id.loc.gov/ontologies/bibframe/assigner"]) {
                nodeMap["LC Classification"].push(`${n2["http://www.loc.gov/mads/rdf/v1#code"][0]["@value"]} (${n2["http://id.loc.gov/ontologies/bibframe/assigner"][0]["@id"].split("/").pop()})`);
              } else if (n2["http://www.loc.gov/mads/rdf/v1#code"]) {
                nodeMap["LC Classification"].push(n2["http://www.loc.gov/mads/rdf/v1#code"][0]["@value"]);
              }
            }
            if (n2["http://www.loc.gov/mads/rdf/v1#classification"]) {
              nodeMap["Classification"] = n2["http://www.loc.gov/mads/rdf/v1#classification"].map(function(d2) {
                return d2["@value"];
              });
              nodeMap["Classification"] = nodeMap["Classification"].filter((v2) => {
              });
            }
          });
          data.forEach(function(n2) {
            Object.keys(nodeMap).forEach(function(k2) {
              if (!results.nodeMap[k2]) {
                results.nodeMap[k2] = [];
              }
              nodeMap[k2].forEach(function(uri) {
                if (k2 == "MADS Collection") {
                  if (results.nodeMap[k2].indexOf(uri.split("/").slice(-1)[0].replace("collection_", "")) == -1) {
                    results.nodeMap[k2].push(uri.split("/").slice(-1)[0].replace("collection_", ""));
                  }
                } else if (k2 == "Classification") {
                  if (nodeMap[k2].length > 0) {
                    results.nodeMap[k2] = nodeMap[k2];
                  }
                } else if (k2 == "LC Classification") {
                  if (nodeMap[k2].length > 0) {
                    results.nodeMap[k2] = nodeMap[k2];
                  }
                } else if (k2 == "GAC(s)") {
                  if (nodeMap[k2].length > 0) {
                    results.nodeMap[k2] = nodeMap[k2];
                  }
                } else if (n2["@id"] && n2["@id"] == uri) {
                  if (n2["http://www.loc.gov/mads/rdf/v1#authoritativeLabel"]) {
                    n2["http://www.loc.gov/mads/rdf/v1#authoritativeLabel"].forEach(function(val) {
                      if (val["@value"]) {
                        results.nodeMap[k2].push(val["@value"]);
                      }
                    });
                  } else if (n2["http://www.w3.org/2000/01/rdf-schema#label"]) {
                    n2["http://www.w3.org/2000/01/rdf-schema#label"].forEach(function(val) {
                      if (val["@value"]) {
                        results.nodeMap[k2].push(val["@value"]);
                      }
                    });
                  } else {
                    console.log("NO label found for ", n2);
                  }
                } else if (uri.includes("id.loc.gov")) {
                  let slug = uri.split("/").slice(-1)[0];
                  if (results.nodeMap[k2].indexOf(slug) == -1) {
                    results.nodeMap[k2].push(slug);
                  }
                }
              });
            });
          });
          data.forEach((n2) => {
            var citation = "";
            var variant = "";
            var title = "";
            if (n2["http://www.loc.gov/mads/rdf/v1#citation-source"]) {
              citation = citation + " Source: " + n2["http://www.loc.gov/mads/rdf/v1#citation-source"].map(function(v2) {
                return v2["@value"] + " ";
              });
            }
            if (n2["http://www.loc.gov/mads/rdf/v1#citation-note"]) {
              citation = citation + " Note: " + n2["http://www.loc.gov/mads/rdf/v1#citation-note"].map(function(v2) {
                return v2["@value"] + " ";
              });
            }
            if (n2["http://www.loc.gov/mads/rdf/v1#citation-status"]) {
              citation = citation + " Status: " + n2["http://www.loc.gov/mads/rdf/v1#citation-status"].map(function(v2) {
                return v2["@value"] + " ";
              });
            }
            if (n2["http://www.loc.gov/mads/rdf/v1#citationSource"]) {
              citation = citation + " Source: " + n2["http://www.loc.gov/mads/rdf/v1#citationSource"].map(function(v2) {
                return v2["@value"] + " ";
              });
            }
            if (n2["http://www.loc.gov/mads/rdf/v1#citationNote"]) {
              citation = citation + " Note: " + n2["http://www.loc.gov/mads/rdf/v1#citationNote"].map(function(v2) {
                return v2["@value"] + " ";
              });
            }
            if (n2["http://www.loc.gov/mads/rdf/v1#citationStatus"]) {
              citation = citation + " Status: " + n2["http://www.loc.gov/mads/rdf/v1#citationStatus"].map(function(v2) {
                return v2["@value"] + " ";
              });
            }
            if (n2["http://www.loc.gov/mads/rdf/v1#variantLabel"]) {
              variant = variant + n2["http://www.loc.gov/mads/rdf/v1#variantLabel"].map(function(v2) {
                return v2["@value"] + " ";
              });
            }
            if (n2["@id"] && n2["@id"] == data.uri && n2["http://www.loc.gov/mads/rdf/v1#authoritativeLabel"]) {
              title = title + n2["http://www.loc.gov/mads/rdf/v1#authoritativeLabel"].map(function(v2) {
                return v2["@value"] + " ";
              });
            }
            if (n2["@id"] && n2["@id"] == data.uri && n2["@type"]) {
              n2["@type"].forEach((t2) => {
                if (results.type === null) {
                  results.type = this.rdfType(t2);
                  results.typeFull = t2;
                }
              });
              if (n2["@type"].includes("http://www.loc.gov/mads/rdf/v1#DeprecatedAuthority")) {
                results.depreciated = true;
              }
            }
            citation = citation.trim();
            variant = variant.trim();
            title = title.trim();
            if (variant != "") {
              results.variant.push(variant);
            }
            if (citation != "") {
              results.source.push(citation);
            }
            if (title != "") {
              results.title = title;
            }
            if (n2["@type"] && n2["@type"] == "http://id.loc.gov/ontologies/bibframe/Title") {
              if (n2["bibframe:mainTitle"]) {
                results.title = n2["bibframe:mainTitle"];
              }
            }
            if (n2["@type"] && (n2["@type"] == "http://id.loc.gov/ontologies/bibframe/Agent" || n2["@type"].indexOf("http://id.loc.gov/ontologies/bibframe/Agent") > -1)) {
              if (n2["bflc:name00MatchKey"]) {
                results.contributor.push(n2["bflc:name00MatchKey"]);
              }
            }
            if (n2["bibframe:creationDate"] && n2["bibframe:creationDate"]["@value"]) {
              results.date = n2["bibframe:creationDate"]["@value"];
            }
            if (n2["@type"] && n2["@type"] == "http://id.loc.gov/ontologies/bibframe/GenreForm") {
              if (n2["bibframe:mainTitle"]) {
                results.genreForm = n2["rdf-schema:label"];
              }
            }
          });
        }
        Object.keys(results.nodeMap).forEach((k2) => {
          if (results.nodeMap[k2].length == 0) {
            delete results.nodeMap[k2];
          }
        });
        return results;
      },
      /**
      * Returns a short version based on the RDF type
      * @param {string} type - the URI of the type
      * @return {string} - a MADSRDF type of the string
      */
      rdfType: function(type) {
        var rdftype = null;
        if (type == "http://www.loc.gov/mads/rdf/v1#PersonalName" || type == "http://id.loc.gov/ontologies/bibframe/Person") {
          rdftype = "PersonalName";
        } else if (type == "http://id.loc.gov/ontologies/bibframe/Topic" || type == "http://www.loc.gov/mads/rdf/v1#Topic") {
          rdftype = "Topic";
        } else if (type == "http://www.loc.gov/mads/rdf/v1#Place" || type == "http://id.loc.gov/ontologies/bibframe/Place" || type == "http://www.loc.gov/mads/rdf/v1#Geographic") {
          rdftype = "Geographic";
        } else if (type == "http://www.loc.gov/mads/rdf/v1#Temporal") {
          rdftype = "Temporal";
        } else if (type == "http://www.loc.gov/mads/rdf/v1#Organization" || type == "http://www.loc.gov/mads/rdf/v1#CorporateName" || type == "http://id.loc.gov/ontologies/bibframe/Organization") {
          rdftype = "CorporateName";
        } else if (type == "http://www.loc.gov/mads/rdf/v1#Family" || type == "http://id.loc.gov/ontologies/bibframe/Family") {
          rdftype = "FamilyName";
        } else if (type == "http://www.loc.gov/mads/rdf/v1#Meeting" || type == "http://id.loc.gov/ontologies/bibframe/Meeting") {
          rdftype = "ConferenceName";
        } else if (type == "http://www.loc.gov/mads/rdf/v1#Jurisdiction" || type == "http://id.loc.gov/ontologies/bibframe/Jurisdiction") {
          rdftype = "Geographic";
        } else if (type == "http://id.loc.gov/ontologies/bibframe/GenreForm" || type == "http://www.loc.gov/mads/rdf/v1#GenreForm") {
          rdftype = "GenreForm";
        } else if (type == "http://id.loc.gov/ontologies/bibframe/Role") {
          rdftype = "Role";
        } else if (type == "http://id.loc.gov/ontologies/madsrdf/v1.html#ComplexSubject") {
          rdftype = "ComplexSubject";
        } else if (type == "http://www.loc.gov/mads/rdf/v1#NameTitle") {
          rdftype = "NameTitle";
        } else if (type == "http://www.loc.gov/mads/rdf/v1#Title") {
          rdftype = "Title";
        } else if (type == "http://www.loc.gov/mads/rdf/v1#ComplexSubject") {
          rdftype = "ComplexSubject";
        } else if (type == "Q5") {
          rdftype = "PersonalName";
        } else if (type == "http://id.loc.gov/ontologies/bibframe/Work") {
          rdftype = "Work";
        } else if (type == "http://id.loc.gov/ontologies/bibframe/Instance") {
          rdftype = "Instance";
        }
        return rdftype;
      },
      fetchBfdbXML: async function(url) {
        if (url.includes("/works/")) {
          url = url.replace(/\.jsonld/, ".rdf");
        }
        url = url.replace(/\.jsonld/, ".xml");
        if (!url.includes("?")) {
          url = url + "?nocache=" + Date.now();
        }
        let r2;
        try {
          r2 = await this.fetchSimpleLookup(url);
        } catch (error) {
          r2 = "ERROR: Error fetching record.";
        }
        return r2;
      },
      /**
      * 
      * @typedef {subjectLinkModeResolveLCSHResult} subjectLinkModeResolveLCSHResult
      * @property {string} lccn - the lccn searched
      */
      /**
      * 
      * @async
      * @param {string} lcsh - the LCSH string MARC encoded 
      * @return {subjectLinkModeResolveLCSHResult} - A {@link subjectLinkModeResolveLCSHResult} result
      */
      subjectLinkModeResolveLCSH: async function(lcsh) {
        let result = {
          resultType: "",
          msg: ""
        };
        let regexResults;
        lcsh = lcsh.normalize();
        if (!lcsh) {
          result.resultType = "ERROR";
          result.msg = "REGEX Error: That value doesn't look like a valid MARC encoded LCSH string (undefined)";
        } else if (lcsh && typeof lcsh != "string") {
          result.resultType = "ERROR";
          result.msg = "REGEX Error: That value doesn't look like a valid MARC encoded LCSH string (not string)";
        }
        lcsh = lcsh.replace(/\$c/g, "").replace(/\$d/g, "").replace(/‡c/g, "").replace(/‡d/g, "").replace(/\s{2,}/g, " ");
        if (lcsh.substring(0, 2) != "$a" && lcsh.substring(0, 2) != "‡a") {
          lcsh = "$a" + lcsh;
        }
        if (lcsh.match(/[$‡]z.*([$‡]z.*)/) && lcsh.match(/[$‡]z.*([$‡]z.*)/).length === 2) {
          let secondDollarZ = lcsh.match(/[$‡]z.*([$‡]z.*)/)[1];
          let collapsedDollarZ;
          if (lcsh.match(/[$]z.*([$]z.*)/)) {
            collapsedDollarZ = secondDollarZ.replace("$z", "--");
          } else {
            collapsedDollarZ = secondDollarZ.replace("‡z", "--");
          }
          lcsh = lcsh.replace(secondDollarZ, collapsedDollarZ);
        }
        let dollarCount = lcsh.split(/[$‡]/).length - 1;
        if (dollarCount > 0) {
          if (dollarCount == 1) {
            regexResults = lcsh.match(/([$‡][avxyz].*)/);
          } else if (dollarCount == 2) {
            regexResults = lcsh.match(/([$‡][avxyz].*)([$‡][avxyz].*)/);
          } else if (dollarCount == 3) {
            regexResults = lcsh.match(/([$‡][avxyz].*)([$‡][avxyz].*)([$‡][avxyz].*)/);
          } else if (dollarCount == 4) {
            regexResults = lcsh.match(/([$‡][avxyz].*)([$‡][avxyz].*)([$‡][avxyz].*)([$‡][avxyz].*)/);
          } else if (dollarCount == 5) {
            regexResults = lcsh.match(/([$‡][avxyz].*)([$‡][avxyz].*)([$‡][avxyz].*)([$‡][avxyz].*)([$‡][avxyz].*)/);
          } else if (dollarCount == 6) {
            regexResults = lcsh.match(/([$‡][avxyz].*)([$‡][avxyz].*)([$‡][avxyz].*)([$‡][avxyz].*)([$‡][avxyz].*)([$‡][avxyz].*)/);
          } else if (dollarCount == 7) {
            regexResults = lcsh.match(/([$‡][avxyz].*)([$‡][avxyz].*)([$‡][avxyz].*)([$‡][avxyz].*)([$‡][avxyz].*)([$‡][avxyz].*)([$‡][avxyz].*)/);
          } else if (dollarCount == 8) {
            regexResults = lcsh.match(/([$‡][avxyz].*)([$‡][avxyz].*)([$‡][avxyz].*)([$‡][avxyz].*)([$‡][avxyz].*)([$‡][avxyz].*)([$‡][avxyz].*)([$‡][avxyz].*)/);
          } else {
            result.resultType = "ERROR";
            result.msg = "REGEX Error: That value doesn't look like a valid MARC encoded LCSH string (too long? invalid format?)";
          }
          try {
            regexResults = regexResults.slice(1, regexResults.length);
            for (let r2 of regexResults) {
              if (r2.slice(0, 2).toLowerCase() != "$v" && r2.slice(0, 2).toLowerCase() != "$a" && r2.slice(0, 2).toLowerCase() != "$x" && r2.slice(0, 2).toLowerCase() != "$y" && r2.slice(0, 2).toLowerCase() != "$z" && r2.slice(0, 2).toLowerCase() != "‡v" && r2.slice(0, 2).toLowerCase() != "‡a" && r2.slice(0, 2).toLowerCase() != "‡x" && r2.slice(0, 2).toLowerCase() != "‡y" && r2.slice(0, 2).toLowerCase() != "‡z") {
                result.resultType = "ERROR";
                result.msg = "REGEX Error: That value doesn't look like a valid MARC encoded LCSH string (error spliting into seperate values)";
              }
            }
          } catch {
            result.resultType = "ERROR";
            result.msg = "REGEX Error: That value doesn't look like a valid MARC encoded LCSH string (error spliting into seperate values)";
          }
        } else {
          result.resultType = "ERROR";
          result.msg = "REGEX Error: That value doesn't look like a valid MARC encoded LCSH string";
        }
        if (result.resultType == "ERROR") {
          return result;
        }
        let headings = regexResults.slice(0, regexResults.length).map((r2) => {
          return {
            type: r2.slice(1, 2),
            label: r2.slice(2, r2.length).trim().replace(/\.[$‡]/gu, "").replace(/\.$/, "")
            // remove any trailing periods
          };
        });
        for (const [i2, r2] of headings.entries()) {
          if (i2 > 0) {
            r2.subdivision = true;
            r2.primary = false;
          } else {
            r2.subdivision = false;
            r2.primary = true;
          }
          if (r2.type == "a") {
            r2.rdfType = "http://www.loc.gov/mads/rdf/v1#Topic";
          } else if (r2.type == "v") {
            r2.rdfType = "http://www.loc.gov/mads/rdf/v1#GenreForm";
          } else if (r2.type == "x") {
            r2.rdfType = "http://www.loc.gov/mads/rdf/v1#Topic";
          } else if (r2.type == "z") {
            r2.rdfType = "http://www.loc.gov/mads/rdf/v1#Geographic";
          } else if (r2.type == "y") {
            r2.rdfType = "http://www.loc.gov/mads/rdf/v1#Temporal";
          } else {
            r2.rdfType = "http://www.loc.gov/mads/rdf/v1#Topic";
          }
        }
        let complexHeading = headings.map((r2) => {
          return r2.label;
        }).join("--");
        let subjectUrlComplex = useConfigStore().lookupConfig["http://id.loc.gov/authorities/subjects"].modes[0]["LCSH All"].url.replace("<QUERY>", complexHeading).replace("&count=25", "&count=5") + "&rdftype=ComplexType";
        let searchPayloadSubjectsComplex = {
          processor: "lcAuthorities",
          url: [subjectUrlComplex],
          searchValue: complexHeading
        };
        for (let heading of headings) {
          let foundHeading = false;
          if (result && result.resultType && result.resultType == "COMPLEX") {
            break;
          }
          let searchVal = heading.label;
          let namesUrl = useConfigStore().lookupConfig["http://preprod.id.loc.gov/authorities/names"].modes[0]["NAF All"].url.replace("<QUERY>", searchVal).replace("&count=25", "&count=5");
          let namesUrlSubdivision = useConfigStore().lookupConfig["http://preprod.id.loc.gov/authorities/names"].modes[0]["NAF All"].url.replace("<QUERY>", searchVal).replace("&count=25", "&count=5") + "&memberOf=http://id.loc.gov/authorities/subjects/collection_Subdivisions";
          let subjectUrlSimple = useConfigStore().lookupConfig["http://id.loc.gov/authorities/subjects"].modes[0]["LCSH All"].url.replace("<QUERY>", searchVal).replace("&count=25", "&count=5") + "&rdftype=SimpleType";
          let subjectUrlSimpleSubdivison = useConfigStore().lookupConfig["http://id.loc.gov/authorities/subjects"].modes[0]["LCSH All"].url.replace("<QUERY>", searchVal).replace("&count=25", "&count=5") + "&rdftype=SimpleType&memberOf=http://id.loc.gov/authorities/subjects/collection_Subdivisions";
          let subjectUrlTemporal = useConfigStore().lookupConfig["http://id.loc.gov/authorities/subjects"].modes[0]["LCSH All"].url.replace("<QUERY>", searchVal).replace("&count=25", "&count=5") + "&memberOf=http://id.loc.gov/authorities/subjects/collection_TemporalSubdivisions";
          let subjectUrlGenre = useConfigStore().lookupConfig["http://id.loc.gov/authorities/subjects"].modes[0]["LCSH All"].url.replace("<QUERY>", searchVal).replace("&count=25", "&count=5") + "&rdftype=GenreForm";
          let worksUrlAnchored = useConfigStore().lookupConfig["https://preprod-8080.id.loc.gov/resources/works"].modes[0]["Works - Left Anchored"].url.replace("<QUERY>", searchVal).replace("&count=25", "&count=5");
          let hubsUrlAnchored = useConfigStore().lookupConfig["https://preprod-8080.id.loc.gov/resources/works"].modes[0]["Hubs - Left Anchored"].url.replace("<QUERY>", searchVal).replace("&count=25", "&count=5");
          let subjectUrlHierarchicalGeographic = useConfigStore().lookupConfig["HierarchicalGeographic"].modes[0]["All"].url.replace("<QUERY>", searchVal).replace("&count=25", "&count=5");
          let subjectUrlHierarchicalGeographicLCSH = useConfigStore().lookupConfig["http://id.loc.gov/authorities/subjects"].modes[0]["LCSH All"].url.replace("<QUERY>", searchVal).replace("&count=25", "&count=5") + "&rdftype=HierarchicalGeographic";
          let subjectUrlGeographicLCSH = useConfigStore().lookupConfig["http://id.loc.gov/authorities/subjects"].modes[0]["LCSH All"].url.replace("<QUERY>", searchVal).replace("&count=25", "&count=5") + "&rdftype=Geographic&memberOf=http://id.loc.gov/authorities/subjects/collection_Subdivisions";
          let subjectUrlGeographicLCNAF = useConfigStore().lookupConfig["http://preprod.id.loc.gov/authorities/names"].modes[0]["NAF All"].url.replace("<QUERY>", searchVal).replace("&count=25", "&count=5") + "&rdftype=Geographic&memberOf=http://id.loc.gov/authorities/subjects/collection_Subdivisions";
          let searchPayloadNames = {
            processor: "lcAuthorities",
            url: [namesUrl],
            searchValue: searchVal
          };
          let searchPayloadNamesSubdivision = {
            processor: "lcAuthorities",
            url: [namesUrlSubdivision],
            searchValue: searchVal
          };
          let searchPayloadSubjectsSimple = {
            processor: "lcAuthorities",
            url: [subjectUrlSimple],
            searchValue: searchVal
          };
          let searchPayloadSubjectsSimpleSubdivision = {
            processor: "lcAuthorities",
            url: [subjectUrlSimpleSubdivison],
            searchValue: searchVal
          };
          let searchPayloadTemporal = {
            processor: "lcAuthorities",
            url: [subjectUrlTemporal],
            searchValue: searchVal
          };
          let searchPayloadGenre = {
            processor: "lcAuthorities",
            url: [subjectUrlGenre],
            searchValue: searchVal
          };
          let searchPayloadHierarchicalGeographic = {
            processor: "lcAuthorities",
            url: [subjectUrlHierarchicalGeographic],
            searchValue: searchVal
          };
          let searchPayloadHierarchicalGeographicLCSH = {
            processor: "lcAuthorities",
            url: [subjectUrlHierarchicalGeographicLCSH],
            searchValue: searchVal
          };
          let searchPayloadGeographicLCSH = {
            processor: "lcAuthorities",
            url: [subjectUrlGeographicLCSH],
            searchValue: searchVal
          };
          let searchPayloadGeographicLCNAF = {
            processor: "lcAuthorities",
            url: [subjectUrlGeographicLCNAF],
            searchValue: searchVal
          };
          let searchPayloadWorksAnchored = {
            processor: "lcAuthorities",
            url: [worksUrlAnchored],
            searchValue: searchVal
          };
          let searchPayloadHubsAnchored = {
            processor: "lcAuthorities",
            url: [hubsUrlAnchored],
            searchValue: searchVal
          };
          let resultsNames = [];
          let resultsNamesSubdivision = [];
          let resultsSubjectsSimple = [];
          let resultsSubjectsComplex = [];
          let resultsHierarchicalGeographic = [];
          let resultsHierarchicalGeographicLCSH = [];
          let resultsWorksAnchored = [];
          let resultsHubsAnchored = [];
          let resultsPayloadSubjectsSimpleSubdivision = [];
          let resultsPayloadSubjectsTemporal = [];
          let resultsGeographicLCNAF = [];
          let resultsGeographicLCSH = [];
          let resultsGenre = [];
          if (heading.primary) {
            [resultsNames, resultsNamesSubdivision, resultsSubjectsSimple, resultsPayloadSubjectsSimpleSubdivision, resultsSubjectsComplex, resultsHierarchicalGeographic, resultsHierarchicalGeographicLCSH, resultsWorksAnchored, resultsHubsAnchored] = await Promise.all([
              this.searchComplex(searchPayloadNames),
              this.searchComplex(searchPayloadNamesSubdivision),
              this.searchComplex(searchPayloadSubjectsSimple),
              this.searchComplex(searchPayloadSubjectsSimpleSubdivision),
              this.searchComplex(searchPayloadSubjectsComplex),
              this.searchComplex(searchPayloadHierarchicalGeographic),
              this.searchComplex(searchPayloadHierarchicalGeographicLCSH),
              this.searchComplex(searchPayloadWorksAnchored),
              this.searchComplex(searchPayloadHubsAnchored)
            ]);
            resultsNames = resultsNames.filter((r2) => {
              return !r2.literal;
            });
            resultsNamesSubdivision = resultsNamesSubdivision.filter((r2) => {
              return !r2.literal;
            });
            resultsSubjectsSimple = resultsSubjectsSimple.filter((r2) => {
              return !r2.literal;
            });
            resultsSubjectsComplex = resultsSubjectsComplex.filter((r2) => {
              return !r2.literal;
            });
            resultsHierarchicalGeographic = resultsHierarchicalGeographic.filter((r2) => {
              return !r2.literal;
            });
            resultsHierarchicalGeographicLCSH = resultsHierarchicalGeographicLCSH.filter((r2) => {
              return !r2.literal;
            });
            resultsWorksAnchored = resultsWorksAnchored.filter((r2) => {
              return !r2.literal;
            });
            resultsHubsAnchored = resultsHubsAnchored.filter((r2) => {
              return !r2.literal;
            });
            resultsPayloadSubjectsSimpleSubdivision = resultsPayloadSubjectsSimpleSubdivision.filter((r2) => {
              return !r2.literal;
            });
            if (resultsSubjectsComplex.length > 0) {
              for (let r2 of resultsSubjectsComplex) {
                if (complexHeading.toLowerCase().trim().toLowerCase().trim().replace(/\s+/g, " ").replace(/[\p{P}$+<=>^`|~]/gu, "") == r2.label.toLowerCase().trim().toLowerCase().trim().replace(/\s+/g, " ").replace(/[\p{P}$+<=>^`|~]/gu, "")) {
                  result.resultType = "COMPLEX";
                  r2.heading = heading;
                  result.hit = r2;
                  foundHeading = true;
                  break;
                }
              }
              if (foundHeading) {
                break;
              }
            }
            let subdivisionUris = resultsPayloadSubjectsSimpleSubdivision.map((r2) => {
              return r2.uri;
            });
            resultsSubjectsSimple = resultsSubjectsSimple.filter((r2) => {
              return subdivisionUris.indexOf(r2.uri);
            });
            subdivisionUris = resultsNamesSubdivision.map((r2) => {
              return r2.uri;
            });
            resultsNames = resultsNames.filter((r2) => {
              return subdivisionUris.indexOf(r2.uri);
            });
            if (resultsSubjectsSimple.length > 0) {
              for (let r2 of resultsSubjectsSimple) {
                if (heading.label.toLowerCase().trim().replace(/\s+/g, " ").replace(/[\p{P}$+<=>^`|~]/gu, "") == r2.label.toLowerCase().trim().replace(/[\p{P}$+<=>^`|~]/gu, "") || heading.label.toLowerCase().trim().replace(/\s+/g, " ").replace(/[\p{P}$+<=>^`|~]/gu, "") == r2.vlabel.toLowerCase().trim().replace(/[\p{P}$+<=>^`|~]/gu, "")) {
                  result.resultType = "PRECOORD-LCSH";
                  if (!result.hit) {
                    result.hit = [];
                  }
                  r2.heading = heading;
                  result.hit.push(r2);
                  foundHeading = true;
                  break;
                }
              }
              if (foundHeading) {
                continue;
              }
            }
            if (resultsNames.length > 0) {
              for (let r2 of resultsNames) {
                if (heading.label.toLowerCase().trim().replace(/\s+/g, " ").replace(/[\p{P}$+<=>^`|~]/gu, "") == r2.label.toLowerCase().trim().replace(/[\p{P}$+<=>^`|~]/gu, "")) {
                  result.resultType = "PRECOORD-NAF";
                  if (!result.hit) {
                    result.hit = [];
                  }
                  r2.heading = heading;
                  result.hit.push(r2);
                  foundHeading = true;
                  break;
                }
              }
              if (foundHeading) {
                continue;
              }
            }
            if (resultsWorksAnchored.length > 0) {
              for (let r2 of resultsWorksAnchored) {
                if (heading.label.toLowerCase().trim().replace(/\s+/g, " ").replace(/[\p{P}$+<=>^`|~]/gu, "") == r2.label.toLowerCase().trim().replace(/[\p{P}$+<=>^`|~]/gu, "")) {
                  result.resultType = "PRECOORD-WORK";
                  if (!result.hit) {
                    result.hit = [];
                  }
                  r2.heading = heading;
                  result.hit.push(r2);
                  foundHeading = true;
                  break;
                }
              }
              if (foundHeading) {
                continue;
              }
            }
            if (resultsHubsAnchored.length > 0) {
              for (let r2 of resultsHubsAnchored) {
                if (heading.label.toLowerCase().trim().replace(/\s+/g, " ").replace(/[\p{P}$+<=>^`|~]/gu, "") == r2.label.toLowerCase().trim().replace(/[\p{P}$+<=>^`|~]/gu, "")) {
                  result.resultType = "PRECOORD-HUB";
                  if (!result.hit) {
                    result.hit = [];
                  }
                  r2.heading = heading;
                  result.hit.push(r2);
                  foundHeading = true;
                  break;
                }
              }
              if (foundHeading) {
                continue;
              }
            }
            if (!foundHeading) {
              if (!result.hit) {
                result.hit = [];
              }
              result.hit.push({
                label: heading.label,
                suggestLabel: heading.label,
                uri: null,
                literal: true,
                depreciated: false,
                extra: "",
                heading
              });
            }
          } else {
            if (heading.type === "z") {
              [resultsHierarchicalGeographic, resultsHierarchicalGeographicLCSH, resultsGeographicLCNAF, resultsGeographicLCSH] = await Promise.all([
                this.searchComplex(searchPayloadHierarchicalGeographic),
                this.searchComplex(searchPayloadHierarchicalGeographicLCSH),
                this.searchComplex(searchPayloadGeographicLCNAF),
                this.searchComplex(searchPayloadGeographicLCSH)
              ]);
              resultsHierarchicalGeographic = resultsHierarchicalGeographic.filter((r2) => {
                return !r2.literal;
              });
              resultsHierarchicalGeographicLCSH = resultsHierarchicalGeographicLCSH.filter((r2) => {
                return !r2.literal;
              });
              resultsGeographicLCNAF = resultsGeographicLCNAF.filter((r2) => {
                return !r2.literal;
              });
              resultsGeographicLCSH = resultsGeographicLCSH.filter((r2) => {
                return !r2.literal;
              });
              if (resultsHierarchicalGeographic.length > 0) {
                for (let r2 of resultsHierarchicalGeographic) {
                  if (heading.label.toLowerCase().trim().replace(/\s+/g, " ").replace(/[\p{P}$+<=>^`|~]/gu, "") == r2.label.toLowerCase().trim().replace(/[\p{P}$+<=>^`|~]/gu, "")) {
                    r2.heading = heading;
                    result.hit.push(r2);
                    foundHeading = true;
                  }
                }
                if (foundHeading) {
                  continue;
                }
              }
              if (resultsHierarchicalGeographicLCSH.length > 0) {
                for (let r2 of resultsHierarchicalGeographicLCSH) {
                  if (heading.label.toLowerCase().trim().replace(/\s+/g, " ").replace(/[\p{P}$+<=>^`|~]/gu, "") == r2.label.toLowerCase().trim().replace(/[\p{P}$+<=>^`|~]/gu, "")) {
                    r2.heading = heading;
                    result.hit.push(r2);
                    foundHeading = true;
                  }
                }
                if (foundHeading) {
                  continue;
                }
              }
              if (resultsGeographicLCNAF.length > 0) {
                for (let r2 of resultsGeographicLCNAF) {
                  if (heading.label.toLowerCase().trim().replace(/\s+/g, " ").replace(/[\p{P}$+<=>^`|~]/gu, "") == r2.label.toLowerCase().trim().replace(/[\p{P}$+<=>^`|~]/gu, "")) {
                    r2.heading = heading;
                    result.hit.push(r2);
                    foundHeading = true;
                  }
                }
                if (foundHeading) {
                  continue;
                }
              }
              if (resultsGeographicLCSH.length > 0) {
                for (let r2 of resultsGeographicLCSH) {
                  if (heading.label.toLowerCase().trim().replace(/\s+/g, " ").replace(/[\p{P}$+<=>^`|~]/gu, "") == r2.label.toLowerCase().trim().replace(/[\p{P}$+<=>^`|~]/gu, "")) {
                    r2.heading = heading;
                    result.hit.push(r2);
                    foundHeading = true;
                  }
                }
                if (foundHeading) {
                  continue;
                }
              }
              if (!foundHeading) {
                result.hit.push({
                  label: heading.label,
                  suggestLabel: heading.label,
                  uri: null,
                  literal: true,
                  depreciated: false,
                  extra: "",
                  heading
                });
              }
            } else if (heading.type === "x" || heading.type === "a") {
              [resultsPayloadSubjectsSimpleSubdivision] = await Promise.all([
                this.searchComplex(searchPayloadSubjectsSimpleSubdivision)
              ]);
              resultsPayloadSubjectsSimpleSubdivision = resultsPayloadSubjectsSimpleSubdivision.filter((r2) => {
                return !r2.literal;
              });
              if (resultsPayloadSubjectsSimpleSubdivision.length > 0) {
                for (let r2 of resultsPayloadSubjectsSimpleSubdivision) {
                  if (heading.label.toLowerCase().trim().replace(/\s+/g, " ").replace(/[\p{P}$+<=>^`|~]/gu, "") == r2.label.toLowerCase().trim().replace(/[\p{P}$+<=>^`|~]/gu, "")) {
                    r2.heading = heading;
                    result.hit.push(r2);
                    foundHeading = true;
                  }
                }
                if (foundHeading) {
                  continue;
                }
              }
              if (!foundHeading) {
                result.hit.push({
                  label: heading.label,
                  suggestLabel: heading.label,
                  uri: null,
                  literal: true,
                  depreciated: false,
                  extra: "",
                  heading
                });
              }
            } else if (heading.type === "y") {
              [resultsPayloadSubjectsTemporal] = await Promise.all([
                this.searchComplex(searchPayloadTemporal)
              ]);
              resultsPayloadSubjectsTemporal = resultsPayloadSubjectsTemporal.filter((r2) => {
                return !r2.literal;
              });
              if (resultsPayloadSubjectsTemporal.length > 0) {
                for (let r2 of resultsPayloadSubjectsTemporal) {
                  if (heading.label.toLowerCase().trim().replace(/\s+/g, " ").replace(/[\p{P}$+<=>^`|~]/gu, "") == r2.label.toLowerCase().trim().replace(/[\p{P}$+<=>^`|~]/gu, "")) {
                    r2.heading = heading;
                    result.hit.push(r2);
                    foundHeading = true;
                  }
                }
                if (foundHeading) {
                  continue;
                }
              }
              if (!foundHeading) {
                result.hit.push({
                  label: heading.label,
                  suggestLabel: heading.label,
                  uri: null,
                  literal: true,
                  depreciated: false,
                  extra: "",
                  heading
                });
              }
            } else if (heading.type === "v") {
              [resultsGenre] = await Promise.all([
                this.searchComplex(searchPayloadGenre)
              ]);
              resultsGenre = resultsGenre.filter((r2) => {
                return !r2.literal;
              });
              if (resultsGenre.length > 0) {
                for (let r2 of resultsGenre) {
                  if (heading.label.toLowerCase().trim().replace(/\s+/g, " ").replace(/[\p{P}$+<=>^`|~]/gu, "") == r2.label.toLowerCase().trim().replace(/[\p{P}$+<=>^`|~]/gu, "")) {
                    r2.heading = heading;
                    result.hit.push(r2);
                    foundHeading = true;
                  }
                }
                if (foundHeading) {
                  continue;
                }
              }
              if (!foundHeading) {
                result.hit.push({
                  label: heading.label,
                  suggestLabel: heading.label,
                  uri: null,
                  literal: true,
                  depreciated: false,
                  extra: "",
                  heading
                });
              }
            }
          }
        }
        if (Array.isArray(result.hit)) {
          for (let r2 of result.hit) {
            if (!r2.literal && r2.uri.indexOf("id.loc.gov/authorities/names/")) {
              let responseUri = await this.returnRDFType(r2.uri);
              if (responseUri) {
                r2.heading.rdfType = responseUri;
              }
            }
          }
        }
        return result;
      },
      /**
      * Send the URI it returns the URI to the MADS RDF type, mostly used for authoirties/names uris from id.loc.gov
      * @async
      * @param {string} uri - the URI to the authority we want to find the RDF type for
      * @return {string} - The URI of the likely MADSRDF rdf type
      */
      returnRDFType: async function(uri) {
        uri = uri.trim();
        let uriToLookFor = uri;
        if (uri.indexOf("id.loc.gov") > -1) {
          uriToLookFor = uriToLookFor.replace("https://", "http://");
          if (uri[uri.length - 1] === "/") {
            uri = uri.slice(0, -2);
          }
          uri = uri.replace(".html", ".json");
          if (uri.indexOf(".json") === -1) {
            uri = uri + ".json";
          }
        }
        let data = await this.fetchSimpleLookup(uri, true);
        if (uri.indexOf("id.loc.gov") > -1) {
          for (let d2 of data) {
            if (d2 && d2["@id"] && d2["@id"] == uriToLookFor) {
              if (d2["@type"]) {
                for (let type of d2["@type"]) {
                  if (type == "http://www.loc.gov/mads/rdf/v1#Temporal") {
                    return "http://www.loc.gov/mads/rdf/v1#Temporal";
                  } else if (type == "http://www.loc.gov/mads/rdf/v1#ComplexSubject") {
                    return "http://www.loc.gov/mads/rdf/v1#ComplexSubject";
                  } else if (type == "http://www.loc.gov/mads/rdf/v1#ConferenceName") {
                    return "http://www.loc.gov/mads/rdf/v1#ConferenceName";
                  } else if (type == "http://www.loc.gov/mads/rdf/v1#CorporateName") {
                    return "http://www.loc.gov/mads/rdf/v1#CorporateName";
                  } else if (type == "http://www.loc.gov/mads/rdf/v1#FamilyName") {
                    return "http://www.loc.gov/mads/rdf/v1#FamilyName";
                  } else if (type == "http://www.loc.gov/mads/rdf/v1#Geographic") {
                    return "http://www.loc.gov/mads/rdf/v1#Geographic";
                  } else if (type == "http://www.loc.gov/mads/rdf/v1#GenreForm") {
                    return "http://www.loc.gov/mads/rdf/v1#GenreForm";
                  } else if (type == "http://www.loc.gov/mads/rdf/v1#Language") {
                    return "http://www.loc.gov/mads/rdf/v1#Language";
                  } else if (type == "http://www.loc.gov/mads/rdf/v1#MainTitleElement") {
                    return "http://www.loc.gov/mads/rdf/v1#MainTitleElement";
                  } else if (type == "http://www.loc.gov/mads/rdf/v1#Meeting") {
                    return "http://www.loc.gov/mads/rdf/v1#Meeting";
                  } else if (type == "http://www.loc.gov/mads/rdf/v1#NameTitle") {
                    return "http://www.loc.gov/mads/rdf/v1#NameTitle";
                  } else if (type == "http://www.loc.gov/mads/rdf/v1#PersonalName") {
                    return "http://www.loc.gov/mads/rdf/v1#PersonalName";
                  } else if (type == "http://www.loc.gov/mads/rdf/v1#Temporal") {
                    return "http://www.loc.gov/mads/rdf/v1#Temporal";
                  } else if (type == "http://www.loc.gov/mads/rdf/v1#Title") {
                    return "http://www.loc.gov/mads/rdf/v1#Title";
                  } else if (type == "http://www.loc.gov/mads/rdf/v1#Topic") {
                    return "http://www.loc.gov/mads/rdf/v1#Topic";
                  } else if (type == "http://www.loc.gov/mads/rdf/v1#SimpleType") {
                    return "http://www.loc.gov/mads/rdf/v1#SimpleType";
                  }
                }
              }
            }
          }
        }
        return false;
      },
      /**
      * 
      * @async
      * @param {string} searchVal - the value to search lcsh for
      * @param {string} complexVal - The orginal full string
      * @param {string} mode - the search mode LCSHNAF GEO WORKS HUBS
      * @return {} - 
      */
      subjectSearch: async function(searchVal, complexVal, mode) {
        console.log(useConfigStore().lookupConfig);
        let namesUrl = useConfigStore().lookupConfig["http://preprod.id.loc.gov/authorities/names"].modes[0]["NAF All"].url.replace("<QUERY>", searchVal).replace("&count=25", "&count=4");
        let subjectUrlComplex = useConfigStore().lookupConfig["http://id.loc.gov/authorities/subjects"].modes[0]["LCSH All"].url.replace("<QUERY>", complexVal).replace("&count=25", "&count=5") + "&rdftype=ComplexType";
        let subjectUrlSimple = useConfigStore().lookupConfig["http://id.loc.gov/authorities/subjects"].modes[0]["LCSH All"].url.replace("<QUERY>", searchVal).replace("&count=25", "&count=4") + "&rdftype=SimpleType";
        let worksUrlKeyword = useConfigStore().lookupConfig["https://preprod-8080.id.loc.gov/resources/works"].modes[0]["Works - Keyword"].url.replace("<QUERY>", searchVal).replace("&count=25", "&count=5");
        let worksUrlAnchored = useConfigStore().lookupConfig["https://preprod-8080.id.loc.gov/resources/works"].modes[0]["Works - Left Anchored"].url.replace("<QUERY>", searchVal).replace("&count=25", "&count=5");
        let hubsUrlKeyword = useConfigStore().lookupConfig["https://preprod-8080.id.loc.gov/resources/works"].modes[0]["Hubs - Keyword"].url.replace("<QUERY>", searchVal).replace("&count=25", "&count=5");
        let hubsUrlAnchored = useConfigStore().lookupConfig["https://preprod-8080.id.loc.gov/resources/works"].modes[0]["Hubs - Left Anchored"].url.replace("<QUERY>", searchVal).replace("&count=25", "&count=5");
        let searchValHierarchicalGeographic = searchVal.replaceAll("‑", "-");
        let subjectUrlHierarchicalGeographic = useConfigStore().lookupConfig["HierarchicalGeographic"].modes[0]["All"].url.replace("<QUERY>", searchValHierarchicalGeographic).replace("&count=25", "&count=4");
        if (mode == "GEO") {
          subjectUrlHierarchicalGeographic = subjectUrlHierarchicalGeographic.replace("&count=4", "&count=12");
        }
        let searchPayloadNames = {
          processor: "lcAuthorities",
          url: [namesUrl],
          searchValue: searchVal
        };
        let searchPayloadSubjectsSimple = {
          processor: "lcAuthorities",
          url: [subjectUrlSimple],
          searchValue: searchVal
        };
        let searchPayloadSubjectsComplex = {
          processor: "lcAuthorities",
          url: [subjectUrlComplex],
          searchValue: searchVal
        };
        let searchPayloadHierarchicalGeographic = {
          processor: "lcAuthorities",
          url: [subjectUrlHierarchicalGeographic],
          searchValue: searchValHierarchicalGeographic
        };
        let searchPayloadWorksAnchored = {
          processor: "lcAuthorities",
          url: [worksUrlAnchored],
          searchValue: searchVal
        };
        let searchPayloadWorksKeyword = {
          processor: "lcAuthorities",
          url: [worksUrlKeyword],
          searchValue: searchVal
        };
        let searchPayloadHubsAnchored = {
          processor: "lcAuthorities",
          url: [hubsUrlAnchored],
          searchValue: searchVal
        };
        let searchPayloadHubsKeyword = {
          processor: "lcAuthorities",
          url: [hubsUrlKeyword],
          searchValue: searchVal
        };
        let resultsNames = [];
        let resultsSubjectsSimple = [];
        let resultsSubjectsComplex = [];
        let resultsHierarchicalGeographic = [];
        let resultsWorksAnchored = [];
        let resultsWorksKeyword = [];
        let resultsHubsAnchored = [];
        let resultsHubsKeyword = [];
        if (mode == "LCSHNAF") {
          [resultsNames, resultsSubjectsSimple, resultsSubjectsComplex, resultsHierarchicalGeographic] = await Promise.all([
            this.searchComplex(searchPayloadNames),
            this.searchComplex(searchPayloadSubjectsSimple),
            this.searchComplex(searchPayloadSubjectsComplex),
            this.searchComplex(searchPayloadHierarchicalGeographic)
          ]);
        } else if (mode == "GEO") {
          [resultsHierarchicalGeographic] = await Promise.all([
            this.searchComplex(searchPayloadHierarchicalGeographic)
          ]);
        } else if (mode == "WORKS") {
          [resultsWorksAnchored, resultsWorksKeyword] = await Promise.all([
            this.searchComplex(searchPayloadWorksAnchored),
            this.searchComplex(searchPayloadWorksKeyword)
          ]);
        } else if (mode == "HUBS") {
          [resultsHubsAnchored, resultsHubsKeyword] = await Promise.all([
            this.searchComplex(searchPayloadHubsAnchored),
            this.searchComplex(searchPayloadHubsKeyword)
          ]);
        }
        if (resultsNames.length > 0) {
          resultsNames.pop();
        }
        if (resultsSubjectsComplex.length > 0) {
          resultsSubjectsComplex.pop();
        }
        if (resultsSubjectsSimple.length > 0) {
          resultsSubjectsSimple.push(resultsSubjectsSimple.pop());
          resultsSubjectsSimple.reverse();
        }
        resultsSubjectsComplex.reverse();
        let newresultsHierarchicalGeographic = [];
        for (let x2 of resultsHierarchicalGeographic) {
          if (!x2.literal) {
            newresultsHierarchicalGeographic.push(x2);
          }
        }
        resultsHierarchicalGeographic = newresultsHierarchicalGeographic;
        if (mode == "WORKS") {
          resultsSubjectsSimple = resultsWorksAnchored;
          resultsSubjectsComplex = resultsWorksKeyword;
        }
        if (mode == "HUBS") {
          resultsSubjectsSimple = resultsHubsAnchored;
          resultsSubjectsComplex = resultsHubsKeyword;
        }
        let results = {
          "subjectsSimple": resultsSubjectsSimple,
          "subjectsComplex": resultsSubjectsComplex,
          "names": resultsNames,
          "hierarchicalGeographic": resultsHierarchicalGeographic
        };
        return results;
      },
      /**
      * Send the UNPOSTED record to the back end
      * @async
      * @param {string} xml - the XML from the export process
      * @param {string} eId - the editor id
      * @return {void} - 
      */
      saveRecord: async function(xml, eId) {
        const putMethod = {
          method: "PUT",
          // Method itself
          headers: {
            "Content-type": "application/xml"
            // Indicates the content 
          },
          body: xml
          // We send data in JSON format
        };
        console.log(putMethod);
        let url = useConfigStore().returnUrls.ldpjs + "ldp/" + eId;
        await fetch(url, putMethod).then((response) => console.log(response.text)).then((responseText) => {
        }).catch((err) => {
          console.log(err);
          alert("Error: Could not save the record!", err);
        });
      },
      /**
      * Retrive the UNPOSTED record from the back end
      * @async
      * @param {string} xml - the XML from the export process
      * @param {string} eId - the editor id
      * @return {void} - 
      */
      loadSavedRecord: async function(id2) {
        let url = useConfigStore().returnUrls.ldpjs + "ldp/" + id2;
        try {
          let response = await fetch(url);
          let data = await response.text();
          return data;
        } catch (err) {
          console.error(err);
        }
      },
      searchSavedRecords: async function(user, search) {
        let utilUrl = useConfigStore().returnUrls.util;
        let utilPath = useConfigStore().returnUrls.env;
        let url;
        if (user && !search) {
          url = `${utilUrl}myrecords/${utilPath}/${user}`;
        } else if (user && search) {
          url = `${utilUrl}allrecords/${utilPath}/${search}/${user}`;
        } else {
          url = `${utilUrl}allrecords/${utilPath}/`;
        }
        let r2 = await this.fetchSimpleLookup(url);
        if (r2 !== false) {
          let rSorted = [];
          for (let id2 in r2) {
            rSorted.push(r2[id2]);
          }
          rSorted.sort(function(a2, b2) {
            return b2.timestamp - a2.timestamp;
          });
          return rSorted;
        }
        return [];
      },
      /**
      * Send the record 
      * @async
      * @param {string} xml - The xml string
      * @param {string} eid - the e12345678 number
      * @param {obj} activeProfile - the activeProfile we're posting
      * @return {obj} - {status:false, msg: ""}
      */
      publish: async function(xml, eid, activeProfile) {
        let postingHub = false;
        if (activeProfile) {
          if (activeProfile.id && activeProfile.id === "Hub") {
            postingHub = true;
          }
        }
        let url = useConfigStore().returnUrls.publish;
        let uuid = translator$1.toUUID(translator$1.new());
        const rawResponse = await fetch(url, {
          method: "POST",
          headers: {
            "Accept": "application/json",
            "Content-Type": "application/json"
          },
          body: JSON.stringify({ name: uuid, rdfxml: xml, eid, hub: postingHub })
        });
        const content = await rawResponse.json();
        if (content && content.publish && content.publish.status && content.publish.status == "published") {
          return { status: true };
        } else {
          return { status: false, msg: JSON.stringify(content.publish, null, 2) };
        }
      },
      /**
      * Send off a rdf bibframe xml files in the format <rdf:RDF><bf:Work/><bf:Instance/>...etc...</rdf:RDF>
      * @async
      * @param {string} xml - The xml string
      * @return {string} - the MARC in XML response
      */
      marcPreview: async function(xml) {
        let url = useConfigStore().returnUrls.util + "/marcpreview";
        const rawResponse = await fetch(url, {
          method: "POST",
          headers: {
            "Accept": "application/json",
            "Content-Type": "application/json"
          },
          body: JSON.stringify({ rdfxml: xml })
        });
        const content = await rawResponse.json();
        console.log(content);
        return content;
      },
      /**
      * A result from searching ID by LCCN
      * @typedef {lccnSearchResult} lccnSearchResult
      * @property {string} lccn - the lccn searched
      * @property {string} label - the label to display in a search result
      * @property {string} bfdbURL - the http url to the bfdb url\
      * @property {string} idURL - the http url to the id.loc.gov page for instance
      * @property {string} bfdbPackageURL - the http url to the data package for this instance
      */
      /**
      * Looks for instances by LCCN against ID, returns into for them to be displayed and load the resource
      * @param {string} lccn - the lccn to search for
      * @return {array} - An array of {@link lccnSearchResult} results
      */
      searchInstanceByLCCN: async function(lccn) {
        lccn = lccn.replaceAll(" ", "");
        try {
          let req = await fetch(useConfigStore().returnUrls.id + `resources/instances/suggest2?q=${lccn}&searchtype=keyword`);
          let results = await req.json();
          let returnVal = [];
          for (let r2 of results.hits) {
            returnVal.push({
              lccn,
              label: r2.aLabel,
              bfdbURL: useConfigStore().returnUrls.bfdb + r2.uri.split("id.loc.gov/")[1],
              idURL: useConfigStore().returnUrls.id + r2.uri.split("id.loc.gov/")[1],
              bfdbPackageURL: useConfigStore().returnUrls.bfdb + r2.uri.split("id.loc.gov/")[1] + ".convertedit-pkg.xml"
            });
          }
          return returnVal;
        } catch {
          return ["Error searching LCCN"];
        }
      },
      /**
      * Send off a rdf bibframe xml files in the format <rdf:RDF><bf:Work/><bf:Instance/>...etc...</rdf:RDF>
      * @async
      * @param {string} xml - The xml string
      * @return {string} - the MARC in XML response
      */
      scriptShifterRequestTrans: async function(lang, text, capitalize2, t_dir) {
        let url = useConfigStore().returnUrls.scriptshifter + "trans";
        let r2 = await fetch(url, {
          method: "POST",
          headers: {
            "Accept": "application/json, text/plain, */*",
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            lang,
            text,
            capitalize: capitalize2,
            t_dir
          })
        });
        let results = await r2.text();
        if (r2.status !== 200) {
          alert(results);
          return false;
        } else {
          return results;
        }
      }
    };
    const returnDOMParser$1 = function() {
      let p2;
      try {
        p2 = new DOMParser();
      } catch (error) {
        p2 = new window.DOMParser();
      }
      return p2;
    };
    const XMLParser = returnDOMParser$1();
    const utilsRDF = {
      namespace: {
        "bflc": "http://id.loc.gov/ontologies/bflc/",
        "bf": "http://id.loc.gov/ontologies/bibframe/",
        "bfsimple": "http://id.loc.gov/ontologies/bfsimple/",
        "madsrdf": "http://www.loc.gov/mads/rdf/v1#",
        "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
        "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
        "lclocal": "http://id.loc.gov/ontologies/lclocal/",
        "pmo": "http://performedmusicontology.org/ontology/",
        "datatypes": "http://id.loc.gov/datatypes/",
        "xsd": "http://www.w3.org/2001/XMLSchema#",
        "mstatus": "https://id.loc.gov/vocabulary/mstatus/",
        "mnotetype": "http://id.loc.gov/vocabulary/mnotetype/",
        "dcterms": "http://purl.org/dc/terms/",
        "owl": "http://www.w3.org/2002/07/owl#",
        "void": "http://rdfs.org/ns/void#"
      },
      // these are the RDF:Types that are considered literals in the system
      LITERAL_TYPES: [
        "http://www.w3.org/2000/01/rdf-schema#Literal"
      ],
      /**
      * a convience function to say if a sepcific type of URI is a literal
      * this allows a single place to change what qualifies as a literal
      * @param {string} URI - the string URI to test
      * @return {bolean}
      */
      isUriALiteral: function(URI) {
        if (this.LITERAL_TYPES.map((v2) => {
          return v2.toLowerCase();
        }).indexOf(URI.toLowerCase()) > -1) {
          return true;
        }
        return false;
      },
      /**
      * returns a Class type basedon the predicate from the the profiles
      * @param {string} URI - the string URI to test
      * @param {obj} pt - the pt template from the profile
      * @param {obj} rtLookup - the rtLookup from the processed profiles
      * @return {string} URI - the uri of the type
      */
      suggestTypeProfile: function(propertyURI, pt2) {
        let rtLookup = useProfileStore().rtLookup;
        if (propertyURI == pt2.propertyURI) {
          if (pt2.valueConstraint && pt2.valueConstraint.valueDataType && pt2.valueConstraint.valueDataType.dataTypeURI && pt2.valueConstraint.valueDataType.dataTypeURI.trim() != "") {
            return pt2.valueConstraint.valueDataType.dataTypeURI.trim();
          }
        }
        if (pt2 && pt2.valueConstraint && pt2.valueConstraint && pt2.valueConstraint.valueTemplateRefs && pt2.valueConstraint.valueTemplateRefs.length > 0) {
          let possibleTypes = [];
          for (let rtKey of pt2.valueConstraint.valueTemplateRefs) {
            if (rtLookup[rtKey]) {
              for (let p2 of rtLookup[rtKey].propertyTemplates) {
                if (p2.propertyURI == propertyURI) {
                  if (p2.valueConstraint && p2.valueConstraint.valueDataType && p2.valueConstraint.valueDataType.dataTypeURI && p2.valueConstraint.valueDataType.dataTypeURI.trim() != "") {
                    possibleTypes.push(p2.valueConstraint.valueDataType.dataTypeURI.trim());
                  }
                }
              }
            } else {
              console.warn("Did not find the requested template name", rtKey);
            }
          }
          possibleTypes = [...new Set(possibleTypes)];
          if (possibleTypes.length == 1) {
            return possibleTypes[0];
          }
          let lookForResourceURI = false;
          if (!pt2.userValue[pt2.propertyURI]) {
            lookForResourceURI = true;
          } else {
            if (pt2.userValue[pt2.propertyURI] && pt2.userValue[pt2.propertyURI][0]) {
              console.log(pt2.userValue[pt2.propertyURI]);
              if (!pt2.userValue[pt2.propertyURI][0]["@type"]) {
                lookForResourceURI = true;
              }
            } else {
              lookForResourceURI = true;
            }
          }
          if (lookForResourceURI) {
            if (pt2 && pt2.valueConstraint && pt2.valueConstraint && pt2.valueConstraint.valueTemplateRefs && pt2.valueConstraint.valueTemplateRefs.length > 0) {
              let rtKey = pt2.valueConstraint.valueTemplateRefs[0];
              if (rtLookup[rtKey]) {
                return rtLookup[rtKey].resourceURI;
              } else {
                console.warn("Did not find the requested template name", rtKey);
              }
            }
          }
        }
        return false;
      },
      /**
      * returns a Class type basedon the range returned from the ontology
      * @param {string} propertyURI - the string URI to test
      * @return {string|boolean} URI - the uri of the type or false
      */
      suggestTypeNetwork: async function(propertyURI) {
        let result = false;
        if (propertyURI === "http://www.w3.org/2000/01/rdf-schema#label") {
          return "http://www.w3.org/2000/01/rdf-schema#Literal";
        }
        if (propertyURI === "http://www.loc.gov/mads/rdf/v1#authoritativeLabel") {
          return "http://www.w3.org/2000/01/rdf-schema#Literal";
        }
        if (propertyURI === "http://www.w3.org/1999/02/22-rdf-syntax-ns#value") {
          return "http://www.w3.org/2000/01/rdf-schema#Literal";
        }
        if (propertyURI === "http://www.loc.gov/mads/rdf/v1#componentList") {
          return "http://www.w3.org/1999/02/22-rdf-syntax-ns#List";
        }
        let propXml = await this.fetchOntology(propertyURI);
        let prop = XMLParser.parseFromString(propXml, "text/xml");
        let range = prop.getElementsByTagName("rdfs:range");
        if (range.length > 0) {
          range = range[0];
          if (range.attributes["rdf:resource"]) {
            result = range.attributes["rdf:resource"].value;
          }
        }
        if (propertyURI === "http://id.loc.gov/ontologies/bfsimple/prefTitle") {
          result = "http://www.w3.org/2000/01/rdf-schema#Literal";
        }
        if (propertyURI === "http://id.loc.gov/ontologies/bfsimple/variantTitle") {
          result = "http://www.w3.org/2000/01/rdf-schema#Literal";
        }
        if (propertyURI === "http://id.loc.gov/ontologies/bfsimple/transTitle") {
          result = "http://www.w3.org/2000/01/rdf-schema#Literal";
        }
        if (propertyURI === "http://id.loc.gov/ontologies/bflc/date") {
          result = "http://www.w3.org/2000/01/rdf-schema#Literal";
        }
        if (propertyURI === "http://id.loc.gov/ontologies/bflc/aap-normalized") {
          result = "http://www.w3.org/2000/01/rdf-schema#Literal";
        }
        if (propertyURI === "http://id.loc.gov/ontologies/bflc/aap") {
          result = "http://www.w3.org/2000/01/rdf-schema#Literal";
        }
        if (result === "http://id.loc.gov/ontologies/bflc/date") {
          result = "http://www.w3.org/2000/01/rdf-schema#Literal";
        }
        if (result == "http://www.loc.gov/standards/datetime/pre-submission.html") {
          result = "http://www.w3.org/2000/01/rdf-schema#Literal";
        }
        if (propertyURI === "http://id.loc.gov/ontologies/bflc/simplePlace") {
          result = "http://www.w3.org/2000/01/rdf-schema#Literal";
        }
        if (propertyURI === "http://id.loc.gov/ontologies/bflc/simpleAgent") {
          result = "http://www.w3.org/2000/01/rdf-schema#Literal";
        }
        if (propertyURI === "http://id.loc.gov/ontologies/bflc/simpleDate") {
          result = "http://www.w3.org/2000/01/rdf-schema#Literal";
        }
        if (result === false) {
          console.warn("Could not @type this ", propertyURI);
        }
        return result;
      },
      /**
      * Takes care of calling and storing in the local storage the response a URI 
      * used to figure out the @type for blanknodes
      * @param {string} url - the string URI to test
      * @return {obj} - the objext response from the server, also stores it in the localstorage
      */
      fetchOntology: async function(url) {
        let currentTS = Math.floor(Date.now() / 1e3);
        if (window.localStorage && window.localStorage.getItem("ontology_" + url + ".rdf")) {
          let response = JSON.parse(window.localStorage.getItem("ontology_" + url + ".rdf"));
          if (response && response.response && response.ts) {
            if (currentTS - response.ts < 86400 * 7) {
              return response.response;
            }
          }
        }
        if (url.endsWith(".rdf") === false) {
          url = url + ".rdf";
        }
        let r2;
        try {
          r2 = await utilsNetwork.fetchSimpleLookup(url);
        } catch {
          return false;
        }
        if (window.localStorage) {
          let toset = { response: r2, ts: currentTS };
          window.localStorage.setItem("ontology_" + url, JSON.stringify(toset));
        }
        return r2;
      },
      /**
      * Gose through all URIs used in the profiles and stores their info, used to figure out the @type for blanknodes
      * @param {string} url - the string URI to test
      * @return {obj} - the objext response from the server, also stores it in the localstorage
      */
      fetchAllOntology: async function(profiles) {
        let allData = {};
        for (let key2 of Object.keys(profiles.lookup)) {
          if (profiles.lookup[key2].resourceURI.includes("id.loc.gov/ontologies/")) {
            let r2 = await this.fetchOntology(profiles.lookup[key2].resourceURI);
            allData[profiles.lookup[key2].resourceURI] = r2;
          }
          for (let pt2 of profiles.lookup[key2].propertyTemplates) {
            if (pt2.propertyURI.includes("id.loc.gov/ontologies/")) {
              let r2 = await this.fetchOntology(pt2.propertyURI);
              allData[pt2.propertyURI] = r2;
            }
          }
        }
        return allData;
      }
    };
    const utilsParse = {
      data: {
        work: [],
        instance: [],
        item: []
      },
      activeDom: null,
      hasItem: false,
      namespace: utilsRDF.namespace,
      /**
      * Tests if a URI string is likely an RDF Class
      * 
      * @param {string} uri - the URI to test
      * @return {boolean}
      */
      isClass: function(uri) {
        if (uri.match(/bf:[A-Z]/)) {
          return true;
        }
        if (uri.match(/bflc:[A-Z]/)) {
          return true;
        }
        if (uri.match(/madsrdf:[A-Z]/)) {
          return true;
        }
        if (uri.match(/rdfs:[A-Z]/)) {
          return true;
        }
        if (uri.match(/rdf:[A-Z]/)) {
          return true;
        }
        if (uri.match(/lclocal:[A-Z]/)) {
          return true;
        }
        return false;
      },
      /**
      * Takes a URI and turns it into the shortened namespaced version bf:whatever
      * 
      * @param {string} uri - the URI to convert
      * @return {string} - the namespaced version
      */
      namespaceUri: function(uri) {
        for (let ns in this.namespace) {
          let nsuri = this.namespace[ns];
          if (uri.includes(nsuri)) {
            return uri.replace(nsuri, `${ns}:`);
          }
        }
      },
      /**
      * Takes a shortened namespaced version bf:whatever and turns it into the full URI
      * 
      * @param {string} uri - the URI to convert
      * @return {string} - the full version
      */
      UriNamespace: function(passedNS) {
        for (let ns in this.namespace) {
          let nsuri = this.namespace[ns];
          if (passedNS.startsWith(`${ns}:`)) {
            return passedNS.replace(`${ns}:`, nsuri);
          }
        }
      },
      /**
      * Small helper to add a modifer to URIs being pulled from the data
      * 
      * @param {string} uri - the URI to extract
      * @return {string} - the modified URI
      */
      extractURI: function(uri) {
        uri = uri.replace("https://id.loc.gov", "http://id.loc.gov");
        return uri;
      },
      /**
      * Returns the first child of where the parent is a spefific XML node
      * 
      * @param {dom} selection - XML dom tree to parse
      * @param {string} requiredParent - the tagName of parent that is requreid
      * @return {dom} - the dom xml of the result
      */
      returnOneWhereParentIs: function(selection, requiredParent) {
        if (selection.length == 1) {
          if (selection[0].parentNode.tagName === requiredParent) {
            return selection[0];
          } else {
            return false;
          }
        }
        for (let el of selection) {
          if (el.parentNode.tagName === requiredParent) {
            return el;
          }
        }
        return false;
      },
      /**
      * For ID uris, return the code from the uri 
      * 
      * @param {string} uri - the URI to test
      * @return {string} - the trailing part of the uri
      */
      returnLookupListFromURI: function(uri) {
        if (uri.includes("http://id.loc.gov/vocabulary/") || uri.includes("https://id.loc.gov/vocabulary/")) {
          uri = uri.split("/");
          uri.splice(-1, 1);
          uri = uri.join("/");
          return uri;
        }
        return false;
      },
      testSeperateRdfTypeProperty: function(pt2) {
        if (pt2.valueConstraint && pt2.valueConstraint.valueTemplateRefs) {
          for (let id2 of pt2.valueConstraint.valueTemplateRefs) {
            if (useProfileStore().rtLookup[id2]) {
              for (let p2 of useProfileStore().rtLookup[id2].propertyTemplates) {
                if (p2.propertyURI === "http://www.w3.org/1999/02/22-rdf-syntax-ns#type") {
                  return true;
                }
              }
            }
          }
        }
        return false;
      },
      /**
      * Takes the XML and parses it
      * 
      * @param {string} xml - the XML payload
      * @return {void}
      */
      parseXml: function(xml) {
        this.xmlSource = xml;
        if (window.DOMParser) {
          let parser2 = new DOMParser();
          this.activeDom = parser2.parseFromString(xml, "text/xml");
          this.testDom = parser2.parseFromString(xml, "text/xml");
          this.hasItem = this.activeDom.getElementsByTagName("bf:Item").length;
          this.hasInstance = this.activeDom.getElementsByTagName("bf:Instance").length;
        }
      },
      specialTransforms: {
        // not currently used
      },
      transformRts: async function(profile) {
        let toDeleteNoData = [];
        for (const pkey in profile.rt) {
          let tle = "";
          if (pkey.includes(":Work")) {
            tle = "bf:Work";
          } else if (pkey.includes(":Instance")) {
            tle = "bf:Instance";
          } else if (pkey.includes(":Item")) {
            tle = "bf:Item";
          } else if (pkey.endsWith(":Hub")) {
            tle = "bf:Hub";
          } else {
            continue;
          }
          let pt2 = profile.rt[pkey].pt;
          let xml = this.activeDom.getElementsByTagName(tle);
          profile.xmlSource = this.xmlSource;
          xml = this.returnOneWhereParentIs(xml, "rdf:RDF");
          console.log("selecting to process:", xml);
          if (xml === false && tle == "bf:Hub") {
            tle = "bf:Work";
            console.warn("No bf:Hub found, looking for bf:Work");
            if (testRun) {
              xml = this.testDom.getElementsByTagName(tle);
            } else {
              xml = this.activeDom.getElementsByTagName(tle);
            }
            xml = this.returnOneWhereParentIs(xml, "rdf:RDF");
            console.log("selecting to process:", xml);
          }
          if (xml === false) {
            console.warn(tle, "was not processed because it failed the top level test, must be a nested resource?");
            toDeleteNoData.push(pkey);
            continue;
          }
          if (!xml) {
            console.warn("Could not find the requested XML fragment, looking for ", tle);
            toDeleteNoData.push(pkey);
            continue;
          }
          if (xml.attributes["rdf:resource"]) {
            profile.rt[pkey].URI = xml.attributes["rdf:resource"].value;
          } else if (xml.attributes["rdf:about"]) {
            profile.rt[pkey].URI = xml.attributes["rdf:about"].value;
          }
          for (let child2 of xml.children) {
            if (child2.tagName == "rdf:type") {
              if (child2.attributes["rdf:resource"]) {
                profile.rt[pkey]["@type"] = child2.attributes["rdf:resource"].value;
                child2.parentNode.removeChild(child2);
              }
            }
          }
          if (tle == "bf:Instance") {
            if (xml.getElementsByTagName("bf:instanceOf").length > 0) {
              let instanceOf = xml.getElementsByTagName("bf:instanceOf")[0];
              if (instanceOf.attributes["rdf:resource"]) {
                profile.rt[pkey].instanceOf = instanceOf.attributes["rdf:resource"].value;
              } else if (instanceOf.attributes["rdf:about"]) {
                profile.rt[pkey].instanceOf = instanceOf.attributes["rdf:about"].value;
              }
            }
          }
          if (tle == "bf:Item") {
            if (xml.getElementsByTagName("bf:itemOf").length > 0) {
              let itemOf = xml.getElementsByTagName("bf:itemOf")[0];
              if (itemOf.attributes["rdf:resource"]) {
                profile.rt[pkey].itemOf = itemOf.attributes["rdf:resource"].value;
              } else if (itemOf.attributes["rdf:about"]) {
                profile.rt[pkey].itemOf = itemOf.attributes["rdf:about"].value;
              }
              itemOf.remove();
            }
          }
          let sucessfulProperties = [];
          let sucessfulElements = [];
          for (let k2 in pt2) {
            let ptk = JSON.parse(JSON.stringify(pt2[k2]));
            ptk["@guid"] = short.generate();
            ptk.valueConstraint.defaults = [];
            let propertyURI = ptk.propertyURI;
            let prefixURI = this.namespaceUri(propertyURI);
            let el = [];
            for (let e2 of xml.children) {
              if (this.UriNamespace(e2.tagName) == propertyURI) {
                el.push(e2);
              }
            }
            if (propertyURI === "http://id.loc.gov/ontologies/bibframe/Work") {
              if (profile.rt[pkey].URI) {
                ptk.userValue = {
                  "@root": "http://id.loc.gov/ontologies/bibframe/Work",
                  "@guid": short.generate(),
                  "@id": profile.rt[pkey].URI
                };
              }
              pt2[k2] = ptk;
              continue;
            }
            if (profile.rt[pkey]["@type"] && propertyURI == "http://www.w3.org/1999/02/22-rdf-syntax-ns#type") {
              ptk.userValue = {
                "@root": "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",
                "@guid": short.generate(),
                "@id": profile.rt[pkey]["@type"]
              };
              pt2[k2] = ptk;
              continue;
            }
            if (el.length > 0) {
              sucessfulProperties.push(prefixURI);
              ptk.hasData = true;
              ptk.canBeHidden = false;
              let counter = 0;
              for (let e2 of el) {
                if (ptk.propertyURI == "http://id.loc.gov/ontologies/bibframe/contribution") {
                  console.log("Found contributor");
                  let isPrimaryContribXML = false;
                  if (useConfigStore().profileHacks.removeExtraFieldsInContributor.enabled) {
                    for (let aEl of e2.getElementsByTagName("bflc:name00MatchKey")) {
                      aEl.remove();
                    }
                    for (let aEl of e2.getElementsByTagName("bflc:primaryContributorName00MatchKey")) {
                      aEl.remove();
                    }
                    for (let aEl of e2.getElementsByTagName("bflc:name00MarcKey")) {
                      aEl.remove();
                    }
                  }
                  for (let typeEl of e2.getElementsByTagName("rdf:type")) {
                    if (typeEl.attributes["rdf:resource"] && typeEl.attributes["rdf:resource"].value == "http://id.loc.gov/ontologies/bflc/PrimaryContribution") {
                      isPrimaryContribXML = true;
                    }
                  }
                  if (e2.getElementsByTagName("bflc:PrimaryContribution").length > 0) {
                    isPrimaryContribXML = true;
                  }
                  if (ptk.valueConstraint.valueDataType.dataTypeURI && ptk.valueConstraint.valueDataType.dataTypeURI == "http://id.loc.gov/ontologies/bflc/PrimaryContribution") {
                    if (!isPrimaryContribXML) {
                      console.log("Skipping the ptk says yes, if the xml doesn't jump to next");
                      continue;
                    }
                  } else {
                    if (isPrimaryContribXML) {
                      console.log("Skipping the ptk says no, if the xml says yesh jump to next", ptk.valueConstraint.valueDataType.dataTypeURI);
                      continue;
                    }
                  }
                }
                let populateData = null;
                populateData = JSON.parse(JSON.stringify(ptk));
                populateData.xmlSource = e2.outerHTML;
                populateData["@guid"] = short.generate();
                populateData.userValue[populateData.propertyURI] = [{}];
                let userValue = populateData.userValue[populateData.propertyURI][0];
                if (this.specialTransforms[prefixURI]) {
                  populateData = this.specialTransforms[prefixURI].call(this, e2, populateData);
                } else if (e2.children.length == 0) {
                  userValue["@guid"] = short.generate();
                  let eProperty = this.UriNamespace(e2.tagName);
                  console.log(e2.tagName, this.isClass(e2.tagName));
                  if (this.isClass(e2.tagName)) {
                    userValue["@type"] = this.UriNamespace(e2.tagName);
                    if (e2.attributes && e2.attributes["rdf:about"]) {
                      userValue["@id"] = this.extractURI(e2.attributes["rdf:about"].value);
                    } else if (e2.attributes && e2.attributes["rdf:resource"]) {
                      userValue["@id"] = this.extractURI(e2.attributes["rdf:resource"].value);
                    } else
                      ;
                  } else if (this.UriNamespace(e2.tagName) == "http://www.w3.org/1999/02/22-rdf-syntax-ns#type") {
                    if (this.testSeperateRdfTypeProperty(populateData)) {
                      console.warn("Need to account for rdf:type at this level.");
                    }
                    if (e2.attributes && e2.attributes["rdf:about"]) {
                      userValue["@type"] = e2.attributes["rdf:about"].value;
                    } else if (e2.attributes && e2.attributes["rdf:resource"]) {
                      userValue["@type"] = e2.attributes["rdf:resource"].value;
                    } else {
                      console.warn("---------------------------------------------");
                      console.warn("There was a e RDF Type node but could not extract the type");
                      console.warn(e2);
                      console.warn("---------------------------------------------");
                    }
                  } else if (e2.attributes["rdf:resource"] && e2.innerHTML.trim() == "") {
                    userValue["@guid"] = short.generate();
                    userValue["@id"] = this.extractURI(e2.attributes["rdf:resource"].value);
                  } else {
                    if (!userValue[eProperty]) {
                      userValue[eProperty] = [];
                    }
                    if (e2.attributes && e2.attributes["rdf:about"]) {
                      userValue["@id"] = this.extractURI(e2.attributes["rdf:about"].value);
                    } else if (e2.attributes && e2.attributes["rdf:resource"]) {
                      userValue["@id"] = this.extractURI(e2.attributes["rdf:resource"].value);
                    } else
                      ;
                    if (e2.innerHTML != null && e2.innerHTML.trim() != "") {
                      userValue[eProperty] = e2.innerHTML;
                      if (e2.attributes && e2.attributes["rdf:datatype"]) {
                        userValue["@datatype"] = e2.attributes["rdf:datatype"].value;
                      }
                      if (e2.attributes && e2.attributes["http://www.w3.org/1999/02/22-rdf-syntax-ns#datatype"]) {
                        userValue["@datatype"] = e2.attributes["http://www.w3.org/1999/02/22-rdf-syntax-ns#datatype"].value;
                      }
                      if (e2.attributes && e2.attributes["xml:lang"]) {
                        userValue["@language"] = e2.attributes["xml:lang"].value;
                      }
                      if (e2.attributes && e2.attributes["rdf:parseType"]) {
                        userValue["@parseType"] = e2.attributes["rdf:parseType"].value;
                      }
                    }
                  }
                } else {
                  if (e2.children.length > 1) {
                    console.error("---------------------------------------------");
                    console.error("There are more than one 1st lvl bnodes!!!!!!!");
                    console.error(e2);
                    console.error("---------------------------------------------");
                  }
                  for (let child2 of e2.children) {
                    userValue["@guid"] = short.generate();
                    userValue["@type"] = this.UriNamespace(child2.tagName);
                    if (child2.attributes && child2.attributes["rdf:about"]) {
                      userValue["@id"] = this.extractURI(child2.attributes["rdf:about"].value);
                    } else if (child2.attributes && child2.attributes["rdf:resource"]) {
                      userValue["@id"] = this.extractURI(child2.attributes["rdf:resource"].value);
                    } else
                      ;
                    for (let gChild of child2.children) {
                      if (this.UriNamespace(gChild.tagName) == "http://www.w3.org/1999/02/22-rdf-syntax-ns#type") {
                        if (this.testSeperateRdfTypeProperty(populateData)) {
                          let rdfTypeUri = null;
                          if (gChild.attributes && gChild.attributes["rdf:resource"]) {
                            rdfTypeUri = gChild.attributes["rdf:resource"].value;
                          } else if (gChild.attributes && gChild.attributes["rdf:about"]) {
                            rdfTypeUri = gChild.attributes["rdf:about"].value;
                          }
                          if (rdfTypeUri) {
                            userValue["http://www.w3.org/1999/02/22-rdf-syntax-ns#type"] = [
                              {
                                "@guid": short.generate(),
                                "@id": rdfTypeUri
                              }
                            ];
                          } else if (gChild.innerHTML && gChild.innerHTML.trim() != "") {
                            userValue["http://www.w3.org/1999/02/22-rdf-syntax-ns#type"] = [
                              {
                                "@guid": short.generate(),
                                "http://www.w3.org/2000/01/rdf-schema#label": [
                                  {
                                    "@guid": short.generate(),
                                    "http://www.w3.org/2000/01/rdf-schema#label": gChild.innerHTML
                                  }
                                ]
                              }
                            ];
                          }
                        } else {
                          if (gChild.attributes && gChild.attributes["rdf:about"]) {
                            userValue["@type"] = gChild.attributes["rdf:about"].value;
                          } else if (gChild.attributes && gChild.attributes["rdf:resource"]) {
                            userValue["@type"] = gChild.attributes["rdf:resource"].value;
                          } else {
                            console.warn("---------------------------------------------");
                            console.warn("There was a gChild RDF Type node but could not extract the type");
                            console.warn(gChild);
                            console.warn("---------------------------------------------");
                          }
                        }
                      } else if (gChild.children.length == 0) {
                        let gChildProperty = this.UriNamespace(gChild.tagName);
                        if (this.isClass(gChild.tagName)) {
                          let gChildData = { "@guid": short.generate() };
                          userValue[gChildProperty].push(gChildData);
                        } else {
                          if (!userValue[gChildProperty]) {
                            userValue[gChildProperty] = [];
                          }
                          let gChildData = { "@guid": short.generate() };
                          if (gChild.attributes && gChild.attributes["rdf:about"]) {
                            gChildData["@id"] = this.extractURI(gChild.attributes["rdf:about"].value);
                          } else if (gChild.attributes && gChild.attributes["rdf:resource"]) {
                            gChildData["@id"] = this.extractURI(gChild.attributes["rdf:resource"].value);
                          } else
                            ;
                          if (gChild.innerHTML != null && gChild.innerHTML.trim() != "") {
                            gChildData[gChildProperty] = gChild.innerHTML;
                            if (gChild.attributes && gChild.attributes["rdf:datatype"]) {
                              gChildData["@datatype"] = gChild.attributes["rdf:datatype"].value;
                            }
                            if (gChild.attributes && gChild.attributes["http://www.w3.org/1999/02/22-rdf-syntax-ns#datatype"]) {
                              gChildData["@datatype"] = gChild.attributes["http://www.w3.org/1999/02/22-rdf-syntax-ns#datatype"].value;
                            }
                            if (gChild.attributes && gChild.attributes["xml:lang"]) {
                              gChildData["@language"] = gChild.attributes["xml:lang"].value;
                            }
                            if (gChild.attributes && gChild.attributes["rdf:parseType"]) {
                              gChildData["@parseType"] = gChild.attributes["rdf:parseType"].value;
                            }
                          }
                          userValue[gChildProperty].push(gChildData);
                        }
                      } else {
                        let gChildProperty = this.UriNamespace(gChild.tagName);
                        if (!userValue[gChildProperty]) {
                          userValue[gChildProperty] = [];
                        }
                        let gChildData = { "@guid": short.generate() };
                        for (let ggChild of gChild.children) {
                          if (this.isClass(ggChild.tagName)) {
                            gChildData = { "@guid": short.generate() };
                            gChildData["@type"] = this.UriNamespace(ggChild.tagName);
                            if (ggChild.attributes && ggChild.attributes["rdf:about"]) {
                              gChildData["@id"] = this.extractURI(ggChild.attributes["rdf:about"].value);
                            } else if (ggChild.attributes && ggChild.attributes["rdf:resource"]) {
                              gChildData["@id"] = this.extractURI(ggChild.attributes["rdf:resource"].value);
                            } else
                              ;
                            for (let gggChild of ggChild.children) {
                              if (this.UriNamespace(gggChild.tagName) == "http://www.w3.org/1999/02/22-rdf-syntax-ns#type") {
                                if (gggChild.attributes && gggChild.attributes["rdf:about"]) {
                                  gChildData["@type"] = gggChild.attributes["rdf:about"].value;
                                } else if (gggChild.attributes && gggChild.attributes["rdf:resource"]) {
                                  gChildData["@type"] = gggChild.attributes["rdf:resource"].value;
                                } else {
                                  console.warn("---------------------------------------------");
                                  console.warn("There was a gggChild RDF Type node but could not extract the type");
                                  console.warn(gggChild);
                                  console.warn("---------------------------------------------");
                                }
                              } else if (gggChild.children.length == 0) {
                                let gggChildProperty = this.UriNamespace(gggChild.tagName);
                                if (!gChildData[gggChildProperty]) {
                                  gChildData[gggChildProperty] = [];
                                }
                                let gggChildData = { "@guid": short.generate() };
                                if (gggChild.attributes && gggChild.attributes["rdf:about"]) {
                                  gggChildData["@id"] = this.extractURI(gggChild.attributes["rdf:about"].value);
                                } else if (gggChild.attributes && gggChild.attributes["rdf:resource"]) {
                                  gggChildData["@id"] = this.extractURI(gggChild.attributes["rdf:resource"].value);
                                } else
                                  ;
                                if (gggChild.innerHTML != null && gggChild.innerHTML.trim() != "") {
                                  gggChildData[gggChildProperty] = gggChild.innerHTML;
                                  if (gggChild.attributes && gggChild.attributes["rdf:datatype"]) {
                                    gggChildData["@datatype"] = gggChild.attributes["rdf:datatype"].value;
                                  }
                                  if (gggChild.attributes && gggChild.attributes["http://www.w3.org/1999/02/22-rdf-syntax-ns#datatype"]) {
                                    gggChildData["@datatype"] = gggChild.attributes["http://www.w3.org/1999/02/22-rdf-syntax-ns#datatype"].value;
                                  }
                                  if (gggChild.attributes && gggChild.attributes["xml:lang"]) {
                                    gggChildData["@language"] = gggChild.attributes["xml:lang"].value;
                                  }
                                  if (gggChild.attributes && gggChild.attributes["rdf:parseType"]) {
                                    gggChildData["@parseType"] = gggChild.attributes["rdf:parseType"].value;
                                  }
                                }
                                gChildData[gggChildProperty].push(gggChildData);
                              } else {
                                let gggChildProperty = this.UriNamespace(gggChild.tagName);
                                if (!gChildData[gggChildProperty]) {
                                  gChildData[gggChildProperty] = [];
                                }
                                let gggData = { "@guid": short.generate() };
                                for (let ggggChild of gggChild.children) {
                                  if (this.isClass(ggggChild.tagName)) {
                                    gggData["@type"] = this.UriNamespace(ggggChild.tagName);
                                    if (ggggChild.attributes && ggggChild.attributes["rdf:about"]) {
                                      gggData["@id"] = this.extractURI(ggggChild.attributes["rdf:about"].value);
                                    } else if (ggggChild.attributes && ggggChild.attributes["rdf:resource"]) {
                                      gggData["@id"] = this.extractURI(ggggChild.attributes["rdf:resource"].value);
                                    } else
                                      ;
                                    for (let gggggChild of ggggChild.children) {
                                      let gggggChildProperty = this.UriNamespace(gggggChild.tagName);
                                      if (this.UriNamespace(gggggChild.tagName) == "http://www.w3.org/1999/02/22-rdf-syntax-ns#type") {
                                        if (gggggChild.attributes && gggggChild.attributes["rdf:about"]) {
                                          gggData["@type"] = gggggChild.attributes["rdf:about"].value;
                                        } else if (gggggChild.attributes && gggggChild.attributes["rdf:resource"]) {
                                          gggData["@type"] = gggggChild.attributes["rdf:resource"].value;
                                        } else {
                                          console.warn("---------------------------------------------");
                                          console.warn("There was a gggChild RDF Type node but could not extract the type");
                                          console.warn(gggggChild);
                                          console.warn("---------------------------------------------");
                                        }
                                      } else if (gggggChild.children.length == 0) {
                                        if (!gggData[gggggChildProperty]) {
                                          gggData[gggggChildProperty] = [];
                                        }
                                        let ggggChildData = { "@guid": short.generate() };
                                        if (gggggChild.attributes && gggggChild.attributes["rdf:about"]) {
                                          gggData["@id"] = this.extractURI(gggggChild.attributes["rdf:about"].value);
                                        } else if (gggggChild.attributes && gggggChild.attributes["rdf:resource"]) {
                                          gggData["@id"] = this.extractURI(gggggChild.attributes["rdf:resource"].value);
                                        } else
                                          ;
                                        if (gggggChild.innerHTML != null && gggggChild.innerHTML.trim() != "") {
                                          ggggChildData[gggggChildProperty] = gggggChild.innerHTML;
                                          if (gggggChild.attributes && gggggChild.attributes["rdf:datatype"]) {
                                            ggggChildData["@datatype"] = gggggChild.attributes["rdf:datatype"].value;
                                          }
                                          if (gggggChild.attributes && gggggChild.attributes["http://www.w3.org/1999/02/22-rdf-syntax-ns#datatype"]) {
                                            ggggChildData["@datatype"] = gggggChild.attributes["http://www.w3.org/1999/02/22-rdf-syntax-ns#datatype"].value;
                                          }
                                          if (gggggChild.attributes && gggggChild.attributes["xml:lang"]) {
                                            ggggChildData["@language"] = gggggChild.attributes["xml:lang"].value;
                                          }
                                          if (gggggChild.attributes && gggggChild.attributes["rdf:parseType"]) {
                                            ggggChildData["@parseType"] = gggggChild.attributes["rdf:parseType"].value;
                                          }
                                        }
                                        gggData[gggggChildProperty].push(ggggChildData);
                                      } else {
                                        console.warn("---------------------------------------------");
                                        console.warn("Reached the max depth for hiearchy, cannot read the properties nested below");
                                        console.warn(gggggChild);
                                        console.warn(ggggChild);
                                        console.warn("---------------------------------------------");
                                      }
                                    }
                                  } else {
                                    let ggggChildProperty = this.UriNamespace(ggggChild.tagName);
                                    if (!gggData[ggggChildProperty]) {
                                      gggData[ggggChildProperty] = [];
                                    }
                                    if (ggggChild.attributes && ggggChild.attributes["rdf:about"]) {
                                      gggData["@id"] = this.extractURI(ggggChild.attributes["rdf:about"].value);
                                    } else if (ggggChild.attributes && ggggChild.attributes["rdf:resource"]) {
                                      gggData["@id"] = this.extractURI(ggggChild.attributes["rdf:resource"].value);
                                    } else
                                      ;
                                    let ggggChildData = { "@guid": short.generate() };
                                    if (ggggChild.innerHTML != null && ggggChild.innerHTML.trim() != "") {
                                      ggggChildData[ggggChildProperty] = ggggChild.innerHTML;
                                      if (ggggChild.attributes && ggggChild.attributes["rdf:datatype"]) {
                                        ggggChildData["@datatype"] = ggggChild.attributes["rdf:datatype"].value;
                                      }
                                      if (ggggChild.attributes && ggggChild.attributes["http://www.w3.org/1999/02/22-rdf-syntax-ns#datatype"]) {
                                        ggggChildData["@datatype"] = ggggChild.attributes["http://www.w3.org/1999/02/22-rdf-syntax-ns#datatype"].value;
                                      }
                                      if (ggggChild.attributes && ggggChild.attributes["xml:lang"]) {
                                        ggggChildData["@language"] = ggggChild.attributes["xml:lang"].value;
                                      }
                                      if (ggggChild.attributes && ggggChild.attributes["rdf:parseType"]) {
                                        ggggChildData["@parseType"] = ggggChild.attributes["rdf:parseType"].value;
                                      }
                                    }
                                    gggData[ggggChildProperty].push(ggggChildData);
                                  }
                                }
                                gChildData[gggChildProperty].push(gggData);
                              }
                            }
                            userValue[gChildProperty].push(gChildData);
                            gChildData = false;
                          } else {
                            if (this.UriNamespace(ggChild.tagName) == "http://www.w3.org/1999/02/22-rdf-syntax-ns#type") {
                              if (ggChild.attributes && ggChild.attributes["rdf:about"]) {
                                gChildData["@type"] = ggChild.attributes["rdf:about"].value;
                              } else if (ggChild.attributes && ggChild.attributes["rdf:resource"]) {
                                gChildData["@type"] = ggChild.attributes["rdf:resource"].value;
                              } else {
                                console.warn("---------------------------------------------");
                                console.warn("There was a ggChild RDF Type node but could not extract the type");
                                console.warn(ggChild);
                                console.warn("---------------------------------------------");
                              }
                            } else if (ggChild.children.length == 0) {
                              let ggChildProperty = this.UriNamespace(ggChild.tagName);
                              if (!gChildData[ggChildProperty]) {
                                gChildData[ggChildProperty] = [];
                              }
                              let ggChildData = { "@guid": short.generate() };
                              if (ggChild.attributes && ggChild.attributes["rdf:about"]) {
                                ggChildData["@id"] = this.extractURI(ggChild.attributes["rdf:about"].value);
                              } else if (ggChild.attributes && ggChild.attributes["rdf:resource"]) {
                                ggChildData["@id"] = this.extractURI(ggChild.attributes["rdf:resource"].value);
                              } else
                                ;
                              if (ggChild.innerHTML != null && ggChild.innerHTML.trim() != "") {
                                ggChildData[ggChildProperty] = ggChild.innerHTML;
                                if (ggChild.attributes && ggChild.attributes["rdf:datatype"]) {
                                  ggChildData["@datatype"] = ggChild.attributes["rdf:datatype"].value;
                                }
                                if (ggChild.attributes && ggChild.attributes["http://www.w3.org/1999/02/22-rdf-syntax-ns#datatype"]) {
                                  ggChildData["@datatype"] = ggChild.attributes["http://www.w3.org/1999/02/22-rdf-syntax-ns#datatype"].value;
                                }
                                if (ggChild.attributes && ggChild.attributes["xml:lang"]) {
                                  ggChildData["@language"] = ggChild.attributes["xml:lang"].value;
                                }
                                if (ggChild.attributes && ggChild.attributes["rdf:parseType"]) {
                                  ggChildData["@parseType"] = ggChild.attributes["rdf:parseType"].value;
                                }
                              }
                              gChildData[ggChildProperty].push(ggChildData);
                            } else {
                              console.warn("---------------------------------------------");
                              console.warn("There was a ggChild that was not a class, but has children");
                              console.warn(ggChild);
                              console.warn(gChild);
                              console.warn(this.isClass(ggChild.tagName));
                              console.warn(ggChild.tagName);
                              console.warn("---------------------------------------------");
                            }
                          }
                        }
                        if (gChildData !== false) {
                          userValue[gChildProperty].push(gChildData);
                        }
                      }
                    }
                  }
                }
                sucessfulElements.push(e2.outerHTML);
                if (counter === 0) {
                  pt2[k2] = populateData;
                } else {
                  let newKey = `${k2}_${counter}`;
                  let currentpos = profile.rt[pkey].ptOrder.indexOf(k2);
                  profile.rt[pkey].ptOrder.splice(currentpos + 1, 0, newKey);
                  pt2[newKey] = populateData;
                }
                counter++;
              }
            }
            for (let p2 of sucessfulProperties) {
              let els = xml.getElementsByTagName(p2);
              for (let step = els.length - 1; step >= 0; step = step - 1) {
                if (sucessfulElements.indexOf(els[step].outerHTML) > -1) {
                  els[step].remove();
                }
              }
            }
          }
          profile.rt[pkey].unusedXml = xml.outerHTML;
          if (xml.children.length == 0) {
            profile.rt[pkey].unusedXml = false;
          }
          for (let key2 in profile.rt[pkey].pt) {
            if (profile.rt[pkey].pt[key2].propertyURI == "http://id.loc.gov/ontologies/bibframe/adminMetadata") {
              if (!profile.rt[pkey].pt[key2].userValue["http://id.loc.gov/ontologies/bibframe/adminMetadata"]) {
                profile.rt[pkey].pt[key2].userValue["http://id.loc.gov/ontologies/bibframe/adminMetadata"] = [{}];
              }
              let userValue = profile.rt[pkey].pt[key2].userValue["http://id.loc.gov/ontologies/bibframe/adminMetadata"][0];
              if (!userValue["http://id.loc.gov/ontologies/bflc/catalogerId"]) {
                userValue["http://id.loc.gov/ontologies/bflc/catalogerId"] = [
                  {
                    "@guid": short.generate(),
                    "http://id.loc.gov/ontologies/bflc/catalogerId": useProfileStore().catInitials
                  }
                ];
              }
              userValue["http://id.loc.gov/ontologies/bflc/procInfo"] = [
                {
                  "@guid": short.generate(),
                  "http://id.loc.gov/ontologies/bflc/procInfo": profile.procInfo
                }
              ];
            }
          }
          let uniquePropertyURIs = {};
          for (let key2 in profile.rt[pkey].pt) {
            if (Object.keys(uniquePropertyURIs).indexOf(profile.rt[pkey].pt[key2].propertyURI) === -1) {
              uniquePropertyURIs[profile.rt[pkey].pt[key2].propertyURI] = { status: false, data: [], resourceTemplates: {}, unAssingedProperties: [] };
            }
            if (Object.keys(profile.rt[pkey].pt[key2].userValue).length > 1) {
              profile.rt[pkey].pt[key2].dataLoaded = true;
            } else {
              profile.rt[pkey].pt[key2].dataLoaded = false;
              for (let k2 in profile.rt[pkey].pt[key2].userValue) {
                if (k2 == "http://www.w3.org/2000/01/rdf-schema#label") {
                  if (Array.isArray(profile.rt[pkey].pt[key2].userValue[k2])) {
                    for (let kValue of profile.rt[pkey].pt[key2].userValue[k2]) {
                      for (let kValueKey in kValue) {
                        if (kValueKey == "http://www.w3.org/2000/01/rdf-schema#label") {
                          kValue[kValueKey] = cleanXmlEscapes(kValue[kValueKey]);
                        }
                      }
                    }
                  }
                }
                if (Array.isArray(profile.rt[pkey].pt[key2].userValue[k2])) {
                  for (let kItem of profile.rt[pkey].pt[key2].userValue[k2]) {
                    for (let kItemKey in kItem) {
                      if (kItemKey == "http://www.w3.org/2000/01/rdf-schema#label") {
                        if (Array.isArray(kItem[kItemKey])) {
                          for (let kValue of kItem[kItemKey]) {
                            for (let kValueKey in kValue) {
                              if (kValueKey == "http://www.w3.org/2000/01/rdf-schema#label") {
                                kValue[kValueKey] = cleanXmlEscapes(kValue[kValueKey]);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              uniquePropertyURIs[profile.rt[pkey].pt[key2].propertyURI].status = true;
              uniquePropertyURIs[profile.rt[pkey].pt[key2].propertyURI].data.push({ "json": profile.rt[pkey].pt[key2].userValue, "propertyLabel": profile.rt[pkey].pt[key2].propertyLabel, "xml": profile.rt[pkey].pt[key2].xmlSource });
              uniquePropertyURIs[profile.rt[pkey].pt[key2].propertyURI].resourceTemplates[key2] = profile.rt[pkey].pt[key2];
              let allUris = [profile.rt[pkey].pt[key2].propertyURI];
              profile.rt[pkey].pt[key2].valueConstraint.valueTemplateRefs.forEach((rtName) => {
                useProfileStore().rtLookup[rtName].propertyTemplates.forEach((ptObj) => {
                  if (allUris.indexOf(ptObj.propertyURI) == -1) {
                    allUris.push(ptObj.propertyURI);
                  }
                });
              });
              profile.rt[pkey].pt[key2].missingProfile = [];
              Object.keys(profile.rt[pkey].pt[key2].userValue).forEach((userURI) => {
                if (!userURI.includes("@")) {
                  if (allUris.indexOf(userURI) === -1) {
                    profile.rt[pkey].pt[key2].missingProfile.push(userURI);
                    uniquePropertyURIs[profile.rt[pkey].pt[key2].propertyURI].unAssingedProperties.push(userURI);
                  }
                }
              });
              if (uniquePropertyURIs[profile.rt[pkey].pt[key2].propertyURI].unAssingedProperties.length > 0) {
                uniquePropertyURIs[profile.rt[pkey].pt[key2].propertyURI].status = "mixed";
              }
            }
          }
          profile.rt[pkey].propertyLoadReport = uniquePropertyURIs;
          profile.rt[pkey].propertyLoadRatio = parseInt(Object.keys(uniquePropertyURIs).filter((k2) => uniquePropertyURIs[k2].status).length / Object.keys(uniquePropertyURIs).length * 100);
          if (tle == "bf:Item" || tle == "bf:Instance") {
            console.log("Done processing XML fragment, removing", xml);
            xml.remove();
          }
        }
        for (let x2 of toDeleteNoData) {
          profile.rt[x2].noData = true;
        }
        console.log("profileprofileprofileprofile", JSON.parse(JSON.stringify(profile)));
        return profile;
      }
    };
    const utilsMisc = {
      globalNav: function(dir, source) {
        let allSelectable = document.getElementsByClassName("can-select");
        let foundSource = false;
        allSelectable = [...allSelectable];
        if (dir == "up") {
          allSelectable = allSelectable.reverse();
        }
        for (let el of allSelectable) {
          if (foundSource) {
            el.focus();
            break;
          }
          if (el === source) {
            foundSource = true;
          }
        }
      },
      prettifyXmlJS(xml, tab = "	", nl = "\n") {
        let formatted = "", indent = "";
        const nodes = xml.slice(1, -1).split(/>\s*</);
        if (nodes[0][0] == "?")
          formatted += "<" + nodes.shift() + ">" + nl;
        for (let i2 = 0; i2 < nodes.length; i2++) {
          const node = nodes[i2];
          if (node[0] == "/")
            indent = indent.slice(tab.length);
          formatted += indent + "<" + node + ">" + nl;
          if (node[0] != "/" && node[node.length - 1] != "/" && node.indexOf("</") == -1)
            indent += tab;
        }
        return formatted;
      }
    };
    const formatXML = function(xml, tab = "	", nl = "\n") {
      if (!xml) {
        return "No XML";
      }
      let formatted = "", indent = "";
      const nodes = xml.slice(1, -1).split(/>\s*</);
      if (nodes[0][0] == "?")
        formatted += "<" + nodes.shift() + ">" + nl;
      for (let i2 = 0; i2 < nodes.length; i2++) {
        const node = nodes[i2];
        if (node[0] == "/")
          indent = indent.slice(tab.length);
        formatted += indent + "<" + node + ">" + nl;
        if (node[0] != "/" && node[node.length - 1] != "/" && node.indexOf("</") == -1)
          indent += tab;
      }
      return formatted;
    };
    const returnDOMParser = function() {
      let p2;
      try {
        p2 = new DOMParser();
      } catch (error) {
        p2 = new window.DOMParser();
      }
      return p2;
    };
    const utilsExport = {
      // all the namespaces are stored in the utils_rdf
      namespace: utilsRDF.namespace,
      // ignore these beause they control the shape of the xml and we want to control that
      ignoreProperties: [
        "http://id.loc.gov/ontologies/bibframe/instanceOf",
        "http://id.loc.gov/ontologies/bibframe/hasItem",
        "http://id.loc.gov/ontologies/bibframe/itemOf",
        "http://id.loc.gov/ontologies/bibframe/hasInstance",
        "http://id.loc.gov/ontologies/bibframe/Work"
      ],
      /**
      * if passed full uri like http://id.loc.gov/ontology/bibframe/xxx will convert to a prefixed bf:xxx 
      * 
      * @param {string} uri - the uri to convert 
      * @return {string}
      */
      namespaceUri: function(uri) {
        for (let ns in this.namespace) {
          let nsuri = this.namespace[ns];
          if (uri.includes(nsuri)) {
            return uri.replace(nsuri, `${ns}:`);
          }
        }
      },
      /**
      * if passed a prefix like bf:xxx it will expand it to http://id.loc.gov/ontology/bibframe...
      * 
      * @param {string} passedNS - the prefixed element/prop 
      * @return {string}
      */
      UriNamespace: function(passedNS) {
        for (let ns in this.namespace) {
          let nsuri = this.namespace[ns];
          if (passedNS.startsWith(`${ns}:`)) {
            return passedNS.replace(`${ns}:`, nsuri);
          }
        }
      },
      /**
      * creates a element with createElementNS using the correct namespace
      * 
      * @param {string} elStr - the element to create 
      * @return {element}
      */
      createElByBestNS: function(elStr) {
        if (elStr == "http://www.loc.gov/mads/rdf/v1#") {
          elStr = "http://www.loc.gov/mads/rdf/v1#Authority";
        }
        elStr = elStr.replace("https://", "http://");
        if (!elStr.startsWith("http")) {
          elStr = this.UriNamespace(elStr);
        }
        for (let ns of Object.keys(this.namespace)) {
          if (elStr.startsWith(this.namespace[ns])) {
            return document.createElementNS(this.namespace[ns], this.namespaceUri(elStr));
          }
        }
        console.error("could not find namespace for ", elStr);
        return null;
      },
      /**
      * A helper function that will build blank node based on userValue obj
      * 
      * @param {obj} userValue - the uservalue to test
      * @param {string} property - the property uri
      * @return {boolean}
      */
      createBnode: function(userValue, property) {
        if (property == "http://id.loc.gov/ontologies/bibframe/agent") {
          let bnode = this.createElByBestNS("bf:Agent");
          if (userValue["@id"]) {
            bnode.setAttributeNS(this.namespace.rdf, "rdf:about", userValue["@id"]);
          }
          let rdftype = this.createElByBestNS("rdf:type");
          rdftype.setAttributeNS(this.namespace.rdf, "rdf:resource", userValue["@type"]);
          bnode.appendChild(rdftype);
          if (userValue["@parseType"]) {
            bnode.setAttribute("rdf:parseType", userValue["@parseType"]);
          }
          return bnode;
        } else if (userValue["@type"] && userValue["@type"].includes("id.loc.gov/vocabulary/mnotetype")) {
          let bnode = this.createElByBestNS("bf:Note");
          let rdftype = this.createElByBestNS("rdf:type");
          rdftype.setAttributeNS(this.namespace.rdf, "rdf:resource", userValue["@type"]);
          bnode.appendChild(rdftype);
          return bnode;
        } else {
          let bnode = this.createElByBestNS(userValue["@type"]);
          if (userValue["@id"]) {
            bnode.setAttributeNS(this.namespace.rdf, "rdf:about", userValue["@id"]);
          }
          if (userValue["@parseType"]) {
            bnode.setAttribute("rdf:parseType", userValue["@parseType"]);
          }
          return bnode;
        }
      },
      /**
      * A helper function that will build a literal value element
      * 
      * @param {string} property - the property uri
      * @param {obj} userValue - the uservalue to test
      * @return {boolean}
      */
      createLiteral: function(property, userValue) {
        let p2 = this.createElByBestNS(property);
        if (userValue[property]) {
          if (userValue[property].trim() == "") {
            return false;
          }
          p2.innerHTML = userValue[property];
        }
        if (userValue["@id"]) {
          p2.setAttributeNS(this.namespace.rdf, "rdf:resource", userValue["@id"]);
        }
        if (userValue["@datatype"]) {
          p2.setAttributeNS(this.namespace.rdf, "rdf:datatype", userValue["@datatype"]);
        }
        if (userValue["@language"]) {
          p2.setAttribute("xml:lang", userValue["@language"]);
        }
        if (userValue["@parseType"]) {
          p2.setAttribute("rdf:parseType", userValue["@parseType"]);
        }
        return p2;
      },
      /**
      * 
      * 
      * @param {obj} userValue - the uservalue to test
      * @return {boolean}
      */
      isBnode: function(userValue) {
        if (userValue["@type"]) {
          return true;
        }
        return false;
      },
      /**
      * Some structures share the same predicate
      * 
      * @param {string} key - the uri
      * @return {boolean}
      */
      needsNewPredicate: function(key2) {
        if (key2 == "http://www.loc.gov/mads/rdf/v1#componentList") {
          return false;
        }
        return true;
      },
      /**
      * 
      * 
      * @param {obj} userValue - the uservalue to test
      * @return {boolean}
      */
      hasUserValue: function(userValue) {
        for (let key2 in userValue) {
          if (key2 == "@id" || key2.includes("http://") || key2.includes("https://")) {
            return true;
          }
        }
        return false;
      },
      /**
      * returns the just the item portion of the profile
      * 
      * @param {string} URI - the uri of the instance to look for it's items
      * @param {obj} profile - profile
      * @param {obj} tleLookup - the lookup created out of the export XML process
      * @return {obj}
      */
      returnHasItem: function(URI, profile, tleLookup) {
        let results = [];
        let parser2 = returnDOMParser();
        for (let rt2 in profile.rt) {
          if (profile.rt[rt2].itemOf && profile.rt[rt2].itemOf == URI) {
            if (tleLookup["Item"][profile.rt[rt2].URI].getElementsByTagName("bf:itemOf").length == 0) {
              let hasItem = this.createElByBestNS("bf:itemOf");
              hasItem.setAttributeNS(this.namespace.rdf, "rdf:resource", profile.rt[rt2].itemOf);
              tleLookup["Item"][profile.rt[rt2].URI].appendChild(hasItem);
            }
            let item = new XMLSerializer().serializeToString(tleLookup["Item"][profile.rt[rt2].URI]);
            item = parser2.parseFromString(item, "text/xml").children[0];
            results.push(item);
          }
        }
        return results;
      },
      /**
      * returns the just the work portion of the profile
      * 
      * @param {string} instanceURI - the uri of the instance 
      * @param {obj} profile - profile
      * @param {obj} tleLookup - the lookup created out of the export XML process
      * @return {obj}
      */
      returnWorkFromInstance: function(instanceURI, profile, tleLookup) {
        let parser2 = returnDOMParser();
        let results = null;
        for (let rt2 in profile.rt) {
          if (profile.rt[rt2].instanceOf && profile.rt[rt2].URI == instanceURI) {
            results = new XMLSerializer().serializeToString(tleLookup["Work"][profile.rt[rt2].instanceOf]);
            results = parser2.parseFromString(results, "text/xml").children[0];
          }
        }
        if (!results) {
          for (let wUri in tleLookup["Work"]) {
            results = tleLookup["Work"][wUri];
            break;
          }
        }
        return results;
      },
      /**
      * 
      * 
      * @param {string} uri - the URI to test
      * @return {boolean}
      */
      buildXML: async function(profile) {
        let xmlLog = [];
        let componentXmlLookup = {};
        let orginalProfile = profile;
        profile = JSON.parse(JSON.stringify(profile));
        let rdf = document.createElementNS(this.namespace.rdf, "RDF");
        let rdfBasic = document.createElementNS(this.namespace.rdf, "RDF");
        for (let ns of Object.keys(this.namespace)) {
          rdf.setAttributeNS("http://www.w3.org/2000/xmlns/", `xmlns:${ns}`, this.namespace[ns]);
          rdfBasic.setAttributeNS("http://www.w3.org/2000/xmlns/", `xmlns:${ns}`, this.namespace[ns]);
        }
        let xmlVoidDataRtsUsed = [];
        let xmlVoidDataType = [];
        let xmlVoidExternalID = [];
        let xmlVoidDataTitle = "";
        let xmlVoidDataContributor = "";
        let xmlVoidDataLccn = "";
        let tleLookup = {
          Work: {},
          Instance: {},
          Item: {},
          Hub: {}
        };
        for (let rt2 of profile.rtOrder) {
          xmlLog.push(`Processing rt: ${rt2}`);
          if (profile.rt[rt2].noData) {
            xmlLog.push(` - ${rt2} has no data, skipping it.`);
            continue;
          }
          let rootEl2;
          let rootElName;
          if (rt2.includes(":Work")) {
            rootEl2 = document.createElementNS(this.namespace.bf, "bf:Work");
            rootElName = "Work";
          } else if (rt2.includes(":Instance")) {
            rootEl2 = document.createElementNS(this.namespace.bf, "bf:Instance");
            rootElName = "Instance";
          } else if (rt2.includes(":Item")) {
            rootEl2 = document.createElementNS(this.namespace.bf, "bf:Item");
            rootElName = "Item";
          } else if (rt2.endsWith(":Hub")) {
            rootEl2 = document.createElementNS(this.namespace.bf, "bf:Hub");
            rootElName = "Hub";
          } else {
            xmlLog.push(`Dunno what this part is, skipping ${rt2}`);
            continue;
          }
          xmlLog.push(`Building ${rootElName}`);
          if (profile.rt[rt2].URI) {
            rootEl2.setAttributeNS(this.namespace.rdf, "rdf:about", profile.rt[rt2].URI);
            xmlLog.push(`Setting URI for this resource rdf:about to: ${profile.rt[rt2].URI}`);
            xmlVoidExternalID.push(profile.rt[rt2].URI);
          }
          if (profile.rt[rt2]["@type"]) {
            let type = this.createElByBestNS("http://www.w3.org/1999/02/22-rdf-syntax-ns#type");
            type.setAttributeNS(this.namespace.rdf, "rdf:resource", profile.rt[rt2]["@type"]);
            xmlLog.push(`Setting URI for this resource rdf:resource to: ${profile.rt[rt2]["@type"]}`);
            rootEl2.appendChild(type);
          }
          xmlLog.push(`Looping through the PTs`);
          for (let pt2 of profile.rt[rt2].ptOrder) {
            let ptObj = profile.rt[rt2].pt[pt2];
            xmlLog.push(`Working on: ${pt2}`);
            let userValue;
            if (ptObj.userValue[ptObj.propertyURI] && ptObj.userValue[ptObj.propertyURI][0]) {
              userValue = ptObj.userValue[ptObj.propertyURI][0];
            } else if (ptObj.userValue[ptObj.propertyURI]) {
              userValue = ptObj.userValue[ptObj.propertyURI];
            } else {
              userValue = ptObj.userValue;
            }
            for (let k2 of Object.keys(userValue)) {
              if (k2 === "undefined") {
                delete userValue[k2];
              }
            }
            xmlLog.push(["Set userValue to:", JSON.parse(JSON.stringify(userValue))]);
            if (this.ignoreProperties.indexOf(ptObj.propertyURI) > -1) {
              xmlLog.push(`Skpping it because it is in the ignoreProperties list`);
              continue;
            }
            if (pt2.includes("http://id.loc.gov/ontologies/bibframe/adminMetadata")) {
              let adminData = ptObj.userValue["http://id.loc.gov/ontologies/bibframe/adminMetadata"][0];
              adminData["http://id.loc.gov/ontologies/bflc/profile"] = [
                {
                  "http://id.loc.gov/ontologies/bflc/profile": rt2
                }
              ];
              try {
                delete adminData["http://id.loc.gov/ontologies/bibframe/changeDate"];
              } catch (e2) {
              }
              adminData["http://id.loc.gov/ontologies/bibframe/changeDate"] = [
                {
                  "http://id.loc.gov/ontologies/bibframe/changeDate": (/* @__PURE__ */ new Date()).toISOString().split(".")[0] + "Z",
                  "@datatype": "http://www.w3.org/2001/XMLSchema#dateTime"
                }
              ];
              if (!adminData["http://id.loc.gov/ontologies/bibframe/creationDate"]) {
                adminData["http://id.loc.gov/ontologies/bibframe/creationDate"] = [
                  {
                    "http://id.loc.gov/ontologies/bibframe/creationDate": (/* @__PURE__ */ new Date()).toISOString().split(".")[0] + "Z",
                    "@datatype": "http://www.w3.org/2001/XMLSchema#dateTime"
                  }
                ];
              }
              xmlLog.push(["Set adminData to:", JSON.parse(JSON.stringify(adminData))]);
            }
            if (this.hasUserValue(userValue)) {
              if (xmlVoidDataRtsUsed.indexOf(rt2) == -1) {
                xmlVoidDataRtsUsed.push(rt2);
              }
              if (xmlVoidDataType.indexOf(rootElName) == -1) {
                xmlVoidDataType.push(rootElName);
              }
              if (this.isBnode(userValue)) {
                xmlLog.push(`Root level bnode: ${ptObj.propertyURI}`);
                let pLvl1 = this.createElByBestNS(ptObj.propertyURI);
                let bnodeLvl1 = this.createBnode(userValue, ptObj.propertyURI);
                xmlLog.push(`Created lvl 1 predicate: ${pLvl1.tagName} and bnode: ${bnodeLvl1.tagName}`);
                for (let key1 of Object.keys(userValue).filter((k2) => !k2.includes("@") ? true : false)) {
                  xmlLog.push(`Looking at property : ${key1} in the userValue`);
                  let pLvl2 = this.createElByBestNS(key1);
                  if (key1 == "http://www.loc.gov/mads/rdf/v1#componentList") {
                    pLvl2.setAttribute("rdf:parseType", "Collection");
                  }
                  xmlLog.push(`Created lvl 2 predicate: ${pLvl2.tagName}`);
                  if (key1 == "http://www.w3.org/1999/02/22-rdf-syntax-ns#type") {
                    if (userValue[key1] && userValue[key1][0] && userValue[key1][0]["@id"]) {
                      let rdftype = this.createElByBestNS(key1);
                      rdftype.setAttributeNS(this.namespace.rdf, "rdf:resource", userValue[key1][0]["@id"]);
                      bnodeLvl1.appendChild(rdftype);
                      xmlLog.push(`This bnode just has a rdf:type : ${rdftype} setting it an continuing`);
                      continue;
                    } else if (userValue[key1] && userValue[key1][0] && userValue[key1][0]["http://www.w3.org/2000/01/rdf-schema#label"]) {
                      let rdftype = this.createElByBestNS(key1);
                      rdftype.innerHTML = userValue[key1][0]["http://www.w3.org/2000/01/rdf-schema#label"][0]["http://www.w3.org/2000/01/rdf-schema#label"];
                      xmlLog.push(`This bnode just has a rdf:type and label : ${rdftype} setting it an continuing`);
                      bnodeLvl1.appendChild(rdftype);
                      continue;
                    }
                  }
                  let value1FirstLoop = true;
                  for (let value1 of userValue[key1]) {
                    if (!value1FirstLoop && this.needsNewPredicate(key1)) {
                      pLvl2 = this.createElByBestNS(key1);
                      xmlLog.push(`Creating lvl 2 property : ${pLvl2.tagName} for ${JSON.stringify(value1)}`);
                    }
                    if (this.isBnode(value1)) {
                      let bnodeLvl2 = this.createBnode(value1, key1);
                      pLvl2.appendChild(bnodeLvl2);
                      bnodeLvl1.appendChild(pLvl2);
                      xmlLog.push(`Creating bnode lvl 2 for it ${bnodeLvl2.tagName}`);
                      for (let key2 of Object.keys(value1).filter((k2) => !k2.includes("@") ? true : false)) {
                        let pLvl3 = this.createElByBestNS(key2);
                        xmlLog.push(`Creating lvl 3 property: ${pLvl3.tagName} for ${key2}`);
                        for (let value2 of value1[key2]) {
                          if (this.isBnode(value2)) {
                            let bnodeLvl3 = this.createBnode(value2, key2);
                            pLvl3.appendChild(bnodeLvl3);
                            bnodeLvl2.appendChild(pLvl3);
                            xmlLog.push(`Creating lvl 3 bnode: ${bnodeLvl3.tagName} for ${key2}`);
                            for (let key3 of Object.keys(value2).filter((k2) => !k2.includes("@") ? true : false)) {
                              for (let value3 of value2[key3]) {
                                if (this.isBnode(value3)) {
                                  console.error("Max hierarchy depth reached, but there are more levels left:", key3, "in", userValue);
                                  xmlLog.push(`Max hierarchy depth reached, but there are more levels left for ${key3}`);
                                } else {
                                  for (let key4 of Object.keys(value3).filter((k2) => !k2.includes("@") ? true : false)) {
                                    if (typeof value3[key4] == "string" || typeof value3[key4] == "number") {
                                      let p4 = this.createLiteral(key4, value3);
                                      if (p4 !== false)
                                        bnodeLvl3.appendChild(p4);
                                      xmlLog.push(`Added literal ${p4} for ${key4}`);
                                    } else {
                                      console.error("key4", key4, value3[key4], "not a literal, should not happen");
                                      xmlLog.push(`Error not a literal but I thought it was at ${key4}`);
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            for (let key3 of Object.keys(value2).filter((k2) => !k2.includes("@") ? true : false)) {
                              if (typeof value2[key3] == "string" || typeof value2[key3] == "number") {
                                let p3 = this.createLiteral(key3, value2);
                                if (p3 !== false)
                                  bnodeLvl2.appendChild(p3);
                                xmlLog.push(`Created Literal ${p3.innerHTML} for ${key3}`);
                              } else {
                                console.error("key3", key3, value2[key3], "not a literal, should not happen");
                                xmlLog.push(`Error not a literal but I thought it was at ${key3}`);
                              }
                            }
                          }
                        }
                      }
                    } else {
                      xmlLog.push(`It's value at lvl is not a bnode, looping through and adding a literal value`);
                      let keys = Object.keys(value1).filter((k2) => !k2.includes("@") ? true : false);
                      if (userValue["@type"] && key1 === userValue["@type"]) {
                        if (value1["@id"]) {
                          xmlLog.push(`Setting its rdf:about to ${value1["@id"]}`);
                          bnodeLvl1.setAttributeNS(this.namespace.rdf, "rdf:about", value1["@id"]);
                        }
                      }
                      if (keys.length > 0) {
                        for (let key2 of keys) {
                          if (typeof value1[key2] == "string" || typeof value1[key2] == "number") {
                            let p2 = this.createLiteral(key2, value1);
                            xmlLog.push(`Creating literal ${JSON.stringify(value1)}`);
                            if (p2 !== false)
                              bnodeLvl1.appendChild(p2);
                          } else if (Array.isArray(value1[key2])) {
                            for (let arrayValue of value1[key2]) {
                              let keysLevel2 = Object.keys(arrayValue).filter((k2) => !k2.includes("@") ? true : false);
                              if (keysLevel2.length > 0) {
                                for (let key22 of keysLevel2) {
                                  if (typeof arrayValue[key22] == "string" || typeof arrayValue[key22] == "number") {
                                    let p2 = this.createLiteral(key22, arrayValue);
                                    xmlLog.push(`Creating literal ${JSON.stringify(arrayValue[key22])}`);
                                    if (p2 !== false)
                                      bnodeLvl1.appendChild(p2);
                                  } else {
                                    console.error("key22", key22, arrayValue[key22], "not a literal, should not happen");
                                    xmlLog.push(`Error not a literal ${arrayValue[key22]}`);
                                  }
                                }
                              }
                            }
                          } else {
                            console.error("key2", key2, value1[key2], "not a literal, should not happen");
                            xmlLog.push(`Key 2 (${key2}) error, not a literal ${value1[key2]}`);
                          }
                        }
                      } else if (keys.length == 0 && value1["@id"]) {
                        let p2 = this.createLiteral(key1, value1);
                        if (p2 !== false)
                          bnodeLvl1.appendChild(p2);
                      } else {
                        console.error("Unhadled literal situtation");
                      }
                    }
                    value1FirstLoop = false;
                  }
                }
                pLvl1.appendChild(bnodeLvl1);
                rootEl2.appendChild(pLvl1);
                componentXmlLookup[`${rt2}-${pt2}`] = formatXML(pLvl1.outerHTML);
              } else {
                xmlLog.push(`Root level does not look like a bnode: ${ptObj.propertyURI}`);
                let userValueArray = userValue;
                if (!Array.isArray(userValue)) {
                  userValueArray = [userValue];
                }
                for (let userValue2 of userValueArray) {
                  if (userValue2["@flags"] && userValue2["@flags"].indexOf("simpleLookupTopLevelMulti") > -1)
                    ;
                  else if (userValue2["@type"] && userValue2["@id"]) {
                    let p2 = this.createElByBestNS(ptObj.propertyURI);
                    let bnode = this.createElByBestNS(userValue2["@type"]);
                    bnode.setAttributeNS(this.namespace.rdf, "rdf:about", userValue2["@id"]);
                    xmlLog.push(`Created ${p2.tagName} property and ${bnode.tagName} bnode`);
                    p2.appendChild(bnode);
                    rootEl2.appendChild(p2);
                    componentXmlLookup[`${rt2}-${pt2}`] = formatXML(p2.outerHTML);
                  } else if (userValue2["@type"] && !userValue2["@id"]) {
                    xmlLog.push(`Should have a URI in ${ptObj.propertyURI} but can't find one`);
                    console.error("Does not have URI, ERROR");
                  } else if (await utilsRDF.suggestTypeNetwork(ptObj.propertyURI) == "http://www.w3.org/2000/01/rdf-schema#Literal") {
                    let allXMLFragments = "";
                    for (let key1 of Object.keys(userValue2).filter((k2) => !k2.includes("@") ? true : false)) {
                      if (typeof userValue2[key1] === "string" || typeof userValue2[key1] === "number") {
                        let p1 = this.createLiteral(key1, userValue2);
                        if (p1 !== false) {
                          rootEl2.appendChild(p1);
                          xmlLog.push(`Creating literal at root level for ${key1} with value ${p1.innerHTML}`);
                          allXMLFragments = allXMLFragments + `
${formatXML(p1.outerHTML)}`;
                        }
                      } else {
                        for (let value1 of userValue2[key1]) {
                          for (let key2 of Object.keys(value1).filter((k2) => !k2.includes("@") ? true : false)) {
                            if (typeof value1[key2] == "string" || typeof value1[key2] == "number") {
                              let p1 = this.createLiteral(key2, value1);
                              if (p1 !== false) {
                                rootEl2.appendChild(p1);
                                allXMLFragments = allXMLFragments + `
${formatXML(p1.outerHTML)}`;
                                xmlLog.push(`Creating literal at root level for ${key2} with value ${value1}`);
                              }
                            } else {
                              console.error("key2", key2, value1[key2], "not a literal, should not happen");
                              xmlLog.push(`Not a literal at root level ${key2} with value ${value1[key2]}`);
                            }
                          }
                        }
                      }
                    }
                    componentXmlLookup[`${rt2}-${pt2}`] = allXMLFragments;
                  } else if (await utilsRDF.suggestTypeNetwork(ptObj.propertyURI) == "http://www.w3.org/2000/01/rdf-schema#Resource") {
                    let allXMLFragments = "";
                    for (let key1 of Object.keys(userValue2).filter((k2) => !k2.includes("@") ? true : false)) {
                      for (let value1 of userValue2[key1]) {
                        for (let key2 of Object.keys(value1).filter((k2) => !k2.includes("@") ? true : false)) {
                          if (typeof value1[key2] == "string" || typeof value1[key2] == "number") {
                            let p1 = this.createLiteral(key2, value1);
                            if (p1 !== false) {
                              rootEl2.appendChild(p1);
                              allXMLFragments = allXMLFragments + `
${formatXML(p1.outerHTML)}`;
                              xmlLog.push(`Listed as rdf:Resource but treating it a a literal, Creating literal for ${key2} with value ${p1.innerHTML}`);
                            }
                          } else {
                            console.error("key2", key2, value1[key2], "not a literal, should not happen");
                            xmlLog.push(`Not a literal at root level ${key2} with value ${value1[key2]}`);
                          }
                        }
                      }
                    }
                    componentXmlLookup[`${rt2}-${pt2}`] = allXMLFragments;
                  } else if (userValue2["@id"]) {
                    let p2 = this.createElByBestNS(ptObj.propertyURI);
                    p2.setAttributeNS(this.namespace.rdf, "rdf:resource", userValue2["@id"]);
                    rootEl2.appendChild(p2);
                    componentXmlLookup[`${rt2}-${pt2}`] = formatXML(p2.outerHTML);
                  } else if (ptObj.propertyURI == "http://www.w3.org/2000/01/rdf-schema#label") {
                    let p2 = this.createElByBestNS(ptObj.propertyURI);
                    p2.innerHTML = userValue2["http://www.w3.org/2000/01/rdf-schema#label"][0]["http://www.w3.org/2000/01/rdf-schema#label"];
                    rootEl2.appendChild(p2);
                    componentXmlLookup[`${rt2}-${pt2}`] = formatXML(p2.outerHTML);
                  } else {
                    console.warn("Should not be here");
                  }
                }
              }
            } else {
              xmlLog.push(`Skpping it because hasUserValue == false`);
            }
          }
          if (orginalProfile.rt[rt2].unusedXml) {
            let parser3 = returnDOMParser();
            let unusedXmlNode = parser3.parseFromString(orginalProfile.rt[rt2].unusedXml, "text/xml");
            unusedXmlNode = unusedXmlNode.children[0];
            for (let el2 of unusedXmlNode.children) {
              if (el2.tagName != "rdfs:label") {
                let newEl = new XMLSerializer().serializeToString(el2);
                newEl = parser3.parseFromString(newEl, "text/xml");
                newEl = newEl.children[0];
                rootEl2.appendChild(newEl);
              }
            }
          }
          tleLookup[rootElName][orginalProfile.rt[rt2].URI] = rootEl2;
        }
        let parser2 = returnDOMParser();
        for (let URI in tleLookup["Work"]) {
          let theWork = new XMLSerializer().serializeToString(tleLookup["Work"][URI]);
          theWork = parser2.parseFromString(theWork, "text/xml").children[0];
          rdfBasic.appendChild(theWork);
        }
        for (let URI in tleLookup["Hub"]) {
          let theHub = new XMLSerializer().serializeToString(tleLookup["Hub"][URI]);
          theHub = parser2.parseFromString(theHub, "text/xml").children[0];
          rdfBasic.appendChild(theHub);
        }
        for (let URI in tleLookup["Instance"]) {
          let instance = new XMLSerializer().serializeToString(tleLookup["Instance"][URI]);
          instance = parser2.parseFromString(instance, "text/xml").children[0];
          let items = this.returnHasItem(URI, orginalProfile, tleLookup);
          for (let item of items) {
            let uri = null;
            if (item.attributes["rdf:resource"]) {
              uri = item.attributes["rdf:resource"].value;
            } else if (item.attributes["rdf:about"]) {
              uri = item.attributes["rdf:about"].value;
            }
            if (uri) {
              let hasItem = this.createElByBestNS("bf:hasItem");
              hasItem.setAttributeNS(this.namespace.rdf, "rdf:resource", uri);
              instance.appendChild(hasItem);
            }
          }
          for (let WorkURI in tleLookup["Work"]) {
            let instanceOf = this.createElByBestNS("bf:instanceOf");
            instanceOf.setAttributeNS(this.namespace.rdf, "rdf:resource", WorkURI);
            instance.appendChild(instanceOf);
          }
          rdfBasic.appendChild(instance);
        }
        for (let URI in tleLookup["Item"]) {
          let item = new XMLSerializer().serializeToString(tleLookup["Item"][URI]);
          item = parser2.parseFromString(item, "text/xml").children[0];
          rdfBasic.appendChild(item);
        }
        if (orginalProfile.procInfo.includes("update")) {
          if (Object.keys(tleLookup["Instance"]).length > 0) {
            for (let URI in tleLookup["Instance"]) {
              let instance = new XMLSerializer().serializeToString(tleLookup["Instance"][URI]);
              instance = parser2.parseFromString(instance, "text/xml").children[0];
              let items = this.returnHasItem(URI, orginalProfile, tleLookup);
              if (items.length > 0) {
                for (let item of items) {
                  let p2 = this.createElByBestNS("bf:hasItem");
                  p2.appendChild(item);
                  instance.appendChild(p2);
                }
              }
              let work = this.returnWorkFromInstance(URI, orginalProfile, tleLookup);
              if (work) {
                let p2 = this.createElByBestNS("bf:instanceOf");
                p2.appendChild(work);
                instance.appendChild(p2);
              }
              rdf.appendChild(instance);
            }
          } else {
            let workKey = Object.keys(tleLookup["Work"])[0];
            let work = tleLookup["Work"][workKey];
            if (work) {
              rdf.appendChild(work);
            }
          }
        } else {
          for (let URI in tleLookup["Instance"]) {
            let instance = new XMLSerializer().serializeToString(tleLookup["Instance"][URI]);
            instance = parser2.parseFromString(instance, "text/xml").children[0];
            let items = this.returnHasItem(URI, orginalProfile, tleLookup);
            if (items.length > 0) {
              for (let item of items) {
                let p2 = this.createElByBestNS("bf:hasItem");
                p2.appendChild(item);
                instance.appendChild(p2);
              }
            }
            let work = this.returnWorkFromInstance(URI, orginalProfile, tleLookup);
            if (work) {
              let p2 = this.createElByBestNS("bf:instanceOf");
              p2.appendChild(work);
              instance.appendChild(p2);
            }
            rdf.appendChild(instance);
          }
        }
        if (Object.keys(tleLookup["Work"]).length == 0 && Object.keys(tleLookup["Hub"]).length == 1) {
          let theHub = new XMLSerializer().serializeToString(rdfBasic);
          theHub = parser2.parseFromString(theHub, "text/xml").children[0];
          rdf = theHub;
        }
        if (rdfBasic.getElementsByTagName("bf:mainTitle").length > 0) {
          xmlVoidDataTitle = rdfBasic.getElementsByTagName("bf:mainTitle")[0].innerHTML;
        } else if (rdfBasic.getElementsByTagName("bfsimple:prefTitle").length > 0) {
          xmlVoidDataTitle = rdfBasic.getElementsByTagName("bfsimple:prefTitle")[0].innerHTML;
        } else {
          console.warn("no title found for db");
        }
        if (rdfBasic.getElementsByTagName("bflc:PrimaryContribution").length > 0) {
          if (rdfBasic.getElementsByTagName("bflc:PrimaryContribution")[0].getElementsByTagName("rdfs:label").length > 0) {
            xmlVoidDataContributor = rdfBasic.getElementsByTagName("bflc:PrimaryContribution")[0].getElementsByTagName("rdfs:label")[0].innerHTML;
          }
        } else {
          if (rdfBasic.getElementsByTagName("bf:Contribution").length > 0) {
            if (rdfBasic.getElementsByTagName("bf:Contribution")[0].getElementsByTagName("rdfs:label").length > 0) {
              xmlVoidDataContributor = rdfBasic.getElementsByTagName("bf:Contribution")[0].getElementsByTagName("rdfs:label")[0].innerHTML;
            } else {
              console.warn("no PrimaryContribution or Contribution found for db");
            }
          } else {
            console.warn("no PrimaryContribution or Contribution found for db");
          }
        }
        if (rdfBasic.getElementsByTagName("bf:Instance").length > 0) {
          let i2 = rdfBasic.getElementsByTagName("bf:Instance")[0];
          for (let c2 of i2.children) {
            if (c2.tagName === "bf:identifiedBy") {
              if (c2.getElementsByTagName("bf:Lccn").length > 0) {
                let lccnEl = c2.getElementsByTagName("bf:Lccn")[0];
                if (lccnEl.getElementsByTagName("bf:Status").length == 0) {
                  xmlVoidDataLccn = lccnEl.innerText || lccnEl.textContent;
                } else if (lccnEl.getElementsByTagName("bf:Status").length > 0) {
                  if (lccnEl.getElementsByTagName("bf:Status")[0].hasAttribute("rdf:about") && lccnEl.getElementsByTagName("bf:Status")[0].attributes["rdf:about"].value == "http://id.loc.gov/vocabulary/mstatus/cancinv") {
                    continue;
                  }
                  for (let cc of lccnEl.children) {
                    if (cc.tagName == "rdf:value") {
                      xmlVoidDataLccn = cc.innerText || cc.textContent;
                    }
                  }
                }
              }
            }
          }
        }
        let datasetDescriptionEl = document.createElementNS(this.namespace.void, "void:DatasetDescription");
        datasetDescriptionEl.setAttributeNS("http://www.w3.org/2000/xmlns/", `xmlns:void`, this.namespace.void);
        datasetDescriptionEl.setAttributeNS("http://www.w3.org/2000/xmlns/", `xmlns:lclocal`, this.namespace.lclocal);
        let el;
        for (let x2 of xmlVoidDataRtsUsed) {
          el = document.createElementNS(this.namespace.lclocal, "lclocal:rtsused");
          el.innerHTML = x2;
          datasetDescriptionEl.appendChild(el);
        }
        for (let x2 of xmlVoidDataType) {
          el = document.createElementNS(this.namespace.lclocal, "lclocal:profiletypes");
          el.innerHTML = x2;
          datasetDescriptionEl.appendChild(el);
        }
        el = document.createElementNS(this.namespace.lclocal, "lclocal:title");
        el.innerHTML = xmlVoidDataTitle;
        datasetDescriptionEl.appendChild(el);
        el = document.createElementNS(this.namespace.lclocal, "lclocal:contributor");
        el.innerHTML = xmlVoidDataContributor;
        datasetDescriptionEl.appendChild(el);
        el = document.createElementNS(this.namespace.lclocal, "lclocal:lccn");
        el.innerHTML = xmlVoidDataLccn;
        datasetDescriptionEl.appendChild(el);
        console.log("SETTING the user", profile);
        el = document.createElementNS(this.namespace.lclocal, "lclocal:user");
        el.innerHTML = profile.user;
        datasetDescriptionEl.appendChild(el);
        el = document.createElementNS(this.namespace.lclocal, "lclocal:status");
        el.innerHTML = profile.status;
        datasetDescriptionEl.appendChild(el);
        el = document.createElementNS(this.namespace.lclocal, "lclocal:eid");
        el.innerHTML = profile.eId;
        datasetDescriptionEl.appendChild(el);
        el = document.createElementNS(this.namespace.lclocal, "lclocal:typeid");
        el.innerHTML = profile.id;
        datasetDescriptionEl.appendChild(el);
        el = document.createElementNS(this.namespace.lclocal, "lclocal:procinfo");
        el.innerHTML = orginalProfile.procInfo;
        datasetDescriptionEl.appendChild(el);
        for (let x2 of xmlVoidExternalID) {
          el = document.createElementNS(this.namespace.lclocal, "lclocal:externalid");
          el.innerHTML = x2;
          datasetDescriptionEl.appendChild(el);
        }
        let strXmlFormatted = new XMLSerializer().serializeToString(rdf);
        strXmlFormatted = utilsMisc.prettifyXmlJS(strXmlFormatted, " ");
        rdfBasic.appendChild(datasetDescriptionEl);
        let strXmlBasic = new XMLSerializer().serializeToString(rdfBasic);
        let strXml = new XMLSerializer().serializeToString(rdf);
        if (useConfigStore().postUsingAlmaXmlFormat) {
          let almaWorksEl = rdfBasic.getElementsByTagName("bf:Work");
          let almaInstancesEl = rdfBasic.getElementsByTagName("bf:Instance");
          let almaItemsEl = rdfBasic.getElementsByTagName("bf:Item");
          const doc2 = document.implementation.createDocument("", "", null);
          let almaXmlElBib = doc2.createElement("bib");
          let almaXmlElRecordFormat = doc2.createElement("record_format");
          almaXmlElRecordFormat.innerHTML = "BIBFRAME";
          almaXmlElBib.appendChild(almaXmlElRecordFormat);
          let almaXmlElRecord = doc2.createElement("record");
          let almaXmlElRdf = doc2.createElement("rdf:RDF");
          almaXmlElRdf.setAttribute("xmlns:rdf", "http://www.w3.org/1999/02/22-rdf-syntax-ns#");
          almaXmlElRecord.appendChild(almaXmlElRdf);
          almaXmlElBib.appendChild(almaXmlElRecord);
          for (let el2 of almaWorksEl) {
            almaXmlElRdf.appendChild(el2);
          }
          for (let el2 of almaInstancesEl) {
            almaXmlElRdf.appendChild(el2);
          }
          for (let el2 of almaItemsEl) {
            almaXmlElRdf.appendChild(el2);
          }
          let strAlmaXmlElBib = new XMLSerializer().serializeToString(almaXmlElBib);
          strXml = strAlmaXmlElBib;
        }
        let bf2MarcXmlElRdf = this.createElByBestNS("http://www.w3.org/1999/02/22-rdf-syntax-ns#RDF");
        for (let el2 of rdfBasic.getElementsByTagName("bf:Work")) {
          bf2MarcXmlElRdf.appendChild(el2);
        }
        for (let el2 of rdfBasic.getElementsByTagName("bf:Instance")) {
          bf2MarcXmlElRdf.appendChild(el2);
        }
        for (let el2 of rdfBasic.getElementsByTagName("bf:Item")) {
          bf2MarcXmlElRdf.appendChild(el2);
        }
        let strBf2MarcXmlElBib = new XMLSerializer().serializeToString(bf2MarcXmlElRdf);
        console.log(strXmlFormatted);
        console.log("------");
        console.log(strXmlBasic);
        return {
          xmlDom: rdf,
          xmlStringFormatted: strXmlFormatted,
          xlmString: strXml,
          bf2Marc: strBf2MarcXmlElBib,
          xlmStringBasic: strXmlBasic,
          voidTitle: xmlVoidDataTitle,
          voidContributor: xmlVoidDataContributor,
          componentXmlLookup
        };
      }
    };
    const assert = (condition, message = "Internal Logic Error") => {
      if (!condition) {
        throw new Error(typeof message === "function" ? message() : message);
      }
    };
    class Value {
      constructor(value, excluded) {
        this.value = value;
        this.excluded = excluded;
        this.isSimpleStarRec = value === "**";
        this.isRegexStarRec = value.startsWith("**(") && value.endsWith(")");
        this.isStarRec = this.isSimpleStarRec || this.isRegexStarRec;
      }
    }
    let Ref$1 = class Ref2 {
      constructor(type, link2 = null) {
        this.left = link2 === null;
        this.link = link2 === null ? new Ref2(type, this) : link2;
        this.type = type;
        this.isStarRec = this.type === "**";
        this.node = null;
        this.pointer = null;
      }
      setPointer(pointer) {
        this.pointer = pointer;
        this.link.pointer = pointer;
      }
      setNode(node) {
        this.node = node;
        this.link.node = node;
      }
    };
    const throwError$1 = (msg, input, context = {}) => {
      throw new Error(Object.entries(context).reduce((p2, [k2, v2]) => `${p2}, ${k2} ${v2}`, `${msg}: ${input}`));
    };
    const getSimple = (arr) => arr.length === 1 ? arr[0] : arr;
    const arraySelectorRegex = /^[?*+\d]+$/;
    const Result$1 = (input) => {
      let cResult = [];
      cResult.or = true;
      let inArray = false;
      let excludeNext = false;
      let cursor = 0;
      const parentStack = [];
      const newChild = (asOr) => {
        if (cResult.excluded === true) {
          assert(excludeNext === false);
          excludeNext = true;
        }
        parentStack.push(cResult);
        cResult = [];
        cResult.or = asOr;
      };
      const finishChild = () => {
        const parent = parentStack.pop();
        const child2 = getSimple(cResult);
        if (parent.or === true && child2.or === true) {
          parent.push(...child2);
        } else {
          parent.push(child2);
        }
        cResult = parent;
      };
      newChild(false);
      return {
        setInArray: (flag, idx) => {
          if (inArray === flag) {
            throwError$1(inArray ? "Bad Array Start" : "Bad Array Terminator", input, { char: idx });
          }
          inArray = flag;
        },
        finishElement: (idx, err, fins, { finReq = false, group = false } = {}) => {
          const isFinished = cursor === idx;
          if (isFinished) {
            if (!fins.includes(input[idx - 1] || null)) {
              throwError$1(err, input, { char: idx });
            }
            cursor += 1;
          } else {
            if (finReq) {
              throwError$1(err, input, { char: idx });
            }
            const ele = input.slice(cursor, idx);
            if (group && !["**", "++"].includes(ele)) {
              throwError$1("Bad Group Start", input, { char: idx });
            }
            if (inArray && !(arraySelectorRegex.test(ele) || ele.startsWith("(") && ele.endsWith(")"))) {
              throwError$1("Bad Array Selector", input, { selector: ele });
            }
            if (group) {
              cResult.push(new Ref$1(ele));
            } else {
              cResult.push(new Value(inArray ? `[${ele}]` : ele, excludeNext));
              excludeNext = false;
            }
            cursor = idx + 1;
          }
        },
        startExclusion: (idx) => {
          if (excludeNext !== false) {
            throwError$1("Redundant Exclusion", input, { char: idx });
          }
          excludeNext = true;
        },
        startGroup: () => {
          newChild(true);
          if (excludeNext) {
            cResult.excluded = true;
            excludeNext = false;
          }
          newChild(false);
        },
        newGroupElement: () => {
          finishChild();
          newChild(false);
        },
        finishGroup: (idx) => {
          if (parentStack.length < 2) {
            throwError$1("Unexpected Group Terminator", input, { char: idx });
          }
          finishChild();
          finishChild();
          assert(Array.isArray(cResult));
          const refMaybe = cResult[cResult.length - 2];
          if (refMaybe instanceof Ref$1 && refMaybe.left === true) {
            cResult.push(refMaybe.link);
          }
        },
        finalizeResult: () => {
          finishChild();
          assert(excludeNext === false);
          if (parentStack.length !== 0) {
            throwError$1("Non Terminated Group", input);
          }
          if (inArray) {
            throwError$1("Non Terminated Array", input);
          }
          return getSimple(cResult);
        }
      };
    };
    const BACKSLASH_REGEX = /\\/g;
    const throwError = (msg, input, context = {}) => {
      throw new Error(Object.entries(context).reduce((p2, [k2, v2]) => `${p2}, ${k2} ${v2}`, `${msg}: ${input}`));
    };
    const parse$1 = (input, ctx) => {
      if (input === "") {
        return new Value("", false);
      }
      if (Array.isArray(input)) {
        if (input.length === 0) {
          return new Value("", false);
        }
        return input.map((e2, idx) => {
          if (typeof e2 === "number") {
            if (!ctx.useArraySelector) {
              throwError("Forbidden Array Selector", JSON.stringify(input), { idx });
            }
            return new Value(`[${e2}]`, false);
          }
          return new Value(e2.replace(BACKSLASH_REGEX, "\\\\"), false);
        });
      }
      const result = Result$1(input);
      const inputLength = input.length;
      let escaped = false;
      let bracketDepth = 0;
      for (let idx = 0; idx < inputLength; idx += 1) {
        const char = input[idx];
        if (escaped === false) {
          if (bracketDepth === 0) {
            switch (char) {
              case ".":
                result.finishElement(idx, "Bad Path Separator", ["]", "}"]);
                break;
              case "[":
                if (!ctx.useArraySelector) {
                  throwError("Forbidden Array Selector", input, { char: idx });
                }
                result.finishElement(idx, "Bad Array Start", [null, "!", "{", ",", "}", "]"]);
                result.setInArray(true, idx);
                break;
              case "]":
                result.finishElement(idx, "Bad Array Terminator", ["}"]);
                result.setInArray(false, idx);
                break;
              case "{":
                result.finishElement(idx, "Bad Group Start", [null, "!", ".", "[", "{", ","], { group: true });
                result.startGroup();
                break;
              case ",":
                result.finishElement(idx, "Bad Group Separator", ["]", "}"]);
                result.newGroupElement();
                break;
              case "}":
                result.finishElement(idx, "Bad Group Terminator", ["]", "}"]);
                result.finishGroup(idx);
                break;
              case "!":
                result.finishElement(idx, "Bad Exclusion", [null, ".", ",", "{", "["], { finReq: true });
                result.startExclusion(idx);
                break;
            }
          }
          switch (char) {
            case "(":
              bracketDepth += 1;
              break;
            case ")":
              if (bracketDepth === 0) {
                throwError("Unexpected Parentheses", input, { char: idx });
              }
              bracketDepth -= 1;
              break;
          }
        }
        escaped = char === "\\" ? !escaped : false;
      }
      if (escaped !== false) {
        throwError("Dangling Escape", input, { char: inputLength - 1 });
      }
      if (bracketDepth !== 0) {
        throwError("Unterminated Parentheses", input);
      }
      result.finishElement(inputLength, "Bad Terminator", ["]", "}"]);
      return result.finalizeResult();
    };
    const parser = { parse: parse$1 };
    const iterator$1 = (tree, cb) => {
      const stack2 = [tree];
      const parent = [null];
      const count = [];
      const depth = [];
      let idx = 0;
      let inc2 = true;
      while (idx !== -1) {
        const e2 = stack2[idx];
        if (Array.isArray(e2)) {
          if (e2.or !== true) {
            stack2.splice(idx, 1, ...e2);
            parent.splice(idx, 1, ...new Array(e2.length).fill(parent[idx]));
            if (parent[idx] !== null) {
              depth[parent[idx]] += e2.length - 1;
            }
          } else {
            if (count[idx] === void 0) {
              count[idx] = 0;
              depth[idx] = 0;
            } else if (depth[idx] !== 0) {
              stack2.splice(idx + 1, depth[idx]);
              parent.splice(idx + 1, depth[idx]);
              depth[idx] = 0;
            }
            if (count[idx] < e2.length) {
              stack2.splice(idx + 1, 0, e2[count[idx]]);
              parent.splice(idx + 1, 0, idx);
              count[idx] = (count[idx] || 0) + 1;
              depth[idx] += 1;
              inc2 = true;
              idx += 1;
            } else {
              count[idx] = 0;
              idx -= 1;
            }
          }
        } else if (inc2 === true) {
          cb("ADD", e2);
          if (idx === stack2.length - 1) {
            cb("FIN", e2);
            inc2 = false;
          } else {
            idx += 1;
          }
        } else {
          cb("RM", e2);
          idx -= 1;
        }
      }
    };
    const iterator = (tower, needle, tree, { onAdd, onFin }) => {
      const stack2 = [[[tower, null]]];
      let excluded = false;
      iterator$1(tree, (type, v2) => {
        if (type === "RM") {
          if (v2.excluded === true) {
            excluded = false;
          }
          stack2.length -= 2;
        } else if (type === "ADD") {
          if (v2.excluded === true) {
            if (excluded) {
              throw new Error(`Redundant Exclusion: "${needle}"`);
            }
            excluded = true;
          }
          const toAdd = [];
          const vParent = stack2[stack2.length - 2];
          stack2[stack2.length - 1].forEach(([cur, parent]) => onAdd(cur, parent, v2, vParent, (e2) => toAdd.push([e2, cur])));
          stack2.push(v2, toAdd);
        } else {
          stack2[stack2.length - 1].filter(([cur]) => cur !== tower).forEach(([cur, parent]) => onFin(cur, parent, v2, excluded));
        }
      });
    };
    const specialChars = /[?!,.*+[\](){}\\]/g;
    const escape = (input) => input.replace(specialChars, "\\$&");
    const regex = /^\^?[^-/\\^$*+?.()|[\]{}]*\$?$/g;
    const asRegex = (regexStr) => {
      if (regex.test(regexStr)) {
        const start2 = regexStr.startsWith("^");
        const end2 = regexStr.endsWith("$");
        if (start2 && end2) {
          const value = regexStr.slice(1, -1);
          return { test: (v2) => v2 === value };
        }
        if (start2) {
          const value = regexStr.slice(1);
          return { test: (v2) => v2.startsWith(value) };
        }
        if (end2) {
          const value = regexStr.slice(0, -1);
          return { test: (v2) => v2.endsWith(value) };
        }
        return { test: (v2) => v2.includes(regexStr) };
      }
      try {
        return new RegExp(regexStr);
      } catch (e2) {
        throw new Error(`Invalid Regex: "${regexStr}"`);
      }
    };
    const toPath = (input) => input.reduce((p2, c2) => `${p2}${typeof c2 === "number" ? `[${c2}]` : `${p2 ? "." : ""}${escape(c2)}`}`, "");
    const formatNeedle = (n2) => Array.isArray(n2) ? toPath(n2) : n2;
    const charsToEscape = ["-", "/", "\\", "^", "$", "*", "+", "?", ".", "(", ")", "|", "[", "]", "{", "}"];
    const parseValue = (value) => {
      let regex2 = "";
      let escaped = false;
      let simple = true;
      for (let idx = 0; idx < value.length; idx += 1) {
        const char = value[idx];
        if (!escaped && char === "\\") {
          escaped = true;
        } else if (!escaped && char === "*") {
          simple = false;
          regex2 += ".*";
        } else if (!escaped && char === "+") {
          simple = false;
          regex2 += ".+";
        } else if (!escaped && char === "?") {
          simple = false;
          regex2 += ".";
        } else {
          if (charsToEscape.includes(char)) {
            simple = false;
            regex2 += "\\";
          }
          regex2 += char;
          escaped = false;
        }
      }
      if (simple) {
        return { test: (v2) => v2 === regex2 };
      }
      if (regex2 === ".+") {
        return { test: (v2) => v2 !== "" };
      }
      return new RegExp(`^${regex2}$`);
    };
    const compileValue = (value) => {
      if ((value.startsWith("**(") || value.startsWith("++(")) && value.endsWith(")")) {
        return asRegex(value.slice(3, -1));
      }
      if (value.startsWith("[(") && value.endsWith(")]")) {
        return asRegex(value.slice(2, -2));
      }
      if (value.startsWith("(") && value.endsWith(")")) {
        return asRegex(value.slice(1, -1));
      }
      if (value.startsWith("[") && value.endsWith("]")) {
        return parseValue(value.slice(1, -1));
      }
      return parseValue(value);
    };
    let Node$1 = class Node {
      constructor(value, ctx) {
        ctx.nodes.push(this);
        this.value = value;
        this.ctx = ctx;
        this.order = ctx.counter;
        this.children = [];
        this.match = false;
        this.matches = false;
        this.needles = [];
        this.leafNeedles = [];
        this.leafNeedlesExclude = [];
        this.leafNeedlesMatch = [];
        this.isArrayTarget = value.startsWith("[") && value.endsWith("]");
        this.isSimpleStarRec = value === "**";
        this.isSimplePlusRec = value === "++";
        this.isSimpleRec = this.isSimpleStarRec || this.isSimplePlusRec;
        this.isRegexStarRec = value.startsWith("**(") && value.endsWith(")");
        this.isRegexPlusRec = value.startsWith("++(") && value.endsWith(")");
        this.isStarRec = this.isSimpleStarRec || this.isRegexStarRec;
        this.isPlusRec = this.isSimplePlusRec || this.isRegexPlusRec;
        this.isRec = this.isStarRec || this.isPlusRec;
        this.isAnyArrayTarget = value === "[*]";
        this.isAnyObjTarget = value === "*";
        if (this.isSimpleRec || this.isAnyObjTarget || this.isAnyArrayTarget) {
          this.regex = null;
        } else {
          const { regex: regex2 } = ctx;
          if (!(value in regex2)) {
            regex2[value] = compileValue(value);
          }
          this.regex = regex2[value];
        }
      }
      recMatch(key2) {
        if (!this.isRec) {
          return false;
        }
        if (this.isSimpleRec) {
          return true;
        }
        return this.regex.test(key2);
      }
      typeMatch(key2, isArray2) {
        if (this.isSimpleRec) {
          return true;
        }
        if (this.isAnyArrayTarget) {
          return isArray2;
        }
        if (this.isAnyObjTarget) {
          return !isArray2;
        }
        if (isArray2 !== this.isArrayTarget && !this.isRec) {
          return false;
        }
        return this.regex.test(key2);
      }
      add(v2) {
        this.children.push(v2);
      }
      get(k2) {
        return this.children.find(({ value }) => value === k2);
      }
      markMatches() {
        this.matches = true;
      }
      addNeedle(needle) {
        if (!this.needles.includes(needle)) {
          this.needles.push(needle);
        }
      }
      setRoots(roots) {
        this.roots = roots;
      }
      finish(needle, excluded, index2) {
        this.addNeedle(needle);
        if (!this.leafNeedles.includes(needle)) {
          this.leafNeedles.push(needle);
        }
        const target = excluded ? this.leafNeedlesExclude : this.leafNeedlesMatch;
        if (!target.includes(needle)) {
          target.push(needle);
        }
        this.match = !excluded;
        this.matches = this.match;
        this.index = index2;
      }
    };
    const applyNeedle = (tower, needle, tree, ctx) => {
      iterator(tower, needle, tree, {
        onAdd: (cur, parent, v2, vParent, next) => {
          cur.addNeedle(needle);
          if (v2 instanceof Ref$1) {
            if (v2.left === true) {
              if (v2.isStarRec) {
                v2.setPointer(cur);
              }
              v2.setNode(new Node$1("*", ctx));
              ctx.links.push(cur, v2.node);
              next(v2.node);
            } else {
              v2.target = "target" in vParent ? vParent.target : parent.get(vParent.value);
              ctx.links.push(v2.target, v2.node);
              if (v2.pointer !== null) {
                next(v2.pointer);
                v2.setPointer(null);
              }
              next(cur);
            }
            return;
          }
          const redundantRecursion = v2.isStarRec && v2.value === (vParent == null ? void 0 : vParent.value);
          if (redundantRecursion && ctx.strict) {
            throw new Error(`Redundant Recursion: "${needle}"`);
          }
          if (!redundantRecursion) {
            let node = cur.get(v2.value);
            if (node === void 0) {
              node = new Node$1(v2.value, ctx);
              cur.add(node);
            }
            next(node);
          } else {
            v2.target = cur;
          }
          if (v2.isStarRec) {
            next(cur);
          }
        },
        onFin: (cur, parent, v2, excluded) => {
          if (ctx.strict && v2.isSimpleStarRec) {
            const unnecessary = parent.children.filter(({ value }) => !["", "**"].includes(value));
            if (unnecessary.length !== 0) {
              throw new Error(`Needle Target Invalidated: "${unnecessary[0].needles[0]}" by "${needle}"`);
            }
          }
          if (ctx.strict && cur.leafNeedles.length !== 0) {
            const nLeft = formatNeedle(cur.leafNeedles[0]);
            const nRight = formatNeedle(needle);
            throw new Error(`Redundant Needle Target: "${nLeft}" vs "${nRight}"`);
          }
          cur.finish(needle, excluded, ctx.counter);
          ctx.counter += 1;
        }
      });
    };
    const finalizeTower = (tower, ctx) => {
      const { links } = ctx;
      while (links.length !== 0) {
        const child2 = links.pop();
        const parent = links.pop();
        const { children } = parent;
        parent.children = [...child2.children.filter((c2) => !children.includes(c2)), ...children];
      }
      if (ctx.useArraySelector === false) {
        tower.setRoots(tower.children.filter(({ isStarRec, value }) => isStarRec || value === ""));
      }
      const { nodes } = ctx;
      while (nodes.length !== 0) {
        const node = nodes.pop();
        const { children } = node;
        children.reverse();
        if (children.some(({ matches: matches2 }) => matches2)) {
          node.markMatches();
        }
      }
    };
    const compile = (needles, ctx) => {
      ctx.counter = 0;
      ctx.links = [];
      ctx.nodes = [];
      ctx.regex = /* @__PURE__ */ Object.create(null);
      const tower = new Node$1("*", ctx);
      for (let idx = 0; idx < needles.length; idx += 1) {
        const needle = needles[idx];
        const tree = [parser.parse(needle, ctx)];
        applyNeedle(tower, needle, tree, ctx);
      }
      finalizeTower(tower, ctx);
      return tower;
    };
    const getUniques = (searches, key2) => {
      const result = [];
      for (let i2 = 0, lenS = searches.length; i2 < lenS; i2 += 1) {
        const needles = searches[i2][key2];
        for (let j2 = 0, lenN = needles.length; j2 < lenN; j2 += 1) {
          const needle = needles[j2];
          if (!result.includes(needle)) {
            result.push(needle);
          }
        }
      }
      return result;
    };
    const matchedBy = (searches) => getUniques(searches, "leafNeedlesMatch");
    const excludedBy = (searches) => getUniques(searches, "leafNeedlesExclude");
    const traversedBy = (searches) => getUniques(searches, "needles");
    const isLastLeafMatch = (searches) => {
      let maxLeafIndex = -1;
      let maxLeafMatch = false;
      let idx = searches.length;
      while (idx--) {
        const { index: index2, match } = searches[idx];
        if (index2 > maxLeafIndex) {
          maxLeafIndex = index2;
          maxLeafMatch = match;
        }
      }
      return maxLeafMatch;
    };
    const formatPath = (input, joined) => joined ? toPath(input) : [...input];
    const Result = (kwargs, ctx) => {
      if (ctx.rtn === "context") {
        return {
          onMatch: () => {
          },
          get: () => kwargs.context
        };
      }
      if (ctx.rtn === "bool") {
        let result2 = false;
        return {
          onMatch: () => {
            result2 = true;
          },
          get: () => result2
        };
      }
      if (ctx.rtn === "count") {
        let result2 = 0;
        return {
          onMatch: () => {
            result2 += 1;
          },
          get: () => result2
        };
      }
      if (ctx.rtn === "sum") {
        let result2 = 0;
        return {
          onMatch: ({ value }) => {
            result2 += value;
          },
          get: () => result2
        };
      }
      const result = [];
      return {
        onMatch: (() => {
          if (typeof ctx.rtn === "function") {
            return () => result.push(ctx.rtn(kwargs));
          }
          if (Array.isArray(ctx.rtn)) {
            return () => result.push(ctx.rtn.map((rtn) => kwargs[rtn]));
          }
          return () => result.push(kwargs[ctx.rtn]);
        })(),
        get: () => ctx.abort ? result[0] : result
      };
    };
    const find$1 = (haystack_, search_, ctx) => {
      const state = {
        haystack: haystack_,
        context: ctx.context
      };
      if (ctx.beforeFn !== void 0) {
        const r2 = ctx.beforeFn(state);
        if (r2 !== void 0) {
          state.haystack = r2;
        }
      }
      const stack2 = [false, [search_], null, 0];
      const path = [];
      const parents = [];
      let depth;
      let segment;
      let searches;
      let isMatch;
      let haystack = state.haystack;
      const kwargs = {
        getKey: (joined = ctx.joined) => formatPath(path, joined),
        get key() {
          return kwargs.getKey();
        },
        getValue: () => haystack,
        get value() {
          return kwargs.getValue();
        },
        getEntry: (joined = ctx.joined) => [formatPath(path, joined), haystack],
        get entry() {
          return kwargs.getEntry();
        },
        getIsMatch: () => isMatch,
        get isMatch() {
          return kwargs.getIsMatch();
        },
        getMatchedBy: () => matchedBy(searches),
        get matchedBy() {
          return kwargs.getMatchedBy();
        },
        getExcludedBy: () => excludedBy(searches),
        get excludedBy() {
          return kwargs.getExcludedBy();
        },
        getTraversedBy: () => traversedBy(searches),
        get traversedBy() {
          return kwargs.getTraversedBy();
        },
        getGproperty: () => path[path.length - 2],
        get gproperty() {
          return kwargs.getGproperty();
        },
        getProperty: () => path[path.length - 1],
        get property() {
          return kwargs.getProperty();
        },
        getGparent: () => parents[parents.length - 2],
        get gparent() {
          return kwargs.getGparent();
        },
        getParent: () => parents[parents.length - 1],
        get parent() {
          return kwargs.getParent();
        },
        getParents: () => [...parents].reverse(),
        get parents() {
          return kwargs.getParents();
        },
        getIsCircular: () => parents.includes(haystack),
        get isCircular() {
          return kwargs.getIsCircular();
        },
        getIsLeaf: () => !(haystack instanceof Object),
        get isLeaf() {
          return kwargs.getIsLeaf();
        },
        getDepth: () => path.length,
        get depth() {
          return kwargs.getDepth();
        },
        /* getResult: <defined-below> */
        get result() {
          return kwargs.getResult();
        },
        context: state.context
      };
      const result = Result(kwargs, ctx);
      kwargs.getResult = () => result.get();
      if (ctx.useArraySelector || !Array.isArray(state.haystack)) {
        const child2 = search_.get("");
        if (child2 !== void 0) {
          stack2[1].push(child2);
        }
      }
      do {
        depth = stack2.pop();
        segment = stack2.pop();
        searches = stack2.pop();
        isMatch = stack2.pop();
        const diff = path.length - depth;
        for (let idx = 0; idx < diff; idx += 1) {
          parents.pop();
          path.pop();
        }
        if (diff === -1) {
          parents.push(haystack);
          path.push(segment);
          haystack = haystack[segment];
        } else if (segment !== null) {
          path[path.length - 1] = segment;
          haystack = parents[parents.length - 1][segment];
        } else {
          haystack = state.haystack;
        }
        if (isMatch) {
          if (ctx.filterFn === void 0 || ctx.filterFn(kwargs) !== false) {
            result.onMatch(kwargs);
            if (ctx.abort) {
              stack2.length = 0;
            }
          }
          continue;
        }
        if (!searches.some(({ matches: matches2 }) => matches2)) {
          continue;
        }
        const autoTraverseArray = ctx.useArraySelector === false && Array.isArray(haystack);
        if (!autoTraverseArray && isLastLeafMatch(searches)) {
          stack2.push(true, searches, segment, depth);
          isMatch = true;
        }
        if ((ctx.breakFn === void 0 || ctx.breakFn(kwargs) !== true) && haystack instanceof Object) {
          const isArray2 = Array.isArray(haystack);
          const keys = Object.keys(haystack);
          if (!isArray2 && ctx.compareFn) {
            keys.sort(ctx.compareFn(kwargs));
          }
          if (!ctx.reverse) {
            keys.reverse();
          }
          for (let kIdx = 0, kLen = keys.length; kIdx < kLen; kIdx += 1) {
            const key2 = keys[kIdx];
            const searchesOut = [];
            if (autoTraverseArray) {
              searchesOut.push(...searches);
              if (depth === 0) {
                searchesOut.push(...search_.roots);
              }
            } else {
              for (let sIdx = 0, sLen = searches.length; sIdx !== sLen; sIdx += 1) {
                const search = searches[sIdx];
                if (search.recMatch(key2)) {
                  searchesOut.push(search);
                }
                const { children } = search;
                let eIdx = children.length;
                while (eIdx--) {
                  const child2 = children[eIdx];
                  if (child2.typeMatch(key2, isArray2)) {
                    searchesOut.push(child2);
                  }
                }
              }
            }
            if (ctx.orderByNeedles) {
              searchesOut.index = Buffer.from(searchesOut.map(({ order: order2 }) => order2).sort());
              let checkIdx = stack2.length - 3;
              const checkIdxMin = checkIdx - kIdx * 4;
              while (checkIdx !== checkIdxMin && Buffer.compare(searchesOut.index, stack2[checkIdx].index) === 1) {
                checkIdx -= 4;
              }
              stack2.splice(checkIdx + 3, 0, false, searchesOut, isArray2 ? Number(key2) : key2, depth + 1);
            } else {
              stack2.push(false, searchesOut, isArray2 ? Number(key2) : key2, depth + 1);
            }
          }
        }
      } while (stack2.length !== 0);
      state.result = result.get();
      if (ctx.afterFn !== void 0) {
        const r2 = ctx.afterFn(state);
        if (r2 !== void 0) {
          state.result = r2;
        }
      }
      return state.result;
    };
    const expect = (opts, option, types) => {
      assert(
        types.includes(typeof opts[option]),
        () => `Option "${option}" not one of [${types.join(", ")}]`
      );
    };
    const Context = (opts) => {
      const ctx = {
        filterFn: void 0,
        breakFn: void 0,
        beforeFn: void 0,
        afterFn: void 0,
        compareFn: void 0,
        reverse: true,
        orderByNeedles: false,
        abort: false,
        rtn: void 0,
        joined: false,
        useArraySelector: true,
        strict: true,
        ...opts
      };
      assert(Object.keys(ctx).length === 12, "Unexpected Option provided");
      expect(ctx, "filterFn", ["function", "undefined"]);
      expect(ctx, "breakFn", ["function", "undefined"]);
      expect(ctx, "beforeFn", ["function", "undefined"]);
      expect(ctx, "afterFn", ["function", "undefined"]);
      expect(ctx, "compareFn", ["function", "undefined"]);
      expect(ctx, "reverse", ["boolean"]);
      expect(ctx, "orderByNeedles", ["boolean"]);
      expect(ctx, "abort", ["boolean"]);
      assert(
        typeof ctx.rtn === "function" && ctx.rtn.length === 1 || [
          void 0,
          "context",
          "key",
          "value",
          "entry",
          "property",
          "gproperty",
          "parent",
          "gparent",
          "parents",
          "isMatch",
          "matchedBy",
          "excludedBy",
          "traversedBy",
          "isCircular",
          "isLeaf",
          "depth",
          "bool",
          "count",
          "sum"
        ].includes(ctx.rtn) || Array.isArray(ctx.rtn) && ctx.rtn.every((e2) => [
          "key",
          "value",
          "entry",
          "property",
          "gproperty",
          "parent",
          "gparent",
          "parents",
          "isMatch",
          "matchedBy",
          "excludedBy",
          "traversedBy",
          "isCircular",
          "isLeaf",
          "depth"
        ].includes(e2)),
        'Option "rtn" is malformed'
      );
      expect(ctx, "joined", ["boolean"]);
      expect(ctx, "useArraySelector", ["boolean"]);
      expect(ctx, "strict", ["boolean"]);
      return ctx;
    };
    const objectScan = (needles, opts = {}) => {
      assert(
        Array.isArray(needles),
        'Argument "needles" expected to be Array'
      );
      assert(
        opts instanceof Object && !Array.isArray(opts),
        'Argument "opts" expected to be Object'
      );
      if (needles.length === 0) {
        return (_2, ctx2) => ctx2 === void 0 ? [] : ctx2;
      }
      const ctx = Context(opts);
      const search = compile(needles, ctx);
      return (haystack, context) => find$1(haystack, search, {
        context,
        ...ctx,
        rtn: ctx.rtn || (context === void 0 ? "key" : "context")
      });
    };
    const utilsProfile = {
      /**
      * Returns the piece of the the userValue passed that contains the given @guid
      * 
      * @param {object} obj - the object, most likely the userValue
      * @param {string} guid - the guid to search for
      * @return {object|boolean} - will return the obj or false if not found
      */
      returnGuidLocation: function(obj, guid) {
        let foundPos = objectScan(["*.**.@guid,*.**.@guid.**.@guid,*.**.@guid.**.@guid.**.@guid,*.**.@guid.**.@guid.**.@guid.**.@guid"])(obj);
        for (let fp of foundPos) {
          let pointer = obj;
          let pointerParent = null;
          for (let pos of fp) {
            pointerParent = pointer;
            if (typeof pointer === "undefined") {
              break;
            }
            pointer = pointer[pos];
            if (pointer === guid) {
              return pointerParent;
            }
          }
        }
        return false;
      },
      /**
      * Returns the parent of the node with that guid
      * 
      * @param {object} obj - the object, most likely the userValue
      * @param {string} guid - the guid to search for
      * @return {object|boolean} - will return the obj or false if not found
      */
      returnGuidParent: function(obj, guid) {
        let foundPos = objectScan(["*.**.@guid,*.**.@guid.**.@guid,*.**.@guid.**.@guid.**.@guid,*.**.@guid.**.@guid.**.@guid.**.@guid"])(obj);
        for (let fp of foundPos) {
          let pointer = obj;
          let pointerHistory = [];
          for (let pos of fp) {
            if (typeof pointer === "undefined") {
              break;
            }
            if (pointer[pos] === guid) {
              if (pointerHistory[pointerHistory.length - 3]) {
                return pointerHistory[pointerHistory.length - 3];
              } else {
                return pointerHistory[0];
              }
            } else {
              pointerHistory.push(pointer[pos]);
              pointer = pointer[pos];
            }
          }
        }
        return false;
      },
      /**
      * Returns the piece profile passed to find the sepcific PT requested regardless of RT
      * 
      * @param {object} prfoile - the object, most likely the activeProfile
      * @param {string} guid - the guid to search for
      * @return {object|boolean} - will return the obj or false if not found
      */
      returnPt: function(profile, guid) {
        for (let rt2 in profile.rt) {
          for (let pt2 in profile.rt[rt2].pt) {
            if (profile.rt[rt2].pt[pt2]["@guid"] === guid) {
              return profile.rt[rt2].pt[pt2];
            }
          }
        }
        return false;
      },
      /**
      * Will return the number of values in a given property path for a uservalue
      * Useful to know when dealing with repeated literal values in a something like a mainTitle
      * @async
      * @param {object} pt - the pt field for that component
      * @param {array} propertyPath - the array of URI strings that points to the place to build the blank node obj
      * @return {number} - will return the count
      */
      countValues: function(pt2, propertyPath) {
        let pointer = pt2.userValue;
        let counter = 0;
        for (let p2 of propertyPath) {
          p2 = p2.propertyURI;
          if (!pointer[p2]) {
            return counter;
          } else {
            if (p2 === propertyPath[propertyPath.length - 1].propertyURI) {
              counter = pointer[p2].length;
            } else {
              if (pointer[p2][0]) {
                pointer = pointer[p2][0];
              } else {
                return counter;
              }
            }
          }
        }
        return counter;
      },
      /**
      * Will return the postion at the end of the property hiearchy but not the specific value blank node
      * Used to get to the parent of a value
      * @async
      * @param {object} pt - the pt field for that component
      * @param {array} propertyPath - the array of URI strings that points to the place to build the blank node obj
      * @return {object|boolean} - the position in the pt hiearchy or false
      */
      returnPropertyPathParent: function(pt2, propertyPath) {
        let pointer = pt2.userValue;
        for (let p2 of propertyPath) {
          p2 = p2.propertyURI;
          if (!pointer[p2]) {
            return false;
          } else {
            if (p2 === propertyPath[propertyPath.length - 1].propertyURI) {
              return pointer;
            } else {
              if (pointer[p2][0]) {
                pointer = pointer[p2][0];
              } else {
                return false;
              }
            }
          }
        }
      },
      /**
      * creates a path to the blank node supplied, there mgiht be some special rules around
      * the propertes and how we represent them in the userValue
      * @async
      * @param {object} pt - the pt field for that component
      * @param {array} propertyPath - the array of URI strings that points to the place to build the blank node obj
      * @return {array} - will return an array with the pt as 0 and the new @guid of the blanknode as 1
      */
      buildBlanknode: async function(pt2, propertyPath) {
        let pointer = pt2.userValue;
        for (let p2 of propertyPath) {
          p2 = p2.propertyURI;
          if (!pointer[p2]) {
            pointer[p2] = [{
              // always create a guid for it
              "@guid": short.generate()
            }];
            let type = utilsRDF.suggestTypeProfile(p2, pt2);
            if (type === false) {
              type = await utilsRDF.suggestTypeNetwork(p2);
            }
            if (type !== false) {
              if (utilsRDF.isUriALiteral(type) === false) {
                pointer[p2][0]["@type"] = type;
              }
            } else {
              console.error("Could not find type for this property", p2, "of", propertyPath, "in", pt2);
            }
            pointer = pointer[p2][0];
          } else {
            if (pointer[p2][0]) {
              console.log("Linink to", pointer[p2][0]);
              pointer = pointer[p2][0];
            } else {
              console.error("Trying to link to a level in userValue and unable to find it", p2, "of", propertyPath, "in", pt2);
            }
          }
        }
        if (!pointer || !pointer["@guid"]) {
          console.error("There was an unknown error trying to create a blank node in", propertyPath, " in ", pt2);
        }
        return [pt2, pointer["@guid"]];
      },
      /**
      * returns the value array that is at the end of the property path hierachy
      * @param {object} pt - the pt field for that component
      * @param {array} propertyPath - the array of URI strings that points to the place to build the blank node obj
      * @return {array} - will return the value array at the end of the property path if it exists
      */
      returnValueFromPropertyPath: function(pt2, propertyPath) {
        let deepestLevel = propertyPath[propertyPath.length - 1].level;
        let pointer = pt2.userValue;
        for (let p2 of propertyPath) {
          if (pointer[p2.propertyURI]) {
            if (Array.isArray(pointer[p2.propertyURI])) {
              if (pointer[p2.propertyURI].length === 0) {
                console.warn("Expecting there to be at least one value here: ", pt2, p2, propertyPath);
              }
              if (p2.level !== deepestLevel) {
                pointer = pointer[p2.propertyURI][0];
              } else {
                pointer = pointer[p2.propertyURI];
              }
            } else {
              console.error("Expecting Array in this userValue property:", pt2, p2, propertyPath);
              return false;
            }
          } else {
            return false;
          }
        }
        return pointer;
      },
      /**
      * Loops through a uservalue and looks for properties that have children that 
      * only have a @guid and/or a @type but no other data, an empty blank node
      * @param {object} userValue - the userValue
      * @return {object} - will return the userValue pruned
      */
      pruneUserValue: function(userValue) {
        for (let key2 in userValue) {
          if (Array.isArray(userValue[key2])) {
            console.log(key2);
            let hasData = false;
            for (let value of userValue[key2]) {
              for (let key22 in value) {
                console.log(key22);
                if (!["@guid", "@type"].includes(key22)) {
                  hasData = true;
                }
              }
            }
            if (!hasData) {
              console.log(key2, "does not have data");
              delete userValue[key2];
            }
          }
        }
        return userValue;
      },
      /**
      * Loads a record from the marva backend store and parses the XML into the profile
      * 
      * @param {string} recordId - the userValue
      * @return {object} - the profile
      */
      loadRecordFromBackend: async function(recordId) {
        console.log(recordId);
        let xml = await utilsNetwork.loadSavedRecord(recordId);
        console.log(xml);
        let meta = this.returnMetaFromSavedXML(xml);
        console.log(meta.xml);
        utilsParse.parseXml(meta.xml);
        let useProfile = null;
        if (useProfileStore().profiles[meta.profile]) {
          useProfile = JSON.parse(JSON.stringify(useProfileStore().profiles[meta.profile]));
        } else {
          alert("Cannot find that profile:", meta.profile);
        }
        if (utilsParse.hasItem > 0) {
          let useItemRtLabel;
          let instanceId = meta.rts.filter((id2) => {
            return id2.includes(":Instance");
          });
          if (instanceId.length > 0) {
            useItemRtLabel = instanceId[0].replace(":Instance", ":Item");
          }
          if (!useItemRtLabel) {
            let instanceId2 = meta.rts.filter((id2) => {
              return id2.includes(":Work");
            });
            if (instanceId2.length > 0) {
              useItemRtLabel = instanceId2[0].replace(":Work", ":Item");
            }
          }
          for (let step = 0; step < utilsParse.hasItem; step++) {
            for (let pkey in useProfileStore().profiles) {
              for (let rtkey in useProfileStore().profiles[pkey].rt) {
                if (rtkey == useItemRtLabel) {
                  let useItem = JSON.parse(JSON.stringify(useProfileStore().profiles[pkey].rt[rtkey]));
                  useProfile.rtOrder.push(useItemRtLabel + "-" + step);
                  useProfile.rt[useItemRtLabel + "-" + step] = useItem;
                }
              }
            }
          }
        }
        if (!useProfile.log) {
          useProfile.log = [];
        }
        useProfile.log.push({ action: "loadInstanceFromSave", from: meta.eid });
        useProfile.procInfo = meta.procInfo;
        useProfile.eId = meta.eid;
        useProfile.user = meta.user;
        useProfile.status = meta.status;
        let transformResults = await utilsParse.transformRts(useProfile);
        transformResults = this.reorderRTOrder(transformResults);
        console.log("transformResults", transformResults);
        return transformResults;
      },
      /**
      * Pass it a profile and it will reorder the rtOrder array abased on how it should flow
      * Work->Instance1->Item1,Item2->Instance2-Item2-1,etc..
      * 
      * @param {object} profile - the profile
      * @return {object} - the profile
      */
      reorderRTOrder: function(profile) {
        let itemLookup = {};
        for (let rt2 of profile.rtOrder) {
          if (rt2.includes(":Item")) {
            if (profile.rt[rt2] && profile.rt[rt2].itemOf) {
              itemLookup[rt2] = profile.rt[rt2].itemOf;
            } else {
              console.warn("Cannot find the itemOf of this item", rt2);
            }
          }
        }
        let newOrder = [];
        let theWork = null;
        for (let rt2 of profile.rtOrder) {
          if (rt2.includes(":Work")) {
            theWork = rt2;
          }
          if (rt2.includes(":Instance")) {
            newOrder.push(rt2);
            let thisInstanceURI = profile.rt[rt2].URI;
            for (let k2 in itemLookup) {
              if (itemLookup[k2] == thisInstanceURI) {
                newOrder.push(k2);
              }
            }
          }
        }
        if (theWork) {
          newOrder.unshift(theWork);
        }
        for (let rt2 of profile.rtOrder) {
          if (newOrder.indexOf(rt2) === -1) {
            if (rt2.includes(":Hub")) {
              newOrder.unshift(rt2);
            } else {
              newOrder.push(rt2);
            }
          }
        }
        profile.rtOrder = JSON.parse(JSON.stringify(newOrder));
        return profile;
      },
      returnMetaFromSavedXML: function(xml) {
        let parser2 = new DOMParser();
        xml = parser2.parseFromString(xml, "text/xml");
        let voidData = xml.getElementsByTagName("void:DatasetDescription")[0];
        let rts = [];
        for (let rt2 of voidData.getElementsByTagName("lclocal:rtsused")) {
          rts.push(rt2.innerHTML);
        }
        let eid = null;
        for (let el of voidData.getElementsByTagName("lclocal:eid")) {
          eid = el.innerHTML;
        }
        let status = null;
        for (let el of voidData.getElementsByTagName("lclocal:status")) {
          status = el.innerHTML;
        }
        let profile = null;
        for (let el of voidData.getElementsByTagName("lclocal:typeid")) {
          profile = el.innerHTML;
        }
        let procInfo = null;
        for (let el of voidData.getElementsByTagName("lclocal:procinfo")) {
          procInfo = el.innerHTML;
        }
        let user = null;
        for (let el of voidData.getElementsByTagName("lclocal:user")) {
          user = el.innerHTML;
        }
        voidData.remove();
        xml = new XMLSerializer().serializeToString(xml);
        return {
          rts,
          xml,
          eid,
          status,
          profile,
          procInfo,
          user
        };
      }
    };
    const translator = short();
    const decimalTranslator$1 = short("0123456789");
    const hashCode = (s2) => s2.split("").reduce((a2, b2) => (a2 << 5) - a2 + b2.charCodeAt(0) | 0, 0);
    const LABEL_PREDICATES = [
      "http://www.w3.org/2000/01/rdf-schema#label",
      "http://www.loc.gov/mads/rdf/v1#authoritativeLabel",
      "http://id.loc.gov/ontologies/bibframe/code"
    ];
    const useProfileStore = defineStore("profile", {
      state: () => ({
        // flag if the profiles have been loaded and processed
        profilesLoaded: false,
        // holds all profiles
        profiles: {},
        // holds all rts, with its ID as the key
        rtLookup: {},
        // the starting points that display on the create new page
        startingPoints: {},
        // the current active profile
        activeProfile: {},
        activeProfileSaved: true,
        showPostModal: false,
        // bf:title component/predicate for example, value will be the structure object for this component
        activeComponent: null,
        // bf:mainTitle for example, value will be the the structure object for this field
        // main thing we can use it for is to see which field is currently active in the interface via the @guid
        activeField: { "@guid": null }
      }),
      getters: {
        /**
        * Can be used to return the structure of the component by passing the GUID
        * It doesn't care what profile it is in it will loop through all of them to find the unique GUID
        * @param {string} guid - the guid of the component
        * @return {object}
        */
        returnStructureByGUID: (state) => {
          return (guid) => {
            for (let rt2 in state.activeProfile.rt) {
              for (let pt2 in state.activeProfile.rt[rt2].pt) {
                if (state.activeProfile.rt[rt2].pt[pt2]["@guid"] === guid) {
                  return state.activeProfile.rt[rt2].pt[pt2];
                }
              }
            }
          };
        }
      },
      actions: {
        /**
        * The main first process that takes the raw profiles and processes them for use
        * 
        * @return {void}
        */
        async buildProfiles() {
          const config2 = useConfigStore();
          let profileData;
          try {
            let response = await fetch(config2.returnUrls.profiles);
            profileData = await response.json();
          } catch (err) {
            alert("Could not download the profiles, unable to continue.");
            console.error(err);
          }
          let startingPointData;
          try {
            let response = await fetch(config2.returnUrls.starting);
            startingPointData = await response.json();
          } catch (err) {
            alert("Could not download the starting points, unable to continue.");
            console.error(err);
          }
          if (startingPointData[0]) {
            startingPointData[0].json.push(
              {
                "menuGroup": "Hub",
                "menuItems": [
                  {
                    "label": "Hub",
                    "type": [
                      "http://id.loc.gov/ontologies/bibframe/Hub"
                    ],
                    "useResourceTemplates": [
                      "lc:RT:bf2:Hub:Hub"
                    ]
                  }
                ]
              }
            );
          } else if (startingPointData.json) {
            startingPointData.json.push(
              {
                "menuGroup": "Hub",
                "menuItems": [
                  {
                    "label": "Hub",
                    "type": [
                      "http://id.loc.gov/ontologies/bibframe/Hub"
                    ],
                    "useResourceTemplates": [
                      "lc:RT:bf2:Hub:Hub"
                    ]
                  }
                ]
              }
            );
          }
          for (let p2 of profileData) {
            if (p2.json.Profile.id == "lc:profile:bf2:Agents:Attributes") {
              for (let rt2 of p2.json.Profile.resourceTemplates) {
                if (["lc:RT:bf2:Agent:Person", "lc:RT:bf2:Agent:Family", "lc:RT:bf2:Agent:CorporateBody", "lc:RT:bf2:Agent:Conference", "lc:RT:bf2:Agent:Jurisdiction"].indexOf(rt2.id) > -1) {
                  rt2.propertyTemplates = [rt2.propertyTemplates[0]];
                }
              }
            }
            p2.json.Profile.resourceTemplates = p2.json.Profile.resourceTemplates.filter((rt2) => {
              rt2.propertyTemplates = rt2.propertyTemplates.filter((pt2) => {
                if (pt2.propertyLabel && (pt2.propertyLabel.startsWith("Input RDA relationship designator ter") || pt2.propertyLabel.startsWith("Input Geographic Coverage (if not on list)"))) {
                  return false;
                }
                if (pt2.propertyURI == "http://id.loc.gov/ontologies/bibframe/adminMetadata") {
                  return false;
                }
                return true;
              });
              if (rt2) {
                return true;
              }
            });
            for (let rt2 of p2.json.Profile.resourceTemplates) {
              if (config2.profileHacks.profileParseFixLowerCaseContribution.enabled) {
                if (rt2.id === "lc:RT:bf2:Agents:contribution") {
                  rt2.id = "lc:RT:bf2:Agents:Contribution";
                }
              }
              if (rt2.id == "lc:RT:bf2:Components") {
                for (let pt2 of rt2.propertyTemplates) {
                  pt2.valueConstraint.valueTemplateRefs = pt2.valueConstraint.valueTemplateRefs.filter((ref2) => {
                    if (ref2 == "lc:RT:bf2:Topic:madsTopic") {
                      return true;
                    }
                  });
                }
              }
              if (rt2.id == "lc:RT:bf2:Topic:Place:Components") {
                for (let pt2 of rt2.propertyTemplates) {
                  pt2.valueConstraint.valueTemplateRefs = pt2.valueConstraint.valueTemplateRefs.filter((ref2) => {
                    if (ref2 == "lc:RT:bf2:Topic:madsGeogHeading") {
                      return true;
                    }
                  });
                }
              }
              if (rt2.id == "lc:RT:bf2:Topic:Childrens:Components") {
                for (let pt2 of rt2.propertyTemplates) {
                  pt2.valueConstraint.valueTemplateRefs = pt2.valueConstraint.valueTemplateRefs.filter((ref2) => {
                    if (ref2 == "lc:RT:bf2:Topic:Childrens:Topic") {
                      return true;
                    }
                  });
                }
              }
              if (rt2.id == "lc:RT:bf2:Brief:Work") {
                rt2.propertyTemplates = [
                  {
                    "mandatory": "false",
                    "propertyLabel": "Lookup",
                    "propertyURI": "http://id.loc.gov/ontologies/bibframe/Work",
                    "repeatable": "true",
                    "resourceTemplates": [],
                    "type": "lookup",
                    "valueConstraint": {
                      "defaults": [],
                      "useValuesFrom": [
                        "https://preprod-8230.id.loc.gov/resources/works"
                      ],
                      "valueDataType": {
                        "dataTypeURI": ""
                      },
                      "valueTemplateRefs": []
                    }
                  }
                ];
              }
              if (rt2.id == "lc:RT:bf2:GPORelWorkBrief") {
                rt2.propertyTemplates = [
                  {
                    "mandatory": "false",
                    "propertyLabel": "Lookup",
                    "propertyURI": "http://id.loc.gov/ontologies/bibframe/Work",
                    "repeatable": "true",
                    "resourceTemplates": [],
                    "type": "lookup",
                    "valueConstraint": {
                      "defaults": [],
                      "useValuesFrom": [
                        "https://preprod-8295.id.loc.gov/resources/works"
                      ],
                      "valueDataType": {
                        "dataTypeURI": ""
                      },
                      "valueTemplateRefs": []
                    }
                  }
                ];
              }
              if (rt2.id == "lc:RT:bf2:Brief:Instance") {
                rt2.propertyTemplates = [
                  {
                    "mandatory": "false",
                    "propertyLabel": "Lookup",
                    "propertyURI": "http://id.loc.gov/ontologies/bibframe/Instance",
                    "repeatable": "true",
                    "resourceTemplates": [],
                    "type": "lookup",
                    "valueConstraint": {
                      "defaults": [],
                      "useValuesFrom": [
                        "https://preprod-8230.id.loc.gov/resources/instances"
                      ],
                      "valueDataType": {
                        "dataTypeURI": ""
                      },
                      "valueTemplateRefs": []
                    }
                  }
                ];
              }
              if (rt2.id.includes(":Agent")) {
                for (let pt2 of rt2.propertyTemplates) {
                  if (pt2.valueConstraint.useValuesFrom.indexOf("http://preprod.id.loc.gov/authorities/names") > -1) {
                    if (pt2.valueConstraint.useValuesFrom.indexOf("https://www.wikidata.org/w/api.php") == -1) {
                      pt2.valueConstraint.useValuesFrom.push("https://www.wikidata.org/w/api.php");
                    }
                  }
                }
              }
              for (let pt2 of rt2.propertyTemplates) {
                if (config2.profileHacks.profileParseFixPropertyURIWhenUpperCase.enabled) {
                  if (pt2.propertyURI == "http://id.loc.gov/ontologies/bibframe/Role") {
                    pt2.propertyURI = "http://id.loc.gov/ontologies/bibframe/role";
                  } else if (pt2.propertyURI == "http://id.loc.gov/ontologies/bibframe/Frequency") {
                    pt2.propertyURI = "http://id.loc.gov/ontologies/bibframe/frequency";
                  } else if (pt2.propertyURI == "http://id.loc.gov/ontologies/bibframe/ProductionMethod") {
                    pt2.propertyURI = "http://id.loc.gov/ontologies/bibframe/productionMethod";
                  } else if (pt2.propertyURI == "http://id.loc.gov/ontologies/bibframe/GrooveCharacteristic") {
                    pt2.propertyURI = "http://id.loc.gov/ontologies/bibframe/soundCharacteristic";
                  } else if (pt2.propertyURI == "http://id.loc.gov/ontologies/bibframe/MusicNotation") {
                    pt2.propertyURI = "http://id.loc.gov/ontologies/bibframe/notation";
                  } else if (pt2.propertyURI == "http://id.loc.gov/ontologies/bflc/Relation") {
                    pt2.propertyURI = "http://id.loc.gov/ontologies/bflc/relation";
                  } else if (pt2.propertyURI == "http://id.loc.gov/ontologies/bibframe/Scale") {
                    pt2.propertyURI = "http://id.loc.gov/ontologies/bibframe/scale";
                  } else if (pt2.propertyURI == "http://id.loc.gov/ontologies/bibframe/Frequency") {
                    pt2.propertyURI = "http://id.loc.gov/ontologies/bibframe/frequency";
                  } else if (pt2.propertyURI == "http://id.loc.gov/ontologies/bibframe/Place") {
                    pt2.propertyURI = "http://id.loc.gov/ontologies/bibframe/place";
                  } else if (pt2.propertyURI == "http://id.loc.gov/ontologies/bibframe/Illustration") {
                    pt2.propertyURI = "http://id.loc.gov/ontologies/bibframe/illustrativeContent";
                  } else if (pt2.propertyURI == "http://id.loc.gov/ontologies/bibframe/PlaybackChannels") {
                    pt2.propertyURI = "http://id.loc.gov/ontologies/bibframe/soundCharacteristic";
                  } else if (pt2.propertyURI == "http://id.loc.gov/ontologies/bibframe/RecordingMethod") {
                    pt2.propertyURI = "http://id.loc.gov/ontologies/bibframe/soundCharacteristic";
                  } else if (pt2.propertyURI == "http://id.loc.gov/ontologies/bibframe/BroadcastStandard") {
                    pt2.propertyURI = "http://id.loc.gov/ontologies/bibframe/videoCharacteristic";
                  } else if (pt2.propertyURI == "http://id.loc.gov/ontologies/bibframe/ColorContent") {
                    pt2.propertyURI = "http://id.loc.gov/ontologies/bibframe/colorContent";
                  } else if (pt2.propertyURI == "http://id.loc.gov/ontologies/bibframe/ColorContent") {
                    pt2.propertyURI = "http://id.loc.gov/ontologies/bibframe/colorContent";
                  } else if (pt2.propertyURI == "http://id.loc.gov/ontologies/bibframe/EncodingFormat") {
                    pt2.propertyURI = "http://id.loc.gov/ontologies/bibframe/digitalCharacteristic";
                  } else if (pt2.propertyURI == "http://id.loc.gov/ontologies/bibframe/FileType") {
                    pt2.propertyURI = "http://id.loc.gov/ontologies/bibframe/digitalCharacteristic";
                  } else if (pt2.propertyURI == "http://id.loc.gov/ontologies/bibframe/IntendedAudience") {
                    pt2.propertyURI = "http://id.loc.gov/ontologies/bibframe/intendedAudience";
                  } else if (pt2.propertyURI == "http://id.loc.gov/ontologies/bibframe/PresentationFormat") {
                    pt2.propertyURI = "http://id.loc.gov/ontologies/bibframe/projectionCharacteristic";
                  } else if (pt2.propertyURI == "http://id.loc.gov/ontologies/bibframe/Language") {
                    pt2.propertyURI = "http://id.loc.gov/ontologies/bibframe/language";
                  } else if (pt2.propertyURI == "http://id.loc.gov/ontologies/bibframe/SupplementaryContent") {
                    pt2.propertyURI = "http://id.loc.gov/ontologies/bibframe/supplementaryContent";
                  }
                }
              }
            }
          }
          profileData.forEach((p2) => {
            if (p2.json && p2.json.Profile) {
              this.profiles[p2.json.Profile.id] = {
                rtOrder: [],
                rt: {},
                id: p2.json.Profile.id
              };
              if (p2.json.Profile.resourceTemplates) {
                p2.json.Profile.resourceTemplates.forEach((rt2) => {
                  this.profiles[p2.json.Profile.id].rtOrder.push(rt2.id);
                  this.profiles[p2.json.Profile.id].rt[rt2.id] = { ptOrder: [], pt: {} };
                  if (rt2.propertyTemplates) {
                    rt2.propertyTemplates.forEach((pt2) => {
                      pt2.parent = p2.json.Profile.id + rt2.id + p2.id;
                      pt2.parentId = rt2.id;
                      pt2.userValue = { "@root": pt2.propertyURI };
                      pt2.valueConstraint.valueTemplateRefs = pt2.valueConstraint.valueTemplateRefs.filter((v2) => {
                        return v2.length > 0;
                      });
                      pt2["@guid"] = short.generate();
                      pt2.canBeHidden = true;
                      if (pt2.type === "literal-lang") {
                        this.profiles[p2.json.Profile.id].rt[rt2.id].hasLiteralLangFields = true;
                      }
                      let key2 = pt2.propertyURI.replace("http://", "").replace("https://", "").replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, "_") + "__" + (pt2.propertyLabel ? pt2.propertyLabel.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, "").replace(/\s+/g, "_").toLowerCase() : "plabel");
                      this.profiles[p2.json.Profile.id].rt[rt2.id].ptOrder.push(key2);
                      this.profiles[p2.json.Profile.id].rt[rt2.id].pt[key2] = pt2;
                      this.profiles[p2.json.Profile.id].rt[rt2.id].pt[key2].id = key2;
                    });
                  }
                });
              }
            }
            if (p2.json && p2.json.Profile && p2.json.Profile.resourceTemplates) {
              p2.json.Profile.resourceTemplates.forEach((rt2) => {
                this.rtLookup[rt2.id] = rt2;
              });
            }
          });
          let plookup = {};
          for (let p2 of Object.keys(this.profiles)) {
            this.profiles[p2].rtOrder.forEach((rtname) => {
              plookup[rtname] = this.profiles[p2].rt[rtname];
            });
          }
          if (Array.isArray(startingPointData)) {
            startingPointData = startingPointData[0];
          }
          if (config2.returnUrls.env != "production") {
            startingPointData.json.splice(2, 0, {
              "menuGroup": "GPO Monograph",
              "menuItems": [
                {
                  "label": "Instance",
                  "type": [
                    "http://id.loc.gov/ontologies/bibframe/Instance"
                  ],
                  "useResourceTemplates": [
                    "lc:RT:bf2:GPOMono:Instance"
                  ]
                },
                {
                  "label": "Work",
                  "type": [
                    "http://id.loc.gov/ontologies/bibframe/Work"
                  ],
                  "useResourceTemplates": [
                    "lc:RT:bf2:GPOMono:Work"
                  ]
                }
              ]
            });
            startingPointData.json.splice(3, 0, {
              "menuGroup": "GPO Serial",
              "menuItems": [
                {
                  "label": "Instance",
                  "type": [
                    "http://id.loc.gov/ontologies/bibframe/Instance"
                  ],
                  "useResourceTemplates": [
                    "lc:RT:bf2:GPOSerial:Instance"
                  ]
                },
                {
                  "label": "Work",
                  "type": [
                    "http://id.loc.gov/ontologies/bibframe/Work"
                  ],
                  "useResourceTemplates": [
                    "lc:RT:bf2:GPOSerial:Work"
                  ]
                }
              ]
            });
          }
          startingPointData.json.forEach((sp) => {
            this.startingPoints[sp.menuGroup] = { name: sp.menuGroup, work: null, instance: null, item: null };
            sp.menuItems.forEach((mi) => {
              if (mi.type.indexOf("http://id.loc.gov/ontologies/bibframe/Instance") > -1) {
                this.startingPoints[sp.menuGroup].instance = mi.useResourceTemplates[0];
              }
              if (mi.type.indexOf("http://id.loc.gov/ontologies/bibframe/Work") > -1) {
                this.startingPoints[sp.menuGroup].work = mi.useResourceTemplates[0];
              }
              if (mi.type.indexOf("http://id.loc.gov/ontologies/bibframe/Item") > -1) {
                this.startingPoints[sp.menuGroup].item = mi.useResourceTemplates[0];
              }
              if (mi.type.indexOf("http://id.loc.gov/ontologies/bibframe/Hub") > -1) {
                this.startingPoints[sp.menuGroup].hub = mi.useResourceTemplates[0];
              }
            });
            this.profiles[sp.menuGroup] = { id: sp.menuGroup, rt: {}, rtOrder: [] };
            if (this.startingPoints[sp.menuGroup].hub) {
              this.profiles[sp.menuGroup].rt[this.startingPoints[sp.menuGroup].hub] = plookup[this.startingPoints[sp.menuGroup].hub];
              this.profiles[sp.menuGroup].rtOrder.push(this.startingPoints[sp.menuGroup].hub);
            }
            if (this.startingPoints[sp.menuGroup].work) {
              this.profiles[sp.menuGroup].rt[this.startingPoints[sp.menuGroup].work] = plookup[this.startingPoints[sp.menuGroup].work];
              this.profiles[sp.menuGroup].rtOrder.push(this.startingPoints[sp.menuGroup].work);
            }
            if (this.startingPoints[sp.menuGroup].instance) {
              this.profiles[sp.menuGroup].rt[this.startingPoints[sp.menuGroup].instance] = plookup[this.startingPoints[sp.menuGroup].instance];
              this.profiles[sp.menuGroup].rtOrder.push(this.startingPoints[sp.menuGroup].instance);
            }
            if (this.startingPoints[sp.menuGroup].hub && this.startingPoints[sp.menuGroup].work && this.startingPoints[sp.menuGroup].instance) {
              this.profiles[sp.menuGroup].rtOrder = [];
              this.profiles[sp.menuGroup].rtOrder.push(this.startingPoints[sp.menuGroup].hub);
              this.profiles[sp.menuGroup].rtOrder.push(this.startingPoints[sp.menuGroup].work);
              this.profiles[sp.menuGroup].rtOrder.push(this.startingPoints[sp.menuGroup].instance);
            }
          });
          for (let p2 in this.profiles) {
            this.profiles[p2].hashRts = {};
            this.profiles[p2].hashPts = {};
            for (let rt2 in this.profiles[p2].rt) {
              if (this.profiles[p2].rt[rt2]) {
                this.profiles[p2].hashRts[rt2] = this.hashRt(this.profiles[p2].rt[rt2]);
              }
              if (this.profiles[p2].rt[rt2] && this.profiles[p2].rt[rt2].pt) {
                for (let pt2 in this.profiles[p2].rt[rt2].pt) {
                  let id2 = rt2 + "|" + this.profiles[p2].rt[rt2].pt[pt2].propertyURI;
                  if (this.profiles[p2].rt[rt2].pt[pt2].valueConstraint && this.profiles[p2].rt[rt2].pt[pt2].valueConstraint.valueDataType && this.profiles[p2].rt[rt2].pt[pt2].valueConstraint.valueDataType.dataTypeURI && this.profiles[p2].rt[rt2].pt[pt2].valueConstraint.valueDataType.dataTypeURI.trim() != "") {
                    id2 = id2 + "|" + this.profiles[p2].rt[rt2].pt[pt2].valueConstraint.valueDataType.dataTypeURI;
                  }
                  let ptVal = JSON.parse(JSON.stringify(this.profiles[p2].rt[rt2].pt[pt2]));
                  delete ptVal["@guid"];
                  this.profiles[p2].hashPts[id2] = hashCode(JSON.stringify(ptVal));
                }
              }
            }
          }
          console.log("this.profiles", this.profiles);
          this.profilesLoaded = true;
        },
        /**
        * Takes a resource template from the profile and creates a hash of the json-fied version of it to use as a fingerprint, to see if it changes later
        * For use in "template" functionality, to know if a resource template has changed since a template has used it
        * 
        * @param {object} rt - the rt from the profile
        * @return {number} The fingerprint hash
        */
        hashRt: function(rt2) {
          rt2 = JSON.parse(JSON.stringify(rt2));
          for (let pt2 in rt2.pt) {
            delete rt2.pt[pt2]["@guid"];
          }
          return hashCode(JSON.stringify(rt2));
        },
        /**
        * does all the work to setup a new profile read to be edited and posted as new resource
        * 
        * @param {string} useStartingPoint - the name of the starting point to use to as the profile
        * @param {string} addAdmin - the caloger user id to use in the admin metadata, if undefined it will not add a adminMetadata
        * @param {object} userTemplateSupplied - a specific profile is being asked to be prepared, so don't look it up in the starting points, just use this one
        * @return {object} useProfile - the profile modified ready to bet set in the state and edited
        */
        loadNewTemplate(useStartingPoint, addAdmin, userTemplateSupplied) {
          const config2 = useConfigStore();
          if (typeof addAdmin === "undefined") {
            addAdmin = false;
          }
          let useProfile;
          if (userTemplateSupplied) {
            useProfile = userTemplateSupplied;
          } else {
            useProfile = JSON.parse(JSON.stringify(this.profiles[useStartingPoint]));
          }
          let toRemove = [];
          let toKeep = [];
          for (let rt2 of useProfile.rtOrder) {
            let hasTLS = false;
            for (let TLS of config2.validTopLevelProfileSufixes) {
              if (rt2.includes(TLS)) {
                hasTLS = true;
              }
            }
            if (hasTLS === false) {
              toRemove.push(rt2);
            } else {
              toKeep.push(rt2);
            }
          }
          for (let rt2 of toRemove) {
            delete useProfile.rt[rt2];
          }
          useProfile.rtOrder = toKeep;
          console.log("useProfile", useProfile);
          if (!useProfile.log) {
            useProfile.log = [];
          }
          useProfile.log.push({ action: "createWorkInstance" });
          useProfile.procInfo = config2.procInfoNewWorkInstance;
          if (!useProfile.eId) {
            let uuid = "e" + decimalTranslator$1.new();
            uuid = uuid.substring(0, 8);
            useProfile.eId = uuid;
          }
          if (!useProfile.user) {
            useProfile.user = usePreferenceStore().returnUserNameForSaving;
          }
          if (!useProfile.status) {
            useProfile.status = "unposted";
          }
          let workUri = null;
          let workUriId = translator.toUUID(translator.new());
          for (let rt2 in useProfile.rt) {
            let uri = null;
            if (rt2.endsWith(config2.validTopLevelWork)) {
              uri = config2.baseURIWork + workUriId;
              workUri = uri;
            } else if (rt2.endsWith(config2.validTopLevelInstance)) {
              uri = config2.baseURIInstance + workUriId;
            } else if (rt2.endsWith(config2.validTopLevelItem)) {
              uri = config2.baseURIItem + translator.toUUID(translator.new());
            } else if (rt2.endsWith(config2.validTopLevelHub)) {
              uri = config2.baseURIHub + translator.toUUID(translator.new());
            } else {
              uri = "http://id.loc.gov/resources/unknown/" + translator.toUUID(translator.new());
            }
            useProfile.rt[rt2].URI = uri;
            for (let pt2 in useProfile.rt[rt2].pt) {
              if (useProfile.rt[rt2].pt[pt2].propertyURI == "http://id.loc.gov/ontologies/bibframe/Work") {
                useProfile.rt[rt2].pt[pt2].userValue = {
                  "@root": "http://id.loc.gov/ontologies/bibframe/Work",
                  "@guid": short.generate(),
                  "@id": uri
                };
              }
            }
          }
          for (let rt2 in useProfile.rt) {
            if (rt2.includes(config2.validTopLevelWork))
              ;
            else if (rt2.includes(config2.validTopLevelInstance)) {
              useProfile.rt[rt2].instanceOf = workUri;
            } else if (rt2.includes(config2.validTopLevelItem))
              ;
          }
          if (addAdmin) {
            for (let rt2 in useProfile.rt) {
              let adminMetadataProperty = {
                "mandatory": false,
                "propertyLabel": "Admin Metadata",
                "propertyURI": "http://id.loc.gov/ontologies/bibframe/adminMetadata",
                "repeatable": false,
                "resourceTemplates": [],
                "@guid": short.generate(),
                "type": "resource",
                "userValue": {
                  "@root": "http://id.loc.gov/ontologies/bibframe/adminMetadata",
                  "http://id.loc.gov/ontologies/bibframe/adminMetadata": [{
                    "@type": "http://id.loc.gov/ontologies/bibframe/AdminMetadata",
                    "@guid": short.generate(),
                    "http://id.loc.gov/ontologies/bflc/catalogerId": [
                      {
                        "@guid": short.generate(),
                        "http://id.loc.gov/ontologies/bflc/catalogerId": addAdmin
                      }
                    ]
                  }]
                },
                "valueConstraint": {
                  "defaults": [],
                  "useValuesFrom": [],
                  "valueDataType": {},
                  "valueTemplateRefs": [!rt2.includes(":GPO") ? "lc:RT:bf2:AdminMetadata:BFDB" : "lc:RT:bf2:GPOMono:AdminMetadata"]
                }
              };
              let adminMetadataPropertyLabel = "http://id.loc.gov/ontologies/bibframe/adminMetadata".replace("http://", "").replace("https://", "").replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, "_") + "__admin_metadata";
              if (useProfile.rt[rt2].pt[adminMetadataPropertyLabel]) {
                if (useProfile.rt[rt2].pt[adminMetadataPropertyLabel].userValue["http://id.loc.gov/ontologies/bibframe/adminMetadata"][0]["http://id.loc.gov/ontologies/bflc/catalogerId"]) {
                  useProfile.rt[rt2].pt[adminMetadataPropertyLabel].userValue["http://id.loc.gov/ontologies/bibframe/adminMetadata"][0]["http://id.loc.gov/ontologies/bflc/catalogerId"] = [
                    {
                      "@guid": short.generate(),
                      "http://id.loc.gov/ontologies/bflc/catalogerId": addAdmin
                    }
                  ];
                }
              } else {
                useProfile.rt[rt2].ptOrder.push(adminMetadataPropertyLabel);
                useProfile.rt[rt2].pt[adminMetadataPropertyLabel] = JSON.parse(JSON.stringify(adminMetadataProperty));
              }
            }
          }
          return useProfile;
        },
        /**
        * Keeps track of what field and component the user interface is currently working in
        * 
        * @param {object} structure - the profile structure the field is being built with 
        * @return {void}
        */
        setActiveField: function(structure) {
        },
        /**
            * Prepares the data in the component for switch the ref template, for example going
            * from main title to variant title, it needs to change the userValue mostly
            * @param {string} componentGuid - the guid of the component (the parent of all fields)
            * @param {array} propertyPath - array of strings mapping the predicates to the blanknode for the value
            * @param {object} nextRef - the template object representing the template we are switching to
            * @param {object} thisRef - the template object representing the template we currently on
        
            * @return {void}
            */
        changeRefTemplate: function(componentGuid, propertyPath, nextRef, thisRef) {
          let pt2 = utilsProfile.returnPt(this.activeProfile, componentGuid);
          if (pt2 !== false) {
            pt2.activeType = nextRef.resourceURI;
            let baseURI = pt2.propertyURI;
            if (!pt2.userValue[baseURI]) {
              pt2.userValue[baseURI] = [{}];
            }
            let userValue = pt2.userValue[baseURI][0];
            if (userValue["@id"]) {
              delete userValue["@id"];
            }
            userValue["@type"] = nextRef.resourceURI;
            if (!pt2.refTemplateUserValueKeys) {
              pt2.refTemplateUserValueKeys = {};
            }
            if (!pt2.refTemplateUserValueKeys[thisRef.id]) {
              pt2.refTemplateUserValueKeys[thisRef.id] = [];
            }
            for (let key2 in pt2.userValue) {
              if (!key2.startsWith("@")) {
                pt2.refTemplateUserValueKeys[thisRef.id].push(key2);
              }
            }
            let possibleProperties = nextRef.propertyTemplates.map((p2) => {
              return p2.propertyURI;
            });
            if (!pt2.refTemplateUserValue) {
              pt2.refTemplateUserValue = {};
            }
            for (let key2 in userValue) {
              if (!key2.startsWith("@")) {
                if (possibleProperties.indexOf(key2) == -1) {
                  pt2.refTemplateUserValue[key2] = JSON.parse(JSON.stringify(userValue[key2]));
                  delete userValue[key2];
                }
              }
            }
            for (let pp of possibleProperties) {
              if (pt2.refTemplateUserValue[pp]) {
                if (pp != "http://id.loc.gov/ontologies/bibframe/assigner") {
                  userValue[pp] = JSON.parse(JSON.stringify(pt2.refTemplateUserValue[pp]));
                }
                delete pt2.refTemplateUserValue[pp];
              }
            }
            for (let ptIdx of this.rtLookup[nextRef.id].propertyTemplates) {
              if (ptIdx.valueConstraint.defaults && ptIdx.valueConstraint.defaults.length > 0) {
                if (userValue[ptIdx.propertyURI]) {
                  userValue[ptIdx.propertyURI] = [];
                }
                if (ptIdx.valueConstraint.defaults[0].defaultLiteral) {
                  if (ptIdx.propertyURI === "http://www.w3.org/2000/01/rdf-schema#label") {
                    userValue[ptIdx.propertyURI] = [
                      {
                        "http://www.w3.org/2000/01/rdf-schema#label": ptIdx.valueConstraint.defaults[0].defaultLiteral,
                        "@guid": short.generate()
                      }
                    ];
                  } else {
                    userValue[ptIdx.propertyURI] = [{
                      "@guid": short.generate(),
                      "http://www.w3.org/2000/01/rdf-schema#label": [
                        {
                          "http://www.w3.org/2000/01/rdf-schema#label": ptIdx.valueConstraint.defaults[0].defaultLiteral,
                          "@guid": short.generate()
                        }
                      ]
                    }];
                  }
                }
                if (ptIdx.valueConstraint.defaults[0].defaultURI && ptIdx.valueConstraint.defaults[0].defaultURI.trim() != "") {
                  userValue[ptIdx.propertyURI][0]["@id"] = ptIdx.valueConstraint.defaults[0].defaultURI;
                  if (ptIdx.valueConstraint.valueDataType && ptIdx.valueConstraint.valueDataType.dataTypeURI) {
                    userValue[ptIdx.propertyURI][0]["@type"] = ptIdx.valueConstraint.valueDataType.dataTypeURI;
                  }
                }
              }
            }
            this.activeProfileSaved = false;
          } else {
            console.error("changeRefTemplate: Cannot locate the component by guid", componentGuid, this.activeProfile);
          }
        },
        /**
            * Sets a "Simple lookup" value, things from small controlled lists like role
            * this function only creates new values, does not modify (aka delete)
            * @async
            * @param {string} componentGuid - the guid of the component (the parent of all fields)
            * @param {string} fieldGuid - the guid of the field
            * @param {array} propertyPath - array of strings mapping the predicates to the blanknode for the value
            * @param {string} URI - the URI for the value
            * @param {string} label - the label to use
        
            * @return {void}
            */
        setValueSimple: async function(componentGuid, fieldGuid, propertyPath, URI, label2) {
          propertyPath = propertyPath.filter((v2) => {
            return v2.propertyURI !== "http://www.w3.org/2002/07/owl#sameAs";
          });
          let lastProperty = propertyPath.at(-1).propertyURI;
          let pt2 = utilsProfile.returnPt(this.activeProfile, componentGuid);
          if (pt2 !== false) {
            pt2.hasData = true;
            let blankNode = utilsProfile.returnGuidLocation(pt2.userValue, fieldGuid);
            console.log("blankNode === ", blankNode, fieldGuid);
            if (blankNode === false) {
              let buildBlankNodeResult = await utilsProfile.buildBlanknode(pt2, propertyPath);
              console.log("buildBlankNodeResult", buildBlankNodeResult);
              pt2 = buildBlankNodeResult[0];
              blankNode = utilsProfile.returnGuidLocation(pt2.userValue, buildBlankNodeResult[1]);
              if (URI !== null) {
                blankNode["@id"] = URI;
              }
              blankNode["http://www.w3.org/2000/01/rdf-schema#label"] = [
                {
                  "@guid": short.generate(),
                  "http://www.w3.org/2000/01/rdf-schema#label": label2
                }
              ];
            } else {
              let parent = utilsProfile.returnGuidParent(pt2.userValue, fieldGuid);
              if (parent[lastProperty]) {
                parent[lastProperty].push({
                  "@id": URI,
                  "@guid": short.generate(),
                  "http://www.w3.org/2000/01/rdf-schema#label": [
                    {
                      "@guid": short.generate(),
                      "http://www.w3.org/2000/01/rdf-schema#label": label2
                    }
                  ]
                });
              } else {
                console.error("Could not find the parent[lastProperty] of the existing value", { "parent": parent, "pt.userValue": pt2.userValue, "fieldGuid": fieldGuid });
              }
            }
            this.activeProfileSaved = false;
          } else {
            console.error("setValueSimple: Cannot locate the component by guid", componentGuid, this.activeProfile);
          }
        },
        /**
        * This removes the values of a complex lookup field    
        * 
        * @param {string} componentGuid - the guid of the component (the parent of all fields)
        * @param {string} fieldGuid - the guid of the field
        * @return {void}
        */
        removeValueComplex: async function(componentGuid, fieldGuid) {
          let pt2 = utilsProfile.returnPt(this.activeProfile, componentGuid);
          if (pt2 !== false) {
            console.log("pt ==", pt2);
            console.log("fieldGuid ==", fieldGuid);
            let parent = utilsProfile.returnGuidParent(pt2.userValue, fieldGuid);
            if (parent && parent.length === 1 && parent[0]["@guid"] === fieldGuid) {
              parent = pt2.userValue;
            }
            for (let p2 in parent) {
              if (Array.isArray(parent[p2])) {
                parent[p2] = parent[p2].filter((v2) => {
                  if (v2 && v2["@guid"] && v2["@guid"] === fieldGuid) {
                    return false;
                  } else {
                    return true;
                  }
                });
              }
            }
            for (let p2 in parent) {
              if (Array.isArray(parent[p2])) {
                if (parent[p2].length === 0) {
                  delete parent[p2];
                }
              }
            }
            pt2.userValue = utilsProfile.pruneUserValue(pt2.userValue);
            this.activeProfileSaved = false;
          } else {
            console.error("removeValueSimple: Cannot locate the component by guid", componentGuid, this.activeProfile);
          }
        },
        /**
        * This removes the values of a simple lookup field    
        * 
        * @param {string} componentGuid - the guid of the component (the parent of all fields)
        * @param {string} fieldGuid - the guid of the field
        * @return {void}
        */
        removeValueSimple: async function(componentGuid, fieldGuid) {
          let pt2 = utilsProfile.returnPt(this.activeProfile, componentGuid);
          if (pt2 !== false) {
            if (pt2.valueConstraint.valueTemplateRefs.length === 0) {
              for (let key2 in pt2.userValue) {
                if (Array.isArray(pt2.userValue[key2])) {
                  pt2.userValue[key2] = pt2.userValue[key2].filter((v2) => {
                    if (v2 && v2["@guid"] && v2["@guid"] === fieldGuid) {
                      return false;
                    } else {
                      return true;
                    }
                  });
                }
              }
              for (let key2 in pt2.userValue) {
                if (Array.isArray(pt2.userValue[key2])) {
                  if (pt2.userValue[key2].length === 0) {
                    delete pt2.userValue[key2];
                  }
                }
              }
            }
            let parent = utilsProfile.returnGuidParent(pt2.userValue, fieldGuid);
            for (let p2 in parent) {
              if (Array.isArray(parent[p2])) {
                parent[p2] = parent[p2].filter((v2) => {
                  console.log(v2);
                  if (v2 && v2["@guid"] && v2["@guid"] === fieldGuid) {
                    return false;
                  } else {
                    return true;
                  }
                });
              }
            }
            for (let p2 in parent) {
              if (Array.isArray(parent[p2])) {
                if (parent[p2].length === 0) {
                  delete parent[p2];
                }
              }
            }
            this.activeProfileSaved = false;
          } else {
            console.error("removeValueSimple: Cannot locate the component by guid", componentGuid, this.activeProfile);
          }
        },
        /**
        * Sets a literal value of field
        * 
        * @param {string} componentGuid - the guid of the component (the parent of all fields)
        * @param {string} fieldGuid - the guid of the field
        * @param {array} propertyPath - array of strings mapping the predicates to the blanknode for the value
        * @param {string} lang - the ISO rdf language value like 'en' to append to the literal 'xxxxx@en'
        * @return {void}
        */
        setValueLiteral: async function(componentGuid, fieldGuid, propertyPath, value, lang, repeatedLiteral) {
          let lastProperty = propertyPath.at(-1).propertyURI;
          let pt2 = utilsProfile.returnPt(this.activeProfile, componentGuid);
          console.log(componentGuid, fieldGuid, propertyPath, value, lang, repeatedLiteral);
          if (pt2 !== false) {
            pt2.hasData = true;
            let blankNode = utilsProfile.returnGuidLocation(pt2.userValue, fieldGuid);
            console.log("blankNode -->", blankNode);
            if (blankNode === false) {
              let buildBlankNodeResult;
              let currentValueCount = utilsProfile.countValues(pt2, propertyPath);
              if (currentValueCount === 0) {
                buildBlankNodeResult = await utilsProfile.buildBlanknode(pt2, propertyPath);
                console.log("buildBlankNodeResult", JSON.stringify(buildBlankNodeResult, null, 2));
                pt2 = buildBlankNodeResult[0];
                blankNode = utilsProfile.returnGuidLocation(pt2.userValue, buildBlankNodeResult[1]);
                console.log("blankNode", JSON.stringify(blankNode, null, 2));
                blankNode["@guid"] = fieldGuid;
                blankNode[lastProperty] = true;
              } else {
                let parent = utilsProfile.returnPropertyPathParent(pt2, propertyPath);
                if (!parent) {
                  console.error("Trying to add second literal, could not find the property path parent", pt2);
                  return false;
                }
                if (!parent[lastProperty]) {
                  console.error("Trying to find the value of this literal, unable to:", componentGuid, fieldGuid, propertyPath, value, lang, pt2);
                  return false;
                }
                let newGuid = short.generate();
                parent[lastProperty].push(
                  {
                    "@guid": newGuid
                  }
                );
                blankNode = utilsProfile.returnGuidLocation(pt2.userValue, newGuid);
                blankNode[lastProperty] = true;
              }
              console.log("currentValueCount", currentValueCount);
            }
            if (!blankNode[lastProperty]) {
              console.error("Trying to find the value of this literal, unable to:", componentGuid, fieldGuid, propertyPath, value, lang, pt2);
            }
            blankNode[lastProperty] = value;
            if (value.trim() === "") {
              delete blankNode[lastProperty];
              let parent = utilsProfile.returnPropertyPathParent(pt2, propertyPath);
              console.log("PARENT is", parent);
              if (parent && parent[lastProperty]) {
                let keep = [];
                if (parent[lastProperty].length > 0) {
                  for (let value2 of parent[lastProperty]) {
                    if (value2[lastProperty] && value2[lastProperty] != "") {
                      keep.push(value2);
                    }
                  }
                }
                parent[lastProperty] = keep;
                if (parent[lastProperty].length == 0) {
                  delete parent[lastProperty];
                }
              }
            }
            this.activeProfileSaved = false;
          } else {
            console.error("setValueLiteral: Cannot locate the component by guid", componentGuid, this.activeProfile);
          }
        },
        /**
        * returns a literal value of field
        * 
        * @param {string} componentGuid - the guid of the component (the parent of all fields)
        * @param {array} propertyPath - array of strings mapping the predicates to the blanknode for the value
        * @return {array} - an array of objs representing the literals
        */
        returnLiteralValueFromProfile: function(componentGuid, propertyPath) {
          let pt2 = utilsProfile.returnPt(this.activeProfile, componentGuid);
          let valueLocation = utilsProfile.returnValueFromPropertyPath(pt2, propertyPath);
          let deepestLevelURI = propertyPath[propertyPath.length - 1].propertyURI;
          if (valueLocation) {
            let values = [];
            for (let v2 of valueLocation) {
              if (v2[deepestLevelURI]) {
                values.push({
                  "@guid": v2["@guid"],
                  value: v2[deepestLevelURI],
                  "@lang": v2["@lang"] ? v2["@lang"] : null
                });
              } else {
                return false;
              }
            }
            return values;
          }
          return valueLocation;
        },
        /**
        * returns a simple lookup value of field
        * 
        * @param {string} componentGuid - the guid of the component (the parent of all fields)
        * @param {array} propertyPath - array of strings mapping the predicates to the blanknode for the value
        * @return {array} - an array of objs representing the simple lookup values
        */
        returnSimpleLookupValueFromProfile: function(componentGuid, propertyPath) {
          propertyPath = propertyPath.filter((v2) => {
            return v2.propertyURI !== "http://www.w3.org/2002/07/owl#sameAs";
          });
          let pt2 = utilsProfile.returnPt(this.activeProfile, componentGuid);
          let valueLocation = utilsProfile.returnValueFromPropertyPath(pt2, propertyPath);
          propertyPath[propertyPath.length - 1].propertyURI;
          if (valueLocation) {
            let values = [];
            for (let v2 of valueLocation) {
              let URI = null;
              let label2 = null;
              if (v2["@id"]) {
                URI = v2["@id"];
              }
              for (let lP of LABEL_PREDICATES) {
                if (v2[lP] && v2[lP][0][lP]) {
                  label2 = v2[lP][0][lP];
                  break;
                }
              }
              if (URI && label2) {
                values.push({
                  "@guid": v2["@guid"],
                  URI,
                  label: label2,
                  needsDereference: false,
                  isLiteral: false
                });
              } else if (URI && !label2) {
                values.push({
                  "@guid": v2["@guid"],
                  URI,
                  label: label2,
                  needsDereference: true,
                  isLiteral: false
                });
              } else if (!URI && label2) {
                values.push({
                  "@guid": v2["@guid"],
                  URI,
                  label: label2,
                  needsDereference: false,
                  isLiteral: true
                });
              }
            }
            return values;
          }
          return [];
        },
        /**
        * returns a complex lookup value of field
        * 
        * @param {string} componentGuid - the guid of the component (the parent of all fields)
        * @param {array} propertyPath - array of strings mapping the predicates to the blanknode for the value
        * @return {array} - an array of objs representing the simple lookup values
        */
        returnComplexLookupValueFromProfile: function(componentGuid, propertyPath) {
          propertyPath = propertyPath.filter((v2) => {
            return v2.propertyURI !== "http://www.w3.org/2002/07/owl#sameAs";
          });
          propertyPath = propertyPath.filter((v2) => {
            return v2.propertyURI !== "http://www.loc.gov/mads/rdf/v1#componentList";
          });
          propertyPath = propertyPath.filter((v2) => {
            return v2.propertyURI !== "http://www.loc.gov/mads/rdf/v1#Topic";
          });
          let pt2 = utilsProfile.returnPt(this.activeProfile, componentGuid);
          let valueLocation = utilsProfile.returnValueFromPropertyPath(pt2, propertyPath);
          propertyPath[propertyPath.length - 1].propertyURI;
          if (valueLocation) {
            let values = [];
            for (let v2 of valueLocation) {
              let URI = null;
              let label2 = null;
              if (v2["@id"]) {
                URI = v2["@id"];
              }
              for (let lP of LABEL_PREDICATES) {
                if (v2[lP] && v2[lP][0][lP]) {
                  label2 = v2[lP][0][lP];
                  break;
                }
              }
              if (URI && label2) {
                values.push({
                  "@guid": v2["@guid"],
                  URI,
                  label: label2,
                  needsDereference: false,
                  isLiteral: false,
                  type: v2["@type"]
                });
              } else if (URI && !label2) {
                values.push({
                  "@guid": v2["@guid"],
                  URI,
                  label: label2,
                  needsDereference: true,
                  isLiteral: false,
                  type: v2["@type"]
                });
              } else if (!URI && label2) {
                values.push({
                  "@guid": v2["@guid"],
                  URI,
                  label: label2,
                  needsDereference: false,
                  isLiteral: true,
                  type: v2["@type"]
                });
              }
            }
            return values;
          }
          return [];
        },
        /**
            * Sets a "Complex lookup" value, things from large lookups like NAF LCSH, etc
            * this function only creates new values, does not modify (aka delete)
            * @async
            * @param {string} componentGuid - the guid of the component (the parent of all fields)
            * @param {string} fieldGuid - the guid of the field
            * @param {array} propertyPath - array of strings mapping the predicates to the blanknode for the value
            * @param {string} URI - the URI for the value
            * @param {string} label - the label to use
            * @param {string} type - the URI of the type to use, like http://www.loc.gov/mads/rdf/v1#CorporateName
        
            * @return {void}
            */
        setValueComplex: async function(componentGuid, fieldGuid, propertyPath, URI, label2, type) {
          propertyPath = propertyPath.filter((v2) => {
            return v2.propertyURI !== "http://www.w3.org/2002/07/owl#sameAs";
          });
          let lastProperty = propertyPath.at(-1).propertyURI;
          let pt2 = utilsProfile.returnPt(this.activeProfile, componentGuid);
          if (!type) {
            let context = await utilsNetwork.returnContext(URI);
            type = context.typeFull;
          }
          if (pt2 !== false) {
            pt2.hasData = true;
            let blankNode = utilsProfile.returnGuidLocation(pt2.userValue, fieldGuid);
            console.log("blankNode === ", blankNode, fieldGuid);
            if (blankNode === false) {
              let buildBlankNodeResult = await utilsProfile.buildBlanknode(pt2, propertyPath);
              console.log("buildBlankNodeResult", buildBlankNodeResult);
              pt2 = buildBlankNodeResult[0];
              blankNode = utilsProfile.returnGuidLocation(pt2.userValue, buildBlankNodeResult[1]);
              if (URI !== null) {
                blankNode["@id"] = URI;
              }
              blankNode["@type"] = type;
              blankNode["http://www.w3.org/2000/01/rdf-schema#label"] = [
                {
                  "@guid": short.generate(),
                  "http://www.w3.org/2000/01/rdf-schema#label": label2
                }
              ];
            } else {
              let parent = utilsProfile.returnGuidParent(pt2.userValue, fieldGuid);
              if (parent[lastProperty]) {
                parent[lastProperty].push({
                  "@id": URI,
                  "@guid": short.generate(),
                  "http://www.w3.org/2000/01/rdf-schema#label": [
                    {
                      "@guid": short.generate(),
                      "http://www.w3.org/2000/01/rdf-schema#label": label2
                    }
                  ]
                });
              } else {
                console.error("Could not find the parent[lastProperty] of the existing value", { "parent": parent, "pt.userValue": pt2.userValue, "fieldGuid": fieldGuid });
              }
            }
            this.activeProfileSaved = false;
          } else {
            console.error("setValueSimple: Cannot locate the component by guid", componentGuid, this.activeProfile);
          }
          console.log("pt is ", pt2);
        },
        /**
        * sets the uservalue when dealing with subject headings
        * @param {string} componentGuid - the guid of the component (the parent of all fields)
        * @param {array} subjectComponents - objects with the data to represent the component parts of subject heading
        * @param {array} propertyPath - the path of uris to get to this level
        * @return {void} - 
        */
        setValueSubject: async function(componentGuid, subjectComponents, propertyPath) {
          let pt2 = utilsProfile.returnPt(this.activeProfile, componentGuid);
          console.log("-----");
          console.log(pt2);
          console.log(subjectComponents);
          console.log(propertyPath);
          if (pt2) {
            let userValue = {};
            let currentUserValuePos = userValue;
            for (let p2 of propertyPath) {
              if (p2.propertyURI == "http://www.w3.org/2002/07/owl#sameAs") {
                break;
              }
              if (p2.propertyURI == "http://www.loc.gov/mads/rdf/v1#componentList") {
                break;
              }
              if (!currentUserValuePos[p2.propertyURI]) {
                currentUserValuePos[p2.propertyURI] = [];
              }
              let thisLevelType = utilsRDF.suggestTypeProfile(p2.propertyURI, pt2);
              if (thisLevelType === false) {
                thisLevelType = await utilsRDF.suggestTypeNetwork(p2.propertyURI);
              }
              let thisLevel = { "@guid": short.generate() };
              if (!utilsRDF.isUriALiteral(thisLevelType)) {
                thisLevel["@type"] = thisLevelType;
              }
              if (currentUserValuePos[p2.propertyURI].length == 0) {
                currentUserValuePos[p2.propertyURI].push(thisLevel);
              }
              currentUserValuePos = currentUserValuePos[p2.propertyURI][0];
            }
            if (pt2.userValue["http://id.loc.gov/ontologies/bibframe/subject"] && pt2.userValue["http://id.loc.gov/ontologies/bibframe/subject"][0] && pt2.userValue["http://id.loc.gov/ontologies/bibframe/subject"][0]["http://id.loc.gov/ontologies/bibframe/source"] && pt2.userValue["http://id.loc.gov/ontologies/bibframe/subject"][0]["http://id.loc.gov/ontologies/bibframe/source"][0]) {
              userValue["http://id.loc.gov/ontologies/bibframe/subject"][0]["http://id.loc.gov/ontologies/bibframe/source"] = JSON.parse(JSON.stringify(pt2.userValue["http://id.loc.gov/ontologies/bibframe/subject"][0]["http://id.loc.gov/ontologies/bibframe/source"]));
            }
            if (pt2.userValue["@root"]) {
              userValue["@root"] = JSON.parse(JSON.stringify(pt2.userValue["@root"]));
            }
            if (pt2.userValue["@guid"]) {
              userValue["@guid"] = JSON.parse(JSON.stringify(pt2.userValue["@guid"]));
            }
            currentUserValuePos["http://www.loc.gov/mads/rdf/v1#isMemberOfMADSScheme"] = [{
              "@guid": short.generate(),
              "@id": "http://id.loc.gov/authorities/subjects"
            }];
            if (subjectComponents.length == 1) {
              currentUserValuePos["@id"] = subjectComponents[0].uri;
              currentUserValuePos["@type"] = subjectComponents[0].type.replace("madsrdf:", "http://www.loc.gov/mads/rdf/v1#");
              currentUserValuePos["http://www.loc.gov/mads/rdf/v1#authoritativeLabel"] = [{
                "@guid": short.generate(),
                "http://www.loc.gov/mads/rdf/v1#authoritativeLabel": subjectComponents[0].label
              }];
              currentUserValuePos["http://www.w3.org/2000/01/rdf-schema#label"] = [{
                "@guid": short.generate(),
                "http://www.w3.org/2000/01/rdf-schema#label": subjectComponents[0].label
              }];
            } else if (subjectComponents.length > 1) {
              let fullLabel = subjectComponents.map((c2) => {
                return c2.label;
              }).join("--");
              currentUserValuePos["http://www.loc.gov/mads/rdf/v1#authoritativeLabel"] = [{
                "@guid": short.generate(),
                "http://www.loc.gov/mads/rdf/v1#authoritativeLabel": fullLabel
              }];
              currentUserValuePos["http://www.w3.org/2000/01/rdf-schema#label"] = [{
                "@guid": short.generate(),
                "http://www.w3.org/2000/01/rdf-schema#label": fullLabel
              }];
              currentUserValuePos["http://www.loc.gov/mads/rdf/v1#componentList"] = [];
              for (let c2 of subjectComponents) {
                let compo = {
                  "@guid": short.generate(),
                  "@type": c2.type.replace("madsrdf:", "http://www.loc.gov/mads/rdf/v1#"),
                  "http://www.loc.gov/mads/rdf/v1#authoritativeLabel": [{
                    "@guid": short.generate(),
                    "http://www.loc.gov/mads/rdf/v1#authoritativeLabel": c2.label
                  }]
                };
                if (c2.uri) {
                  compo["@id"] = c2.uri;
                }
                currentUserValuePos["http://www.loc.gov/mads/rdf/v1#componentList"].push(compo);
              }
            }
            this.activeProfileSaved = false;
            console.log("USERVALUE IS", userValue);
            pt2.userValue = userValue;
          }
        },
        /**
        * returns the structure of the component, used in the debug modal
        * 
        * @param {string} componentGuid - the guid of the component (the parent of all fields)
        * @return {array} - an array of objs representing the simple lookup values
        */
        returnStructureByComponentGuid: function(componentGuid) {
          let pt2 = utilsProfile.returnPt(this.activeProfile, componentGuid);
          return pt2;
        },
        /**
            * return the XML of the active editing record
            * 
        
            * @return {string} - the XML string of output
            */
        buildExportXML: function() {
          return utilsExport.buildXML(this.activeProfile);
        },
        /**
            * Save the record to the Marva scratch-pad backend
            * 
        
            * @return {boolean} - did it save
            */
        saveRecord: async function() {
          let xml = await utilsExport.buildXML(this.activeProfile);
          utilsNetwork.saveRecord(xml.xlmStringBasic, this.activeProfile.eId);
          this.activeProfileSaved = true;
        },
        /**
            * Ask for a record and parse it to load it into the editor
            * 
        
            * @return {boolean} - did it save
            */
        loadRecord: async function(eid, profile) {
          let xml = await utilsExport.buildXML(this.activeProfile);
          console.log("*****");
          console.log(xml);
          utilsNetwork.saveRecord(xml.xlmStringBasic, this.activeProfile.eId);
          this.activeProfileSaved = true;
        },
        /**
            * Publish record to backend
            * 
        
            * @return {obj} - response from posting action
            */
        publishRecord: async function(eid, profile) {
          let xml = await utilsExport.buildXML(this.activeProfile);
          let pubResuts = utilsNetwork.publish(xml.xlmStringBasic, this.activeProfile.eId, this.activeProfile);
          pubResuts.resourceLinks = [];
          if (pubResuts.status) {
            this.activeProfile.status = "published";
            await this.saveRecord();
            const config2 = useConfigStore();
            for (let rt2 in this.activeProfile.rt) {
              let type = rt2.split(":").slice(-1)[0];
              let url = config2.convertToRegionUrl(this.activeProfile.rt[rt2].URI);
              let env = config2.returnUrls().env;
              pubResuts.resourceLinks.push({
                "type": type,
                "url": url,
                "env": env
              });
            }
          }
          return pubResuts;
        },
        /**
        * returns the label to use in bf code mode
        * 
        * @param {object} structure - the structure value from the profile
        * @return {string} - the label
        */
        returnBfCodeLabel: function(structure) {
          let code2 = utilsParse.namespaceUri(structure.propertyURI);
          if (structure.propertyURI == "http://www.loc.gov/mads/rdf/v1#Topic") {
            code2 = "bf:subject";
          }
          if (["rdfs:label", "owl:sameAs"].includes(code2)) {
            code2 = utilsParse.namespaceUri(this.rtLookup[structure.parentId].resourceURI);
          }
          let orgCode = code2;
          code2 = code2.replace("bflc:", "lc:");
          if (code2.charAt(3) === code2.charAt(3).toUpperCase()) {
            code2 = code2.substring(0, 3) + code2.charAt(3).toLowerCase() + code2.substring(3 + 1);
          }
          let justProperty = code2.split(":")[1];
          let numUpper = justProperty.length - justProperty.replace(/[A-Z]/g, "").length;
          if (numUpper == 2) {
            code2 = code2.split(":")[0] + ":" + justProperty.charAt(0) + justProperty.replace(/[a-z]/g, "");
          } else if (numUpper == 1) {
            code2 = code2.split(":")[0] + ":" + justProperty.charAt(0) + justProperty.charAt(1) + justProperty.replace(/[a-z]/g, "");
          } else if (numUpper == 0) {
            code2 = code2.split(":")[0] + ":" + justProperty.charAt(0) + justProperty.charAt(1) + justProperty.charAt(2);
          }
          if (code2 == "rdf:val") {
            let useLabel = structure.propertyLabel.split(" ")[0];
            if (useLabel.length <= 6) {
              code2 = useLabel.toLowerCase();
            } else {
              code2 = `${useLabel.charAt(0)}${useLabel.charAt(1)}${useLabel.charAt(2)}${useLabel.charAt(3)}${useLabel.charAt(4)}${useLabel.charAt(5)}`.toLowerCase();
            }
          }
          if (code2.includes(":")) {
            code2 = code2.split(":")[1];
          }
          console.log("****!", orgCode, ",", orgCode.includes("bf:") ? `https://id.loc.gov/ontologies/bibframe.html#p_${orgCode.split(":")[1]}` : "bflc or other", ",", code2);
          return code2;
        },
        /**
        * returns if the request property is the "main" property of that component
        * 
        * @param {string} componentGuid - the guid of the component
        * @param {array} propertyPath - the property path of the property in question
        * @return {boolean} - 
        */
        inlineIsMainProperty: function(componentGuid, fieldStructure, propertyPath) {
          let pt2 = utilsProfile.returnPt(this.activeProfile, componentGuid);
          if (fieldStructure.propertyURI === "http://id.loc.gov/ontologies/bflc/nonSortNum") {
            return false;
          }
          if (fieldStructure.propertyURI === "http://id.loc.gov/ontologies/bibframe/mainTitle") {
            return true;
          }
          if (pt2.valueConstraint.valueTemplateRefs.length == 0) {
            return true;
          }
          for (let ref2 of pt2.valueConstraint.valueTemplateRefs) {
            if (this.rtLookup[ref2].propertyTemplates[0].propertyLabel === fieldStructure.propertyLabel) {
              return true;
            }
          }
          return false;
        },
        /**
        * returns if the request property has a value in it
        * 
        * @param {string} componentGuid - the guid of the component
        * @param {array} propertyPath - the property path of the property in question
        * @return {boolean} - 
        */
        inlinePropertyHasValue: function(componentGuid, fieldStructure, propertyPath) {
          let pt2 = utilsProfile.returnPt(this.activeProfile, componentGuid);
          let valueLocation = utilsProfile.returnValueFromPropertyPath(pt2, propertyPath);
          if (valueLocation !== false) {
            return true;
          }
          return false;
        },
        /**
        * returns possible fields in that can be displayed in the component
        * 
        * @return {array} - array of the fields
        */
        returnPossibleFieldsInComponent: function(componentGuid) {
          console.log("returnPossibleFieldsInComponent");
          let pt2 = utilsProfile.returnPt(this.activeProfile, componentGuid);
          if (pt2.valueConstraint.valueTemplateRefs.length == 0) {
            console.log("n o valueTemplateRefs");
            return [];
          }
          let use = [];
          if (pt2.valueConstraint.valueTemplateRefs.length === 1) {
            use = this.rtLookup[pt2.valueConstraint.valueTemplateRefs[0]].propertyTemplates;
          } else {
            if (pt2.activeType) {
              console.log("HAS activeType", pt2.activeType);
              console.log("out of", pt2.valueConstraint.valueTemplateRefs);
              for (let ref2 of pt2.valueConstraint.valueTemplateRefs) {
                console.log(this.rtLookup[ref2]);
                if (this.rtLookup[ref2].resourceURI === pt2.activeType) {
                  console.log("using this one:", this.rtLookup[ref2]);
                  use = this.rtLookup[ref2].propertyTemplates;
                  break;
                }
              }
            } else {
              use = this.rtLookup[pt2.valueConstraint.valueTemplateRefs[0]].propertyTemplates;
            }
          }
          let useReturn = [];
          for (let p2 of use) {
            useReturn.push({ "code": this.returnBfCodeLabel(p2), "label": p2.propertyLabel });
          }
          return useReturn;
        },
        /**
        * 
        * 
        * @return {array} - array of the fields
        */
        setInlineDisplay: function(componentGuid, label2) {
          console.log("YEAH");
          let pt2 = utilsProfile.returnPt(this.activeProfile, componentGuid);
          if (!pt2.inlineModeDisplay) {
            pt2.inlineModeDisplay = {};
          }
          pt2.inlineModeDisplay[label2] = true;
          console.log(pt2);
        },
        /**
        * 
        * 
        * @return {array} - array of the fields
        */
        inlineFieldIsToggledForDisplay: function(componentGuid, structure) {
          let pt2 = utilsProfile.returnPt(this.activeProfile, componentGuid);
          if (!pt2.inlineModeDisplay) {
            return false;
          }
          if (pt2.inlineModeDisplay[structure.propertyLabel]) {
            return true;
          }
        },
        /**
        * 
        * 
        * @return {boolean} - true or false if the pt passed will have a ref component drop down selection
        */
        ptHasRefComponent: function(pt2) {
          if (pt2.valueConstraint && pt2.valueConstraint.valueTemplateRefs && pt2.valueConstraint.valueTemplateRefs.length > 1) {
            return true;
          } else {
            if (pt2.valueConstraint && pt2.valueConstraint.valueTemplateRefs && pt2.valueConstraint.valueTemplateRefs.length == 1) {
              let subPt = this.rtLookup[pt2.valueConstraint.valueTemplateRefs[0]].propertyTemplates[0];
              if (subPt.valueConstraint && subPt.valueConstraint.valueTemplateRefs && subPt.valueConstraint.valueTemplateRefs.length > 1) {
                return true;
              }
            }
          }
          return false;
        },
        /**
        * Flips the canBeHidden flag on a property and reordereds it to the the end of the property list
        * In adhoc mode this makes it look like its being added to the profile
        * @return {void} - 
        */
        setPropertyVisible: function(profile, component) {
          console.log(profile, component);
          this.activeProfile.rt[profile].pt[component].canBeHidden = false;
          console.log(this.activeProfile);
          this.activeProfile.rt[profile].ptOrder.push(this.activeProfile.rt[profile].ptOrder.splice(this.activeProfile.rt[profile].ptOrder.indexOf(component), 1)[0]);
        },
        /**
        * Loads the record from marva backend by E id
        * 
        * @return {void} - 
        */
        loadRecordFromBackend: async function(eid) {
          console.log("Loading", eid);
          this.activeProfile = await utilsProfile.loadRecordFromBackend(eid);
        },
        /**
        * Duplicate / create new component
        * 
        * @param {string} componentGuid - the guid of the component (the parent of all fields)
        * @param {boolean} createEmpty - if true make the component have no pre-populated data, if false "duplicate" the data from the source component
        * @return {void}
        */
        duplicateComponent: async function(componentGuid, createEmpty) {
          console.log(componentGuid);
          createEmpty = true;
          let pt2 = utilsProfile.returnPt(this.activeProfile, componentGuid);
          if (pt2 !== false) {
            console.log(this.activeProfile);
            let profile;
            let propertyPosition;
            for (let r2 of this.activeProfile.rtOrder) {
              propertyPosition = this.activeProfile.rt[r2].ptOrder.indexOf(pt2.id);
              if (propertyPosition != -1) {
                profile = r2;
                break;
              }
            }
            let key2 = pt2.propertyURI.replace("http://", "").replace("https://", "").replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, "_") + "__" + (pt2.propertyLabel ? pt2.propertyLabel.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, "").replace(/\s+/g, "_").toLowerCase() : "plabel");
            let newPropertyId = key2 + "_" + +/* @__PURE__ */ new Date();
            let newPt = JSON.parse(JSON.stringify(pt2));
            newPt.id = newPropertyId;
            newPt["@guid"] = short.generate();
            console.log("Lookign at this PT", pt2);
            console.log(this.activeProfile);
            console.log(propertyPosition);
            console.log(key2, newPropertyId);
            if (createEmpty) {
              newPt.userValue = {
                "@guid": short.generate(),
                "@root": newPt.propertyURIhihi
              };
              let idPropertyId = newPt.propertyURI;
              let baseURI = newPt.propertyURI;
              let defaultsProperty;
              let useProfile = profile;
              if (!this.rtLookup[useProfile]) {
                if (useProfile.includes("-")) {
                  useProfile = useProfile.split("-")[0];
                }
              }
              if (this.rtLookup[useProfile]) {
                defaultsProperty = this.rtLookup[useProfile].propertyTemplates.filter((x2) => {
                  return x2.propertyURI === idPropertyId ? true : false;
                });
                if (defaultsProperty.length > 0) {
                  defaultsProperty = defaultsProperty[0];
                }
              }
              if (defaultsProperty && defaultsProperty.valueConstraint.defaults.length > 0) {
                if (!newPt.userValue[baseURI]) {
                  newPt.userValue[baseURI] = [{}];
                }
                let userValue = newPt.userValue[baseURI][0];
                if (defaultsProperty.valueConstraint.defaults[0].defaultLiteral) {
                  userValue["http://www.w3.org/2000/01/rdf-schema#label"] = [{
                    "@guid": short.generate(),
                    "http://www.w3.org/2000/01/rdf-schema#label": defaultsProperty.valueConstraint.defaults[0].defaultLiteral
                  }];
                }
                if (defaultsProperty.valueConstraint.defaults[0].defaultURI) {
                  userValue["@id"] = defaultsProperty.valueConstraint.defaults[0].defaultURI;
                }
              } else if (defaultsProperty && defaultsProperty.valueConstraint.valueTemplateRefs.length > 0) {
                if (!newPt.userValue[baseURI]) {
                  newPt.userValue[baseURI] = [{}];
                }
                let userValue = newPt.userValue[baseURI][0];
                let useRef = defaultsProperty.valueConstraint.valueTemplateRefs[0];
                for (let refPt of this.rtLookup[useRef].propertyTemplates) {
                  if (refPt.valueConstraint.defaults.length > 0) {
                    let defaults2 = refPt.valueConstraint.defaults[0];
                    if (defaults2.defaultLiteral) {
                      userValue[refPt.propertyURI] = [{
                        "@guid": short.generate(),
                        "http://www.w3.org/2000/01/rdf-schema#label": [
                          {
                            "http://www.w3.org/2000/01/rdf-schema#label": defaults2.defaultLiteral,
                            "@guid": short.generate()
                          }
                        ]
                      }];
                    }
                    if (defaults2.defaultURI) {
                      if (userValue[refPt.propertyURI][0]) {
                        userValue[refPt.propertyURI][0]["@id"] = defaults2.defaultURI;
                        if (refPt.valueConstraint.valueDataType && refPt.valueConstraint.valueDataType.dataTypeURI) {
                          userValue[refPt.propertyURI][0]["@type"] = refPt.valueConstraint.valueDataType.dataTypeURI;
                        }
                      }
                    }
                  }
                }
              }
              if (newPt.userValue[baseURI]) {
                if (newPt.userValue[baseURI][0]) {
                  if (Object.keys(newPt.userValue[baseURI][0]).length === 0) {
                    delete newPt.userValue[baseURI];
                  }
                }
              }
            }
            console.log(JSON.stringify(newPt, null, 2));
            this.activeProfile.rt[profile].pt[newPropertyId] = JSON.parse(JSON.stringify(newPt));
            this.activeProfile.rt[profile].ptOrder.splice(propertyPosition + 1, 0, newPropertyId);
            console.log(this.activeProfile.rt[profile].ptOrder);
            this.activeProfileSaved = false;
          } else {
            console.error("duplicateComponent: Cannot locate the component by guid", componentGuid, this.activeProfile);
            console.log(JSON.stringify(this.activeProfile));
          }
        }
      }
    });
    const _export_sfc = (sfc, props) => {
      const target = sfc.__vccOpts || sfc;
      for (const [key2, val] of props) {
        target[key2] = val;
      }
      return target;
    };
    const _sfc_main$y = {
      data() {
        return {};
      },
      computed: {
        // other computed properties
        // ...
        // gives access to this.counterStore and this.userStore
        ...mapStores(useProfileStore),
        // // gives read access to this.count and this.double
        ...mapState(useProfileStore, ["profilesLoaded"])
      },
      // watch: {
      //   // whenever question changes, this function will run
      //   question(newVal, oldVal) {
      //     if(newVal===true){
      //     }
      //   }
      // },
      methods: {},
      mounted() {
        console.log(this.$t("--c-edit-main-splitpane-properties-background-color--desc"), "<-------");
      }
    };
    const _hoisted_1$H = {
      key: 0,
      class: "modal"
    };
    const _hoisted_2$y = { class: "modal-text" };
    function _sfc_render$w(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createBlock(Teleport, { to: "body" }, [
        createVNode(Transition, { appear: "" }, {
          default: withCtx(() => [
            _ctx.profilesLoaded == false ? (openBlock(), createElementBlock("div", _hoisted_1$H, [
              createBaseVNode("div", _hoisted_2$y, [
                createBaseVNode("h1", null, toDisplayString$2(_ctx.$t("message.generalLoadingModalLoadingMsg")), 1)
              ])
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    }
    const LoadingModal = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["render", _sfc_render$w], ["__scopeId", "data-v-e5a76b93"]]);
    function tryOnScopeDispose(fn2) {
      if (getCurrentScope()) {
        onScopeDispose(fn2);
        return true;
      }
      return false;
    }
    function toValue(r2) {
      return typeof r2 === "function" ? r2() : unref(r2);
    }
    const isClient = typeof window !== "undefined" && typeof document !== "undefined";
    typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
    const toString = Object.prototype.toString;
    const isObject$3 = (val) => toString.call(val) === "[object Object]";
    const noop = () => {
    };
    const isIOS = /* @__PURE__ */ getIsIOS();
    function getIsIOS() {
      var _a, _b;
      return isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && (/iP(ad|hone|od)/.test(window.navigator.userAgent) || ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
    }
    function createFilterWrapper(filter2, fn2) {
      function wrapper(...args) {
        return new Promise((resolve2, reject) => {
          Promise.resolve(filter2(() => fn2.apply(this, args), { fn: fn2, thisArg: this, args })).then(resolve2).catch(reject);
        });
      }
      return wrapper;
    }
    const bypassFilter = (invoke2) => {
      return invoke2();
    };
    function debounceFilter(ms, options = {}) {
      let timer;
      let maxTimer;
      let lastRejector = noop;
      const _clearTimeout = (timer2) => {
        clearTimeout(timer2);
        lastRejector();
        lastRejector = noop;
      };
      const filter2 = (invoke2) => {
        const duration = toValue(ms);
        const maxDuration = toValue(options.maxWait);
        if (timer)
          _clearTimeout(timer);
        if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
          if (maxTimer) {
            _clearTimeout(maxTimer);
            maxTimer = null;
          }
          return Promise.resolve(invoke2());
        }
        return new Promise((resolve2, reject) => {
          lastRejector = options.rejectOnCancel ? reject : resolve2;
          if (maxDuration && !maxTimer) {
            maxTimer = setTimeout(() => {
              if (timer)
                _clearTimeout(timer);
              maxTimer = null;
              resolve2(invoke2());
            }, maxDuration);
          }
          timer = setTimeout(() => {
            if (maxTimer)
              _clearTimeout(maxTimer);
            maxTimer = null;
            resolve2(invoke2());
          }, duration);
        });
      };
      return filter2;
    }
    function pausableFilter(extendFilter = bypassFilter) {
      const isActive = ref(true);
      function pause() {
        isActive.value = false;
      }
      function resume() {
        isActive.value = true;
      }
      const eventFilter = (...args) => {
        if (isActive.value)
          extendFilter(...args);
      };
      return { isActive: readonly(isActive), pause, resume, eventFilter };
    }
    function createSingletonPromise(fn2) {
      let _promise;
      function wrapper() {
        if (!_promise)
          _promise = fn2();
        return _promise;
      }
      wrapper.reset = async () => {
        const _prev = _promise;
        _promise = void 0;
        if (_prev)
          await _prev;
      };
      return wrapper;
    }
    function getLifeCycleTarget(target) {
      return getCurrentInstance();
    }
    function useDebounceFn(fn2, ms = 200, options = {}) {
      return createFilterWrapper(
        debounceFilter(ms, options),
        fn2
      );
    }
    function watchWithFilter(source, cb, options = {}) {
      const {
        eventFilter = bypassFilter,
        ...watchOptions
      } = options;
      return watch$1(
        source,
        createFilterWrapper(
          eventFilter,
          cb
        ),
        watchOptions
      );
    }
    function watchPausable(source, cb, options = {}) {
      const {
        eventFilter: filter2,
        ...watchOptions
      } = options;
      const { eventFilter, pause, resume, isActive } = pausableFilter(filter2);
      const stop2 = watchWithFilter(
        source,
        cb,
        {
          ...watchOptions,
          eventFilter
        }
      );
      return { stop: stop2, pause, resume, isActive };
    }
    function tryOnMounted(fn2, sync = true, target) {
      const instance = getLifeCycleTarget();
      if (instance)
        onMounted(fn2, target);
      else if (sync)
        fn2();
      else
        nextTick(fn2);
    }
    function useTimeoutFn(cb, interval, options = {}) {
      const {
        immediate = true
      } = options;
      const isPending = ref(false);
      let timer = null;
      function clear2() {
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
      }
      function stop2() {
        isPending.value = false;
        clear2();
      }
      function start2(...args) {
        clear2();
        isPending.value = true;
        timer = setTimeout(() => {
          isPending.value = false;
          timer = null;
          cb(...args);
        }, toValue(interval));
      }
      if (immediate) {
        isPending.value = true;
        if (isClient)
          start2();
      }
      tryOnScopeDispose(stop2);
      return {
        isPending: readonly(isPending),
        start: start2,
        stop: stop2
      };
    }
    function whenever(source, cb, options) {
      const stop2 = watch$1(
        source,
        (v2, ov, onInvalidate) => {
          if (v2) {
            if (options == null ? void 0 : options.once)
              nextTick(() => stop2());
            cb(v2, ov, onInvalidate);
          }
        },
        {
          ...options,
          once: false
        }
      );
      return stop2;
    }
    function unrefElement(elRef) {
      var _a;
      const plain = toValue(elRef);
      return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
    }
    const defaultWindow = isClient ? window : void 0;
    const defaultNavigator = isClient ? window.navigator : void 0;
    function useEventListener(...args) {
      let target;
      let events2;
      let listeners;
      let options;
      if (typeof args[0] === "string" || Array.isArray(args[0])) {
        [events2, listeners, options] = args;
        target = defaultWindow;
      } else {
        [target, events2, listeners, options] = args;
      }
      if (!target)
        return noop;
      if (!Array.isArray(events2))
        events2 = [events2];
      if (!Array.isArray(listeners))
        listeners = [listeners];
      const cleanups = [];
      const cleanup = () => {
        cleanups.forEach((fn2) => fn2());
        cleanups.length = 0;
      };
      const register = (el, event2, listener, options2) => {
        el.addEventListener(event2, listener, options2);
        return () => el.removeEventListener(event2, listener, options2);
      };
      const stopWatch = watch$1(
        () => [unrefElement(target), toValue(options)],
        ([el, options2]) => {
          cleanup();
          if (!el)
            return;
          const optionsClone = isObject$3(options2) ? { ...options2 } : options2;
          cleanups.push(
            ...events2.flatMap((event2) => {
              return listeners.map((listener) => register(el, event2, listener, optionsClone));
            })
          );
        },
        { immediate: true, flush: "post" }
      );
      const stop2 = () => {
        stopWatch();
        cleanup();
      };
      tryOnScopeDispose(stop2);
      return stop2;
    }
    let _iOSWorkaround = false;
    function onClickOutside(target, handler, options = {}) {
      const { window: window2 = defaultWindow, ignore = [], capture = true, detectIframe = false } = options;
      if (!window2)
        return noop;
      if (isIOS && !_iOSWorkaround) {
        _iOSWorkaround = true;
        Array.from(window2.document.body.children).forEach((el) => el.addEventListener("click", noop));
        window2.document.documentElement.addEventListener("click", noop);
      }
      let shouldListen = true;
      const shouldIgnore = (event2) => {
        return ignore.some((target2) => {
          if (typeof target2 === "string") {
            return Array.from(window2.document.querySelectorAll(target2)).some((el) => el === event2.target || event2.composedPath().includes(el));
          } else {
            const el = unrefElement(target2);
            return el && (event2.target === el || event2.composedPath().includes(el));
          }
        });
      };
      const listener = (event2) => {
        const el = unrefElement(target);
        if (!el || el === event2.target || event2.composedPath().includes(el))
          return;
        if (event2.detail === 0)
          shouldListen = !shouldIgnore(event2);
        if (!shouldListen) {
          shouldListen = true;
          return;
        }
        handler(event2);
      };
      const cleanup = [
        useEventListener(window2, "click", listener, { passive: true, capture }),
        useEventListener(window2, "pointerdown", (e2) => {
          const el = unrefElement(target);
          shouldListen = !shouldIgnore(e2) && !!(el && !e2.composedPath().includes(el));
        }, { passive: true }),
        detectIframe && useEventListener(window2, "blur", (event2) => {
          setTimeout(() => {
            var _a;
            const el = unrefElement(target);
            if (((_a = window2.document.activeElement) == null ? void 0 : _a.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(window2.document.activeElement)))
              handler(event2);
          }, 0);
        })
      ].filter(Boolean);
      const stop2 = () => cleanup.forEach((fn2) => fn2());
      return stop2;
    }
    function useMounted() {
      const isMounted = ref(false);
      const instance = getCurrentInstance();
      if (instance) {
        onMounted(() => {
          isMounted.value = true;
        }, instance);
      }
      return isMounted;
    }
    function useSupported(callback) {
      const isMounted = useMounted();
      return computed(() => {
        isMounted.value;
        return Boolean(callback());
      });
    }
    function usePermission(permissionDesc, options = {}) {
      const {
        controls = false,
        navigator: navigator2 = defaultNavigator
      } = options;
      const isSupported = useSupported(() => navigator2 && "permissions" in navigator2);
      let permissionStatus;
      const desc = typeof permissionDesc === "string" ? { name: permissionDesc } : permissionDesc;
      const state = ref();
      const onChange = () => {
        if (permissionStatus)
          state.value = permissionStatus.state;
      };
      const query = createSingletonPromise(async () => {
        if (!isSupported.value)
          return;
        if (!permissionStatus) {
          try {
            permissionStatus = await navigator2.permissions.query(desc);
            useEventListener(permissionStatus, "change", onChange);
            onChange();
          } catch (e2) {
            state.value = "prompt";
          }
        }
        return permissionStatus;
      });
      query();
      if (controls) {
        return {
          state,
          isSupported,
          query
        };
      } else {
        return state;
      }
    }
    function useClipboard(options = {}) {
      const {
        navigator: navigator2 = defaultNavigator,
        read: read2 = false,
        source,
        copiedDuring = 1500,
        legacy = false
      } = options;
      const isClipboardApiSupported = useSupported(() => navigator2 && "clipboard" in navigator2);
      const permissionRead = usePermission("clipboard-read");
      const permissionWrite = usePermission("clipboard-write");
      const isSupported = computed(() => isClipboardApiSupported.value || legacy);
      const text = ref("");
      const copied = ref(false);
      const timeout = useTimeoutFn(() => copied.value = false, copiedDuring);
      function updateText() {
        if (isClipboardApiSupported.value && isAllowed(permissionRead.value)) {
          navigator2.clipboard.readText().then((value) => {
            text.value = value;
          });
        } else {
          text.value = legacyRead();
        }
      }
      if (isSupported.value && read2)
        useEventListener(["copy", "cut"], updateText);
      async function copy(value = toValue(source)) {
        if (isSupported.value && value != null) {
          if (isClipboardApiSupported.value && isAllowed(permissionWrite.value))
            await navigator2.clipboard.writeText(value);
          else
            legacyCopy(value);
          text.value = value;
          copied.value = true;
          timeout.start();
        }
      }
      function legacyCopy(value) {
        const ta = document.createElement("textarea");
        ta.value = value != null ? value : "";
        ta.style.position = "absolute";
        ta.style.opacity = "0";
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        ta.remove();
      }
      function legacyRead() {
        var _a, _b, _c;
        return (_c = (_b = (_a = document == null ? void 0 : document.getSelection) == null ? void 0 : _a.call(document)) == null ? void 0 : _b.toString()) != null ? _c : "";
      }
      function isAllowed(status) {
        return status === "granted" || status === "prompt";
      }
      return {
        isSupported,
        text,
        copied,
        copy
      };
    }
    const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    const globalKey = "__vueuse_ssr_handlers__";
    const handlers = /* @__PURE__ */ getHandlers();
    function getHandlers() {
      if (!(globalKey in _global))
        _global[globalKey] = _global[globalKey] || {};
      return _global[globalKey];
    }
    function getSSRHandler(key2, fallback) {
      return handlers[key2] || fallback;
    }
    function guessSerializerType(rawInit) {
      return rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : rawInit instanceof Date ? "date" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
    }
    const StorageSerializers = {
      boolean: {
        read: (v2) => v2 === "true",
        write: (v2) => String(v2)
      },
      object: {
        read: (v2) => JSON.parse(v2),
        write: (v2) => JSON.stringify(v2)
      },
      number: {
        read: (v2) => Number.parseFloat(v2),
        write: (v2) => String(v2)
      },
      any: {
        read: (v2) => v2,
        write: (v2) => String(v2)
      },
      string: {
        read: (v2) => v2,
        write: (v2) => String(v2)
      },
      map: {
        read: (v2) => new Map(JSON.parse(v2)),
        write: (v2) => JSON.stringify(Array.from(v2.entries()))
      },
      set: {
        read: (v2) => new Set(JSON.parse(v2)),
        write: (v2) => JSON.stringify(Array.from(v2))
      },
      date: {
        read: (v2) => new Date(v2),
        write: (v2) => v2.toISOString()
      }
    };
    const customStorageEventName = "vueuse-storage";
    function useStorage(key2, defaults2, storage, options = {}) {
      var _a;
      const {
        flush = "pre",
        deep = true,
        listenToStorageChanges = true,
        writeDefaults = true,
        mergeDefaults: mergeDefaults2 = false,
        shallow,
        window: window2 = defaultWindow,
        eventFilter,
        onError = (e2) => {
          console.error(e2);
        },
        initOnMounted
      } = options;
      const data = (shallow ? shallowRef : ref)(typeof defaults2 === "function" ? defaults2() : defaults2);
      if (!storage) {
        try {
          storage = getSSRHandler("getDefaultStorage", () => {
            var _a2;
            return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;
          })();
        } catch (e2) {
          onError(e2);
        }
      }
      if (!storage)
        return data;
      const rawInit = toValue(defaults2);
      const type = guessSerializerType(rawInit);
      const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];
      const { pause: pauseWatch, resume: resumeWatch } = watchPausable(
        data,
        () => write2(data.value),
        { flush, deep, eventFilter }
      );
      if (window2 && listenToStorageChanges) {
        tryOnMounted(() => {
          useEventListener(window2, "storage", update);
          useEventListener(window2, customStorageEventName, updateFromCustomEvent);
          if (initOnMounted)
            update();
        });
      }
      if (!initOnMounted)
        update();
      function dispatchWriteEvent(oldValue, newValue) {
        if (window2) {
          window2.dispatchEvent(new CustomEvent(customStorageEventName, {
            detail: {
              key: key2,
              oldValue,
              newValue,
              storageArea: storage
            }
          }));
        }
      }
      function write2(v2) {
        try {
          const oldValue = storage.getItem(key2);
          if (v2 == null) {
            dispatchWriteEvent(oldValue, null);
            storage.removeItem(key2);
          } else {
            const serialized = serializer.write(v2);
            if (oldValue !== serialized) {
              storage.setItem(key2, serialized);
              dispatchWriteEvent(oldValue, serialized);
            }
          }
        } catch (e2) {
          onError(e2);
        }
      }
      function read2(event2) {
        const rawValue = event2 ? event2.newValue : storage.getItem(key2);
        if (rawValue == null) {
          if (writeDefaults && rawInit != null)
            storage.setItem(key2, serializer.write(rawInit));
          return rawInit;
        } else if (!event2 && mergeDefaults2) {
          const value = serializer.read(rawValue);
          if (typeof mergeDefaults2 === "function")
            return mergeDefaults2(value, rawInit);
          else if (type === "object" && !Array.isArray(value))
            return { ...rawInit, ...value };
          return value;
        } else if (typeof rawValue !== "string") {
          return rawValue;
        } else {
          return serializer.read(rawValue);
        }
      }
      function update(event2) {
        if (event2 && event2.storageArea !== storage)
          return;
        if (event2 && event2.key == null) {
          data.value = rawInit;
          return;
        }
        if (event2 && event2.key !== key2)
          return;
        pauseWatch();
        try {
          if ((event2 == null ? void 0 : event2.newValue) !== serializer.write(data.value))
            data.value = read2(event2);
        } catch (e2) {
          onError(e2);
        } finally {
          if (event2)
            nextTick(resumeWatch);
          else
            resumeWatch();
        }
      }
      function updateFromCustomEvent(event2) {
        update(event2.detail);
      }
      return data;
    }
    function useLocalStorage(key2, initialValue, options = {}) {
      const { window: window2 = defaultWindow } = options;
      return useStorage(key2, initialValue, window2 == null ? void 0 : window2.localStorage, options);
    }
    /*!
    * tabbable 6.2.0
    * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
    */
    var candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
    var candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
    var NoElement = typeof Element === "undefined";
    var matches$1 = NoElement ? function() {
    } : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
      var _element$getRootNode;
      return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
    } : function(element) {
      return element === null || element === void 0 ? void 0 : element.ownerDocument;
    };
    var isInert = function isInert2(node, lookUp) {
      var _node$getAttribute;
      if (lookUp === void 0) {
        lookUp = true;
      }
      var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, "inert");
      var inert = inertAtt === "" || inertAtt === "true";
      var result = inert || lookUp && node && isInert2(node.parentNode);
      return result;
    };
    var isContentEditable = function isContentEditable2(node) {
      var _node$getAttribute2;
      var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, "contenteditable");
      return attValue === "" || attValue === "true";
    };
    var getCandidates = function getCandidates2(el, includeContainer, filter2) {
      if (isInert(el)) {
        return [];
      }
      var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
      if (includeContainer && matches$1.call(el, candidateSelector)) {
        candidates.unshift(el);
      }
      candidates = candidates.filter(filter2);
      return candidates;
    };
    var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
      var candidates = [];
      var elementsToCheck = Array.from(elements);
      while (elementsToCheck.length) {
        var element = elementsToCheck.shift();
        if (isInert(element, false)) {
          continue;
        }
        if (element.tagName === "SLOT") {
          var assigned = element.assignedElements();
          var content = assigned.length ? assigned : element.children;
          var nestedCandidates = getCandidatesIteratively2(content, true, options);
          if (options.flatten) {
            candidates.push.apply(candidates, nestedCandidates);
          } else {
            candidates.push({
              scopeParent: element,
              candidates: nestedCandidates
            });
          }
        } else {
          var validCandidate = matches$1.call(element, candidateSelector);
          if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
            candidates.push(element);
          }
          var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
          typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
          var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));
          if (shadowRoot && validShadowRoot) {
            var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
            if (options.flatten) {
              candidates.push.apply(candidates, _nestedCandidates);
            } else {
              candidates.push({
                scopeParent: element,
                candidates: _nestedCandidates
              });
            }
          } else {
            elementsToCheck.unshift.apply(elementsToCheck, element.children);
          }
        }
      }
      return candidates;
    };
    var hasTabIndex = function hasTabIndex2(node) {
      return !isNaN(parseInt(node.getAttribute("tabindex"), 10));
    };
    var getTabIndex = function getTabIndex2(node) {
      if (!node) {
        throw new Error("No node provided");
      }
      if (node.tabIndex < 0) {
        if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {
          return 0;
        }
      }
      return node.tabIndex;
    };
    var getSortOrderTabIndex = function getSortOrderTabIndex2(node, isScope) {
      var tabIndex = getTabIndex(node);
      if (tabIndex < 0 && isScope && !hasTabIndex(node)) {
        return 0;
      }
      return tabIndex;
    };
    var sortOrderedTabbables = function sortOrderedTabbables2(a2, b2) {
      return a2.tabIndex === b2.tabIndex ? a2.documentOrder - b2.documentOrder : a2.tabIndex - b2.tabIndex;
    };
    var isInput = function isInput2(node) {
      return node.tagName === "INPUT";
    };
    var isHiddenInput = function isHiddenInput2(node) {
      return isInput(node) && node.type === "hidden";
    };
    var isDetailsWithSummary = function isDetailsWithSummary2(node) {
      var r2 = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child2) {
        return child2.tagName === "SUMMARY";
      });
      return r2;
    };
    var getCheckedRadio = function getCheckedRadio2(nodes, form) {
      for (var i2 = 0; i2 < nodes.length; i2++) {
        if (nodes[i2].checked && nodes[i2].form === form) {
          return nodes[i2];
        }
      }
    };
    var isTabbableRadio = function isTabbableRadio2(node) {
      if (!node.name) {
        return true;
      }
      var radioScope = node.form || getRootNode(node);
      var queryRadios = function queryRadios2(name) {
        return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
      };
      var radioSet;
      if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
        radioSet = queryRadios(window.CSS.escape(node.name));
      } else {
        try {
          radioSet = queryRadios(node.name);
        } catch (err) {
          console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
          return false;
        }
      }
      var checked = getCheckedRadio(radioSet, node.form);
      return !checked || checked === node;
    };
    var isRadio = function isRadio2(node) {
      return isInput(node) && node.type === "radio";
    };
    var isNonTabbableRadio = function isNonTabbableRadio2(node) {
      return isRadio(node) && !isTabbableRadio(node);
    };
    var isNodeAttached = function isNodeAttached2(node) {
      var _nodeRoot;
      var nodeRoot = node && getRootNode(node);
      var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
      var attached = false;
      if (nodeRoot && nodeRoot !== node) {
        var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
        attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));
        while (!attached && nodeRootHost) {
          var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
          nodeRoot = getRootNode(nodeRootHost);
          nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
          attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
        }
      }
      return attached;
    };
    var isZeroArea = function isZeroArea2(node) {
      var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
      return width === 0 && height === 0;
    };
    var isHidden = function isHidden2(node, _ref) {
      var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
      if (getComputedStyle(node).visibility === "hidden") {
        return true;
      }
      var isDirectSummary = matches$1.call(node, "details>summary:first-of-type");
      var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
      if (matches$1.call(nodeUnderDetails, "details:not([open]) *")) {
        return true;
      }
      if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
        if (typeof getShadowRoot === "function") {
          var originalNode = node;
          while (node) {
            var parentElement = node.parentElement;
            var rootNode = getRootNode(node);
            if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
              return isZeroArea(node);
            } else if (node.assignedSlot) {
              node = node.assignedSlot;
            } else if (!parentElement && rootNode !== node.ownerDocument) {
              node = rootNode.host;
            } else {
              node = parentElement;
            }
          }
          node = originalNode;
        }
        if (isNodeAttached(node)) {
          return !node.getClientRects().length;
        }
        if (displayCheck !== "legacy-full") {
          return true;
        }
      } else if (displayCheck === "non-zero-area") {
        return isZeroArea(node);
      }
      return false;
    };
    var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
      if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
        var parentNode = node.parentElement;
        while (parentNode) {
          if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
            for (var i2 = 0; i2 < parentNode.children.length; i2++) {
              var child2 = parentNode.children.item(i2);
              if (child2.tagName === "LEGEND") {
                return matches$1.call(parentNode, "fieldset[disabled] *") ? true : !child2.contains(node);
              }
            }
            return true;
          }
          parentNode = parentNode.parentElement;
        }
      }
      return false;
    };
    var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
      if (node.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
      //  because we're limited in the type of selectors we can use in JSDom (see related
      //  note related to `candidateSelectors`)
      isInert(node) || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
      isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
        return false;
      }
      return true;
    };
    var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
      if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
        return false;
      }
      return true;
    };
    var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
      var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
      if (isNaN(tabIndex) || tabIndex >= 0) {
        return true;
      }
      return false;
    };
    var sortByOrder = function sortByOrder2(candidates) {
      var regularTabbables = [];
      var orderedTabbables = [];
      candidates.forEach(function(item, i2) {
        var isScope = !!item.scopeParent;
        var element = isScope ? item.scopeParent : item;
        var candidateTabindex = getSortOrderTabIndex(element, isScope);
        var elements = isScope ? sortByOrder2(item.candidates) : element;
        if (candidateTabindex === 0) {
          isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
        } else {
          orderedTabbables.push({
            documentOrder: i2,
            tabIndex: candidateTabindex,
            item,
            isScope,
            content: elements
          });
        }
      });
      return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
        sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
        return acc;
      }, []).concat(regularTabbables);
    };
    var tabbable = function tabbable2(container, options) {
      options = options || {};
      var candidates;
      if (options.getShadowRoot) {
        candidates = getCandidatesIteratively([container], options.includeContainer, {
          filter: isNodeMatchingSelectorTabbable.bind(null, options),
          flatten: false,
          getShadowRoot: options.getShadowRoot,
          shadowRootFilter: isValidShadowRootTabbable
        });
      } else {
        candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
      }
      return sortByOrder(candidates);
    };
    var focusable = function focusable2(container, options) {
      options = options || {};
      var candidates;
      if (options.getShadowRoot) {
        candidates = getCandidatesIteratively([container], options.includeContainer, {
          filter: isNodeMatchingSelectorFocusable.bind(null, options),
          flatten: true,
          getShadowRoot: options.getShadowRoot
        });
      } else {
        candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
      }
      return candidates;
    };
    var isTabbable = function isTabbable2(node, options) {
      options = options || {};
      if (!node) {
        throw new Error("No node provided");
      }
      if (matches$1.call(node, candidateSelector) === false) {
        return false;
      }
      return isNodeMatchingSelectorTabbable(options, node);
    };
    var focusableCandidateSelector = /* @__PURE__ */ candidateSelectors.concat("iframe").join(",");
    var isFocusable = function isFocusable2(node, options) {
      options = options || {};
      if (!node) {
        throw new Error("No node provided");
      }
      if (matches$1.call(node, focusableCandidateSelector) === false) {
        return false;
      }
      return isNodeMatchingSelectorFocusable(options, node);
    };
    /*!
    * focus-trap 7.5.4
    * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
    */
    function ownKeys$b(e2, r2) {
      var t2 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var o3 = Object.getOwnPropertySymbols(e2);
        r2 && (o3 = o3.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
        })), t2.push.apply(t2, o3);
      }
      return t2;
    }
    function _objectSpread2$1(e2) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys$b(Object(t2), true).forEach(function(r3) {
          _defineProperty$b(e2, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys$b(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e2;
    }
    function _defineProperty$b(obj, key2, value) {
      key2 = _toPropertyKey(key2);
      if (key2 in obj) {
        Object.defineProperty(obj, key2, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key2] = value;
      }
      return obj;
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function _toPropertyKey(arg) {
      var key2 = _toPrimitive(arg, "string");
      return typeof key2 === "symbol" ? key2 : String(key2);
    }
    var activeFocusTraps = {
      activateTrap: function activateTrap(trapStack, trap) {
        if (trapStack.length > 0) {
          var activeTrap = trapStack[trapStack.length - 1];
          if (activeTrap !== trap) {
            activeTrap.pause();
          }
        }
        var trapIndex = trapStack.indexOf(trap);
        if (trapIndex === -1) {
          trapStack.push(trap);
        } else {
          trapStack.splice(trapIndex, 1);
          trapStack.push(trap);
        }
      },
      deactivateTrap: function deactivateTrap(trapStack, trap) {
        var trapIndex = trapStack.indexOf(trap);
        if (trapIndex !== -1) {
          trapStack.splice(trapIndex, 1);
        }
        if (trapStack.length > 0) {
          trapStack[trapStack.length - 1].unpause();
        }
      }
    };
    var isSelectableInput = function isSelectableInput2(node) {
      return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
    };
    var isEscapeEvent = function isEscapeEvent2(e2) {
      return (e2 === null || e2 === void 0 ? void 0 : e2.key) === "Escape" || (e2 === null || e2 === void 0 ? void 0 : e2.key) === "Esc" || (e2 === null || e2 === void 0 ? void 0 : e2.keyCode) === 27;
    };
    var isTabEvent = function isTabEvent2(e2) {
      return (e2 === null || e2 === void 0 ? void 0 : e2.key) === "Tab" || (e2 === null || e2 === void 0 ? void 0 : e2.keyCode) === 9;
    };
    var isKeyForward = function isKeyForward2(e2) {
      return isTabEvent(e2) && !e2.shiftKey;
    };
    var isKeyBackward = function isKeyBackward2(e2) {
      return isTabEvent(e2) && e2.shiftKey;
    };
    var delay = function delay2(fn2) {
      return setTimeout(fn2, 0);
    };
    var findIndex = function findIndex2(arr, fn2) {
      var idx = -1;
      arr.every(function(value, i2) {
        if (fn2(value)) {
          idx = i2;
          return false;
        }
        return true;
      });
      return idx;
    };
    var valueOrHandler = function valueOrHandler2(value) {
      for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        params[_key - 1] = arguments[_key];
      }
      return typeof value === "function" ? value.apply(void 0, params) : value;
    };
    var getActualTarget = function getActualTarget2(event2) {
      return event2.target.shadowRoot && typeof event2.composedPath === "function" ? event2.composedPath()[0] : event2.target;
    };
    var internalTrapStack = [];
    var createFocusTrap = function createFocusTrap2(elements, userOptions) {
      var doc2 = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
      var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;
      var config2 = _objectSpread2$1({
        returnFocusOnDeactivate: true,
        escapeDeactivates: true,
        delayInitialFocus: true,
        isKeyForward,
        isKeyBackward
      }, userOptions);
      var state = {
        // containers given to createFocusTrap()
        // @type {Array<HTMLElement>}
        containers: [],
        // list of objects identifying tabbable nodes in `containers` in the trap
        // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
        //  is active, but the trap should never get to a state where there isn't at least one group
        //  with at least one tabbable node in it (that would lead to an error condition that would
        //  result in an error being thrown)
        // @type {Array<{
        //   container: HTMLElement,
        //   tabbableNodes: Array<HTMLElement>, // empty if none
        //   focusableNodes: Array<HTMLElement>, // empty if none
        //   posTabIndexesFound: boolean,
        //   firstTabbableNode: HTMLElement|undefined,
        //   lastTabbableNode: HTMLElement|undefined,
        //   firstDomTabbableNode: HTMLElement|undefined,
        //   lastDomTabbableNode: HTMLElement|undefined,
        //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
        // }>}
        containerGroups: [],
        // same order/length as `containers` list
        // references to objects in `containerGroups`, but only those that actually have
        //  tabbable nodes in them
        // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
        //  the same length
        tabbableGroups: [],
        nodeFocusedBeforeActivation: null,
        mostRecentlyFocusedNode: null,
        active: false,
        paused: false,
        // timer ID for when delayInitialFocus is true and initial focus in this trap
        //  has been delayed during activation
        delayInitialFocusTimer: void 0,
        // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any
        recentNavEvent: void 0
      };
      var trap;
      var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
        return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config2[configOptionName || optionName];
      };
      var findContainerIndex = function findContainerIndex2(element, event2) {
        var composedPath = typeof (event2 === null || event2 === void 0 ? void 0 : event2.composedPath) === "function" ? event2.composedPath() : void 0;
        return state.containerGroups.findIndex(function(_ref) {
          var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
          return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any
          //  web components if the `tabbableOptions.getShadowRoot` option was used for
          //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
          //  look inside web components even if open)
          (composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function(node) {
            return node === element;
          });
        });
      };
      var getNodeForOption = function getNodeForOption2(optionName) {
        var optionValue = config2[optionName];
        if (typeof optionValue === "function") {
          for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            params[_key2 - 1] = arguments[_key2];
          }
          optionValue = optionValue.apply(void 0, params);
        }
        if (optionValue === true) {
          optionValue = void 0;
        }
        if (!optionValue) {
          if (optionValue === void 0 || optionValue === false) {
            return optionValue;
          }
          throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
        }
        var node = optionValue;
        if (typeof optionValue === "string") {
          node = doc2.querySelector(optionValue);
          if (!node) {
            throw new Error("`".concat(optionName, "` as selector refers to no known node"));
          }
        }
        return node;
      };
      var getInitialFocusNode = function getInitialFocusNode2() {
        var node = getNodeForOption("initialFocus");
        if (node === false) {
          return false;
        }
        if (node === void 0 || !isFocusable(node, config2.tabbableOptions)) {
          if (findContainerIndex(doc2.activeElement) >= 0) {
            node = doc2.activeElement;
          } else {
            var firstTabbableGroup = state.tabbableGroups[0];
            var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
            node = firstTabbableNode || getNodeForOption("fallbackFocus");
          }
        }
        if (!node) {
          throw new Error("Your focus-trap needs to have at least one focusable element");
        }
        return node;
      };
      var updateTabbableNodes = function updateTabbableNodes2() {
        state.containerGroups = state.containers.map(function(container) {
          var tabbableNodes = tabbable(container, config2.tabbableOptions);
          var focusableNodes = focusable(container, config2.tabbableOptions);
          var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;
          var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;
          var firstDomTabbableNode = focusableNodes.find(function(node) {
            return isTabbable(node);
          });
          var lastDomTabbableNode = focusableNodes.slice().reverse().find(function(node) {
            return isTabbable(node);
          });
          var posTabIndexesFound = !!tabbableNodes.find(function(node) {
            return getTabIndex(node) > 0;
          });
          return {
            container,
            tabbableNodes,
            focusableNodes,
            /** True if at least one node with positive `tabindex` was found in this container. */
            posTabIndexesFound,
            /** First tabbable node in container, __tabindex__ order; `undefined` if none. */
            firstTabbableNode,
            /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */
            lastTabbableNode,
            // NOTE: DOM order is NOT NECESSARILY "document position" order, but figuring that out
            //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
            //  because that API doesn't work with Shadow DOM as well as it should (@see
            //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,
            //  to address an edge case related to positive tabindex support, this seems like a much easier,
            //  "close enough most of the time" alternative for positive tabindexes which should generally
            //  be avoided anyway...
            /** First tabbable node in container, __DOM__ order; `undefined` if none. */
            firstDomTabbableNode,
            /** Last tabbable node in container, __DOM__ order; `undefined` if none. */
            lastDomTabbableNode,
            /**
             * Finds the __tabbable__ node that follows the given node in the specified direction,
             *  in this container, if any.
             * @param {HTMLElement} node
             * @param {boolean} [forward] True if going in forward tab order; false if going
             *  in reverse.
             * @returns {HTMLElement|undefined} The next tabbable node, if any.
             */
            nextTabbableNode: function nextTabbableNode(node) {
              var forward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
              var nodeIdx = tabbableNodes.indexOf(node);
              if (nodeIdx < 0) {
                if (forward) {
                  return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(function(el) {
                    return isTabbable(el);
                  });
                }
                return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(function(el) {
                  return isTabbable(el);
                });
              }
              return tabbableNodes[nodeIdx + (forward ? 1 : -1)];
            }
          };
        });
        state.tabbableGroups = state.containerGroups.filter(function(group) {
          return group.tabbableNodes.length > 0;
        });
        if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
          throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
        }
        if (state.containerGroups.find(function(g2) {
          return g2.posTabIndexesFound;
        }) && state.containerGroups.length > 1) {
          throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.");
        }
      };
      var getActiveElement = function getActiveElement2(el) {
        var activeElement = el.activeElement;
        if (!activeElement) {
          return;
        }
        if (activeElement.shadowRoot && activeElement.shadowRoot.activeElement !== null) {
          return getActiveElement2(activeElement.shadowRoot);
        }
        return activeElement;
      };
      var tryFocus = function tryFocus2(node) {
        if (node === false) {
          return;
        }
        if (node === getActiveElement(document)) {
          return;
        }
        if (!node || !node.focus) {
          tryFocus2(getInitialFocusNode());
          return;
        }
        node.focus({
          preventScroll: !!config2.preventScroll
        });
        state.mostRecentlyFocusedNode = node;
        if (isSelectableInput(node)) {
          node.select();
        }
      };
      var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
        var node = getNodeForOption("setReturnFocus", previousActiveElement);
        return node ? node : node === false ? false : previousActiveElement;
      };
      var findNextNavNode = function findNextNavNode2(_ref2) {
        var target = _ref2.target, event2 = _ref2.event, _ref2$isBackward = _ref2.isBackward, isBackward = _ref2$isBackward === void 0 ? false : _ref2$isBackward;
        target = target || getActualTarget(event2);
        updateTabbableNodes();
        var destinationNode = null;
        if (state.tabbableGroups.length > 0) {
          var containerIndex = findContainerIndex(target, event2);
          var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : void 0;
          if (containerIndex < 0) {
            if (isBackward) {
              destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
            } else {
              destinationNode = state.tabbableGroups[0].firstTabbableNode;
            }
          } else if (isBackward) {
            var startOfGroupIndex = findIndex(state.tabbableGroups, function(_ref3) {
              var firstTabbableNode = _ref3.firstTabbableNode;
              return target === firstTabbableNode;
            });
            if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config2.tabbableOptions) && !isTabbable(target, config2.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
              startOfGroupIndex = containerIndex;
            }
            if (startOfGroupIndex >= 0) {
              var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
              var destinationGroup = state.tabbableGroups[destinationGroupIndex];
              destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
            } else if (!isTabEvent(event2)) {
              destinationNode = containerGroup.nextTabbableNode(target, false);
            }
          } else {
            var lastOfGroupIndex = findIndex(state.tabbableGroups, function(_ref4) {
              var lastTabbableNode = _ref4.lastTabbableNode;
              return target === lastTabbableNode;
            });
            if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config2.tabbableOptions) && !isTabbable(target, config2.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
              lastOfGroupIndex = containerIndex;
            }
            if (lastOfGroupIndex >= 0) {
              var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
              var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
              destinationNode = getTabIndex(target) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;
            } else if (!isTabEvent(event2)) {
              destinationNode = containerGroup.nextTabbableNode(target);
            }
          }
        } else {
          destinationNode = getNodeForOption("fallbackFocus");
        }
        return destinationNode;
      };
      var checkPointerDown = function checkPointerDown2(e2) {
        var target = getActualTarget(e2);
        if (findContainerIndex(target, e2) >= 0) {
          return;
        }
        if (valueOrHandler(config2.clickOutsideDeactivates, e2)) {
          trap.deactivate({
            // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
            //  which will result in the outside click setting focus to the node
            //  that was clicked (and if not focusable, to "nothing"); by setting
            //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
            //  on activation (or the configured `setReturnFocus` node), whether the
            //  outside click was on a focusable node or not
            returnFocus: config2.returnFocusOnDeactivate
          });
          return;
        }
        if (valueOrHandler(config2.allowOutsideClick, e2)) {
          return;
        }
        e2.preventDefault();
      };
      var checkFocusIn = function checkFocusIn2(event2) {
        var target = getActualTarget(event2);
        var targetContained = findContainerIndex(target, event2) >= 0;
        if (targetContained || target instanceof Document) {
          if (targetContained) {
            state.mostRecentlyFocusedNode = target;
          }
        } else {
          event2.stopImmediatePropagation();
          var nextNode;
          var navAcrossContainers = true;
          if (state.mostRecentlyFocusedNode) {
            if (getTabIndex(state.mostRecentlyFocusedNode) > 0) {
              var mruContainerIdx = findContainerIndex(state.mostRecentlyFocusedNode);
              var tabbableNodes = state.containerGroups[mruContainerIdx].tabbableNodes;
              if (tabbableNodes.length > 0) {
                var mruTabIdx = tabbableNodes.findIndex(function(node) {
                  return node === state.mostRecentlyFocusedNode;
                });
                if (mruTabIdx >= 0) {
                  if (config2.isKeyForward(state.recentNavEvent)) {
                    if (mruTabIdx + 1 < tabbableNodes.length) {
                      nextNode = tabbableNodes[mruTabIdx + 1];
                      navAcrossContainers = false;
                    }
                  } else {
                    if (mruTabIdx - 1 >= 0) {
                      nextNode = tabbableNodes[mruTabIdx - 1];
                      navAcrossContainers = false;
                    }
                  }
                }
              }
            } else {
              if (!state.containerGroups.some(function(g2) {
                return g2.tabbableNodes.some(function(n2) {
                  return getTabIndex(n2) > 0;
                });
              })) {
                navAcrossContainers = false;
              }
            }
          } else {
            navAcrossContainers = false;
          }
          if (navAcrossContainers) {
            nextNode = findNextNavNode({
              // move FROM the MRU node, not event-related node (which will be the node that is
              //  outside the trap causing the focus escape we're trying to fix)
              target: state.mostRecentlyFocusedNode,
              isBackward: config2.isKeyBackward(state.recentNavEvent)
            });
          }
          if (nextNode) {
            tryFocus(nextNode);
          } else {
            tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
          }
        }
        state.recentNavEvent = void 0;
      };
      var checkKeyNav = function checkKeyNav2(event2) {
        var isBackward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        state.recentNavEvent = event2;
        var destinationNode = findNextNavNode({
          event: event2,
          isBackward
        });
        if (destinationNode) {
          if (isTabEvent(event2)) {
            event2.preventDefault();
          }
          tryFocus(destinationNode);
        }
      };
      var checkKey = function checkKey2(event2) {
        if (isEscapeEvent(event2) && valueOrHandler(config2.escapeDeactivates, event2) !== false) {
          event2.preventDefault();
          trap.deactivate();
          return;
        }
        if (config2.isKeyForward(event2) || config2.isKeyBackward(event2)) {
          checkKeyNav(event2, config2.isKeyBackward(event2));
        }
      };
      var checkClick = function checkClick2(e2) {
        var target = getActualTarget(e2);
        if (findContainerIndex(target, e2) >= 0) {
          return;
        }
        if (valueOrHandler(config2.clickOutsideDeactivates, e2)) {
          return;
        }
        if (valueOrHandler(config2.allowOutsideClick, e2)) {
          return;
        }
        e2.preventDefault();
        e2.stopImmediatePropagation();
      };
      var addListeners = function addListeners2() {
        if (!state.active) {
          return;
        }
        activeFocusTraps.activateTrap(trapStack, trap);
        state.delayInitialFocusTimer = config2.delayInitialFocus ? delay(function() {
          tryFocus(getInitialFocusNode());
        }) : tryFocus(getInitialFocusNode());
        doc2.addEventListener("focusin", checkFocusIn, true);
        doc2.addEventListener("mousedown", checkPointerDown, {
          capture: true,
          passive: false
        });
        doc2.addEventListener("touchstart", checkPointerDown, {
          capture: true,
          passive: false
        });
        doc2.addEventListener("click", checkClick, {
          capture: true,
          passive: false
        });
        doc2.addEventListener("keydown", checkKey, {
          capture: true,
          passive: false
        });
        return trap;
      };
      var removeListeners = function removeListeners2() {
        if (!state.active) {
          return;
        }
        doc2.removeEventListener("focusin", checkFocusIn, true);
        doc2.removeEventListener("mousedown", checkPointerDown, true);
        doc2.removeEventListener("touchstart", checkPointerDown, true);
        doc2.removeEventListener("click", checkClick, true);
        doc2.removeEventListener("keydown", checkKey, true);
        return trap;
      };
      var checkDomRemoval = function checkDomRemoval2(mutations) {
        var isFocusedNodeRemoved = mutations.some(function(mutation) {
          var removedNodes = Array.from(mutation.removedNodes);
          return removedNodes.some(function(node) {
            return node === state.mostRecentlyFocusedNode;
          });
        });
        if (isFocusedNodeRemoved) {
          tryFocus(getInitialFocusNode());
        }
      };
      var mutationObserver = typeof window !== "undefined" && "MutationObserver" in window ? new MutationObserver(checkDomRemoval) : void 0;
      var updateObservedNodes = function updateObservedNodes2() {
        if (!mutationObserver) {
          return;
        }
        mutationObserver.disconnect();
        if (state.active && !state.paused) {
          state.containers.map(function(container) {
            mutationObserver.observe(container, {
              subtree: true,
              childList: true
            });
          });
        }
      };
      trap = {
        get active() {
          return state.active;
        },
        get paused() {
          return state.paused;
        },
        activate: function activate(activateOptions) {
          if (state.active) {
            return this;
          }
          var onActivate = getOption(activateOptions, "onActivate");
          var onPostActivate = getOption(activateOptions, "onPostActivate");
          var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
          if (!checkCanFocusTrap) {
            updateTabbableNodes();
          }
          state.active = true;
          state.paused = false;
          state.nodeFocusedBeforeActivation = doc2.activeElement;
          onActivate === null || onActivate === void 0 || onActivate();
          var finishActivation = function finishActivation2() {
            if (checkCanFocusTrap) {
              updateTabbableNodes();
            }
            addListeners();
            updateObservedNodes();
            onPostActivate === null || onPostActivate === void 0 || onPostActivate();
          };
          if (checkCanFocusTrap) {
            checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
            return this;
          }
          finishActivation();
          return this;
        },
        deactivate: function deactivate(deactivateOptions) {
          if (!state.active) {
            return this;
          }
          var options = _objectSpread2$1({
            onDeactivate: config2.onDeactivate,
            onPostDeactivate: config2.onPostDeactivate,
            checkCanReturnFocus: config2.checkCanReturnFocus
          }, deactivateOptions);
          clearTimeout(state.delayInitialFocusTimer);
          state.delayInitialFocusTimer = void 0;
          removeListeners();
          state.active = false;
          state.paused = false;
          updateObservedNodes();
          activeFocusTraps.deactivateTrap(trapStack, trap);
          var onDeactivate = getOption(options, "onDeactivate");
          var onPostDeactivate = getOption(options, "onPostDeactivate");
          var checkCanReturnFocus = getOption(options, "checkCanReturnFocus");
          var returnFocus = getOption(options, "returnFocus", "returnFocusOnDeactivate");
          onDeactivate === null || onDeactivate === void 0 || onDeactivate();
          var finishDeactivation = function finishDeactivation2() {
            delay(function() {
              if (returnFocus) {
                tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
              }
              onPostDeactivate === null || onPostDeactivate === void 0 || onPostDeactivate();
            });
          };
          if (returnFocus && checkCanReturnFocus) {
            checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
            return this;
          }
          finishDeactivation();
          return this;
        },
        pause: function pause(pauseOptions) {
          if (state.paused || !state.active) {
            return this;
          }
          var onPause = getOption(pauseOptions, "onPause");
          var onPostPause = getOption(pauseOptions, "onPostPause");
          state.paused = true;
          onPause === null || onPause === void 0 || onPause();
          removeListeners();
          updateObservedNodes();
          onPostPause === null || onPostPause === void 0 || onPostPause();
          return this;
        },
        unpause: function unpause(unpauseOptions) {
          if (!state.paused || !state.active) {
            return this;
          }
          var onUnpause = getOption(unpauseOptions, "onUnpause");
          var onPostUnpause = getOption(unpauseOptions, "onPostUnpause");
          state.paused = false;
          onUnpause === null || onUnpause === void 0 || onUnpause();
          updateTabbableNodes();
          addListeners();
          updateObservedNodes();
          onPostUnpause === null || onPostUnpause === void 0 || onPostUnpause();
          return this;
        },
        updateContainerElements: function updateContainerElements(containerElements) {
          var elementsAsArray = [].concat(containerElements).filter(Boolean);
          state.containers = elementsAsArray.map(function(element) {
            return typeof element === "string" ? doc2.querySelector(element) : element;
          });
          if (state.active) {
            updateTabbableNodes();
          }
          updateObservedNodes();
          return this;
        }
      };
      trap.updateContainerElements(elements);
      return trap;
    };
    function useFocusTrap(target, options = {}) {
      let trap;
      const { immediate, ...focusTrapOptions } = options;
      const hasFocus = ref(false);
      const isPaused = ref(false);
      const activate = (opts) => trap && trap.activate(opts);
      const deactivate = (opts) => trap && trap.deactivate(opts);
      const pause = () => {
        if (trap) {
          trap.pause();
          isPaused.value = true;
        }
      };
      const unpause = () => {
        if (trap) {
          trap.unpause();
          isPaused.value = false;
        }
      };
      watch$1(
        () => unrefElement(target),
        (el) => {
          if (!el)
            return;
          trap = createFocusTrap(el, {
            ...focusTrapOptions,
            onActivate() {
              hasFocus.value = true;
              if (options.onActivate)
                options.onActivate();
            },
            onDeactivate() {
              hasFocus.value = false;
              if (options.onDeactivate)
                options.onDeactivate();
            }
          });
          if (immediate)
            activate();
        },
        { flush: "post" }
      );
      tryOnScopeDispose(() => deactivate());
      return {
        hasFocus,
        isPaused,
        activate,
        deactivate,
        pause,
        unpause
      };
    }
    const uo$2 = (e2) => (...o3) => {
      e2 && (e2 == null || e2(...o3), e2 = null);
    }, q$4 = () => {
    };
    function oe$1(e2, o3, l2) {
      return e2 > l2 ? l2 : e2 < o3 ? o3 : e2;
    }
    function fe$3(e2, o3) {
      var s2;
      const l2 = ((s2 = $$3(e2, o3)) == null ? void 0 : s2[0]) || o3;
      e2.push(l2);
    }
    function $$3(e2, o3) {
      const l2 = e2.indexOf(o3);
      if (l2 !== -1)
        return e2.splice(l2, 1);
    }
    const co$2 = {
      /**
       * @description Set `null | false` to disable teleport.
       * @default `'body'`
       * @example
       * ```js
       * teleportTo: '#modals'
       * ```
       */
      teleportTo: {
        type: [String, null, Boolean, Object],
        default: "body"
      },
      /**
       * @description An uniq name for the open/close a modal via vfm.open/vfm.close APIs.
       * @default `undefined`
       * @example Symbol: `Symbol('MyModal')`
       * @example String: `'AUniqString'`
       * @example Number: `300`
       */
      modalId: {
        type: [String, Number, Symbol],
        default: void 0
      },
      /**
       * @description Display the modal or not.
       * @default `undefined`
       * @example
       * ```js
       * const showModal = ref(false)
       * v-model="showModal"
       * ```
       */
      modelValue: {
        type: Boolean,
        default: void 0
      },
      /**
       * @description Render the modal via `if` or `show`.
       * @default `'if'`
       * @example
       * ```js
       * displayDirective: 'if'
       * ```
       * @example
       * ```js
       * displayDirective: 'show'
       * ```
       */
      displayDirective: {
        type: String,
        default: "if",
        validator: (e2) => ["if", "show", "visible"].includes(e2)
      },
      /**
       * @description Hide the overlay or not.
       * @default `undefined`
       * @example
       * ```js
       * hideOverlay="true"
       * ```
       */
      hideOverlay: {
        type: Boolean,
        default: void 0
      },
      /**
       * @description Customize the overlay behavior.
       */
      overlayBehavior: {
        type: String,
        default: "auto",
        validator: (e2) => ["auto", "persist"].includes(e2)
      },
      /**
       * @description Customize the overlay transition.
       * @default `undefined`
       */
      overlayTransition: {
        type: [String, Object],
        default: void 0
      },
      /**
       * @description Customize the content transition.
       * @default `undefined`
       */
      contentTransition: {
        type: [String, Object],
        default: void 0
      },
      /**
       * @description Bind class to vfm__overlay.
       * @default `undefined`
       */
      overlayClass: {
        type: void 0,
        default: void 0
      },
      /**
       * @description Bind class to vfm__content.
       * @default `undefined`
       */
      contentClass: {
        type: void 0,
        default: void 0
      },
      /**
       * @description Bind style to vfm__overlay.
       * @default `undefined`
       */
      overlayStyle: {
        type: [String, Object, Array],
        default: void 0
      },
      /**
       * @description Bind style to vfm__content.
       * @default `undefined`
       */
      contentStyle: {
        type: [String, Object, Array],
        default: void 0
      },
      /**
       * @description Is it allow to close the modal by clicking the overlay.
       * @default `true`
       */
      clickToClose: {
        type: Boolean,
        default: true
      },
      /**
       * @description Is it allow to close the modal by keypress `esc`.
       * @default `true`
       */
      escToClose: {
        type: Boolean,
        default: true
      },
      /**
       * @description Is it allow to click outside of the vfm__content when the modal is opened
       * @default `'non-interactive'`
       */
      background: {
        type: String,
        default: "non-interactive",
        validator: (e2) => ["interactive", "non-interactive"].includes(e2)
      },
      /**
       * @description
       * * Use `{ disabled: true }` to disable the focusTrap.
       * * Checkout the createOptions type here https://github.com/focus-trap/focus-trap for more.
       * @default `{ allowOutsideClick: true }`
       */
      focusTrap: {
        type: [Boolean, Object],
        default: () => ({
          allowOutsideClick: true
        })
      },
      /**
       * @description Lock body scroll or not when the modal is opened.
       * @default `true`
       */
      lockScroll: {
        type: Boolean,
        default: true
      },
      /**
       * @description Creates a padding-right when scroll is locked to prevent the page from jumping
       * @default `true`
       */
      reserveScrollBarGap: {
        type: Boolean,
        default: true
      },
      /**
       * @description Define how to increase the zIndex when there are nested modals
       * @default `({ index }) => 1000 + 2 * index`
       */
      zIndexFn: {
        type: Function,
        default: ({ index: e2 }) => 1e3 + 2 * e2
      },
      /**
       * @description The direction of swiping to close the modal
       * @default `none`
       * @example
       * Set swipeToClose="none" to disable swiping to close
       * ```js
       * swipeToClose="none"
       * ```
       */
      swipeToClose: {
        type: String,
        default: "none",
        validator: (e2) => ["none", "up", "right", "down", "left"].includes(e2)
      },
      /**
       * @description Threshold for swipe to close
       * @default `0`
       */
      threshold: {
        type: Number,
        default: 0
      },
      /**
       * @description If set `:showSwipeBanner="true"`, only allow clicking `swipe-banner` slot to swipe to close
       * @default `undefined`
       * @example
       * ```js
       * swipeToClose="right"
       * :showSwipeBanner="true"
       * ```
       * ```html
       * <VueFinalModal
       *   ...
       *   swipeToClose="right"
       *   :showSwipeBanner="true"
       * >
       *   <template #swipe-banner>
       *     <div style="position: absolute; height: 100%; top: 0; left: 0; width: 10px;" />
       *   </template>
       *   ...modal content
       * </VueFinalModal>
       * ```
       */
      showSwipeBanner: {
        type: Boolean,
        default: void 0
      },
      /**
       * @description When set `:preventNavigationGestures="true"`, there will be two invisible bars for prevent navigation gestures including swiping back/forward on mobile webkit. For example: Safari mobile.
       * @default `undefined`
       * @example
       * Set preventNavigationGestures="true" to prevent Safari navigation gestures including swiping back/forward.
       * ```js
       * :preventNavigationGestures="true"
       * ```
       */
      preventNavigationGestures: {
        type: Boolean,
        default: void 0
      }
    };
    function Oe$2(e2 = false) {
      const o3 = ref(e2), l2 = ref(o3.value ? 0 : void 0);
      return [o3, l2, {
        beforeEnter() {
          l2.value = 1;
        },
        afterEnter() {
          l2.value = 0;
        },
        beforeLeave() {
          l2.value = 3;
        },
        afterLeave() {
          l2.value = 2;
        }
      }];
    }
    function fo$2(e2, o3) {
      const { modelValueLocal: l2, onEntering: s2, onEnter: u2, onLeaving: c2, onLeave: a2 } = o3, n2 = ref(l2.value), [t2, r2, m2] = Oe$2(n2.value), [f2, M2, S2] = Oe$2(n2.value), V2 = computed(() => typeof e2.contentTransition == "string" ? { name: e2.contentTransition, appear: true } : { appear: true, ...e2.contentTransition }), O2 = computed(() => typeof e2.overlayTransition == "string" ? { name: e2.overlayTransition, appear: true } : { appear: true, ...e2.overlayTransition }), E2 = computed(
        () => (e2.hideOverlay || M2.value === 2) && r2.value === 2
        /* Leave */
      );
      watch$1(
        E2,
        (k2) => {
          k2 && (n2.value = false);
        }
      ), watch$1(r2, (k2) => {
        if (k2 === 1) {
          if (!n2.value)
            return;
          s2 == null || s2();
        } else if (k2 === 0) {
          if (!n2.value)
            return;
          u2 == null || u2();
        } else
          k2 === 3 ? c2 == null || c2() : k2 === 2 && (a2 == null || a2());
      });
      async function w2() {
        n2.value = true, await nextTick(), t2.value = true, f2.value = true;
      }
      function D2() {
        t2.value = false, f2.value = false;
      }
      return {
        visible: n2,
        contentVisible: t2,
        contentListeners: m2,
        contentTransition: V2,
        overlayVisible: f2,
        overlayListeners: S2,
        overlayTransition: O2,
        enterTransition: w2,
        leaveTransition: D2
      };
    }
    function vo$2(e2, o3, l2) {
      const { vfmRootEl: s2, vfmContentEl: u2, visible: c2, modelValueLocal: a2 } = l2, n2 = ref();
      function t2() {
        c2.value && e2.escToClose && (a2.value = false);
      }
      function r2(f2) {
        n2.value = f2 == null ? void 0 : f2.target;
      }
      function m2() {
        var f2;
        n2.value === s2.value && (e2.clickToClose ? a2.value = false : ((f2 = u2.value) == null || f2.focus(), o3("clickOutside")));
      }
      return {
        onEsc: t2,
        onMouseupRoot: m2,
        onMousedown: r2
      };
    }
    function po$2(e2, o3, l2) {
      let s2 = false;
      const { open: u2, close: c2 } = l2, a2 = ref(false), n2 = {
        get value() {
          return a2.value;
        },
        set value(r2) {
          t2(r2);
        }
      };
      function t2(r2) {
        (r2 ? u2() : c2()) ? (a2.value = r2, r2 !== e2.modelValue && o3("update:modelValue", r2)) : (s2 = true, o3("update:modelValue", !r2), nextTick(() => {
          s2 = false;
        }));
      }
      return watch$1(() => e2.modelValue, (r2) => {
        s2 || (n2.value = !!r2);
      }), {
        modelValueLocal: n2
      };
    }
    function yo$2(e2, o3) {
      if (e2.focusTrap === false)
        return {
          focus() {
          },
          blur() {
          }
        };
      const { focusEl: l2 } = o3, { hasFocus: s2, activate: u2, deactivate: c2 } = useFocusTrap(l2, e2.focusTrap);
      function a2() {
        requestAnimationFrame(() => {
          u2();
        });
      }
      function n2() {
        s2.value && c2();
      }
      return { focus: a2, blur: n2 };
    }
    let be$3 = false;
    if (typeof window < "u") {
      const e2 = {
        get passive() {
          be$3 = true;
        }
      };
      window.addEventListener("testPassive", null, e2), window.removeEventListener("testPassive", null, e2);
    }
    const He$2 = typeof window < "u" && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === "MacIntel" && window.navigator.maxTouchPoints > 1);
    let j$3 = [], le$2 = false, ne$2 = 0, je$1 = -1, W$4, X$1;
    const ho$2 = (e2) => {
      if (!e2 || e2.nodeType !== Node.ELEMENT_NODE)
        return false;
      const o3 = window.getComputedStyle(e2);
      return ["auto", "scroll"].includes(o3.overflowY) && e2.scrollHeight > e2.clientHeight;
    }, mo$2 = (e2, o3) => !(e2.scrollTop === 0 && o3 < 0 || e2.scrollTop + e2.clientHeight + o3 >= e2.scrollHeight && o3 > 0), wo$2 = (e2) => {
      const o3 = [];
      for (; e2; ) {
        if (o3.push(e2), e2.classList.contains("vfm"))
          return o3;
        e2 = e2.parentElement;
      }
      return o3;
    }, bo$2 = (e2, o3) => {
      let l2 = false;
      return wo$2(e2).forEach((u2) => {
        ho$2(u2) && mo$2(u2, o3) && (l2 = true);
      }), l2;
    }, Ne$3 = (e2) => j$3.some(() => bo$2(e2, -ne$2)), se$2 = (e2) => {
      const o3 = e2 || window.event;
      return Ne$3(o3.target) || o3.touches.length > 1 ? true : (o3.preventDefault && o3.preventDefault(), false);
    }, To$2 = (e2) => {
      if (X$1 === void 0) {
        const o3 = !!e2 && e2.reserveScrollBarGap === true, l2 = window.innerWidth - document.documentElement.clientWidth;
        if (o3 && l2 > 0) {
          const s2 = parseInt(getComputedStyle(document.body).getPropertyValue("padding-right"), 10);
          X$1 = document.body.style.paddingRight, document.body.style.paddingRight = `${s2 + l2}px`;
        }
      }
      W$4 === void 0 && (W$4 = document.body.style.overflow, document.body.style.overflow = "hidden");
    }, So$2 = () => {
      X$1 !== void 0 && (document.body.style.paddingRight = X$1, X$1 = void 0), W$4 !== void 0 && (document.body.style.overflow = W$4, W$4 = void 0);
    }, Mo$2 = (e2) => e2 ? e2.scrollHeight - e2.scrollTop <= e2.clientHeight : false, go$2 = (e2, o3) => (ne$2 = e2.targetTouches[0].clientY - je$1, Ne$3(e2.target) ? false : o3 && o3.scrollTop === 0 && ne$2 > 0 || Mo$2(o3) && ne$2 < 0 ? se$2(e2) : (e2.stopPropagation(), true)), Co$2 = (e2, o3) => {
      if (!e2) {
        console.error(
          "disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices."
        );
        return;
      }
      if (j$3.some((s2) => s2.targetElement === e2))
        return;
      const l2 = {
        targetElement: e2,
        options: o3 || {}
      };
      j$3 = [...j$3, l2], He$2 ? (e2.ontouchstart = (s2) => {
        s2.targetTouches.length === 1 && (je$1 = s2.targetTouches[0].clientY);
      }, e2.ontouchmove = (s2) => {
        s2.targetTouches.length === 1 && go$2(s2, e2);
      }, le$2 || (document.addEventListener("touchmove", se$2, be$3 ? { passive: false } : void 0), le$2 = true)) : To$2(o3);
    }, ko$2 = (e2) => {
      if (!e2) {
        console.error(
          "enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices."
        );
        return;
      }
      j$3 = j$3.filter((o3) => o3.targetElement !== e2), He$2 ? (e2.ontouchstart = null, e2.ontouchmove = null, le$2 && j$3.length === 0 && (document.removeEventListener("touchmove", se$2, be$3 ? { passive: false } : void 0), le$2 = false)) : j$3.length || So$2();
    };
    function Vo$1(e2, o3) {
      const { lockScrollEl: l2, modelValueLocal: s2 } = o3;
      let u2;
      watch$1(l2, (n2) => {
        n2 && (u2 = n2);
      }, { immediate: true }), watch$1(() => e2.lockScroll, (n2) => {
        n2 ? a2() : c2();
      }), onBeforeUnmount(() => {
        c2();
      });
      function c2() {
        u2 && ko$2(u2);
      }
      function a2() {
        s2.value && e2.lockScroll && u2 && Co$2(u2, {
          reserveScrollBarGap: e2.reserveScrollBarGap,
          allowTouchMove: (n2) => {
            for (; n2 && n2 !== document.body; ) {
              if (n2.getAttribute("vfm-scroll-lock-ignore") !== null)
                return true;
              n2 = n2.parentElement;
            }
            return false;
          }
        });
      }
      return {
        enableBodyScroll: c2,
        disableBodyScroll: a2
      };
    }
    function Eo$2(e2) {
      const o3 = ref();
      function l2(u2) {
        var c2;
        o3.value = (c2 = e2.zIndexFn) == null ? void 0 : c2.call(e2, { index: u2 <= -1 ? 0 : u2 });
      }
      function s2() {
        o3.value = void 0;
      }
      return {
        zIndex: o3,
        refreshZIndex: l2,
        resetZIndex: s2
      };
    }
    const ve$3 = {
      beforeMount(e2, { value: o3 }, { transition: l2 }) {
        e2._vov = e2.style.visibility === "hidden" ? "" : e2.style.visibility, l2 && o3 ? l2.beforeEnter(e2) : G$2(e2, o3);
      },
      mounted(e2, { value: o3 }, { transition: l2 }) {
        l2 && o3 && l2.enter(e2);
      },
      updated(e2, { value: o3, oldValue: l2 }, { transition: s2 }) {
        !o3 != !l2 && (s2 ? o3 ? (s2.beforeEnter(e2), G$2(e2, true), s2.enter(e2)) : s2.leave(e2, () => {
          G$2(e2, false);
        }) : G$2(e2, o3));
      },
      beforeUnmount(e2, { value: o3 }) {
        G$2(e2, o3);
      }
    };
    function G$2(e2, o3) {
      e2.style.visibility = o3 ? e2._vov : "hidden";
    }
    const De$1 = (e2) => {
      if (e2 instanceof MouseEvent) {
        const { clientX: o3, clientY: l2 } = e2;
        return { x: o3, y: l2 };
      } else {
        const { clientX: o3, clientY: l2 } = e2.targetTouches[0];
        return { x: o3, y: l2 };
      }
    };
    function Bo$2(e2) {
      if (!e2)
        return false;
      let o3 = false;
      const l2 = {
        get passive() {
          return o3 = true, false;
        }
      };
      return e2.addEventListener("x", q$4, l2), e2.removeEventListener("x", q$4), o3;
    }
    function Oo$2(e2, {
      threshold: o3 = 0,
      onSwipeStart: l2,
      onSwipe: s2,
      onSwipeEnd: u2,
      passive: c2 = true
    }) {
      const a2 = reactive({ x: 0, y: 0 }), n2 = reactive({ x: 0, y: 0 }), t2 = computed(() => a2.x - n2.x), r2 = computed(() => a2.y - n2.y), { max: m2, abs: f2 } = Math, M2 = computed(
        () => m2(f2(t2.value), f2(r2.value)) >= o3
      ), S2 = ref(false), V2 = computed(() => M2.value ? f2(t2.value) > f2(r2.value) ? t2.value > 0 ? "left" : "right" : r2.value > 0 ? "up" : "down" : "none"), O2 = (p2, h2) => {
        a2.x = p2, a2.y = h2;
      }, E2 = (p2, h2) => {
        n2.x = p2, n2.y = h2;
      };
      let w2, D2;
      function k2(p2) {
        w2.capture && !w2.passive && p2.preventDefault();
        const { x: h2, y: R2 } = De$1(p2);
        O2(h2, R2), E2(h2, R2), l2 == null || l2(p2), D2 = [
          useEventListener(e2, "mousemove", P2, w2),
          useEventListener(e2, "touchmove", P2, w2),
          useEventListener(e2, "mouseup", i2, w2),
          useEventListener(e2, "touchend", i2, w2),
          useEventListener(e2, "touchcancel", i2, w2)
        ];
      }
      function P2(p2) {
        const { x: h2, y: R2 } = De$1(p2);
        E2(h2, R2), !S2.value && M2.value && (S2.value = true), S2.value && (s2 == null || s2(p2));
      }
      function i2(p2) {
        S2.value && (u2 == null || u2(p2, V2.value)), S2.value = false, D2.forEach((h2) => h2());
      }
      let b2 = [];
      return onMounted(() => {
        const p2 = Bo$2(window == null ? void 0 : window.document);
        c2 ? w2 = p2 ? { passive: true } : { capture: false } : w2 = p2 ? { passive: false, capture: true } : { capture: true }, b2 = [
          useEventListener(e2, "mousedown", k2, w2),
          useEventListener(e2, "touchstart", k2, w2)
        ];
      }), {
        isSwiping: S2,
        direction: V2,
        coordsStart: a2,
        coordsEnd: n2,
        lengthX: t2,
        lengthY: r2,
        stop: () => {
          b2.forEach((p2) => p2()), D2.forEach((p2) => p2());
        }
      };
    }
    function Do$2(e2, o3) {
      const { vfmContentEl: l2, modelValueLocal: s2 } = o3, u2 = 0.1, c2 = 300, a2 = ref(), n2 = computed(() => {
        if (!(e2.swipeToClose === void 0 || e2.swipeToClose === "none"))
          return e2.showSwipeBanner ? a2.value : l2.value;
      }), t2 = ref(0), r2 = ref(true);
      let m2 = q$4, f2 = true, M2, S2 = false;
      const { lengthX: V2, lengthY: O2, direction: E2, isSwiping: w2 } = Oo$2(n2, {
        threshold: e2.threshold,
        onSwipeStart(i2) {
          m2 = useEventListener(document, "selectionchange", () => {
            var b2;
            r2.value = (b2 = window.getSelection()) == null ? void 0 : b2.isCollapsed;
          }), M2 = (/* @__PURE__ */ new Date()).getTime(), S2 = P2(i2 == null ? void 0 : i2.target);
        },
        onSwipe() {
          var i2, b2, L2, p2;
          if (S2 && r2.value && E2.value === e2.swipeToClose) {
            if (E2.value === "up") {
              const h2 = oe$1(Math.abs(O2.value || 0), 0, ((i2 = n2.value) == null ? void 0 : i2.offsetHeight) || 0) - (e2.threshold || 0);
              t2.value = h2;
            } else if (E2.value === "down") {
              const h2 = oe$1(Math.abs(O2.value || 0), 0, ((b2 = n2.value) == null ? void 0 : b2.offsetHeight) || 0) - (e2.threshold || 0);
              t2.value = -h2;
            } else if (E2.value === "right") {
              const h2 = oe$1(Math.abs(V2.value || 0), 0, ((L2 = n2.value) == null ? void 0 : L2.offsetWidth) || 0) - (e2.threshold || 0);
              t2.value = -h2;
            } else if (E2.value === "left") {
              const h2 = oe$1(Math.abs(V2.value || 0), 0, ((p2 = n2.value) == null ? void 0 : p2.offsetWidth) || 0) - (e2.threshold || 0);
              t2.value = h2;
            }
          }
        },
        onSwipeEnd(i2, b2) {
          if (m2(), !r2.value) {
            r2.value = true;
            return;
          }
          const L2 = (/* @__PURE__ */ new Date()).getTime(), p2 = b2 === e2.swipeToClose, h2 = (() => {
            var J2, Q2;
            if (b2 === "up" || b2 === "down")
              return Math.abs((O2 == null ? void 0 : O2.value) || 0) > u2 * (((J2 = n2.value) == null ? void 0 : J2.offsetHeight) || 0);
            if (b2 === "left" || b2 === "right")
              return Math.abs((V2 == null ? void 0 : V2.value) || 0) > u2 * (((Q2 = n2.value) == null ? void 0 : Q2.offsetWidth) || 0);
          })(), R2 = L2 - M2 <= c2;
          if (f2 && S2 && p2 && (h2 || R2)) {
            s2.value = false;
            return;
          }
          t2.value = 0;
        }
      }), D2 = computed(() => {
        if (e2.swipeToClose === "none")
          return;
        const i2 = (() => {
          switch (e2.swipeToClose) {
            case "up":
            case "down":
              return "translateY";
            case "left":
            case "right":
              return "translateX";
          }
        })();
        return {
          class: { "vfm-bounce-back": !w2.value },
          style: { transform: `${i2}(${-t2.value}px)` }
        };
      });
      watch$1(
        () => r2.value,
        (i2) => {
          i2 || (t2.value = 0);
        }
      ), watch$1(
        () => s2.value,
        (i2) => {
          i2 && (t2.value = 0);
        }
      ), watch$1(
        () => t2.value,
        (i2, b2) => {
          switch (e2.swipeToClose) {
            case "down":
            case "right":
              f2 = i2 < b2;
              break;
            case "up":
            case "left":
              f2 = i2 > b2;
              break;
          }
        }
      );
      function k2(i2) {
        e2.preventNavigationGestures && i2.preventDefault();
      }
      function P2(i2) {
        const b2 = i2 == null ? void 0 : i2.tagName;
        if (!b2 || ["INPUT", "TEXTAREA"].includes(b2))
          return false;
        const L2 = (() => {
          switch (e2.swipeToClose) {
            case "up":
              return (i2 == null ? void 0 : i2.scrollTop) + (i2 == null ? void 0 : i2.clientHeight) === (i2 == null ? void 0 : i2.scrollHeight);
            case "left":
              return (i2 == null ? void 0 : i2.scrollLeft) + (i2 == null ? void 0 : i2.clientWidth) === (i2 == null ? void 0 : i2.scrollWidth);
            case "down":
              return (i2 == null ? void 0 : i2.scrollTop) === 0;
            case "right":
              return (i2 == null ? void 0 : i2.scrollLeft) === 0;
            default:
              return false;
          }
        })();
        return i2 === n2.value ? L2 : L2 && P2(i2 == null ? void 0 : i2.parentElement);
      }
      return {
        vfmContentEl: l2,
        swipeBannerEl: a2,
        bindSwipe: D2,
        onTouchStartSwipeBanner: k2
      };
    }
    const Ye$2 = Symbol("vfm");
    let H$2;
    const Lo$2 = (e2) => H$2 = e2, Po$2 = {
      install: q$4,
      modals: [],
      openedModals: [],
      openedModalOverlays: [],
      dynamicModals: [],
      modalsContainers: ref([]),
      get: () => {
      },
      toggle: () => {
      },
      open: () => {
      },
      close: () => {
      },
      closeAll: () => Promise.allSettled([])
    }, Ao$2 = () => getCurrentInstance() && inject(Ye$2, Po$2) || H$2;
    function zo$2() {
      const e2 = shallowReactive([]), o3 = shallowReactive([]), l2 = shallowReactive([]), s2 = shallowReactive([]), u2 = ref([]), c2 = markRaw({
        install(a2) {
          a2.provide(Ye$2, c2), a2.config.globalProperties.$vfm = c2;
        },
        modals: e2,
        openedModals: o3,
        openedModalOverlays: l2,
        dynamicModals: s2,
        modalsContainers: u2,
        get(a2) {
          return e2.find((n2) => {
            var t2, r2;
            return ((r2 = (t2 = Z$2(n2)) == null ? void 0 : t2.value.modalId) == null ? void 0 : r2.value) === a2;
          });
        },
        toggle(a2, n2) {
          var r2;
          const t2 = c2.get(a2);
          return (r2 = Z$2(t2)) == null ? void 0 : r2.value.toggle(n2);
        },
        open(a2) {
          return c2.toggle(a2, true);
        },
        close(a2) {
          return c2.toggle(a2, false);
        },
        closeAll() {
          return Promise.allSettled(
            o3.reduce((a2, n2) => {
              const t2 = Z$2(n2), r2 = t2 == null ? void 0 : t2.value.toggle(false);
              return r2 && a2.push(r2), a2;
            }, [])
          );
        }
      });
      return Lo$2(c2), c2;
    }
    function Z$2(e2) {
      var o3;
      return (o3 = e2 == null ? void 0 : e2.exposed) == null ? void 0 : o3.modalExposed;
    }
    const Io$2 = /* @__PURE__ */ defineComponent({ inheritAttrs: false }), Ro$2 = /* @__PURE__ */ defineComponent({
      ...Io$2,
      __name: "VueFinalModal",
      props: co$2,
      emits: ["update:modelValue", "beforeOpen", "opened", "beforeClose", "closed", "clickOutside"],
      setup(e2, { expose: o3, emit: l2 }) {
        const s2 = e2, u2 = l2, c2 = useAttrs(), a2 = getCurrentInstance(), { modals: n2, openedModals: t2, openedModalOverlays: r2 } = K$2(), m2 = ref(), f2 = ref(), { focus: M2, blur: S2 } = yo$2(s2, { focusEl: m2 }), { zIndex: V2, refreshZIndex: O2, resetZIndex: E2 } = Eo$2(s2), { modelValueLocal: w2 } = po$2(s2, u2, { open: We2, close: Xe2 }), { enableBodyScroll: D2, disableBodyScroll: k2 } = Vo$1(s2, {
          lockScrollEl: m2,
          modelValueLocal: w2
        });
        let P2 = q$4;
        const {
          visible: i2,
          contentVisible: b2,
          contentListeners: L2,
          contentTransition: p2,
          overlayVisible: h2,
          overlayListeners: R2,
          overlayTransition: J2,
          enterTransition: Q2,
          leaveTransition: xe2
        } = fo$2(s2, {
          modelValueLocal: w2,
          onEntering() {
            nextTick(() => {
              k2(), M2();
            });
          },
          onEnter() {
            u2("opened"), P2("opened");
          },
          onLeave() {
            $$3(t2, a2), E2(), D2(), u2("closed"), P2("closed");
          }
        }), { onEsc: ze2, onMouseupRoot: Ge2, onMousedown: Te2 } = vo$2(s2, u2, { vfmRootEl: m2, vfmContentEl: f2, visible: i2, modelValueLocal: w2 }), {
          swipeBannerEl: $e2,
          bindSwipe: Ue2,
          onTouchStartSwipeBanner: Se2
        } = Do$2(s2, { vfmContentEl: f2, modelValueLocal: w2 }), Me2 = computed(() => a2 ? t2.indexOf(a2) : -1);
        watch$1([() => s2.zIndexFn, Me2], () => {
          i2.value && O2(Me2.value);
        }), onMounted(() => {
          fe$3(n2, a2);
        }), s2.modelValue && (w2.value = true);
        function We2() {
          let d2 = false;
          return u2("beforeOpen", { stop: () => d2 = true }), d2 ? false : (fe$3(t2, a2), fe$3(r2, a2), ie2(), Q2(), true);
        }
        function Xe2() {
          let d2 = false;
          return u2("beforeClose", { stop: () => d2 = true }), d2 ? false : ($$3(r2, a2), ie2(), S2(), xe2(), true);
        }
        function Ze2() {
          w2.value = false;
        }
        onBeforeUnmount(() => {
          D2(), $$3(n2, a2), $$3(t2, a2), S2(), ie2();
        });
        async function ie2() {
          await nextTick();
          const d2 = r2.filter((y2) => {
            var A2;
            const T2 = Z$2(y2);
            return (T2 == null ? void 0 : T2.value.overlayBehavior.value) === "auto" && !((A2 = T2 == null ? void 0 : T2.value.hideOverlay) != null && A2.value);
          });
          d2.forEach((y2, T2) => {
            const A2 = Z$2(y2);
            A2 != null && A2.value && (A2.value.overlayVisible.value = T2 === d2.length - 1);
          });
        }
        const Ke2 = toRef(() => s2.modalId), ge2 = toRef(() => s2.hideOverlay), qe2 = toRef(() => s2.overlayBehavior), Je2 = computed(() => ({
          modalId: Ke2,
          hideOverlay: ge2,
          overlayBehavior: qe2,
          overlayVisible: h2,
          toggle(d2) {
            return new Promise((y2) => {
              P2 = uo$2((A2) => y2(A2));
              const T2 = typeof d2 == "boolean" ? d2 : !w2.value;
              w2.value = T2;
            });
          }
        }));
        return o3({
          modalExposed: Je2
        }), (d2, y2) => (openBlock(), createBlock(Teleport, {
          to: d2.teleportTo ? d2.teleportTo : void 0,
          disabled: !d2.teleportTo
        }, [
          d2.displayDirective !== "if" || unref(i2) ? withDirectives((openBlock(), createElementBlock("div", mergeProps({ key: 0 }, unref(c2), {
            ref_key: "vfmRootEl",
            ref: m2,
            class: ["vfm vfm--fixed vfm--inset", { "vfm--prevent-none": d2.background === "interactive" }],
            style: { zIndex: unref(V2) },
            role: "dialog",
            "aria-modal": "true",
            onKeydown: y2[7] || (y2[7] = withKeys(() => unref(ze2)(), ["esc"])),
            onMouseup: y2[8] || (y2[8] = withModifiers(() => unref(Ge2)(), ["self"])),
            onMousedown: y2[9] || (y2[9] = withModifiers((T2) => unref(Te2)(T2), ["self"]))
          }), [
            ge2.value ? createCommentVNode("", true) : (openBlock(), createBlock(Transition, mergeProps({ key: 0 }, unref(J2), toHandlers(unref(R2))), {
              default: withCtx(() => [
                d2.displayDirective !== "if" || unref(h2) ? withDirectives((openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(["vfm__overlay vfm--overlay vfm--absolute vfm--inset vfm--prevent-none", d2.overlayClass]),
                  style: normalizeStyle(d2.overlayStyle),
                  "aria-hidden": "true"
                }, null, 6)), [
                  [vShow, d2.displayDirective !== "show" || unref(h2)],
                  [unref(ve$3), d2.displayDirective !== "visible" || unref(h2)]
                ]) : createCommentVNode("", true)
              ]),
              _: 1
            }, 16)),
            createVNode(Transition, mergeProps(unref(p2), toHandlers(unref(L2))), {
              default: withCtx(() => [
                d2.displayDirective !== "if" || unref(b2) ? withDirectives((openBlock(), createElementBlock("div", mergeProps({
                  key: 0,
                  ref_key: "vfmContentEl",
                  ref: f2,
                  class: ["vfm__content vfm--outline-none", [d2.contentClass, { "vfm--prevent-auto": d2.background === "interactive" }]],
                  style: d2.contentStyle,
                  tabindex: "0"
                }, unref(Ue2), {
                  onMousedown: y2[6] || (y2[6] = () => unref(Te2)())
                }), [
                  renderSlot(d2.$slots, "default", normalizeProps(guardReactiveProps({ close: Ze2 }))),
                  d2.showSwipeBanner ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    ref_key: "swipeBannerEl",
                    ref: $e2,
                    class: "vfm-swipe-banner-container",
                    onTouchstart: y2[2] || (y2[2] = (T2) => unref(Se2)(T2))
                  }, [
                    renderSlot(d2.$slots, "swipe-banner", {}, () => [
                      createBaseVNode("div", {
                        class: "vfm-swipe-banner-back",
                        onTouchstart: y2[0] || (y2[0] = (T2) => d2.swipeToClose === "left" && T2.preventDefault())
                      }, null, 32),
                      createBaseVNode("div", {
                        class: "vfm-swipe-banner-forward",
                        onTouchstart: y2[1] || (y2[1] = (T2) => d2.swipeToClose === "right" && T2.preventDefault())
                      }, null, 32)
                    ])
                  ], 544)) : !d2.showSwipeBanner && d2.preventNavigationGestures ? (openBlock(), createElementBlock("div", {
                    key: 1,
                    class: "vfm-swipe-banner-container",
                    onTouchstart: y2[5] || (y2[5] = (T2) => unref(Se2)(T2))
                  }, [
                    createBaseVNode("div", {
                      class: "vfm-swipe-banner-back",
                      onTouchstart: y2[3] || (y2[3] = (T2) => d2.swipeToClose === "left" && T2.preventDefault())
                    }, null, 32),
                    createBaseVNode("div", {
                      class: "vfm-swipe-banner-forward",
                      onTouchstart: y2[4] || (y2[4] = (T2) => d2.swipeToClose === "right" && T2.preventDefault())
                    }, null, 32)
                  ], 32)) : createCommentVNode("", true)
                ], 16)), [
                  [vShow, d2.displayDirective !== "show" || unref(b2)],
                  [unref(ve$3), d2.displayDirective !== "visible" || unref(b2)]
                ]) : createCommentVNode("", true)
              ]),
              _: 3
            }, 16)
          ], 16)), [
            [vShow, d2.displayDirective !== "show" || unref(i2)],
            [unref(ve$3), d2.displayDirective !== "visible" || unref(i2)]
          ]) : createCommentVNode("", true)
        ], 8, ["to", "disabled"]));
      }
    });
    function K$2() {
      const e2 = Ao$2();
      if (!e2)
        throw new Error(
          `[Vue Final Modal]: getActiveVfm was called with no active Vfm. Did you forget to install vfm?
	const vfm = createVfm()
	app.use(vfm)
This will fail in production.`
        );
      return e2;
    }
    var dist = { exports: {} };
    (function(module2, exports2) {
      !function(t2, e2) {
        module2.exports = e2(require$$0$1);
      }(self, function(t2) {
        return (() => {
          var e2 = { 705: (t3) => {
            t3.exports = function(t4) {
              var e3 = [];
              return e3.toString = function() {
                return this.map(function(e4) {
                  var i3 = t4(e4);
                  return e4[2] ? "@media ".concat(e4[2], " {").concat(i3, "}") : i3;
                }).join("");
              }, e3.i = function(t5, i3, n3) {
                "string" == typeof t5 && (t5 = [[null, t5, ""]]);
                var o4 = {};
                if (n3)
                  for (var r2 = 0; r2 < this.length; r2++) {
                    var a2 = this[r2][0];
                    null != a2 && (o4[a2] = true);
                  }
                for (var s2 = 0; s2 < t5.length; s2++) {
                  var h2 = [].concat(t5[s2]);
                  n3 && o4[h2[0]] || (i3 && (h2[2] ? h2[2] = "".concat(i3, " and ").concat(h2[2]) : h2[2] = i3), e3.push(h2));
                }
              }, e3;
            };
          }, 566: (t3, e3, i3) => {
            i3.d(e3, { Z: () => r2 });
            var n3 = i3(705), o4 = i3.n(n3)()(function(t4) {
              return t4[1];
            });
            o4.push([t3.id, ".vdr {\n    position: absolute;\n    -webkit-box-sizing: border-box;\n            box-sizing: border-box;\n}\n.vdr.active:before{\n    content: '';\n    width: 100%;\n    height: 100%;\n    position: absolute;\n    top: 0;\n    left: 0;\n    -webkit-box-sizing: border-box;\n            box-sizing: border-box;\n    outline: 1px dashed #d6d6d6;\n}\n.vdr-stick {\n    -webkit-box-sizing: border-box;\n            box-sizing: border-box;\n    position: absolute;\n    font-size: 1px;\n    background: #ffffff;\n    border: 1px solid #6c6c6c;\n    -webkit-box-shadow: 0 0 2px #bbb;\n            box-shadow: 0 0 2px #bbb;\n}\n.inactive .vdr-stick {\n    display: none;\n}\n.vdr-stick-tl, .vdr-stick-br {\n    cursor: nwse-resize;\n}\n.vdr-stick-tm, .vdr-stick-bm {\n    left: 50%;\n    cursor: ns-resize;\n}\n.vdr-stick-tr, .vdr-stick-bl {\n    cursor: nesw-resize;\n}\n.vdr-stick-ml, .vdr-stick-mr {\n    top: 50%;\n    cursor: ew-resize;\n}\n.vdr-stick.not-resizable{\n    display: none;\n}\n.content-container{\n    display: block;\n    position: relative;\n}", ""]);
            const r2 = o4;
          }, 379: (t3, e3, i3) => {
            var n3, o4 = /* @__PURE__ */ function() {
              var t4 = {};
              return function(e4) {
                if (void 0 === t4[e4]) {
                  var i4 = document.querySelector(e4);
                  if (window.HTMLIFrameElement && i4 instanceof window.HTMLIFrameElement)
                    try {
                      i4 = i4.contentDocument.head;
                    } catch (t5) {
                      i4 = null;
                    }
                  t4[e4] = i4;
                }
                return t4[e4];
              };
            }(), r2 = [];
            function a2(t4) {
              for (var e4 = -1, i4 = 0; i4 < r2.length; i4++)
                if (r2[i4].identifier === t4) {
                  e4 = i4;
                  break;
                }
              return e4;
            }
            function s2(t4, e4) {
              for (var i4 = {}, n4 = [], o5 = 0; o5 < t4.length; o5++) {
                var s3 = t4[o5], h3 = e4.base ? s3[0] + e4.base : s3[0], c3 = i4[h3] || 0, l3 = "".concat(h3, " ").concat(c3);
                i4[h3] = c3 + 1;
                var u3 = a2(l3), d3 = { css: s3[1], media: s3[2], sourceMap: s3[3] };
                -1 !== u3 ? (r2[u3].references++, r2[u3].updater(d3)) : r2.push({ identifier: l3, updater: m2(d3, e4), references: 1 }), n4.push(l3);
              }
              return n4;
            }
            function h2(t4) {
              var e4 = document.createElement("style"), n4 = t4.attributes || {};
              if (void 0 === n4.nonce) {
                var r3 = i3.nc;
                r3 && (n4.nonce = r3);
              }
              if (Object.keys(n4).forEach(function(t5) {
                e4.setAttribute(t5, n4[t5]);
              }), "function" == typeof t4.insert)
                t4.insert(e4);
              else {
                var a3 = o4(t4.insert || "head");
                if (!a3)
                  throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
                a3.appendChild(e4);
              }
              return e4;
            }
            var c2, l2 = (c2 = [], function(t4, e4) {
              return c2[t4] = e4, c2.filter(Boolean).join("\n");
            });
            function u2(t4, e4, i4, n4) {
              var o5 = i4 ? "" : n4.media ? "@media ".concat(n4.media, " {").concat(n4.css, "}") : n4.css;
              if (t4.styleSheet)
                t4.styleSheet.cssText = l2(e4, o5);
              else {
                var r3 = document.createTextNode(o5), a3 = t4.childNodes;
                a3[e4] && t4.removeChild(a3[e4]), a3.length ? t4.insertBefore(r3, a3[e4]) : t4.appendChild(r3);
              }
            }
            function d2(t4, e4, i4) {
              var n4 = i4.css, o5 = i4.media, r3 = i4.sourceMap;
              if (o5 ? t4.setAttribute("media", o5) : t4.removeAttribute("media"), r3 && "undefined" != typeof btoa && (n4 += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(r3)))), " */")), t4.styleSheet)
                t4.styleSheet.cssText = n4;
              else {
                for (; t4.firstChild; )
                  t4.removeChild(t4.firstChild);
                t4.appendChild(document.createTextNode(n4));
              }
            }
            var p2 = null, f2 = 0;
            function m2(t4, e4) {
              var i4, n4, o5;
              if (e4.singleton) {
                var r3 = f2++;
                i4 = p2 || (p2 = h2(e4)), n4 = u2.bind(null, i4, r3, false), o5 = u2.bind(null, i4, r3, true);
              } else
                i4 = h2(e4), n4 = d2.bind(null, i4, e4), o5 = function() {
                  !function(t5) {
                    if (null === t5.parentNode)
                      return false;
                    t5.parentNode.removeChild(t5);
                  }(i4);
                };
              return n4(t4), function(e5) {
                if (e5) {
                  if (e5.css === t4.css && e5.media === t4.media && e5.sourceMap === t4.sourceMap)
                    return;
                  n4(t4 = e5);
                } else
                  o5();
              };
            }
            t3.exports = function(t4, e4) {
              (e4 = e4 || {}).singleton || "boolean" == typeof e4.singleton || (e4.singleton = (void 0 === n3 && (n3 = Boolean(window && document && document.all && !window.atob)), n3));
              var i4 = s2(t4 = t4 || [], e4);
              return function(t5) {
                if (t5 = t5 || [], "[object Array]" === Object.prototype.toString.call(t5)) {
                  for (var n4 = 0; n4 < i4.length; n4++) {
                    var o5 = a2(i4[n4]);
                    r2[o5].references--;
                  }
                  for (var h3 = s2(t5, e4), c3 = 0; c3 < i4.length; c3++) {
                    var l3 = a2(i4[c3]);
                    0 === r2[l3].references && (r2[l3].updater(), r2.splice(l3, 1));
                  }
                  i4 = h3;
                }
              };
            };
          }, 507: (e3) => {
            e3.exports = t2;
          } }, i2 = {};
          function n2(t3) {
            var o4 = i2[t3];
            if (void 0 !== o4)
              return o4.exports;
            var r2 = i2[t3] = { id: t3, exports: {} };
            return e2[t3](r2, r2.exports, n2), r2.exports;
          }
          n2.n = (t3) => {
            var e3 = t3 && t3.__esModule ? () => t3.default : () => t3;
            return n2.d(e3, { a: e3 }), e3;
          }, n2.d = (t3, e3) => {
            for (var i3 in e3)
              n2.o(e3, i3) && !n2.o(t3, i3) && Object.defineProperty(t3, i3, { enumerable: true, get: e3[i3] });
          }, n2.o = (t3, e3) => Object.prototype.hasOwnProperty.call(t3, e3), n2.r = (t3) => {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t3, "__esModule", { value: true });
          };
          var o3 = {};
          return (() => {
            n2.r(o3), n2.d(o3, { default: () => u2 });
            var t3 = n2(507);
            function e3(t4) {
              return function(t5) {
                if (Array.isArray(t5))
                  return i3(t5);
              }(t4) || function(t5) {
                if ("undefined" != typeof Symbol && null != t5[Symbol.iterator] || null != t5["@@iterator"])
                  return Array.from(t5);
              }(t4) || function(t5, e4) {
                if (t5) {
                  if ("string" == typeof t5)
                    return i3(t5, e4);
                  var n3 = Object.prototype.toString.call(t5).slice(8, -1);
                  return "Object" === n3 && t5.constructor && (n3 = t5.constructor.name), "Map" === n3 || "Set" === n3 ? Array.from(t5) : "Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3) ? i3(t5, e4) : void 0;
                }
              }(t4) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }();
            }
            function i3(t4, e4) {
              (null == e4 || e4 > t4.length) && (e4 = t4.length);
              for (var i4 = 0, n3 = new Array(e4); i4 < e4; i4++)
                n3[i4] = t4[i4];
              return n3;
            }
            var r2 = { t: "top", m: "marginTop", b: "bottom" }, a2 = { l: "left", m: "marginLeft", r: "right" };
            const s2 = { name: "vue-drag-resize", emits: ["clicked", "dragging", "dragstop", "resizing", "resizestop", "activated", "deactivated"], props: { stickSize: { type: Number, default: 8 }, parentScaleX: { type: Number, default: 1 }, parentScaleY: { type: Number, default: 1 }, isActive: { type: Boolean, default: false }, preventActiveBehavior: { type: Boolean, default: false }, isDraggable: { type: Boolean, default: true }, isResizable: { type: Boolean, default: true }, aspectRatio: { type: Boolean, default: false }, parentLimitation: { type: Boolean, default: false }, snapToGrid: { type: Boolean, default: false }, gridX: { type: Number, default: 50, validator: function(t4) {
              return t4 >= 0;
            } }, gridY: { type: Number, default: 50, validator: function(t4) {
              return t4 >= 0;
            } }, parentW: { type: Number, default: 0, validator: function(t4) {
              return t4 >= 0;
            } }, parentH: { type: Number, default: 0, validator: function(t4) {
              return t4 >= 0;
            } }, w: { type: [String, Number], default: 200, validator: function(t4) {
              return "string" == typeof t4 ? "auto" === t4 : t4 >= 0;
            } }, h: { type: [String, Number], default: 200, validator: function(t4) {
              return "string" == typeof t4 ? "auto" === t4 : t4 >= 0;
            } }, minw: { type: Number, default: 50, validator: function(t4) {
              return t4 >= 0;
            } }, minh: { type: Number, default: 50, validator: function(t4) {
              return t4 >= 0;
            } }, x: { type: Number, default: 0, validator: function(t4) {
              return "number" == typeof t4;
            } }, y: { type: Number, default: 0, validator: function(t4) {
              return "number" == typeof t4;
            } }, z: { type: [String, Number], default: "auto", validator: function(t4) {
              return "string" == typeof t4 ? "auto" === t4 : t4 >= 0;
            } }, dragHandle: { type: String, default: null }, dragCancel: { type: String, default: null }, sticks: { type: Array, default: function() {
              return ["tl", "tm", "tr", "mr", "br", "bm", "bl", "ml"];
            } }, axis: { type: String, default: "both", validator: function(t4) {
              return -1 !== ["x", "y", "both", "none"].indexOf(t4);
            } }, contentClass: { type: String, required: false, default: "" } }, data: function() {
              return { fixAspectRatio: null, active: null, zIndex: null, parentWidth: null, parentHeight: null, left: null, top: null, right: null, bottom: null, minHeight: null };
            }, beforeCreate: function() {
              this.stickDrag = false, this.bodyDrag = false, this.dimensionsBeforeMove = { pointerX: 0, pointerY: 0, x: 0, y: 0, w: 0, h: 0 }, this.limits = { left: { min: null, max: null }, right: { min: null, max: null }, top: { min: null, max: null }, bottom: { min: null, max: null } }, this.currentStick = null;
            }, mounted: function() {
              var t4 = this;
              this.parentElement = this.$el.parentNode, this.parentWidth = this.parentW ? this.parentW : this.parentElement.clientWidth, this.parentHeight = this.parentH ? this.parentH : this.parentElement.clientHeight, this.left = this.x, this.top = this.y, this.right = this.parentWidth - ("auto" === this.w ? this.$refs.container.scrollWidth : this.w) - this.left, this.bottom = this.parentHeight - ("auto" === this.h ? this.$refs.container.scrollHeight : this.h) - this.top, this.domEvents = /* @__PURE__ */ new Map([["mousemove", this.move], ["mouseup", this.up], ["mouseleave", this.up], ["mousedown", this.deselect], ["touchmove", this.move], ["touchend", this.up], ["touchcancel", this.up], ["touchstart", this.up]]), this.domEvents.forEach(function(t5, e4) {
                document.documentElement.addEventListener(e4, t5);
              }), this.dragHandle && e3(this.$el.querySelectorAll(this.dragHandle)).forEach(function(e4) {
                e4.setAttribute("data-drag-handle", t4._uid);
              }), this.dragCancel && e3(this.$el.querySelectorAll(this.dragCancel)).forEach(function(e4) {
                e4.setAttribute("data-drag-cancel", t4._uid);
              });
            }, beforeUnmount: function() {
              this.domEvents.forEach(function(t4, e4) {
                document.documentElement.removeEventListener(e4, t4);
              });
            }, methods: { deselect: function() {
              this.preventActiveBehavior || (this.active = false);
            }, move: function(t4) {
              if (this.stickDrag || this.bodyDrag) {
                t4.stopPropagation();
                var e4 = void 0 !== t4.pageX ? t4.pageX : t4.touches[0].pageX, i4 = void 0 !== t4.pageY ? t4.pageY : t4.touches[0].pageY, n3 = this.dimensionsBeforeMove, o4 = { x: (n3.pointerX - e4) / this.parentScaleX, y: (n3.pointerY - i4) / this.parentScaleY };
                if (this.stickDrag && this.stickMove(o4), this.bodyDrag) {
                  if ("x" === this.axis)
                    o4.y = 0;
                  else if ("y" === this.axis)
                    o4.x = 0;
                  else if ("none" === this.axis)
                    return;
                  this.bodyMove(o4);
                }
              }
            }, up: function(t4) {
              this.stickDrag ? this.stickUp(t4) : this.bodyDrag && this.bodyUp(t4);
            }, bodyDown: function(t4) {
              var e4 = t4.target, i4 = t4.button;
              if (this.preventActiveBehavior || (this.active = true), (!i4 || 0 === i4) && (this.$emit("clicked", t4), this.active && !(this.dragHandle && e4.getAttribute("data-drag-handle") !== this._uid.toString() || this.dragCancel && e4.getAttribute("data-drag-cancel") === this._uid.toString()))) {
                void 0 !== t4.stopPropagation && t4.stopPropagation(), void 0 !== t4.preventDefault && t4.preventDefault(), this.isDraggable && (this.bodyDrag = true);
                var n3 = void 0 !== t4.pageX ? t4.pageX : t4.touches[0].pageX, o4 = void 0 !== t4.pageY ? t4.pageY : t4.touches[0].pageY;
                this.saveDimensionsBeforeMove({ pointerX: n3, pointerY: o4 }), this.parentLimitation && (this.limits = this.calcDragLimitation());
              }
            }, bodyMove: function(t4) {
              var e4 = this.dimensionsBeforeMove, i4 = this.parentWidth, n3 = this.parentHeight, o4 = this.gridX, r3 = this.gridY, a3 = this.width, s3 = this.height, h3 = e4.top - t4.y, c3 = e4.bottom + t4.y, l3 = e4.left - t4.x, u3 = e4.right + t4.x;
              if (this.snapToGrid) {
                var d2 = true, p2 = true, f2 = h3 - Math.floor(h3 / r3) * r3, m2 = n3 - c3 - Math.floor((n3 - c3) / r3) * r3, g2 = l3 - Math.floor(l3 / o4) * o4, v2 = i4 - u3 - Math.floor((i4 - u3) / o4) * o4;
                f2 > r3 / 2 && (f2 -= r3), m2 > r3 / 2 && (m2 -= r3), g2 > o4 / 2 && (g2 -= o4), v2 > o4 / 2 && (v2 -= o4), Math.abs(m2) < Math.abs(f2) && (d2 = false), Math.abs(v2) < Math.abs(g2) && (p2 = false), c3 = n3 - s3 - (h3 -= d2 ? f2 : m2), u3 = i4 - a3 - (l3 -= p2 ? g2 : v2);
              }
              var b2 = this.rectCorrectionByLimit({ newLeft: l3, newRight: u3, newTop: h3, newBottom: c3 });
              this.left = b2.newLeft, this.right = b2.newRight, this.top = b2.newTop, this.bottom = b2.newBottom, this.$emit("dragging", this.rect);
            }, bodyUp: function() {
              this.bodyDrag = false, this.$emit("dragging", this.rect), this.$emit("dragstop", this.rect), this.dimensionsBeforeMove = { pointerX: 0, pointerY: 0, x: 0, y: 0, w: 0, h: 0 }, this.limits = { left: { min: null, max: null }, right: { min: null, max: null }, top: { min: null, max: null }, bottom: { min: null, max: null } };
            }, stickDown: function(t4, e4) {
              var i4 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
              if (this.isResizable && this.active || i4) {
                this.stickDrag = true;
                var n3 = void 0 !== e4.pageX ? e4.pageX : e4.touches[0].pageX, o4 = void 0 !== e4.pageY ? e4.pageY : e4.touches[0].pageY;
                this.saveDimensionsBeforeMove({ pointerX: n3, pointerY: o4 }), this.currentStick = t4, this.limits = this.calcResizeLimits();
              }
            }, saveDimensionsBeforeMove: function(t4) {
              var e4 = t4.pointerX, i4 = t4.pointerY;
              this.dimensionsBeforeMove.pointerX = e4, this.dimensionsBeforeMove.pointerY = i4, this.dimensionsBeforeMove.left = this.left, this.dimensionsBeforeMove.right = this.right, this.dimensionsBeforeMove.top = this.top, this.dimensionsBeforeMove.bottom = this.bottom, this.dimensionsBeforeMove.width = this.width, this.dimensionsBeforeMove.height = this.height, this.aspectFactor = this.width / this.height;
            }, stickMove: function(t4) {
              var e4 = this.currentStick, i4 = this.dimensionsBeforeMove, n3 = this.gridY, o4 = this.gridX, r3 = this.snapToGrid, a3 = this.parentHeight, s3 = this.parentWidth, h3 = i4.top, c3 = i4.bottom, l3 = i4.left, u3 = i4.right;
              switch (e4[0]) {
                case "b":
                  c3 = i4.bottom + t4.y, r3 && (c3 = a3 - Math.round((a3 - c3) / n3) * n3);
                  break;
                case "t":
                  h3 = i4.top - t4.y, r3 && (h3 = Math.round(h3 / n3) * n3);
              }
              switch (e4[1]) {
                case "r":
                  u3 = i4.right + t4.x, r3 && (u3 = s3 - Math.round((s3 - u3) / o4) * o4);
                  break;
                case "l":
                  l3 = i4.left - t4.x, r3 && (l3 = Math.round(l3 / o4) * o4);
              }
              var d2 = this.rectCorrectionByLimit({ newLeft: l3, newRight: u3, newTop: h3, newBottom: c3 });
              if (l3 = d2.newLeft, u3 = d2.newRight, h3 = d2.newTop, c3 = d2.newBottom, this.aspectRatio) {
                var p2 = this.rectCorrectionByAspectRatio({ newLeft: l3, newRight: u3, newTop: h3, newBottom: c3 });
                l3 = p2.newLeft, u3 = p2.newRight, h3 = p2.newTop, c3 = p2.newBottom;
              }
              this.left = l3, this.right = u3, this.top = h3, this.bottom = c3, this.$emit("resizing", this.rect);
            }, stickUp: function() {
              this.stickDrag = false, this.dimensionsBeforeMove = { pointerX: 0, pointerY: 0, x: 0, y: 0, w: 0, h: 0 }, this.limits = { left: { min: null, max: null }, right: { min: null, max: null }, top: { min: null, max: null }, bottom: { min: null, max: null } }, this.$emit("resizing", this.rect), this.$emit("resizestop", this.rect);
            }, calcDragLimitation: function() {
              var t4 = this.parentWidth, e4 = this.parentHeight;
              return { left: { min: 0, max: t4 - this.width }, right: { min: 0, max: t4 - this.width }, top: { min: 0, max: e4 - this.height }, bottom: { min: 0, max: e4 - this.height } };
            }, calcResizeLimits: function() {
              var t4 = this.aspectFactor, e4 = this.width, i4 = this.height, n3 = this.bottom, o4 = this.top, r3 = this.left, a3 = this.right, s3 = this.minh, h3 = this.minw, c3 = this.parentLimitation ? 0 : null;
              this.aspectRatio && (h3 / s3 > t4 ? s3 = h3 / t4 : h3 = t4 * s3);
              var l3 = { left: { min: c3, max: r3 + (e4 - h3) }, right: { min: c3, max: a3 + (e4 - h3) }, top: { min: c3, max: o4 + (i4 - s3) }, bottom: { min: c3, max: n3 + (i4 - s3) } };
              if (this.aspectRatio) {
                var u3 = { left: { min: r3 - Math.min(o4, n3) * t4 * 2, max: r3 + (i4 - s3) / 2 * t4 * 2 }, right: { min: a3 - Math.min(o4, n3) * t4 * 2, max: a3 + (i4 - s3) / 2 * t4 * 2 }, top: { min: o4 - Math.min(r3, a3) / t4 * 2, max: o4 + (e4 - h3) / 2 / t4 * 2 }, bottom: { min: n3 - Math.min(r3, a3) / t4 * 2, max: n3 + (e4 - h3) / 2 / t4 * 2 } };
                "m" === this.currentStick[0] ? (l3.left = { min: Math.max(l3.left.min, u3.left.min), max: Math.min(l3.left.max, u3.left.max) }, l3.right = { min: Math.max(l3.right.min, u3.right.min), max: Math.min(l3.right.max, u3.right.max) }) : "m" === this.currentStick[1] && (l3.top = { min: Math.max(l3.top.min, u3.top.min), max: Math.min(l3.top.max, u3.top.max) }, l3.bottom = { min: Math.max(l3.bottom.min, u3.bottom.min), max: Math.min(l3.bottom.max, u3.bottom.max) });
              }
              return l3;
            }, sideCorrectionByLimit: function(t4, e4) {
              var i4 = e4;
              return null !== t4.min && e4 < t4.min ? i4 = t4.min : null !== t4.max && t4.max < e4 && (i4 = t4.max), i4;
            }, rectCorrectionByLimit: function(t4) {
              var e4 = this.limits, i4 = t4.newRight, n3 = t4.newLeft, o4 = t4.newBottom, r3 = t4.newTop;
              return { newLeft: n3 = this.sideCorrectionByLimit(e4.left, n3), newRight: i4 = this.sideCorrectionByLimit(e4.right, i4), newTop: r3 = this.sideCorrectionByLimit(e4.top, r3), newBottom: o4 = this.sideCorrectionByLimit(e4.bottom, o4) };
            }, rectCorrectionByAspectRatio: function(t4) {
              var e4 = t4.newLeft, i4 = t4.newRight, n3 = t4.newTop, o4 = t4.newBottom, r3 = this.parentWidth, a3 = this.parentHeight, s3 = this.currentStick, h3 = this.aspectFactor, c3 = this.dimensionsBeforeMove, l3 = r3 - e4 - i4, u3 = a3 - n3 - o4;
              if ("m" === s3[1]) {
                var d2 = u3 - c3.height;
                e4 -= d2 * h3 / 2, i4 -= d2 * h3 / 2;
              } else if ("m" === s3[0]) {
                var p2 = l3 - c3.width;
                n3 -= p2 / h3 / 2, o4 -= p2 / h3 / 2;
              } else
                l3 / u3 > h3 ? (l3 = h3 * u3, "l" === s3[1] ? e4 = r3 - i4 - l3 : i4 = r3 - e4 - l3) : (u3 = l3 / h3, "t" === s3[0] ? n3 = a3 - o4 - u3 : o4 = a3 - n3 - u3);
              return { newLeft: e4, newRight: i4, newTop: n3, newBottom: o4 };
            } }, computed: { positionStyle: function() {
              return { top: this.top + "px", left: this.left + "px", zIndex: this.zIndex };
            }, sizeStyle: function() {
              return { width: this.width + "px", height: this.height + "px" };
            }, vdrStick: function() {
              var t4 = this;
              return function(e4) {
                var i4 = { width: "".concat(t4.stickSize / t4.parentScaleX, "px"), height: "".concat(t4.stickSize / t4.parentScaleY, "px") };
                return i4[r2[e4[0]]] = "".concat(t4.stickSize / t4.parentScaleX / -2, "px"), i4[a2[e4[1]]] = "".concat(t4.stickSize / t4.parentScaleX / -2, "px"), i4;
              };
            }, width: function() {
              return this.parentWidth - this.left - this.right;
            }, height: function() {
              return this.parentHeight - this.top - this.bottom;
            }, rect: function() {
              return { left: Math.round(this.left), top: Math.round(this.top), width: Math.round(this.width), height: Math.round(this.height) };
            } }, watch: { active: function(t4) {
              t4 ? this.$emit("activated") : this.$emit("deactivated");
            }, isActive: { immediate: true, handler: function(t4) {
              this.active = t4;
            } }, z: { immediate: true, handler: function(t4) {
              (t4 >= 0 || "auto" === t4) && (this.zIndex = t4);
            } }, x: { handler: function(t4, e4) {
              var i4 = this;
              if (!this.stickDrag && !this.bodyDrag && t4 !== this.left) {
                var n3 = e4 - t4;
                this.bodyDown({ pageX: this.left, pageY: this.top }), this.bodyMove({ x: n3, y: 0 }), this.$nextTick(function() {
                  i4.bodyUp();
                });
              }
            } }, y: { handler: function(t4, e4) {
              var i4 = this;
              if (!this.stickDrag && !this.bodyDrag && t4 !== this.top) {
                var n3 = e4 - t4;
                this.bodyDown({ pageX: this.left, pageY: this.top }), this.bodyMove({ x: 0, y: n3 }), this.$nextTick(function() {
                  i4.bodyUp();
                });
              }
            } }, w: { handler: function(t4, e4) {
              var i4 = this;
              if (!this.stickDrag && !this.bodyDrag && t4 !== this.width) {
                var n3 = e4 - t4;
                this.stickDown("mr", { pageX: this.right, pageY: this.top + this.height / 2 }, true), this.stickMove({ x: n3, y: 0 }), this.$nextTick(function() {
                  i4.stickUp();
                });
              }
            } }, h: { handler: function(t4, e4) {
              var i4 = this;
              if (!this.stickDrag && !this.bodyDrag && t4 !== this.height) {
                var n3 = e4 - t4;
                this.stickDown("bm", { pageX: this.left + this.width / 2, pageY: this.bottom }, true), this.stickMove({ x: 0, y: n3 }), this.$nextTick(function() {
                  i4.stickUp();
                });
              }
            } }, parentW: function(t4) {
              this.right = t4 - this.width - this.left, this.parentWidth = t4;
            }, parentH: function(t4) {
              this.bottom = t4 - this.height - this.top, this.parentHeight = t4;
            } } };
            var h2 = n2(379), c2 = n2.n(h2), l2 = n2(566);
            c2()(l2.Z, { insert: "head", singleton: false }), l2.Z.locals, s2.render = function(e4, i4) {
              return (0, t3.openBlock)(), (0, t3.createBlock)("div", { class: ["vdr", "".concat(e4.active || e4.isActive ? "active" : "inactive", " ").concat(e4.contentClass ? e4.contentClass : "")], style: e4.positionStyle, onMousedown: i4[1] || (i4[1] = function(t4) {
                return e4.bodyDown(t4);
              }), onTouchstart: i4[2] || (i4[2] = function(t4) {
                return e4.bodyDown(t4);
              }), onTouchend: i4[3] || (i4[3] = function(t4) {
                return e4.up(t4);
              }), ref: "container", tabindex: "0" }, [(0, t3.createVNode)("div", { style: e4.sizeStyle, class: "content-container", ref: "container2" }, [(0, t3.renderSlot)(e4.$slots, "default")], 4), ((0, t3.openBlock)(true), (0, t3.createBlock)(t3.Fragment, null, (0, t3.renderList)(e4.sticks, function(i5) {
                return (0, t3.openBlock)(), (0, t3.createBlock)("div", { class: ["vdr-stick", ["vdr-stick-" + i5, e4.isResizable ? "" : "not-resizable"]], onMousedown: (0, t3.withModifiers)(function(t4) {
                  return e4.stickDown(i5, t4);
                }, ["stop", "prevent"]), onTouchstart: (0, t3.withModifiers)(function(t4) {
                  return e4.stickDown(i5, t4);
                }, ["stop", "prevent"]), style: e4.vdrStick(i5) }, null, 46, ["onMousedown", "onTouchstart"]);
              }), 256))], 38);
            };
            const u2 = s2;
          })(), o3;
        })();
      });
    })(dist);
    var distExports = dist.exports;
    const VueDragResize = /* @__PURE__ */ getDefaultExportFromCjs(distExports);
    function _typeof$7(obj) {
      "@babel/helpers - typeof";
      return _typeof$7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof$7(obj);
    }
    var trimLeft = /^\s+/;
    var trimRight = /\s+$/;
    function tinycolor$1(color, opts) {
      color = color ? color : "";
      opts = opts || {};
      if (color instanceof tinycolor$1) {
        return color;
      }
      if (!(this instanceof tinycolor$1)) {
        return new tinycolor$1(color, opts);
      }
      var rgb = inputToRGB$1(color);
      this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb.format;
      this._gradientType = opts.gradientType;
      if (this._r < 1)
        this._r = Math.round(this._r);
      if (this._g < 1)
        this._g = Math.round(this._g);
      if (this._b < 1)
        this._b = Math.round(this._b);
      this._ok = rgb.ok;
    }
    tinycolor$1.prototype = {
      isDark: function isDark() {
        return this.getBrightness() < 128;
      },
      isLight: function isLight() {
        return !this.isDark();
      },
      isValid: function isValid() {
        return this._ok;
      },
      getOriginalInput: function getOriginalInput() {
        return this._originalInput;
      },
      getFormat: function getFormat() {
        return this._format;
      },
      getAlpha: function getAlpha() {
        return this._a;
      },
      getBrightness: function getBrightness() {
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
      },
      getLuminance: function getLuminance() {
        var rgb = this.toRgb();
        var RsRGB, GsRGB, BsRGB, R2, G2, B2;
        RsRGB = rgb.r / 255;
        GsRGB = rgb.g / 255;
        BsRGB = rgb.b / 255;
        if (RsRGB <= 0.03928)
          R2 = RsRGB / 12.92;
        else
          R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
        if (GsRGB <= 0.03928)
          G2 = GsRGB / 12.92;
        else
          G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
        if (BsRGB <= 0.03928)
          B2 = BsRGB / 12.92;
        else
          B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
        return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
      },
      setAlpha: function setAlpha(value) {
        this._a = boundAlpha$1(value);
        this._roundA = Math.round(100 * this._a) / 100;
        return this;
      },
      toHsv: function toHsv() {
        var hsv = rgbToHsv$1(this._r, this._g, this._b);
        return {
          h: hsv.h * 360,
          s: hsv.s,
          v: hsv.v,
          a: this._a
        };
      },
      toHsvString: function toHsvString() {
        var hsv = rgbToHsv$1(this._r, this._g, this._b);
        var h2 = Math.round(hsv.h * 360), s2 = Math.round(hsv.s * 100), v2 = Math.round(hsv.v * 100);
        return this._a == 1 ? "hsv(" + h2 + ", " + s2 + "%, " + v2 + "%)" : "hsva(" + h2 + ", " + s2 + "%, " + v2 + "%, " + this._roundA + ")";
      },
      toHsl: function toHsl() {
        var hsl = rgbToHsl$1(this._r, this._g, this._b);
        return {
          h: hsl.h * 360,
          s: hsl.s,
          l: hsl.l,
          a: this._a
        };
      },
      toHslString: function toHslString() {
        var hsl = rgbToHsl$1(this._r, this._g, this._b);
        var h2 = Math.round(hsl.h * 360), s2 = Math.round(hsl.s * 100), l2 = Math.round(hsl.l * 100);
        return this._a == 1 ? "hsl(" + h2 + ", " + s2 + "%, " + l2 + "%)" : "hsla(" + h2 + ", " + s2 + "%, " + l2 + "%, " + this._roundA + ")";
      },
      toHex: function toHex(allow3Char) {
        return rgbToHex$1(this._r, this._g, this._b, allow3Char);
      },
      toHexString: function toHexString(allow3Char) {
        return "#" + this.toHex(allow3Char);
      },
      toHex8: function toHex8(allow4Char) {
        return rgbaToHex$1(this._r, this._g, this._b, this._a, allow4Char);
      },
      toHex8String: function toHex8String(allow4Char) {
        return "#" + this.toHex8(allow4Char);
      },
      toRgb: function toRgb() {
        return {
          r: Math.round(this._r),
          g: Math.round(this._g),
          b: Math.round(this._b),
          a: this._a
        };
      },
      toRgbString: function toRgbString() {
        return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
      },
      toPercentageRgb: function toPercentageRgb() {
        return {
          r: Math.round(bound01$1(this._r, 255) * 100) + "%",
          g: Math.round(bound01$1(this._g, 255) * 100) + "%",
          b: Math.round(bound01$1(this._b, 255) * 100) + "%",
          a: this._a
        };
      },
      toPercentageRgbString: function toPercentageRgbString() {
        return this._a == 1 ? "rgb(" + Math.round(bound01$1(this._r, 255) * 100) + "%, " + Math.round(bound01$1(this._g, 255) * 100) + "%, " + Math.round(bound01$1(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01$1(this._r, 255) * 100) + "%, " + Math.round(bound01$1(this._g, 255) * 100) + "%, " + Math.round(bound01$1(this._b, 255) * 100) + "%, " + this._roundA + ")";
      },
      toName: function toName() {
        if (this._a === 0) {
          return "transparent";
        }
        if (this._a < 1) {
          return false;
        }
        return hexNames[rgbToHex$1(this._r, this._g, this._b, true)] || false;
      },
      toFilter: function toFilter(secondColor) {
        var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
        var secondHex8String = hex8String;
        var gradientType = this._gradientType ? "GradientType = 1, " : "";
        if (secondColor) {
          var s2 = tinycolor$1(secondColor);
          secondHex8String = "#" + rgbaToArgbHex(s2._r, s2._g, s2._b, s2._a);
        }
        return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
      },
      toString: function toString2(format2) {
        var formatSet = !!format2;
        format2 = format2 || this._format;
        var formattedString = false;
        var hasAlpha = this._a < 1 && this._a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format2 === "hex" || format2 === "hex6" || format2 === "hex3" || format2 === "hex4" || format2 === "hex8" || format2 === "name");
        if (needsAlphaFormat) {
          if (format2 === "name" && this._a === 0) {
            return this.toName();
          }
          return this.toRgbString();
        }
        if (format2 === "rgb") {
          formattedString = this.toRgbString();
        }
        if (format2 === "prgb") {
          formattedString = this.toPercentageRgbString();
        }
        if (format2 === "hex" || format2 === "hex6") {
          formattedString = this.toHexString();
        }
        if (format2 === "hex3") {
          formattedString = this.toHexString(true);
        }
        if (format2 === "hex4") {
          formattedString = this.toHex8String(true);
        }
        if (format2 === "hex8") {
          formattedString = this.toHex8String();
        }
        if (format2 === "name") {
          formattedString = this.toName();
        }
        if (format2 === "hsl") {
          formattedString = this.toHslString();
        }
        if (format2 === "hsv") {
          formattedString = this.toHsvString();
        }
        return formattedString || this.toHexString();
      },
      clone: function clone2() {
        return tinycolor$1(this.toString());
      },
      _applyModification: function _applyModification(fn2, args) {
        var color = fn2.apply(null, [this].concat([].slice.call(args)));
        this._r = color._r;
        this._g = color._g;
        this._b = color._b;
        this.setAlpha(color._a);
        return this;
      },
      lighten: function lighten() {
        return this._applyModification(_lighten, arguments);
      },
      brighten: function brighten() {
        return this._applyModification(_brighten, arguments);
      },
      darken: function darken() {
        return this._applyModification(_darken, arguments);
      },
      desaturate: function desaturate() {
        return this._applyModification(_desaturate, arguments);
      },
      saturate: function saturate() {
        return this._applyModification(_saturate, arguments);
      },
      greyscale: function greyscale() {
        return this._applyModification(_greyscale, arguments);
      },
      spin: function spin() {
        return this._applyModification(_spin, arguments);
      },
      _applyCombination: function _applyCombination(fn2, args) {
        return fn2.apply(null, [this].concat([].slice.call(args)));
      },
      analogous: function analogous() {
        return this._applyCombination(_analogous, arguments);
      },
      complement: function complement() {
        return this._applyCombination(_complement, arguments);
      },
      monochromatic: function monochromatic() {
        return this._applyCombination(_monochromatic, arguments);
      },
      splitcomplement: function splitcomplement() {
        return this._applyCombination(_splitcomplement, arguments);
      },
      // Disabled until https://github.com/bgrins/TinyColor/issues/254
      // polyad: function (number) {
      //   return this._applyCombination(polyad, [number]);
      // },
      triad: function triad() {
        return this._applyCombination(polyad, [3]);
      },
      tetrad: function tetrad() {
        return this._applyCombination(polyad, [4]);
      }
    };
    tinycolor$1.fromRatio = function(color, opts) {
      if (_typeof$7(color) == "object") {
        var newColor = {};
        for (var i2 in color) {
          if (color.hasOwnProperty(i2)) {
            if (i2 === "a") {
              newColor[i2] = color[i2];
            } else {
              newColor[i2] = convertToPercentage$1(color[i2]);
            }
          }
        }
        color = newColor;
      }
      return tinycolor$1(color, opts);
    };
    function inputToRGB$1(color) {
      var rgb = {
        r: 0,
        g: 0,
        b: 0
      };
      var a2 = 1;
      var s2 = null;
      var v2 = null;
      var l2 = null;
      var ok2 = false;
      var format2 = false;
      if (typeof color == "string") {
        color = stringInputToObject$1(color);
      }
      if (_typeof$7(color) == "object") {
        if (isValidCSSUnit$1(color.r) && isValidCSSUnit$1(color.g) && isValidCSSUnit$1(color.b)) {
          rgb = rgbToRgb$1(color.r, color.g, color.b);
          ok2 = true;
          format2 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        } else if (isValidCSSUnit$1(color.h) && isValidCSSUnit$1(color.s) && isValidCSSUnit$1(color.v)) {
          s2 = convertToPercentage$1(color.s);
          v2 = convertToPercentage$1(color.v);
          rgb = hsvToRgb$1(color.h, s2, v2);
          ok2 = true;
          format2 = "hsv";
        } else if (isValidCSSUnit$1(color.h) && isValidCSSUnit$1(color.s) && isValidCSSUnit$1(color.l)) {
          s2 = convertToPercentage$1(color.s);
          l2 = convertToPercentage$1(color.l);
          rgb = hslToRgb$1(color.h, s2, l2);
          ok2 = true;
          format2 = "hsl";
        }
        if (color.hasOwnProperty("a")) {
          a2 = color.a;
        }
      }
      a2 = boundAlpha$1(a2);
      return {
        ok: ok2,
        format: color.format || format2,
        r: Math.min(255, Math.max(rgb.r, 0)),
        g: Math.min(255, Math.max(rgb.g, 0)),
        b: Math.min(255, Math.max(rgb.b, 0)),
        a: a2
      };
    }
    function rgbToRgb$1(r2, g2, b2) {
      return {
        r: bound01$1(r2, 255) * 255,
        g: bound01$1(g2, 255) * 255,
        b: bound01$1(b2, 255) * 255
      };
    }
    function rgbToHsl$1(r2, g2, b2) {
      r2 = bound01$1(r2, 255);
      g2 = bound01$1(g2, 255);
      b2 = bound01$1(b2, 255);
      var max2 = Math.max(r2, g2, b2), min2 = Math.min(r2, g2, b2);
      var h2, s2, l2 = (max2 + min2) / 2;
      if (max2 == min2) {
        h2 = s2 = 0;
      } else {
        var d2 = max2 - min2;
        s2 = l2 > 0.5 ? d2 / (2 - max2 - min2) : d2 / (max2 + min2);
        switch (max2) {
          case r2:
            h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
            break;
          case g2:
            h2 = (b2 - r2) / d2 + 2;
            break;
          case b2:
            h2 = (r2 - g2) / d2 + 4;
            break;
        }
        h2 /= 6;
      }
      return {
        h: h2,
        s: s2,
        l: l2
      };
    }
    function hslToRgb$1(h2, s2, l2) {
      var r2, g2, b2;
      h2 = bound01$1(h2, 360);
      s2 = bound01$1(s2, 100);
      l2 = bound01$1(l2, 100);
      function hue2rgb2(p3, q3, t2) {
        if (t2 < 0)
          t2 += 1;
        if (t2 > 1)
          t2 -= 1;
        if (t2 < 1 / 6)
          return p3 + (q3 - p3) * 6 * t2;
        if (t2 < 1 / 2)
          return q3;
        if (t2 < 2 / 3)
          return p3 + (q3 - p3) * (2 / 3 - t2) * 6;
        return p3;
      }
      if (s2 === 0) {
        r2 = g2 = b2 = l2;
      } else {
        var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
        var p2 = 2 * l2 - q2;
        r2 = hue2rgb2(p2, q2, h2 + 1 / 3);
        g2 = hue2rgb2(p2, q2, h2);
        b2 = hue2rgb2(p2, q2, h2 - 1 / 3);
      }
      return {
        r: r2 * 255,
        g: g2 * 255,
        b: b2 * 255
      };
    }
    function rgbToHsv$1(r2, g2, b2) {
      r2 = bound01$1(r2, 255);
      g2 = bound01$1(g2, 255);
      b2 = bound01$1(b2, 255);
      var max2 = Math.max(r2, g2, b2), min2 = Math.min(r2, g2, b2);
      var h2, s2, v2 = max2;
      var d2 = max2 - min2;
      s2 = max2 === 0 ? 0 : d2 / max2;
      if (max2 == min2) {
        h2 = 0;
      } else {
        switch (max2) {
          case r2:
            h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
            break;
          case g2:
            h2 = (b2 - r2) / d2 + 2;
            break;
          case b2:
            h2 = (r2 - g2) / d2 + 4;
            break;
        }
        h2 /= 6;
      }
      return {
        h: h2,
        s: s2,
        v: v2
      };
    }
    function hsvToRgb$1(h2, s2, v2) {
      h2 = bound01$1(h2, 360) * 6;
      s2 = bound01$1(s2, 100);
      v2 = bound01$1(v2, 100);
      var i2 = Math.floor(h2), f2 = h2 - i2, p2 = v2 * (1 - s2), q2 = v2 * (1 - f2 * s2), t2 = v2 * (1 - (1 - f2) * s2), mod = i2 % 6, r2 = [v2, q2, p2, p2, t2, v2][mod], g2 = [t2, v2, v2, q2, p2, p2][mod], b2 = [p2, p2, t2, v2, v2, q2][mod];
      return {
        r: r2 * 255,
        g: g2 * 255,
        b: b2 * 255
      };
    }
    function rgbToHex$1(r2, g2, b2, allow3Char) {
      var hex = [pad2$1(Math.round(r2).toString(16)), pad2$1(Math.round(g2).toString(16)), pad2$1(Math.round(b2).toString(16))];
      if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
      }
      return hex.join("");
    }
    function rgbaToHex$1(r2, g2, b2, a2, allow4Char) {
      var hex = [pad2$1(Math.round(r2).toString(16)), pad2$1(Math.round(g2).toString(16)), pad2$1(Math.round(b2).toString(16)), pad2$1(convertDecimalToHex$1(a2))];
      if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
      }
      return hex.join("");
    }
    function rgbaToArgbHex(r2, g2, b2, a2) {
      var hex = [pad2$1(convertDecimalToHex$1(a2)), pad2$1(Math.round(r2).toString(16)), pad2$1(Math.round(g2).toString(16)), pad2$1(Math.round(b2).toString(16))];
      return hex.join("");
    }
    tinycolor$1.equals = function(color1, color2) {
      if (!color1 || !color2)
        return false;
      return tinycolor$1(color1).toRgbString() == tinycolor$1(color2).toRgbString();
    };
    tinycolor$1.random = function() {
      return tinycolor$1.fromRatio({
        r: Math.random(),
        g: Math.random(),
        b: Math.random()
      });
    };
    function _desaturate(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor$1(color).toHsl();
      hsl.s -= amount / 100;
      hsl.s = clamp01$1(hsl.s);
      return tinycolor$1(hsl);
    }
    function _saturate(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor$1(color).toHsl();
      hsl.s += amount / 100;
      hsl.s = clamp01$1(hsl.s);
      return tinycolor$1(hsl);
    }
    function _greyscale(color) {
      return tinycolor$1(color).desaturate(100);
    }
    function _lighten(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor$1(color).toHsl();
      hsl.l += amount / 100;
      hsl.l = clamp01$1(hsl.l);
      return tinycolor$1(hsl);
    }
    function _brighten(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var rgb = tinycolor$1(color).toRgb();
      rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
      rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
      rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
      return tinycolor$1(rgb);
    }
    function _darken(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor$1(color).toHsl();
      hsl.l -= amount / 100;
      hsl.l = clamp01$1(hsl.l);
      return tinycolor$1(hsl);
    }
    function _spin(color, amount) {
      var hsl = tinycolor$1(color).toHsl();
      var hue = (hsl.h + amount) % 360;
      hsl.h = hue < 0 ? 360 + hue : hue;
      return tinycolor$1(hsl);
    }
    function _complement(color) {
      var hsl = tinycolor$1(color).toHsl();
      hsl.h = (hsl.h + 180) % 360;
      return tinycolor$1(hsl);
    }
    function polyad(color, number2) {
      if (isNaN(number2) || number2 <= 0) {
        throw new Error("Argument to polyad must be a positive number");
      }
      var hsl = tinycolor$1(color).toHsl();
      var result = [tinycolor$1(color)];
      var step = 360 / number2;
      for (var i2 = 1; i2 < number2; i2++) {
        result.push(tinycolor$1({
          h: (hsl.h + i2 * step) % 360,
          s: hsl.s,
          l: hsl.l
        }));
      }
      return result;
    }
    function _splitcomplement(color) {
      var hsl = tinycolor$1(color).toHsl();
      var h2 = hsl.h;
      return [tinycolor$1(color), tinycolor$1({
        h: (h2 + 72) % 360,
        s: hsl.s,
        l: hsl.l
      }), tinycolor$1({
        h: (h2 + 216) % 360,
        s: hsl.s,
        l: hsl.l
      })];
    }
    function _analogous(color, results, slices) {
      results = results || 6;
      slices = slices || 30;
      var hsl = tinycolor$1(color).toHsl();
      var part = 360 / slices;
      var ret = [tinycolor$1(color)];
      for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(tinycolor$1(hsl));
      }
      return ret;
    }
    function _monochromatic(color, results) {
      results = results || 6;
      var hsv = tinycolor$1(color).toHsv();
      var h2 = hsv.h, s2 = hsv.s, v2 = hsv.v;
      var ret = [];
      var modification = 1 / results;
      while (results--) {
        ret.push(tinycolor$1({
          h: h2,
          s: s2,
          v: v2
        }));
        v2 = (v2 + modification) % 1;
      }
      return ret;
    }
    tinycolor$1.mix = function(color1, color2, amount) {
      amount = amount === 0 ? 0 : amount || 50;
      var rgb1 = tinycolor$1(color1).toRgb();
      var rgb2 = tinycolor$1(color2).toRgb();
      var p2 = amount / 100;
      var rgba = {
        r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
        g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
        b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
        a: (rgb2.a - rgb1.a) * p2 + rgb1.a
      };
      return tinycolor$1(rgba);
    };
    tinycolor$1.readability = function(color1, color2) {
      var c1 = tinycolor$1(color1);
      var c2 = tinycolor$1(color2);
      return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
    };
    tinycolor$1.isReadable = function(color1, color2, wcag2) {
      var readability = tinycolor$1.readability(color1, color2);
      var wcag2Parms, out;
      out = false;
      wcag2Parms = validateWCAG2Parms(wcag2);
      switch (wcag2Parms.level + wcag2Parms.size) {
        case "AAsmall":
        case "AAAlarge":
          out = readability >= 4.5;
          break;
        case "AAlarge":
          out = readability >= 3;
          break;
        case "AAAsmall":
          out = readability >= 7;
          break;
      }
      return out;
    };
    tinycolor$1.mostReadable = function(baseColor, colorList, args) {
      var bestColor = null;
      var bestScore = 0;
      var readability;
      var includeFallbackColors, level, size2;
      args = args || {};
      includeFallbackColors = args.includeFallbackColors;
      level = args.level;
      size2 = args.size;
      for (var i2 = 0; i2 < colorList.length; i2++) {
        readability = tinycolor$1.readability(baseColor, colorList[i2]);
        if (readability > bestScore) {
          bestScore = readability;
          bestColor = tinycolor$1(colorList[i2]);
        }
      }
      if (tinycolor$1.isReadable(baseColor, bestColor, {
        level,
        size: size2
      }) || !includeFallbackColors) {
        return bestColor;
      } else {
        args.includeFallbackColors = false;
        return tinycolor$1.mostReadable(baseColor, ["#fff", "#000"], args);
      }
    };
    var names$1 = tinycolor$1.names = {
      aliceblue: "f0f8ff",
      antiquewhite: "faebd7",
      aqua: "0ff",
      aquamarine: "7fffd4",
      azure: "f0ffff",
      beige: "f5f5dc",
      bisque: "ffe4c4",
      black: "000",
      blanchedalmond: "ffebcd",
      blue: "00f",
      blueviolet: "8a2be2",
      brown: "a52a2a",
      burlywood: "deb887",
      burntsienna: "ea7e5d",
      cadetblue: "5f9ea0",
      chartreuse: "7fff00",
      chocolate: "d2691e",
      coral: "ff7f50",
      cornflowerblue: "6495ed",
      cornsilk: "fff8dc",
      crimson: "dc143c",
      cyan: "0ff",
      darkblue: "00008b",
      darkcyan: "008b8b",
      darkgoldenrod: "b8860b",
      darkgray: "a9a9a9",
      darkgreen: "006400",
      darkgrey: "a9a9a9",
      darkkhaki: "bdb76b",
      darkmagenta: "8b008b",
      darkolivegreen: "556b2f",
      darkorange: "ff8c00",
      darkorchid: "9932cc",
      darkred: "8b0000",
      darksalmon: "e9967a",
      darkseagreen: "8fbc8f",
      darkslateblue: "483d8b",
      darkslategray: "2f4f4f",
      darkslategrey: "2f4f4f",
      darkturquoise: "00ced1",
      darkviolet: "9400d3",
      deeppink: "ff1493",
      deepskyblue: "00bfff",
      dimgray: "696969",
      dimgrey: "696969",
      dodgerblue: "1e90ff",
      firebrick: "b22222",
      floralwhite: "fffaf0",
      forestgreen: "228b22",
      fuchsia: "f0f",
      gainsboro: "dcdcdc",
      ghostwhite: "f8f8ff",
      gold: "ffd700",
      goldenrod: "daa520",
      gray: "808080",
      green: "008000",
      greenyellow: "adff2f",
      grey: "808080",
      honeydew: "f0fff0",
      hotpink: "ff69b4",
      indianred: "cd5c5c",
      indigo: "4b0082",
      ivory: "fffff0",
      khaki: "f0e68c",
      lavender: "e6e6fa",
      lavenderblush: "fff0f5",
      lawngreen: "7cfc00",
      lemonchiffon: "fffacd",
      lightblue: "add8e6",
      lightcoral: "f08080",
      lightcyan: "e0ffff",
      lightgoldenrodyellow: "fafad2",
      lightgray: "d3d3d3",
      lightgreen: "90ee90",
      lightgrey: "d3d3d3",
      lightpink: "ffb6c1",
      lightsalmon: "ffa07a",
      lightseagreen: "20b2aa",
      lightskyblue: "87cefa",
      lightslategray: "789",
      lightslategrey: "789",
      lightsteelblue: "b0c4de",
      lightyellow: "ffffe0",
      lime: "0f0",
      limegreen: "32cd32",
      linen: "faf0e6",
      magenta: "f0f",
      maroon: "800000",
      mediumaquamarine: "66cdaa",
      mediumblue: "0000cd",
      mediumorchid: "ba55d3",
      mediumpurple: "9370db",
      mediumseagreen: "3cb371",
      mediumslateblue: "7b68ee",
      mediumspringgreen: "00fa9a",
      mediumturquoise: "48d1cc",
      mediumvioletred: "c71585",
      midnightblue: "191970",
      mintcream: "f5fffa",
      mistyrose: "ffe4e1",
      moccasin: "ffe4b5",
      navajowhite: "ffdead",
      navy: "000080",
      oldlace: "fdf5e6",
      olive: "808000",
      olivedrab: "6b8e23",
      orange: "ffa500",
      orangered: "ff4500",
      orchid: "da70d6",
      palegoldenrod: "eee8aa",
      palegreen: "98fb98",
      paleturquoise: "afeeee",
      palevioletred: "db7093",
      papayawhip: "ffefd5",
      peachpuff: "ffdab9",
      peru: "cd853f",
      pink: "ffc0cb",
      plum: "dda0dd",
      powderblue: "b0e0e6",
      purple: "800080",
      rebeccapurple: "663399",
      red: "f00",
      rosybrown: "bc8f8f",
      royalblue: "4169e1",
      saddlebrown: "8b4513",
      salmon: "fa8072",
      sandybrown: "f4a460",
      seagreen: "2e8b57",
      seashell: "fff5ee",
      sienna: "a0522d",
      silver: "c0c0c0",
      skyblue: "87ceeb",
      slateblue: "6a5acd",
      slategray: "708090",
      slategrey: "708090",
      snow: "fffafa",
      springgreen: "00ff7f",
      steelblue: "4682b4",
      tan: "d2b48c",
      teal: "008080",
      thistle: "d8bfd8",
      tomato: "ff6347",
      turquoise: "40e0d0",
      violet: "ee82ee",
      wheat: "f5deb3",
      white: "fff",
      whitesmoke: "f5f5f5",
      yellow: "ff0",
      yellowgreen: "9acd32"
    };
    var hexNames = tinycolor$1.hexNames = flip$3(names$1);
    function flip$3(o3) {
      var flipped = {};
      for (var i2 in o3) {
        if (o3.hasOwnProperty(i2)) {
          flipped[o3[i2]] = i2;
        }
      }
      return flipped;
    }
    function boundAlpha$1(a2) {
      a2 = parseFloat(a2);
      if (isNaN(a2) || a2 < 0 || a2 > 1) {
        a2 = 1;
      }
      return a2;
    }
    function bound01$1(n2, max2) {
      if (isOnePointZero$1(n2))
        n2 = "100%";
      var processPercent = isPercentage$1(n2);
      n2 = Math.min(max2, Math.max(0, parseFloat(n2)));
      if (processPercent) {
        n2 = parseInt(n2 * max2, 10) / 100;
      }
      if (Math.abs(n2 - max2) < 1e-6) {
        return 1;
      }
      return n2 % max2 / parseFloat(max2);
    }
    function clamp01$1(val) {
      return Math.min(1, Math.max(0, val));
    }
    function parseIntFromHex$1(val) {
      return parseInt(val, 16);
    }
    function isOnePointZero$1(n2) {
      return typeof n2 == "string" && n2.indexOf(".") != -1 && parseFloat(n2) === 1;
    }
    function isPercentage$1(n2) {
      return typeof n2 === "string" && n2.indexOf("%") != -1;
    }
    function pad2$1(c2) {
      return c2.length == 1 ? "0" + c2 : "" + c2;
    }
    function convertToPercentage$1(n2) {
      if (n2 <= 1) {
        n2 = n2 * 100 + "%";
      }
      return n2;
    }
    function convertDecimalToHex$1(d2) {
      return Math.round(parseFloat(d2) * 255).toString(16);
    }
    function convertHexToDecimal$1(h2) {
      return parseIntFromHex$1(h2) / 255;
    }
    var matchers$1 = function() {
      var CSS_INTEGER2 = "[-\\+]?\\d+%?";
      var CSS_NUMBER2 = "[-\\+]?\\d*\\.\\d+%?";
      var CSS_UNIT2 = "(?:" + CSS_NUMBER2 + ")|(?:" + CSS_INTEGER2 + ")";
      var PERMISSIVE_MATCH32 = "[\\s|\\(]+(" + CSS_UNIT2 + ")[,|\\s]+(" + CSS_UNIT2 + ")[,|\\s]+(" + CSS_UNIT2 + ")\\s*\\)?";
      var PERMISSIVE_MATCH42 = "[\\s|\\(]+(" + CSS_UNIT2 + ")[,|\\s]+(" + CSS_UNIT2 + ")[,|\\s]+(" + CSS_UNIT2 + ")[,|\\s]+(" + CSS_UNIT2 + ")\\s*\\)?";
      return {
        CSS_UNIT: new RegExp(CSS_UNIT2),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH32),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH42),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH32),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH42),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH32),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH42),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
      };
    }();
    function isValidCSSUnit$1(color) {
      return !!matchers$1.CSS_UNIT.exec(color);
    }
    function stringInputToObject$1(color) {
      color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
      var named = false;
      if (names$1[color]) {
        color = names$1[color];
        named = true;
      } else if (color == "transparent") {
        return {
          r: 0,
          g: 0,
          b: 0,
          a: 0,
          format: "name"
        };
      }
      var match;
      if (match = matchers$1.rgb.exec(color)) {
        return {
          r: match[1],
          g: match[2],
          b: match[3]
        };
      }
      if (match = matchers$1.rgba.exec(color)) {
        return {
          r: match[1],
          g: match[2],
          b: match[3],
          a: match[4]
        };
      }
      if (match = matchers$1.hsl.exec(color)) {
        return {
          h: match[1],
          s: match[2],
          l: match[3]
        };
      }
      if (match = matchers$1.hsla.exec(color)) {
        return {
          h: match[1],
          s: match[2],
          l: match[3],
          a: match[4]
        };
      }
      if (match = matchers$1.hsv.exec(color)) {
        return {
          h: match[1],
          s: match[2],
          v: match[3]
        };
      }
      if (match = matchers$1.hsva.exec(color)) {
        return {
          h: match[1],
          s: match[2],
          v: match[3],
          a: match[4]
        };
      }
      if (match = matchers$1.hex8.exec(color)) {
        return {
          r: parseIntFromHex$1(match[1]),
          g: parseIntFromHex$1(match[2]),
          b: parseIntFromHex$1(match[3]),
          a: convertHexToDecimal$1(match[4]),
          format: named ? "name" : "hex8"
        };
      }
      if (match = matchers$1.hex6.exec(color)) {
        return {
          r: parseIntFromHex$1(match[1]),
          g: parseIntFromHex$1(match[2]),
          b: parseIntFromHex$1(match[3]),
          format: named ? "name" : "hex"
        };
      }
      if (match = matchers$1.hex4.exec(color)) {
        return {
          r: parseIntFromHex$1(match[1] + "" + match[1]),
          g: parseIntFromHex$1(match[2] + "" + match[2]),
          b: parseIntFromHex$1(match[3] + "" + match[3]),
          a: convertHexToDecimal$1(match[4] + "" + match[4]),
          format: named ? "name" : "hex8"
        };
      }
      if (match = matchers$1.hex3.exec(color)) {
        return {
          r: parseIntFromHex$1(match[1] + "" + match[1]),
          g: parseIntFromHex$1(match[2] + "" + match[2]),
          b: parseIntFromHex$1(match[3] + "" + match[3]),
          format: named ? "name" : "hex"
        };
      }
      return false;
    }
    function validateWCAG2Parms(parms) {
      var level, size2;
      parms = parms || {
        level: "AA",
        size: "small"
      };
      level = (parms.level || "AA").toUpperCase();
      size2 = (parms.size || "small").toLowerCase();
      if (level !== "AA" && level !== "AAA") {
        level = "AA";
      }
      if (size2 !== "small" && size2 !== "large") {
        size2 = "small";
      }
      return {
        level,
        size: size2
      };
    }
    var GradientParser = GradientParser || {};
    GradientParser.stringify = /* @__PURE__ */ function() {
      var visitor = {
        "visit_linear-gradient": function(node) {
          return visitor.visit_gradient(node);
        },
        "visit_repeating-linear-gradient": function(node) {
          return visitor.visit_gradient(node);
        },
        "visit_radial-gradient": function(node) {
          return visitor.visit_gradient(node);
        },
        "visit_repeating-radial-gradient": function(node) {
          return visitor.visit_gradient(node);
        },
        "visit_gradient": function(node) {
          var orientation = visitor.visit(node.orientation);
          if (orientation) {
            orientation += ", ";
          }
          return node.type + "(" + orientation + visitor.visit(node.colorStops) + ")";
        },
        "visit_shape": function(node) {
          var result = node.value, at2 = visitor.visit(node.at), style = visitor.visit(node.style);
          if (style) {
            result += " " + style;
          }
          if (at2) {
            result += " at " + at2;
          }
          return result;
        },
        "visit_default-radial": function(node) {
          var result = "", at2 = visitor.visit(node.at);
          if (at2) {
            result += at2;
          }
          return result;
        },
        "visit_extent-keyword": function(node) {
          var result = node.value, at2 = visitor.visit(node.at);
          if (at2) {
            result += " at " + at2;
          }
          return result;
        },
        "visit_position-keyword": function(node) {
          return node.value;
        },
        "visit_position": function(node) {
          return visitor.visit(node.value.x) + " " + visitor.visit(node.value.y);
        },
        "visit_%": function(node) {
          return node.value + "%";
        },
        "visit_em": function(node) {
          return node.value + "em";
        },
        "visit_px": function(node) {
          return node.value + "px";
        },
        "visit_literal": function(node) {
          return visitor.visit_color(node.value, node);
        },
        "visit_hex": function(node) {
          return visitor.visit_color("#" + node.value, node);
        },
        "visit_rgb": function(node) {
          return visitor.visit_color("rgb(" + node.value.join(", ") + ")", node);
        },
        "visit_rgba": function(node) {
          return visitor.visit_color("rgba(" + node.value.join(", ") + ")", node);
        },
        "visit_color": function(resultColor, node) {
          var result = resultColor, length = visitor.visit(node.length);
          if (length) {
            result += " " + length;
          }
          return result;
        },
        "visit_angular": function(node) {
          return node.value + "deg";
        },
        "visit_directional": function(node) {
          return "to " + node.value;
        },
        "visit_array": function(elements) {
          var result = "", size2 = elements.length;
          elements.forEach(function(element, i2) {
            result += visitor.visit(element);
            if (i2 < size2 - 1) {
              result += ", ";
            }
          });
          return result;
        },
        "visit": function(element) {
          if (!element) {
            return "";
          }
          var result = "";
          if (element instanceof Array) {
            return visitor.visit_array(element, result);
          } else if (element.type) {
            var nodeVisitor = visitor["visit_" + element.type];
            if (nodeVisitor) {
              return nodeVisitor(element);
            } else {
              throw Error("Missing visitor visit_" + element.type);
            }
          } else {
            throw Error("Invalid node.");
          }
        }
      };
      return function(root2) {
        return visitor.visit(root2);
      };
    }();
    var GradientParser = GradientParser || {};
    GradientParser.parse = /* @__PURE__ */ function() {
      var tokens = {
        linearGradient: /^(\-(webkit|o|ms|moz)\-)?(linear\-gradient)/i,
        repeatingLinearGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-linear\-gradient)/i,
        radialGradient: /^(\-(webkit|o|ms|moz)\-)?(radial\-gradient)/i,
        repeatingRadialGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-radial\-gradient)/i,
        sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|left|right|top|bottom)/i,
        extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
        positionKeywords: /^(left|center|right|top|bottom)/i,
        pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
        percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
        emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
        angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
        startCall: /^\(/,
        endCall: /^\)/,
        comma: /^,/,
        hexColor: /^\#([0-9a-fA-F]+)/,
        literalColor: /^([a-zA-Z]+)/,
        rgbColor: /^rgb/i,
        rgbaColor: /^rgba/i,
        number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
      };
      var input = "";
      function error(msg) {
        var err = new Error(input + ": " + msg);
        err.source = input;
        throw err;
      }
      function getAST() {
        var ast = matchListDefinitions();
        if (input.length > 0) {
          error("Invalid input not EOF");
        }
        return ast;
      }
      function matchListDefinitions() {
        return matchListing(matchDefinition);
      }
      function matchDefinition() {
        return matchGradient(
          "linear-gradient",
          tokens.linearGradient,
          matchLinearOrientation
        ) || matchGradient(
          "repeating-linear-gradient",
          tokens.repeatingLinearGradient,
          matchLinearOrientation
        ) || matchGradient(
          "radial-gradient",
          tokens.radialGradient,
          matchListRadialOrientations
        ) || matchGradient(
          "repeating-radial-gradient",
          tokens.repeatingRadialGradient,
          matchListRadialOrientations
        );
      }
      function matchGradient(gradientType, pattern, orientationMatcher) {
        return matchCall(pattern, function(captures) {
          var orientation = orientationMatcher();
          if (orientation) {
            if (!scan(tokens.comma)) {
              error("Missing comma before color stops");
            }
          }
          return {
            type: gradientType,
            orientation,
            colorStops: matchListing(matchColorStop)
          };
        });
      }
      function matchCall(pattern, callback) {
        var captures = scan(pattern);
        if (captures) {
          if (!scan(tokens.startCall)) {
            error("Missing (");
          }
          var result = callback(captures);
          if (!scan(tokens.endCall)) {
            error("Missing )");
          }
          return result;
        }
      }
      function matchLinearOrientation() {
        return matchSideOrCorner() || matchAngle();
      }
      function matchSideOrCorner() {
        return match("directional", tokens.sideOrCorner, 1);
      }
      function matchAngle() {
        return match("angular", tokens.angleValue, 1);
      }
      function matchListRadialOrientations() {
        var radialOrientations, radialOrientation = matchRadialOrientation(), lookaheadCache;
        if (radialOrientation) {
          radialOrientations = [];
          radialOrientations.push(radialOrientation);
          lookaheadCache = input;
          if (scan(tokens.comma)) {
            radialOrientation = matchRadialOrientation();
            if (radialOrientation) {
              radialOrientations.push(radialOrientation);
            } else {
              input = lookaheadCache;
            }
          }
        }
        return radialOrientations;
      }
      function matchRadialOrientation() {
        var radialType = matchCircle() || matchEllipse();
        if (radialType) {
          radialType.at = matchAtPosition();
        } else {
          var extent = matchExtentKeyword();
          if (extent) {
            radialType = extent;
            var positionAt = matchAtPosition();
            if (positionAt) {
              radialType.at = positionAt;
            }
          } else {
            var defaultPosition = matchPositioning();
            if (defaultPosition) {
              radialType = {
                type: "default-radial",
                at: defaultPosition
              };
            }
          }
        }
        return radialType;
      }
      function matchCircle() {
        var circle = match("shape", /^(circle)/i, 0);
        if (circle) {
          circle.style = matchLength() || matchExtentKeyword();
        }
        return circle;
      }
      function matchEllipse() {
        var ellipse = match("shape", /^(ellipse)/i, 0);
        if (ellipse) {
          ellipse.style = matchDistance() || matchExtentKeyword();
        }
        return ellipse;
      }
      function matchExtentKeyword() {
        return match("extent-keyword", tokens.extentKeywords, 1);
      }
      function matchAtPosition() {
        if (match("position", /^at/, 0)) {
          var positioning = matchPositioning();
          if (!positioning) {
            error("Missing positioning value");
          }
          return positioning;
        }
      }
      function matchPositioning() {
        var location2 = matchCoordinates();
        if (location2.x || location2.y) {
          return {
            type: "position",
            value: location2
          };
        }
      }
      function matchCoordinates() {
        return {
          x: matchDistance(),
          y: matchDistance()
        };
      }
      function matchListing(matcher) {
        var captures = matcher(), result = [];
        if (captures) {
          result.push(captures);
          while (scan(tokens.comma)) {
            captures = matcher();
            if (captures) {
              result.push(captures);
            } else {
              error("One extra comma");
            }
          }
        }
        return result;
      }
      function matchColorStop() {
        var color = matchColor();
        if (!color) {
          error("Expected color definition");
        }
        color.length = matchDistance();
        return color;
      }
      function matchColor() {
        return matchHexColor() || matchRGBAColor() || matchRGBColor() || matchLiteralColor();
      }
      function matchLiteralColor() {
        return match("literal", tokens.literalColor, 0);
      }
      function matchHexColor() {
        return match("hex", tokens.hexColor, 1);
      }
      function matchRGBColor() {
        return matchCall(tokens.rgbColor, function() {
          return {
            type: "rgb",
            value: matchListing(matchNumber)
          };
        });
      }
      function matchRGBAColor() {
        return matchCall(tokens.rgbaColor, function() {
          return {
            type: "rgba",
            value: matchListing(matchNumber)
          };
        });
      }
      function matchNumber() {
        return scan(tokens.number)[1];
      }
      function matchDistance() {
        return match("%", tokens.percentageValue, 1) || matchPositionKeyword() || matchLength();
      }
      function matchPositionKeyword() {
        return match("position-keyword", tokens.positionKeywords, 1);
      }
      function matchLength() {
        return match("px", tokens.pixelValue, 1) || match("em", tokens.emValue, 1);
      }
      function match(type, pattern, captureIndex) {
        var captures = scan(pattern);
        if (captures) {
          return {
            type,
            value: captures[captureIndex]
          };
        }
      }
      function scan(regexp) {
        var captures, blankCaptures;
        blankCaptures = /^[\n\r\t\s]+/.exec(input);
        if (blankCaptures) {
          consume(blankCaptures[0].length);
        }
        captures = regexp.exec(input);
        if (captures) {
          consume(captures[0].length);
        }
        return captures;
      }
      function consume(size2) {
        input = input.substr(size2);
      }
      return function(code2) {
        input = code2.toString();
        return getAST();
      };
    }();
    var parse = GradientParser.parse;
    var stringify = GradientParser.stringify;
    var top$1 = "top";
    var bottom = "bottom";
    var right = "right";
    var left = "left";
    var auto = "auto";
    var basePlacements = [top$1, bottom, right, left];
    var start = "start";
    var end$1 = "end";
    var clippingParents = "clippingParents";
    var viewport = "viewport";
    var popper = "popper";
    var reference = "reference";
    var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
      return acc.concat([placement + "-" + start, placement + "-" + end$1]);
    }, []);
    var placements$1 = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
      return acc.concat([placement, placement + "-" + start, placement + "-" + end$1]);
    }, []);
    var beforeRead = "beforeRead";
    var read = "read";
    var afterRead = "afterRead";
    var beforeMain = "beforeMain";
    var main = "main";
    var afterMain = "afterMain";
    var beforeWrite = "beforeWrite";
    var write = "write";
    var afterWrite = "afterWrite";
    var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
    function getNodeName(element) {
      return element ? (element.nodeName || "").toLowerCase() : null;
    }
    function getWindow(node) {
      if (node == null) {
        return window;
      }
      if (node.toString() !== "[object Window]") {
        var ownerDocument = node.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView || window : window;
      }
      return node;
    }
    function isElement(node) {
      var OwnElement = getWindow(node).Element;
      return node instanceof OwnElement || node instanceof Element;
    }
    function isHTMLElement(node) {
      var OwnElement = getWindow(node).HTMLElement;
      return node instanceof OwnElement || node instanceof HTMLElement;
    }
    function isShadowRoot(node) {
      if (typeof ShadowRoot === "undefined") {
        return false;
      }
      var OwnElement = getWindow(node).ShadowRoot;
      return node instanceof OwnElement || node instanceof ShadowRoot;
    }
    function applyStyles(_ref) {
      var state = _ref.state;
      Object.keys(state.elements).forEach(function(name) {
        var style = state.styles[name] || {};
        var attributes = state.attributes[name] || {};
        var element = state.elements[name];
        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function(name2) {
          var value = attributes[name2];
          if (value === false) {
            element.removeAttribute(name2);
          } else {
            element.setAttribute(name2, value === true ? "" : value);
          }
        });
      });
    }
    function effect$2(_ref2) {
      var state = _ref2.state;
      var initialStyles = {
        popper: {
          position: state.options.strategy,
          left: "0",
          top: "0",
          margin: "0"
        },
        arrow: {
          position: "absolute"
        },
        reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);
      state.styles = initialStyles;
      if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
      }
      return function() {
        Object.keys(state.elements).forEach(function(name) {
          var element = state.elements[name];
          var attributes = state.attributes[name] || {};
          var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
          var style = styleProperties.reduce(function(style2, property) {
            style2[property] = "";
            return style2;
          }, {});
          if (!isHTMLElement(element) || !getNodeName(element)) {
            return;
          }
          Object.assign(element.style, style);
          Object.keys(attributes).forEach(function(attribute) {
            element.removeAttribute(attribute);
          });
        });
      };
    }
    const applyStyles$1 = {
      name: "applyStyles",
      enabled: true,
      phase: "write",
      fn: applyStyles,
      effect: effect$2,
      requires: ["computeStyles"]
    };
    function getBasePlacement(placement) {
      return placement.split("-")[0];
    }
    var max$1 = Math.max;
    var min$1 = Math.min;
    var round$2 = Math.round;
    function getUAString() {
      var uaData = navigator.userAgentData;
      if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
        return uaData.brands.map(function(item) {
          return item.brand + "/" + item.version;
        }).join(" ");
      }
      return navigator.userAgent;
    }
    function isLayoutViewport() {
      return !/^((?!chrome|android).)*safari/i.test(getUAString());
    }
    function getBoundingClientRect(element, includeScale, isFixedStrategy) {
      if (includeScale === void 0) {
        includeScale = false;
      }
      if (isFixedStrategy === void 0) {
        isFixedStrategy = false;
      }
      var clientRect = element.getBoundingClientRect();
      var scaleX = 1;
      var scaleY = 1;
      if (includeScale && isHTMLElement(element)) {
        scaleX = element.offsetWidth > 0 ? round$2(clientRect.width) / element.offsetWidth || 1 : 1;
        scaleY = element.offsetHeight > 0 ? round$2(clientRect.height) / element.offsetHeight || 1 : 1;
      }
      var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
      var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
      var x2 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
      var y2 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
      var width = clientRect.width / scaleX;
      var height = clientRect.height / scaleY;
      return {
        width,
        height,
        top: y2,
        right: x2 + width,
        bottom: y2 + height,
        left: x2,
        x: x2,
        y: y2
      };
    }
    function getLayoutRect(element) {
      var clientRect = getBoundingClientRect(element);
      var width = element.offsetWidth;
      var height = element.offsetHeight;
      if (Math.abs(clientRect.width - width) <= 1) {
        width = clientRect.width;
      }
      if (Math.abs(clientRect.height - height) <= 1) {
        height = clientRect.height;
      }
      return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width,
        height
      };
    }
    function contains(parent, child2) {
      var rootNode = child2.getRootNode && child2.getRootNode();
      if (parent.contains(child2)) {
        return true;
      } else if (rootNode && isShadowRoot(rootNode)) {
        var next = child2;
        do {
          if (next && parent.isSameNode(next)) {
            return true;
          }
          next = next.parentNode || next.host;
        } while (next);
      }
      return false;
    }
    function getComputedStyle$1(element) {
      return getWindow(element).getComputedStyle(element);
    }
    function isTableElement(element) {
      return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
    }
    function getDocumentElement(element) {
      return ((isElement(element) ? element.ownerDocument : (
        // $FlowFixMe[prop-missing]
        element.document
      )) || window.document).documentElement;
    }
    function getParentNode(element) {
      if (getNodeName(element) === "html") {
        return element;
      }
      return (
        // this is a quicker (but less type safe) way to save quite some bytes from the bundle
        // $FlowFixMe[incompatible-return]
        // $FlowFixMe[prop-missing]
        element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
        element.parentNode || // DOM Element detected
        (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
        // $FlowFixMe[incompatible-call]: HTMLElement is a Node
        getDocumentElement(element)
      );
    }
    function getTrueOffsetParent(element) {
      if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
      getComputedStyle$1(element).position === "fixed") {
        return null;
      }
      return element.offsetParent;
    }
    function getContainingBlock(element) {
      var isFirefox = /firefox/i.test(getUAString());
      var isIE = /Trident/i.test(getUAString());
      if (isIE && isHTMLElement(element)) {
        var elementCss = getComputedStyle$1(element);
        if (elementCss.position === "fixed") {
          return null;
        }
      }
      var currentNode = getParentNode(element);
      if (isShadowRoot(currentNode)) {
        currentNode = currentNode.host;
      }
      while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
        var css2 = getComputedStyle$1(currentNode);
        if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].indexOf(css2.willChange) !== -1 || isFirefox && css2.willChange === "filter" || isFirefox && css2.filter && css2.filter !== "none") {
          return currentNode;
        } else {
          currentNode = currentNode.parentNode;
        }
      }
      return null;
    }
    function getOffsetParent(element) {
      var window2 = getWindow(element);
      var offsetParent = getTrueOffsetParent(element);
      while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
        offsetParent = getTrueOffsetParent(offsetParent);
      }
      if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
        return window2;
      }
      return offsetParent || getContainingBlock(element) || window2;
    }
    function getMainAxisFromPlacement(placement) {
      return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
    }
    function within(min2, value, max2) {
      return max$1(min2, min$1(value, max2));
    }
    function withinMaxClamp(min2, value, max2) {
      var v2 = within(min2, value, max2);
      return v2 > max2 ? max2 : v2;
    }
    function getFreshSideObject() {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    }
    function mergePaddingObject(paddingObject) {
      return Object.assign({}, getFreshSideObject(), paddingObject);
    }
    function expandToHashMap(value, keys) {
      return keys.reduce(function(hashMap, key2) {
        hashMap[key2] = value;
        return hashMap;
      }, {});
    }
    var toPaddingObject = function toPaddingObject2(padding, state) {
      padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
        placement: state.placement
      })) : padding;
      return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
    };
    function arrow$1(_ref) {
      var _state$modifiersData$;
      var state = _ref.state, name = _ref.name, options = _ref.options;
      var arrowElement = state.elements.arrow;
      var popperOffsets2 = state.modifiersData.popperOffsets;
      var basePlacement = getBasePlacement(state.placement);
      var axis = getMainAxisFromPlacement(basePlacement);
      var isVertical = [left, right].indexOf(basePlacement) >= 0;
      var len = isVertical ? "height" : "width";
      if (!arrowElement || !popperOffsets2) {
        return;
      }
      var paddingObject = toPaddingObject(options.padding, state);
      var arrowRect = getLayoutRect(arrowElement);
      var minProp = axis === "y" ? top$1 : left;
      var maxProp = axis === "y" ? bottom : right;
      var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
      var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
      var arrowOffsetParent = getOffsetParent(arrowElement);
      var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
      var centerToReference = endDiff / 2 - startDiff / 2;
      var min2 = paddingObject[minProp];
      var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
      var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
      var offset2 = within(min2, center, max2);
      var axisProp = axis;
      state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
    }
    function effect$1(_ref2) {
      var state = _ref2.state, options = _ref2.options;
      var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
      if (arrowElement == null) {
        return;
      }
      if (typeof arrowElement === "string") {
        arrowElement = state.elements.popper.querySelector(arrowElement);
        if (!arrowElement) {
          return;
        }
      }
      if (!contains(state.elements.popper, arrowElement)) {
        return;
      }
      state.elements.arrow = arrowElement;
    }
    const arrow$2 = {
      name: "arrow",
      enabled: true,
      phase: "main",
      fn: arrow$1,
      effect: effect$1,
      requires: ["popperOffsets"],
      requiresIfExists: ["preventOverflow"]
    };
    function getVariation(placement) {
      return placement.split("-")[1];
    }
    var unsetSides = {
      top: "auto",
      right: "auto",
      bottom: "auto",
      left: "auto"
    };
    function roundOffsetsByDPR(_ref, win) {
      var x2 = _ref.x, y2 = _ref.y;
      var dpr = win.devicePixelRatio || 1;
      return {
        x: round$2(x2 * dpr) / dpr || 0,
        y: round$2(y2 * dpr) / dpr || 0
      };
    }
    function mapToStyles(_ref2) {
      var _Object$assign2;
      var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
      var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y2 = _offsets$y === void 0 ? 0 : _offsets$y;
      var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
        x: x2,
        y: y2
      }) : {
        x: x2,
        y: y2
      };
      x2 = _ref3.x;
      y2 = _ref3.y;
      var hasX = offsets.hasOwnProperty("x");
      var hasY = offsets.hasOwnProperty("y");
      var sideX = left;
      var sideY = top$1;
      var win = window;
      if (adaptive) {
        var offsetParent = getOffsetParent(popper2);
        var heightProp = "clientHeight";
        var widthProp = "clientWidth";
        if (offsetParent === getWindow(popper2)) {
          offsetParent = getDocumentElement(popper2);
          if (getComputedStyle$1(offsetParent).position !== "static" && position === "absolute") {
            heightProp = "scrollHeight";
            widthProp = "scrollWidth";
          }
        }
        offsetParent = offsetParent;
        if (placement === top$1 || (placement === left || placement === right) && variation === end$1) {
          sideY = bottom;
          var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
            // $FlowFixMe[prop-missing]
            offsetParent[heightProp]
          );
          y2 -= offsetY - popperRect.height;
          y2 *= gpuAcceleration ? 1 : -1;
        }
        if (placement === left || (placement === top$1 || placement === bottom) && variation === end$1) {
          sideX = right;
          var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
            // $FlowFixMe[prop-missing]
            offsetParent[widthProp]
          );
          x2 -= offsetX - popperRect.width;
          x2 *= gpuAcceleration ? 1 : -1;
        }
      }
      var commonStyles = Object.assign({
        position
      }, adaptive && unsetSides);
      var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
        x: x2,
        y: y2
      }, getWindow(popper2)) : {
        x: x2,
        y: y2
      };
      x2 = _ref4.x;
      y2 = _ref4.y;
      if (gpuAcceleration) {
        var _Object$assign;
        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
      }
      return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
    }
    function computeStyles(_ref5) {
      var state = _ref5.state, options = _ref5.options;
      var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
      var commonStyles = {
        placement: getBasePlacement(state.placement),
        variation: getVariation(state.placement),
        popper: state.elements.popper,
        popperRect: state.rects.popper,
        gpuAcceleration,
        isFixed: state.options.strategy === "fixed"
      };
      if (state.modifiersData.popperOffsets != null) {
        state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.popperOffsets,
          position: state.options.strategy,
          adaptive,
          roundOffsets
        })));
      }
      if (state.modifiersData.arrow != null) {
        state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.arrow,
          position: "absolute",
          adaptive: false,
          roundOffsets
        })));
      }
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        "data-popper-placement": state.placement
      });
    }
    const computeStyles$1 = {
      name: "computeStyles",
      enabled: true,
      phase: "beforeWrite",
      fn: computeStyles,
      data: {}
    };
    var passive = {
      passive: true
    };
    function effect(_ref) {
      var state = _ref.state, instance = _ref.instance, options = _ref.options;
      var _options$scroll = options.scroll, scroll2 = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
      var window2 = getWindow(state.elements.popper);
      var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
      if (scroll2) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.addEventListener("scroll", instance.update, passive);
        });
      }
      if (resize) {
        window2.addEventListener("resize", instance.update, passive);
      }
      return function() {
        if (scroll2) {
          scrollParents.forEach(function(scrollParent) {
            scrollParent.removeEventListener("scroll", instance.update, passive);
          });
        }
        if (resize) {
          window2.removeEventListener("resize", instance.update, passive);
        }
      };
    }
    const eventListeners = {
      name: "eventListeners",
      enabled: true,
      phase: "write",
      fn: function fn2() {
      },
      effect,
      data: {}
    };
    var hash$2 = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    };
    function getOppositePlacement$1(placement) {
      return placement.replace(/left|right|bottom|top/g, function(matched) {
        return hash$2[matched];
      });
    }
    var hash$1 = {
      start: "end",
      end: "start"
    };
    function getOppositeVariationPlacement(placement) {
      return placement.replace(/start|end/g, function(matched) {
        return hash$1[matched];
      });
    }
    function getWindowScroll(node) {
      var win = getWindow(node);
      var scrollLeft = win.pageXOffset;
      var scrollTop = win.pageYOffset;
      return {
        scrollLeft,
        scrollTop
      };
    }
    function getWindowScrollBarX(element) {
      return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
    }
    function getViewportRect(element, strategy) {
      var win = getWindow(element);
      var html = getDocumentElement(element);
      var visualViewport = win.visualViewport;
      var width = html.clientWidth;
      var height = html.clientHeight;
      var x2 = 0;
      var y2 = 0;
      if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height;
        var layoutViewport = isLayoutViewport();
        if (layoutViewport || !layoutViewport && strategy === "fixed") {
          x2 = visualViewport.offsetLeft;
          y2 = visualViewport.offsetTop;
        }
      }
      return {
        width,
        height,
        x: x2 + getWindowScrollBarX(element),
        y: y2
      };
    }
    function getDocumentRect(element) {
      var _element$ownerDocumen;
      var html = getDocumentElement(element);
      var winScroll = getWindowScroll(element);
      var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
      var width = max$1(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
      var height = max$1(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
      var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);
      var y2 = -winScroll.scrollTop;
      if (getComputedStyle$1(body || html).direction === "rtl") {
        x2 += max$1(html.clientWidth, body ? body.clientWidth : 0) - width;
      }
      return {
        width,
        height,
        x: x2,
        y: y2
      };
    }
    function isScrollParent(element) {
      var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
      return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
    }
    function getScrollParent(node) {
      if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
        return node.ownerDocument.body;
      }
      if (isHTMLElement(node) && isScrollParent(node)) {
        return node;
      }
      return getScrollParent(getParentNode(node));
    }
    function listScrollParents(element, list) {
      var _element$ownerDocumen;
      if (list === void 0) {
        list = [];
      }
      var scrollParent = getScrollParent(element);
      var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
      var win = getWindow(scrollParent);
      var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
      var updatedList = list.concat(target);
      return isBody ? updatedList : (
        // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
        updatedList.concat(listScrollParents(getParentNode(target)))
      );
    }
    function rectToClientRect$1(rect) {
      return Object.assign({}, rect, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
      });
    }
    function getInnerBoundingClientRect(element, strategy) {
      var rect = getBoundingClientRect(element, false, strategy === "fixed");
      rect.top = rect.top + element.clientTop;
      rect.left = rect.left + element.clientLeft;
      rect.bottom = rect.top + element.clientHeight;
      rect.right = rect.left + element.clientWidth;
      rect.width = element.clientWidth;
      rect.height = element.clientHeight;
      rect.x = rect.left;
      rect.y = rect.top;
      return rect;
    }
    function getClientRectFromMixedType(element, clippingParent, strategy) {
      return clippingParent === viewport ? rectToClientRect$1(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect$1(getDocumentRect(getDocumentElement(element)));
    }
    function getClippingParents(element) {
      var clippingParents2 = listScrollParents(getParentNode(element));
      var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
      var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
      if (!isElement(clipperElement)) {
        return [];
      }
      return clippingParents2.filter(function(clippingParent) {
        return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
      });
    }
    function getClippingRect(element, boundary, rootBoundary, strategy) {
      var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
      var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
      var firstClippingParent = clippingParents2[0];
      var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
        var rect = getClientRectFromMixedType(element, clippingParent, strategy);
        accRect.top = max$1(rect.top, accRect.top);
        accRect.right = min$1(rect.right, accRect.right);
        accRect.bottom = min$1(rect.bottom, accRect.bottom);
        accRect.left = max$1(rect.left, accRect.left);
        return accRect;
      }, getClientRectFromMixedType(element, firstClippingParent, strategy));
      clippingRect.width = clippingRect.right - clippingRect.left;
      clippingRect.height = clippingRect.bottom - clippingRect.top;
      clippingRect.x = clippingRect.left;
      clippingRect.y = clippingRect.top;
      return clippingRect;
    }
    function computeOffsets(_ref) {
      var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
      var basePlacement = placement ? getBasePlacement(placement) : null;
      var variation = placement ? getVariation(placement) : null;
      var commonX = reference2.x + reference2.width / 2 - element.width / 2;
      var commonY = reference2.y + reference2.height / 2 - element.height / 2;
      var offsets;
      switch (basePlacement) {
        case top$1:
          offsets = {
            x: commonX,
            y: reference2.y - element.height
          };
          break;
        case bottom:
          offsets = {
            x: commonX,
            y: reference2.y + reference2.height
          };
          break;
        case right:
          offsets = {
            x: reference2.x + reference2.width,
            y: commonY
          };
          break;
        case left:
          offsets = {
            x: reference2.x - element.width,
            y: commonY
          };
          break;
        default:
          offsets = {
            x: reference2.x,
            y: reference2.y
          };
      }
      var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
      if (mainAxis != null) {
        var len = mainAxis === "y" ? "height" : "width";
        switch (variation) {
          case start:
            offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
            break;
          case end$1:
            offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
            break;
        }
      }
      return offsets;
    }
    function detectOverflow$1(state, options) {
      if (options === void 0) {
        options = {};
      }
      var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
      var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
      var altContext = elementContext === popper ? reference : popper;
      var popperRect = state.rects.popper;
      var element = state.elements[altBoundary ? altContext : elementContext];
      var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
      var referenceClientRect = getBoundingClientRect(state.elements.reference);
      var popperOffsets2 = computeOffsets({
        reference: referenceClientRect,
        element: popperRect,
        strategy: "absolute",
        placement
      });
      var popperClientRect = rectToClientRect$1(Object.assign({}, popperRect, popperOffsets2));
      var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
      var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
      };
      var offsetData = state.modifiersData.offset;
      if (elementContext === popper && offsetData) {
        var offset2 = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function(key2) {
          var multiply = [right, bottom].indexOf(key2) >= 0 ? 1 : -1;
          var axis = [top$1, bottom].indexOf(key2) >= 0 ? "y" : "x";
          overflowOffsets[key2] += offset2[axis] * multiply;
        });
      }
      return overflowOffsets;
    }
    function computeAutoPlacement(state, options) {
      if (options === void 0) {
        options = {};
      }
      var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements$1 : _options$allowedAutoP;
      var variation = getVariation(placement);
      var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
        return getVariation(placement2) === variation;
      }) : basePlacements;
      var allowedPlacements = placements2.filter(function(placement2) {
        return allowedAutoPlacements.indexOf(placement2) >= 0;
      });
      if (allowedPlacements.length === 0) {
        allowedPlacements = placements2;
      }
      var overflows = allowedPlacements.reduce(function(acc, placement2) {
        acc[placement2] = detectOverflow$1(state, {
          placement: placement2,
          boundary,
          rootBoundary,
          padding
        })[getBasePlacement(placement2)];
        return acc;
      }, {});
      return Object.keys(overflows).sort(function(a2, b2) {
        return overflows[a2] - overflows[b2];
      });
    }
    function getExpandedFallbackPlacements(placement) {
      if (getBasePlacement(placement) === auto) {
        return [];
      }
      var oppositePlacement = getOppositePlacement$1(placement);
      return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
    }
    function flip$1(_ref) {
      var state = _ref.state, options = _ref.options, name = _ref.name;
      if (state.modifiersData[name]._skip) {
        return;
      }
      var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
      var preferredPlacement = state.options.placement;
      var basePlacement = getBasePlacement(preferredPlacement);
      var isBasePlacement = basePlacement === preferredPlacement;
      var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement$1(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
      var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
        return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
          placement: placement2,
          boundary,
          rootBoundary,
          padding,
          flipVariations,
          allowedAutoPlacements
        }) : placement2);
      }, []);
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var checksMap = /* @__PURE__ */ new Map();
      var makeFallbackChecks = true;
      var firstFittingPlacement = placements2[0];
      for (var i2 = 0; i2 < placements2.length; i2++) {
        var placement = placements2[i2];
        var _basePlacement = getBasePlacement(placement);
        var isStartVariation = getVariation(placement) === start;
        var isVertical = [top$1, bottom].indexOf(_basePlacement) >= 0;
        var len = isVertical ? "width" : "height";
        var overflow = detectOverflow$1(state, {
          placement,
          boundary,
          rootBoundary,
          altBoundary,
          padding
        });
        var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top$1;
        if (referenceRect[len] > popperRect[len]) {
          mainVariationSide = getOppositePlacement$1(mainVariationSide);
        }
        var altVariationSide = getOppositePlacement$1(mainVariationSide);
        var checks = [];
        if (checkMainAxis) {
          checks.push(overflow[_basePlacement] <= 0);
        }
        if (checkAltAxis) {
          checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
        }
        if (checks.every(function(check) {
          return check;
        })) {
          firstFittingPlacement = placement;
          makeFallbackChecks = false;
          break;
        }
        checksMap.set(placement, checks);
      }
      if (makeFallbackChecks) {
        var numberOfChecks = flipVariations ? 3 : 1;
        var _loop = function _loop2(_i2) {
          var fittingPlacement = placements2.find(function(placement2) {
            var checks2 = checksMap.get(placement2);
            if (checks2) {
              return checks2.slice(0, _i2).every(function(check) {
                return check;
              });
            }
          });
          if (fittingPlacement) {
            firstFittingPlacement = fittingPlacement;
            return "break";
          }
        };
        for (var _i = numberOfChecks; _i > 0; _i--) {
          var _ret = _loop(_i);
          if (_ret === "break")
            break;
        }
      }
      if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
      }
    }
    const flip$2 = {
      name: "flip",
      enabled: true,
      phase: "main",
      fn: flip$1,
      requiresIfExists: ["offset"],
      data: {
        _skip: false
      }
    };
    function getSideOffsets(overflow, rect, preventedOffsets) {
      if (preventedOffsets === void 0) {
        preventedOffsets = {
          x: 0,
          y: 0
        };
      }
      return {
        top: overflow.top - rect.height - preventedOffsets.y,
        right: overflow.right - rect.width + preventedOffsets.x,
        bottom: overflow.bottom - rect.height + preventedOffsets.y,
        left: overflow.left - rect.width - preventedOffsets.x
      };
    }
    function isAnySideFullyClipped(overflow) {
      return [top$1, right, bottom, left].some(function(side) {
        return overflow[side] >= 0;
      });
    }
    function hide(_ref) {
      var state = _ref.state, name = _ref.name;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var preventedOffsets = state.modifiersData.preventOverflow;
      var referenceOverflow = detectOverflow$1(state, {
        elementContext: "reference"
      });
      var popperAltOverflow = detectOverflow$1(state, {
        altBoundary: true
      });
      var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
      var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
      var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
      var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
      state.modifiersData[name] = {
        referenceClippingOffsets,
        popperEscapeOffsets,
        isReferenceHidden,
        hasPopperEscaped
      };
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        "data-popper-reference-hidden": isReferenceHidden,
        "data-popper-escaped": hasPopperEscaped
      });
    }
    const hide$1 = {
      name: "hide",
      enabled: true,
      phase: "main",
      requiresIfExists: ["preventOverflow"],
      fn: hide
    };
    function distanceAndSkiddingToXY(placement, rects, offset2) {
      var basePlacement = getBasePlacement(placement);
      var invertDistance = [left, top$1].indexOf(basePlacement) >= 0 ? -1 : 1;
      var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
        placement
      })) : offset2, skidding = _ref[0], distance = _ref[1];
      skidding = skidding || 0;
      distance = (distance || 0) * invertDistance;
      return [left, right].indexOf(basePlacement) >= 0 ? {
        x: distance,
        y: skidding
      } : {
        x: skidding,
        y: distance
      };
    }
    function offset$1(_ref2) {
      var state = _ref2.state, options = _ref2.options, name = _ref2.name;
      var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
      var data = placements$1.reduce(function(acc, placement) {
        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
        return acc;
      }, {});
      var _data$state$placement = data[state.placement], x2 = _data$state$placement.x, y2 = _data$state$placement.y;
      if (state.modifiersData.popperOffsets != null) {
        state.modifiersData.popperOffsets.x += x2;
        state.modifiersData.popperOffsets.y += y2;
      }
      state.modifiersData[name] = data;
    }
    const offset$2 = {
      name: "offset",
      enabled: true,
      phase: "main",
      requires: ["popperOffsets"],
      fn: offset$1
    };
    function popperOffsets(_ref) {
      var state = _ref.state, name = _ref.name;
      state.modifiersData[name] = computeOffsets({
        reference: state.rects.reference,
        element: state.rects.popper,
        strategy: "absolute",
        placement: state.placement
      });
    }
    const popperOffsets$1 = {
      name: "popperOffsets",
      enabled: true,
      phase: "read",
      fn: popperOffsets,
      data: {}
    };
    function getAltAxis(axis) {
      return axis === "x" ? "y" : "x";
    }
    function preventOverflow(_ref) {
      var state = _ref.state, options = _ref.options, name = _ref.name;
      var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
      var overflow = detectOverflow$1(state, {
        boundary,
        rootBoundary,
        padding,
        altBoundary
      });
      var basePlacement = getBasePlacement(state.placement);
      var variation = getVariation(state.placement);
      var isBasePlacement = !variation;
      var mainAxis = getMainAxisFromPlacement(basePlacement);
      var altAxis = getAltAxis(mainAxis);
      var popperOffsets2 = state.modifiersData.popperOffsets;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
        placement: state.placement
      })) : tetherOffset;
      var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
        mainAxis: tetherOffsetValue,
        altAxis: tetherOffsetValue
      } : Object.assign({
        mainAxis: 0,
        altAxis: 0
      }, tetherOffsetValue);
      var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
      var data = {
        x: 0,
        y: 0
      };
      if (!popperOffsets2) {
        return;
      }
      if (checkMainAxis) {
        var _offsetModifierState$;
        var mainSide = mainAxis === "y" ? top$1 : left;
        var altSide = mainAxis === "y" ? bottom : right;
        var len = mainAxis === "y" ? "height" : "width";
        var offset2 = popperOffsets2[mainAxis];
        var min2 = offset2 + overflow[mainSide];
        var max2 = offset2 - overflow[altSide];
        var additive = tether ? -popperRect[len] / 2 : 0;
        var minLen = variation === start ? referenceRect[len] : popperRect[len];
        var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
        var arrowElement = state.elements.arrow;
        var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
          width: 0,
          height: 0
        };
        var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide];
        var arrowLen = within(0, referenceRect[len], arrowRect[len]);
        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
        var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
        var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
        var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
        var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = offset2 + maxOffset - offsetModifierValue;
        var preventedOffset = within(tether ? min$1(min2, tetherMin) : min2, offset2, tether ? max$1(max2, tetherMax) : max2);
        popperOffsets2[mainAxis] = preventedOffset;
        data[mainAxis] = preventedOffset - offset2;
      }
      if (checkAltAxis) {
        var _offsetModifierState$2;
        var _mainSide = mainAxis === "x" ? top$1 : left;
        var _altSide = mainAxis === "x" ? bottom : right;
        var _offset = popperOffsets2[altAxis];
        var _len = altAxis === "y" ? "height" : "width";
        var _min = _offset + overflow[_mainSide];
        var _max = _offset - overflow[_altSide];
        var isOriginSide = [top$1, left].indexOf(basePlacement) !== -1;
        var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
        var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
        var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
        var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
        popperOffsets2[altAxis] = _preventedOffset;
        data[altAxis] = _preventedOffset - _offset;
      }
      state.modifiersData[name] = data;
    }
    const preventOverflow$1 = {
      name: "preventOverflow",
      enabled: true,
      phase: "main",
      fn: preventOverflow,
      requiresIfExists: ["offset"]
    };
    function getHTMLElementScroll(element) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }
    function getNodeScroll(node) {
      if (node === getWindow(node) || !isHTMLElement(node)) {
        return getWindowScroll(node);
      } else {
        return getHTMLElementScroll(node);
      }
    }
    function isElementScaled(element) {
      var rect = element.getBoundingClientRect();
      var scaleX = round$2(rect.width) / element.offsetWidth || 1;
      var scaleY = round$2(rect.height) / element.offsetHeight || 1;
      return scaleX !== 1 || scaleY !== 1;
    }
    function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
      if (isFixed === void 0) {
        isFixed = false;
      }
      var isOffsetParentAnElement = isHTMLElement(offsetParent);
      var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
      var documentElement = getDocumentElement(offsetParent);
      var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
      var scroll2 = {
        scrollLeft: 0,
        scrollTop: 0
      };
      var offsets = {
        x: 0,
        y: 0
      };
      if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
        isScrollParent(documentElement)) {
          scroll2 = getNodeScroll(offsetParent);
        }
        if (isHTMLElement(offsetParent)) {
          offsets = getBoundingClientRect(offsetParent, true);
          offsets.x += offsetParent.clientLeft;
          offsets.y += offsetParent.clientTop;
        } else if (documentElement) {
          offsets.x = getWindowScrollBarX(documentElement);
        }
      }
      return {
        x: rect.left + scroll2.scrollLeft - offsets.x,
        y: rect.top + scroll2.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
      };
    }
    function order(modifiers) {
      var map = /* @__PURE__ */ new Map();
      var visited = /* @__PURE__ */ new Set();
      var result = [];
      modifiers.forEach(function(modifier) {
        map.set(modifier.name, modifier);
      });
      function sort(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function(dep) {
          if (!visited.has(dep)) {
            var depModifier = map.get(dep);
            if (depModifier) {
              sort(depModifier);
            }
          }
        });
        result.push(modifier);
      }
      modifiers.forEach(function(modifier) {
        if (!visited.has(modifier.name)) {
          sort(modifier);
        }
      });
      return result;
    }
    function orderModifiers(modifiers) {
      var orderedModifiers = order(modifiers);
      return modifierPhases.reduce(function(acc, phase) {
        return acc.concat(orderedModifiers.filter(function(modifier) {
          return modifier.phase === phase;
        }));
      }, []);
    }
    function debounce$1(fn2) {
      var pending;
      return function() {
        if (!pending) {
          pending = new Promise(function(resolve2) {
            Promise.resolve().then(function() {
              pending = void 0;
              resolve2(fn2());
            });
          });
        }
        return pending;
      };
    }
    function mergeByName(modifiers) {
      var merged = modifiers.reduce(function(merged2, current) {
        var existing = merged2[current.name];
        merged2[current.name] = existing ? Object.assign({}, existing, current, {
          options: Object.assign({}, existing.options, current.options),
          data: Object.assign({}, existing.data, current.data)
        }) : current;
        return merged2;
      }, {});
      return Object.keys(merged).map(function(key2) {
        return merged[key2];
      });
    }
    var DEFAULT_OPTIONS = {
      placement: "bottom",
      modifiers: [],
      strategy: "absolute"
    };
    function areValidElements() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return !args.some(function(element) {
        return !(element && typeof element.getBoundingClientRect === "function");
      });
    }
    function popperGenerator(generatorOptions) {
      if (generatorOptions === void 0) {
        generatorOptions = {};
      }
      var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
      return function createPopper2(reference2, popper2, options) {
        if (options === void 0) {
          options = defaultOptions;
        }
        var state = {
          placement: "bottom",
          orderedModifiers: [],
          options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
          modifiersData: {},
          elements: {
            reference: reference2,
            popper: popper2
          },
          attributes: {},
          styles: {}
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance = {
          state,
          setOptions: function setOptions(setOptionsAction) {
            var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
            cleanupModifierEffects();
            state.options = Object.assign({}, defaultOptions, state.options, options2);
            state.scrollParents = {
              reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
              popper: listScrollParents(popper2)
            };
            var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
            state.orderedModifiers = orderedModifiers.filter(function(m2) {
              return m2.enabled;
            });
            runModifierEffects();
            return instance.update();
          },
          // Sync update – it will always be executed, even if not necessary. This
          // is useful for low frequency updates where sync behavior simplifies the
          // logic.
          // For high frequency updates (e.g. `resize` and `scroll` events), always
          // prefer the async Popper#update method
          forceUpdate: function forceUpdate() {
            if (isDestroyed) {
              return;
            }
            var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
            if (!areValidElements(reference3, popper3)) {
              return;
            }
            state.rects = {
              reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
              popper: getLayoutRect(popper3)
            };
            state.reset = false;
            state.placement = state.options.placement;
            state.orderedModifiers.forEach(function(modifier) {
              return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
            });
            for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
              if (state.reset === true) {
                state.reset = false;
                index2 = -1;
                continue;
              }
              var _state$orderedModifie = state.orderedModifiers[index2], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
              if (typeof fn2 === "function") {
                state = fn2({
                  state,
                  options: _options,
                  name,
                  instance
                }) || state;
              }
            }
          },
          // Async and optimistically optimized update – it will not be executed if
          // not necessary (debounced to run at most once-per-tick)
          update: debounce$1(function() {
            return new Promise(function(resolve2) {
              instance.forceUpdate();
              resolve2(state);
            });
          }),
          destroy: function destroy() {
            cleanupModifierEffects();
            isDestroyed = true;
          }
        };
        if (!areValidElements(reference2, popper2)) {
          return instance;
        }
        instance.setOptions(options).then(function(state2) {
          if (!isDestroyed && options.onFirstUpdate) {
            options.onFirstUpdate(state2);
          }
        });
        function runModifierEffects() {
          state.orderedModifiers.forEach(function(_ref) {
            var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect2 = _ref.effect;
            if (typeof effect2 === "function") {
              var cleanupFn = effect2({
                state,
                name,
                instance,
                options: options2
              });
              var noopFn = function noopFn2() {
              };
              effectCleanupFns.push(cleanupFn || noopFn);
            }
          });
        }
        function cleanupModifierEffects() {
          effectCleanupFns.forEach(function(fn2) {
            return fn2();
          });
          effectCleanupFns = [];
        }
        return instance;
      };
    }
    var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$2, flip$2, preventOverflow$1, arrow$2, hide$1];
    var createPopper = /* @__PURE__ */ popperGenerator({
      defaultModifiers
    });
    /*!
     * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
     *
     * Copyright (c) 2014-2017, Jon Schlinkert.
     * Released under the MIT License.
     */
    function isObject$2(o3) {
      return Object.prototype.toString.call(o3) === "[object Object]";
    }
    function isPlainObject$1(o3) {
      var ctor, prot;
      if (isObject$2(o3) === false)
        return false;
      ctor = o3.constructor;
      if (ctor === void 0)
        return true;
      prot = ctor.prototype;
      if (isObject$2(prot) === false)
        return false;
      if (prot.hasOwnProperty("isPrototypeOf") === false) {
        return false;
      }
      return true;
    }
    function t$2() {
      return t$2 = Object.assign ? Object.assign.bind() : function(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var r2 = arguments[t2];
          for (var n2 in r2)
            Object.prototype.hasOwnProperty.call(r2, n2) && (e2[n2] = r2[n2]);
        }
        return e2;
      }, t$2.apply(this, arguments);
    }
    function r$3(e2, t2) {
      if (null == e2)
        return {};
      var r2, n2, i2 = {}, o22 = Object.keys(e2);
      for (n2 = 0; n2 < o22.length; n2++)
        t2.indexOf(r2 = o22[n2]) >= 0 || (i2[r2] = e2[r2]);
      return i2;
    }
    const n$4 = { silent: false, logLevel: "warn" }, i$3 = ["validator"], o$4 = Object.prototype, a$4 = o$4.toString, s$3 = o$4.hasOwnProperty, u$4 = /^\s*function (\w+)/;
    function l$3(e2) {
      var t2;
      const r2 = null !== (t2 = null == e2 ? void 0 : e2.type) && void 0 !== t2 ? t2 : e2;
      if (r2) {
        const e3 = r2.toString().match(u$4);
        return e3 ? e3[1] : "";
      }
      return "";
    }
    const c$4 = isPlainObject$1, f$3 = (e2) => e2;
    let d$4 = f$3;
    const p$3 = (e2, t2) => s$3.call(e2, t2), y$4 = Number.isInteger || function(e2) {
      return "number" == typeof e2 && isFinite(e2) && Math.floor(e2) === e2;
    }, v$4 = Array.isArray || function(e2) {
      return "[object Array]" === a$4.call(e2);
    }, h$3 = (e2) => "[object Function]" === a$4.call(e2), b$5 = (e2) => c$4(e2) && p$3(e2, "_vueTypes_name"), g$5 = (e2) => c$4(e2) && (p$3(e2, "type") || ["_vueTypes_name", "validator", "default", "required"].some((t2) => p$3(e2, t2)));
    function O$2(e2, t2) {
      return Object.defineProperty(e2.bind(t2), "__original", { value: e2 });
    }
    function m$5(e2, t2, r2 = false) {
      let n2, i2 = true, o22 = "";
      n2 = c$4(e2) ? e2 : { type: e2 };
      const a2 = b$5(n2) ? n2._vueTypes_name + " - " : "";
      if (g$5(n2) && null !== n2.type) {
        if (void 0 === n2.type || true === n2.type)
          return i2;
        if (!n2.required && void 0 === t2)
          return i2;
        v$4(n2.type) ? (i2 = n2.type.some((e3) => true === m$5(e3, t2, true)), o22 = n2.type.map((e3) => l$3(e3)).join(" or ")) : (o22 = l$3(n2), i2 = "Array" === o22 ? v$4(t2) : "Object" === o22 ? c$4(t2) : "String" === o22 || "Number" === o22 || "Boolean" === o22 || "Function" === o22 ? function(e3) {
          if (null == e3)
            return "";
          const t3 = e3.constructor.toString().match(u$4);
          return t3 ? t3[1] : "";
        }(t2) === o22 : t2 instanceof n2.type);
      }
      if (!i2) {
        const e3 = `${a2}value "${t2}" should be of type "${o22}"`;
        return false === r2 ? (d$4(e3), false) : e3;
      }
      if (p$3(n2, "validator") && h$3(n2.validator)) {
        const e3 = d$4, o3 = [];
        if (d$4 = (e4) => {
          o3.push(e4);
        }, i2 = n2.validator(t2), d$4 = e3, !i2) {
          const e4 = (o3.length > 1 ? "* " : "") + o3.join("\n* ");
          return o3.length = 0, false === r2 ? (d$4(e4), i2) : e4;
        }
      }
      return i2;
    }
    function j$2(e2, t2) {
      const r2 = Object.defineProperties(t2, { _vueTypes_name: { value: e2, writable: true }, isRequired: { get() {
        return this.required = true, this;
      } }, def: { value(e3) {
        return void 0 === e3 ? (p$3(this, "default") && delete this.default, this) : h$3(e3) || true === m$5(this, e3, true) ? (this.default = v$4(e3) ? () => [...e3] : c$4(e3) ? () => Object.assign({}, e3) : e3, this) : (d$4(`${this._vueTypes_name} - invalid default value: "${e3}"`), this);
      } } }), { validator: n2 } = r2;
      return h$3(n2) && (r2.validator = O$2(n2, r2)), r2;
    }
    function _$2(e2, t2) {
      const r2 = j$2(e2, t2);
      return Object.defineProperty(r2, "validate", { value(e3) {
        return h$3(this.validator) && d$4(`${this._vueTypes_name} - calling .validate() will overwrite the current custom validator function. Validator info:
${JSON.stringify(this)}`), this.validator = O$2(e3, this), this;
      } });
    }
    function T$2(e2, t2, n2) {
      const o22 = function(e3) {
        const t3 = {};
        return Object.getOwnPropertyNames(e3).forEach((r2) => {
          t3[r2] = Object.getOwnPropertyDescriptor(e3, r2);
        }), Object.defineProperties({}, t3);
      }(t2);
      if (o22._vueTypes_name = e2, !c$4(n2))
        return o22;
      const { validator: a2 } = n2, s2 = r$3(n2, i$3);
      if (h$3(a2)) {
        let { validator: e3 } = o22;
        e3 && (e3 = null !== (l2 = (u2 = e3).__original) && void 0 !== l2 ? l2 : u2), o22.validator = O$2(e3 ? function(t3) {
          return e3.call(this, t3) && a2.call(this, t3);
        } : a2, o22);
      }
      var u2, l2;
      return Object.assign(o22, s2);
    }
    function $$2(e2) {
      return e2.replace(/^(?!\s*$)/gm, "  ");
    }
    const w$4 = () => _$2("any", {}), P$4 = () => _$2("function", { type: Function }), x$4 = () => _$2("boolean", { type: Boolean }), E$2 = () => _$2("string", { type: String }), N$2 = () => _$2("number", { type: Number }), q$3 = () => _$2("array", { type: Array }), A$3 = () => _$2("object", { type: Object }), V$1 = () => j$2("integer", { type: Number, validator: (e2) => y$4(e2) }), S$5 = () => j$2("symbol", { validator: (e2) => "symbol" == typeof e2 });
    function D$2(e2, t2 = "custom validation failed") {
      if ("function" != typeof e2)
        throw new TypeError("[VueTypes error]: You must provide a function as argument");
      return j$2(e2.name || "<<anonymous function>>", { type: null, validator(r2) {
        const n2 = e2(r2);
        return n2 || d$4(`${this._vueTypes_name} - ${t2}`), n2;
      } });
    }
    function L$2(e2) {
      if (!v$4(e2))
        throw new TypeError("[VueTypes error]: You must provide an array as argument.");
      const t2 = `oneOf - value should be one of "${e2.join('", "')}".`, r2 = e2.reduce((e3, t3) => {
        if (null != t3) {
          const r3 = t3.constructor;
          -1 === e3.indexOf(r3) && e3.push(r3);
        }
        return e3;
      }, []);
      return j$2("oneOf", { type: r2.length > 0 ? r2 : void 0, validator(r3) {
        const n2 = -1 !== e2.indexOf(r3);
        return n2 || d$4(t2), n2;
      } });
    }
    function F$2(e2) {
      if (!v$4(e2))
        throw new TypeError("[VueTypes error]: You must provide an array as argument");
      let t2 = false, r2 = [];
      for (let n3 = 0; n3 < e2.length; n3 += 1) {
        const i2 = e2[n3];
        if (g$5(i2)) {
          if (b$5(i2) && "oneOf" === i2._vueTypes_name && i2.type) {
            r2 = r2.concat(i2.type);
            continue;
          }
          if (h$3(i2.validator) && (t2 = true), true === i2.type || !i2.type) {
            d$4('oneOfType - invalid usage of "true" or "null" as types.');
            continue;
          }
          r2 = r2.concat(i2.type);
        } else
          r2.push(i2);
      }
      r2 = r2.filter((e3, t3) => r2.indexOf(e3) === t3);
      const n2 = r2.length > 0 ? r2 : null;
      return j$2("oneOfType", t2 ? { type: n2, validator(t3) {
        const r3 = [], n3 = e2.some((e3) => {
          const n4 = m$5(b$5(e3) && "oneOf" === e3._vueTypes_name ? e3.type || null : e3, t3, true);
          return "string" == typeof n4 && r3.push(n4), true === n4;
        });
        return n3 || d$4(`oneOfType - provided value does not match any of the ${r3.length} passed-in validators:
${$$2(r3.join("\n"))}`), n3;
      } } : { type: n2 });
    }
    function Y$2(e2) {
      return j$2("arrayOf", { type: Array, validator(t2) {
        let r2 = "";
        const n2 = t2.every((t3) => (r2 = m$5(e2, t3, true), true === r2));
        return n2 || d$4(`arrayOf - value validation error:
${$$2(r2)}`), n2;
      } });
    }
    function B$3(e2) {
      return j$2("instanceOf", { type: e2 });
    }
    function I$1(e2) {
      return j$2("objectOf", { type: Object, validator(t2) {
        let r2 = "";
        const n2 = Object.keys(t2).every((n3) => (r2 = m$5(e2, t2[n3], true), true === r2));
        return n2 || d$4(`objectOf - value validation error:
${$$2(r2)}`), n2;
      } });
    }
    function J$2(e2) {
      const t2 = Object.keys(e2), r2 = t2.filter((t3) => {
        var r3;
        return !(null === (r3 = e2[t3]) || void 0 === r3 || !r3.required);
      }), n2 = j$2("shape", { type: Object, validator(n3) {
        if (!c$4(n3))
          return false;
        const i2 = Object.keys(n3);
        if (r2.length > 0 && r2.some((e3) => -1 === i2.indexOf(e3))) {
          const e3 = r2.filter((e4) => -1 === i2.indexOf(e4));
          return d$4(1 === e3.length ? `shape - required property "${e3[0]}" is not defined.` : `shape - required properties "${e3.join('", "')}" are not defined.`), false;
        }
        return i2.every((r3) => {
          if (-1 === t2.indexOf(r3))
            return true === this._vueTypes_isLoose || (d$4(`shape - shape definition does not include a "${r3}" property. Allowed keys: "${t2.join('", "')}".`), false);
          const i3 = m$5(e2[r3], n3[r3], true);
          return "string" == typeof i3 && d$4(`shape - "${r3}" property validation error:
 ${$$2(i3)}`), true === i3;
        });
      } });
      return Object.defineProperty(n2, "_vueTypes_isLoose", { writable: true, value: false }), Object.defineProperty(n2, "loose", { get() {
        return this._vueTypes_isLoose = true, this;
      } }), n2;
    }
    const M$3 = ["name", "validate", "getter"], R$2 = /* @__PURE__ */ (() => {
      var e2;
      return (e2 = class {
        static get any() {
          return w$4();
        }
        static get func() {
          return P$4().def(this.defaults.func);
        }
        static get bool() {
          return x$4().def(this.defaults.bool);
        }
        static get string() {
          return E$2().def(this.defaults.string);
        }
        static get number() {
          return N$2().def(this.defaults.number);
        }
        static get array() {
          return q$3().def(this.defaults.array);
        }
        static get object() {
          return A$3().def(this.defaults.object);
        }
        static get integer() {
          return V$1().def(this.defaults.integer);
        }
        static get symbol() {
          return S$5();
        }
        static get nullable() {
          return { type: null };
        }
        static extend(e3) {
          if (v$4(e3))
            return e3.forEach((e4) => this.extend(e4)), this;
          const { name: t2, validate: n2 = false, getter: i2 = false } = e3, o22 = r$3(e3, M$3);
          if (p$3(this, t2))
            throw new TypeError(`[VueTypes error]: Type "${t2}" already defined`);
          const { type: a2 } = o22;
          if (b$5(a2))
            return delete o22.type, Object.defineProperty(this, t2, i2 ? { get: () => T$2(t2, a2, o22) } : { value(...e4) {
              const r2 = T$2(t2, a2, o22);
              return r2.validator && (r2.validator = r2.validator.bind(r2, ...e4)), r2;
            } });
          let s2;
          return s2 = i2 ? { get() {
            const e4 = Object.assign({}, o22);
            return n2 ? _$2(t2, e4) : j$2(t2, e4);
          }, enumerable: true } : { value(...e4) {
            const r2 = Object.assign({}, o22);
            let i3;
            return i3 = n2 ? _$2(t2, r2) : j$2(t2, r2), r2.validator && (i3.validator = r2.validator.bind(i3, ...e4)), i3;
          }, enumerable: true }, Object.defineProperty(this, t2, s2);
        }
      }).defaults = {}, e2.sensibleDefaults = void 0, e2.config = n$4, e2.custom = D$2, e2.oneOf = L$2, e2.instanceOf = B$3, e2.oneOfType = F$2, e2.arrayOf = Y$2, e2.objectOf = I$1, e2.shape = J$2, e2.utils = { validate: (e3, t2) => true === m$5(t2, e3, true), toType: (e3, t2, r2 = false) => r2 ? _$2(e3, t2) : j$2(e3, t2) }, e2;
    })();
    function z$2(e2 = { func: () => {
    }, bool: true, string: "", number: 0, array: () => [], object: () => ({}), integer: 0 }) {
      var r2;
      return (r2 = class extends R$2 {
        static get sensibleDefaults() {
          return t$2({}, this.defaults);
        }
        static set sensibleDefaults(r3) {
          this.defaults = false !== r3 ? t$2({}, true !== r3 ? r3 : e2) : {};
        }
      }).defaults = t$2({}, e2), r2;
    }
    let C$4 = class C extends z$2() {
    };
    var t$1 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
    function e(t2) {
      var e2 = { exports: {} };
      return t2(e2, e2.exports), e2.exports;
    }
    var n$3 = function(t2) {
      return t2 && t2.Math == Math && t2;
    }, r$2 = n$3("object" == typeof globalThis && globalThis) || n$3("object" == typeof window && window) || n$3("object" == typeof self && self) || n$3("object" == typeof t$1 && t$1) || /* @__PURE__ */ function() {
      return this;
    }() || Function("return this")(), o$3 = function(t2) {
      try {
        return !!t2();
      } catch (t3) {
        return true;
      }
    }, i$2 = !o$3(function() {
      return 7 != Object.defineProperty({}, 1, { get: function() {
        return 7;
      } })[1];
    }), u$3 = {}.propertyIsEnumerable, a$3 = Object.getOwnPropertyDescriptor, c$3 = { f: a$3 && !u$3.call({ 1: 2 }, 1) ? function(t2) {
      var e2 = a$3(this, t2);
      return !!e2 && e2.enumerable;
    } : u$3 }, l$2 = function(t2, e2) {
      return { enumerable: !(1 & t2), configurable: !(2 & t2), writable: !(4 & t2), value: e2 };
    }, f$2 = {}.toString, s$2 = function(t2) {
      return f$2.call(t2).slice(8, -1);
    }, d$3 = "".split, v$3 = o$3(function() {
      return !Object("z").propertyIsEnumerable(0);
    }) ? function(t2) {
      return "String" == s$2(t2) ? d$3.call(t2, "") : Object(t2);
    } : Object, p$2 = function(t2) {
      if (null == t2)
        throw TypeError("Can't call method on " + t2);
      return t2;
    }, g$4 = function(t2) {
      return v$3(p$2(t2));
    }, h$2 = function(t2) {
      return "object" == typeof t2 ? null !== t2 : "function" == typeof t2;
    }, y$3 = function(t2, e2) {
      if (!h$2(t2))
        return t2;
      var n2, r2;
      if (e2 && "function" == typeof (n2 = t2.toString) && !h$2(r2 = n2.call(t2)))
        return r2;
      if ("function" == typeof (n2 = t2.valueOf) && !h$2(r2 = n2.call(t2)))
        return r2;
      if (!e2 && "function" == typeof (n2 = t2.toString) && !h$2(r2 = n2.call(t2)))
        return r2;
      throw TypeError("Can't convert object to primitive value");
    }, m$4 = {}.hasOwnProperty, S$4 = function(t2, e2) {
      return m$4.call(t2, e2);
    }, x$3 = r$2.document, b$4 = h$2(x$3) && h$2(x$3.createElement), E$1 = function(t2) {
      return b$4 ? x$3.createElement(t2) : {};
    }, w$3 = !i$2 && !o$3(function() {
      return 7 != Object.defineProperty(E$1("div"), "a", { get: function() {
        return 7;
      } }).a;
    }), O$1 = Object.getOwnPropertyDescriptor, T$1 = { f: i$2 ? O$1 : function(t2, e2) {
      if (t2 = g$4(t2), e2 = y$3(e2, true), w$3)
        try {
          return O$1(t2, e2);
        } catch (t3) {
        }
      if (S$4(t2, e2))
        return l$2(!c$3.f.call(t2, e2), t2[e2]);
    } }, A$2 = function(t2) {
      if (!h$2(t2))
        throw TypeError(String(t2) + " is not an object");
      return t2;
    }, k$2 = Object.defineProperty, R$1 = { f: i$2 ? k$2 : function(t2, e2, n2) {
      if (A$2(t2), e2 = y$3(e2, true), A$2(n2), w$3)
        try {
          return k$2(t2, e2, n2);
        } catch (t3) {
        }
      if ("get" in n2 || "set" in n2)
        throw TypeError("Accessors not supported");
      return "value" in n2 && (t2[e2] = n2.value), t2;
    } }, I = i$2 ? function(t2, e2, n2) {
      return R$1.f(t2, e2, l$2(1, n2));
    } : function(t2, e2, n2) {
      return t2[e2] = n2, t2;
    }, j$1 = function(t2, e2) {
      try {
        I(r$2, t2, e2);
      } catch (n2) {
        r$2[t2] = e2;
      }
      return e2;
    }, C$3 = r$2["__core-js_shared__"] || j$1("__core-js_shared__", {}), L$1 = Function.toString;
    "function" != typeof C$3.inspectSource && (C$3.inspectSource = function(t2) {
      return L$1.call(t2);
    });
    var P$3, M$2, _$1, D$1 = C$3.inspectSource, U$1 = r$2.WeakMap, N$1 = "function" == typeof U$1 && /native code/.test(D$1(U$1)), F$1 = e(function(t2) {
      (t2.exports = function(t3, e2) {
        return C$3[t3] || (C$3[t3] = void 0 !== e2 ? e2 : {});
      })("versions", []).push({ version: "3.8.3", mode: "global", copyright: "© 2021 Denis Pushkarev (zloirock.ru)" });
    }), W$3 = 0, z$1 = Math.random(), $$1 = function(t2) {
      return "Symbol(" + String(void 0 === t2 ? "" : t2) + ")_" + (++W$3 + z$1).toString(36);
    }, B$2 = F$1("keys"), Y$1 = function(t2) {
      return B$2[t2] || (B$2[t2] = $$1(t2));
    }, G$1 = {}, H$1 = r$2.WeakMap;
    if (N$1) {
      var X = C$3.state || (C$3.state = new H$1()), V = X.get, K$1 = X.has, q$2 = X.set;
      P$3 = function(t2, e2) {
        return e2.facade = t2, q$2.call(X, t2, e2), e2;
      }, M$2 = function(t2) {
        return V.call(X, t2) || {};
      }, _$1 = function(t2) {
        return K$1.call(X, t2);
      };
    } else {
      var Q$1 = Y$1("state");
      G$1[Q$1] = true, P$3 = function(t2, e2) {
        return e2.facade = t2, I(t2, Q$1, e2), e2;
      }, M$2 = function(t2) {
        return S$4(t2, Q$1) ? t2[Q$1] : {};
      }, _$1 = function(t2) {
        return S$4(t2, Q$1);
      };
    }
    var J$1 = { set: P$3, get: M$2, has: _$1, enforce: function(t2) {
      return _$1(t2) ? M$2(t2) : P$3(t2, {});
    }, getterFor: function(t2) {
      return function(e2) {
        var n2;
        if (!h$2(e2) || (n2 = M$2(e2)).type !== t2)
          throw TypeError("Incompatible receiver, " + t2 + " required");
        return n2;
      };
    } }, Z$1 = e(function(t2) {
      var e2 = J$1.get, n2 = J$1.enforce, o3 = String(String).split("String");
      (t2.exports = function(t3, e3, i2, u2) {
        var a2, c2 = !!u2 && !!u2.unsafe, l2 = !!u2 && !!u2.enumerable, f2 = !!u2 && !!u2.noTargetGet;
        "function" == typeof i2 && ("string" != typeof e3 || S$4(i2, "name") || I(i2, "name", e3), (a2 = n2(i2)).source || (a2.source = o3.join("string" == typeof e3 ? e3 : ""))), t3 !== r$2 ? (c2 ? !f2 && t3[e3] && (l2 = true) : delete t3[e3], l2 ? t3[e3] = i2 : I(t3, e3, i2)) : l2 ? t3[e3] = i2 : j$1(e3, i2);
      })(Function.prototype, "toString", function() {
        return "function" == typeof this && e2(this).source || D$1(this);
      });
    }), tt$1 = r$2, et$1 = function(t2) {
      return "function" == typeof t2 ? t2 : void 0;
    }, nt$1 = function(t2, e2) {
      return arguments.length < 2 ? et$1(tt$1[t2]) || et$1(r$2[t2]) : tt$1[t2] && tt$1[t2][e2] || r$2[t2] && r$2[t2][e2];
    }, rt$1 = Math.ceil, ot$1 = Math.floor, it$3 = function(t2) {
      return isNaN(t2 = +t2) ? 0 : (t2 > 0 ? ot$1 : rt$1)(t2);
    }, ut$2 = Math.min, at$1 = function(t2) {
      return t2 > 0 ? ut$2(it$3(t2), 9007199254740991) : 0;
    }, ct$2 = Math.max, lt$2 = Math.min, ft$2 = function(t2, e2) {
      var n2 = it$3(t2);
      return n2 < 0 ? ct$2(n2 + e2, 0) : lt$2(n2, e2);
    }, st$2 = function(t2) {
      return function(e2, n2, r2) {
        var o3, i2 = g$4(e2), u2 = at$1(i2.length), a2 = ft$2(r2, u2);
        if (t2 && n2 != n2) {
          for (; u2 > a2; )
            if ((o3 = i2[a2++]) != o3)
              return true;
        } else
          for (; u2 > a2; a2++)
            if ((t2 || a2 in i2) && i2[a2] === n2)
              return t2 || a2 || 0;
        return !t2 && -1;
      };
    }, dt$2 = { includes: st$2(true), indexOf: st$2(false) }, vt$2 = dt$2.indexOf, pt$2 = function(t2, e2) {
      var n2, r2 = g$4(t2), o3 = 0, i2 = [];
      for (n2 in r2)
        !S$4(G$1, n2) && S$4(r2, n2) && i2.push(n2);
      for (; e2.length > o3; )
        S$4(r2, n2 = e2[o3++]) && (~vt$2(i2, n2) || i2.push(n2));
      return i2;
    }, gt$2 = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], ht$2 = gt$2.concat("length", "prototype"), yt$2 = { f: Object.getOwnPropertyNames || function(t2) {
      return pt$2(t2, ht$2);
    } }, mt$2 = { f: Object.getOwnPropertySymbols }, St$2 = nt$1("Reflect", "ownKeys") || function(t2) {
      var e2 = yt$2.f(A$2(t2)), n2 = mt$2.f;
      return n2 ? e2.concat(n2(t2)) : e2;
    }, xt$1 = function(t2, e2) {
      for (var n2 = St$2(e2), r2 = R$1.f, o3 = T$1.f, i2 = 0; i2 < n2.length; i2++) {
        var u2 = n2[i2];
        S$4(t2, u2) || r2(t2, u2, o3(e2, u2));
      }
    }, bt$2 = /#|\.prototype\./, Et$1 = function(t2, e2) {
      var n2 = Ot$1[wt$2(t2)];
      return n2 == At$1 || n2 != Tt$2 && ("function" == typeof e2 ? o$3(e2) : !!e2);
    }, wt$2 = Et$1.normalize = function(t2) {
      return String(t2).replace(bt$2, ".").toLowerCase();
    }, Ot$1 = Et$1.data = {}, Tt$2 = Et$1.NATIVE = "N", At$1 = Et$1.POLYFILL = "P", kt$1 = Et$1, Rt$1 = T$1.f, It$1 = function(t2, e2) {
      var n2, o3, i2, u2, a2, c2 = t2.target, l2 = t2.global, f2 = t2.stat;
      if (n2 = l2 ? r$2 : f2 ? r$2[c2] || j$1(c2, {}) : (r$2[c2] || {}).prototype)
        for (o3 in e2) {
          if (u2 = e2[o3], i2 = t2.noTargetGet ? (a2 = Rt$1(n2, o3)) && a2.value : n2[o3], !kt$1(l2 ? o3 : c2 + (f2 ? "." : "#") + o3, t2.forced) && void 0 !== i2) {
            if (typeof u2 == typeof i2)
              continue;
            xt$1(u2, i2);
          }
          (t2.sham || i2 && i2.sham) && I(u2, "sham", true), Z$1(n2, o3, u2, t2);
        }
    }, jt$1 = function(t2, e2) {
      var n2 = [][t2];
      return !!n2 && o$3(function() {
        n2.call(null, e2 || function() {
          throw 1;
        }, 1);
      });
    }, Ct$2 = Object.defineProperty, Lt$1 = {}, Pt$2 = function(t2) {
      throw t2;
    }, Mt$1 = function(t2, e2) {
      if (S$4(Lt$1, t2))
        return Lt$1[t2];
      e2 || (e2 = {});
      var n2 = [][t2], r2 = !!S$4(e2, "ACCESSORS") && e2.ACCESSORS, u2 = S$4(e2, 0) ? e2[0] : Pt$2, a2 = S$4(e2, 1) ? e2[1] : void 0;
      return Lt$1[t2] = !!n2 && !o$3(function() {
        if (r2 && !i$2)
          return true;
        var t3 = { length: -1 };
        r2 ? Ct$2(t3, 1, { enumerable: true, get: Pt$2 }) : t3[1] = 1, n2.call(t3, u2, a2);
      });
    }, _t$2 = dt$2.indexOf, Dt$1 = [].indexOf, Ut$1 = !!Dt$1 && 1 / [1].indexOf(1, -0) < 0, Nt$1 = jt$1("indexOf"), Ft$1 = Mt$1("indexOf", { ACCESSORS: true, 1: 0 });
    function Wt$1(t2, e2) {
      if (!(t2 instanceof e2))
        throw new TypeError("Cannot call a class as a function");
    }
    function zt$2(t2, e2) {
      for (var n2 = 0; n2 < e2.length; n2++) {
        var r2 = e2[n2];
        r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t2, r2.key, r2);
      }
    }
    function $t$2(t2, e2, n2) {
      return n2 && zt$2(t2, n2), t2;
    }
    It$1({ target: "Array", proto: true, forced: Ut$1 || !Nt$1 || !Ft$1 }, { indexOf: function(t2) {
      return Ut$1 ? Dt$1.apply(this, arguments) || 0 : _t$2(this, t2, arguments.length > 1 ? arguments[1] : void 0);
    } });
    (function() {
      function t2() {
        Wt$1(this, t2);
      }
      return $t$2(t2, null, [{ key: "isInBrowser", value: function() {
        return "undefined" != typeof window;
      } }, { key: "isServer", value: function() {
        return "undefined" == typeof window;
      } }, { key: "getUA", value: function() {
        return t2.isInBrowser() ? window.navigator.userAgent.toLowerCase() : "";
      } }, { key: "isMobile", value: function() {
        return /Mobile|mini|Fennec|Android|iP(ad|od|hone)/.test(navigator.appVersion);
      } }, { key: "isOpera", value: function() {
        return -1 !== navigator.userAgent.indexOf("Opera");
      } }, { key: "isIE", value: function() {
        var e2 = t2.getUA();
        return "" !== e2 && e2.indexOf("msie") > 0;
      } }, { key: "isIE9", value: function() {
        var e2 = t2.getUA();
        return "" !== e2 && e2.indexOf("msie 9.0") > 0;
      } }, { key: "isEdge", value: function() {
        var e2 = t2.getUA();
        return "" !== e2 && e2.indexOf("edge/") > 0;
      } }, { key: "isChrome", value: function() {
        var e2 = t2.getUA();
        return "" !== e2 && /chrome\/\d+/.test(e2) && !t2.isEdge();
      } }, { key: "isPhantomJS", value: function() {
        var e2 = t2.getUA();
        return "" !== e2 && /phantomjs/.test(e2);
      } }, { key: "isFirefox", value: function() {
        var e2 = t2.getUA();
        return "" !== e2 && /firefox/.test(e2);
      } }]), t2;
    })();
    var Yt$1 = [].join, Gt$1 = v$3 != Object, Ht$1 = jt$1("join", ",");
    It$1({ target: "Array", proto: true, forced: Gt$1 || !Ht$1 }, { join: function(t2) {
      return Yt$1.call(g$4(this), void 0 === t2 ? "," : t2);
    } });
    var Xt$1, Vt$1, Kt$1 = function(t2) {
      return Object(p$2(t2));
    }, qt$2 = Array.isArray || function(t2) {
      return "Array" == s$2(t2);
    }, Qt$1 = !!Object.getOwnPropertySymbols && !o$3(function() {
      return !String(Symbol());
    }), Jt$1 = Qt$1 && !Symbol.sham && "symbol" == typeof Symbol.iterator, Zt$1 = F$1("wks"), te$1 = r$2.Symbol, ee$1 = Jt$1 ? te$1 : te$1 && te$1.withoutSetter || $$1, ne$1 = function(t2) {
      return S$4(Zt$1, t2) || (Qt$1 && S$4(te$1, t2) ? Zt$1[t2] = te$1[t2] : Zt$1[t2] = ee$1("Symbol." + t2)), Zt$1[t2];
    }, re$2 = ne$1("species"), oe = function(t2, e2) {
      var n2;
      return qt$2(t2) && ("function" != typeof (n2 = t2.constructor) || n2 !== Array && !qt$2(n2.prototype) ? h$2(n2) && null === (n2 = n2[re$2]) && (n2 = void 0) : n2 = void 0), new (void 0 === n2 ? Array : n2)(0 === e2 ? 0 : e2);
    }, ie = function(t2, e2, n2) {
      var r2 = y$3(e2);
      r2 in t2 ? R$1.f(t2, r2, l$2(0, n2)) : t2[r2] = n2;
    }, ue$2 = nt$1("navigator", "userAgent") || "", ae$1 = r$2.process, ce$1 = ae$1 && ae$1.versions, le$1 = ce$1 && ce$1.v8;
    le$1 ? Vt$1 = (Xt$1 = le$1.split("."))[0] + Xt$1[1] : ue$2 && (!(Xt$1 = ue$2.match(/Edge\/(\d+)/)) || Xt$1[1] >= 74) && (Xt$1 = ue$2.match(/Chrome\/(\d+)/)) && (Vt$1 = Xt$1[1]);
    var fe$2 = Vt$1 && +Vt$1, se$1 = ne$1("species"), de$3 = function(t2) {
      return fe$2 >= 51 || !o$3(function() {
        var e2 = [];
        return (e2.constructor = {})[se$1] = function() {
          return { foo: 1 };
        }, 1 !== e2[t2](Boolean).foo;
      });
    }, ve$2 = de$3("splice"), pe$1 = Mt$1("splice", { ACCESSORS: true, 0: 0, 1: 2 }), ge = Math.max, he$1 = Math.min;
    It$1({ target: "Array", proto: true, forced: !ve$2 || !pe$1 }, { splice: function(t2, e2) {
      var n2, r2, o3, i2, u2, a2, c2 = Kt$1(this), l2 = at$1(c2.length), f2 = ft$2(t2, l2), s2 = arguments.length;
      if (0 === s2 ? n2 = r2 = 0 : 1 === s2 ? (n2 = 0, r2 = l2 - f2) : (n2 = s2 - 2, r2 = he$1(ge(it$3(e2), 0), l2 - f2)), l2 + n2 - r2 > 9007199254740991)
        throw TypeError("Maximum allowed length exceeded");
      for (o3 = oe(c2, r2), i2 = 0; i2 < r2; i2++)
        (u2 = f2 + i2) in c2 && ie(o3, i2, c2[u2]);
      if (o3.length = r2, n2 < r2) {
        for (i2 = f2; i2 < l2 - r2; i2++)
          a2 = i2 + n2, (u2 = i2 + r2) in c2 ? c2[a2] = c2[u2] : delete c2[a2];
        for (i2 = l2; i2 > l2 - r2 + n2; i2--)
          delete c2[i2 - 1];
      } else if (n2 > r2)
        for (i2 = l2 - r2; i2 > f2; i2--)
          a2 = i2 + n2 - 1, (u2 = i2 + r2 - 1) in c2 ? c2[a2] = c2[u2] : delete c2[a2];
      for (i2 = 0; i2 < n2; i2++)
        c2[i2 + f2] = arguments[i2 + 2];
      return c2.length = l2 - r2 + n2, o3;
    } });
    var ye$2 = {};
    ye$2[ne$1("toStringTag")] = "z";
    var me$1 = "[object z]" === String(ye$2), Se$2 = ne$1("toStringTag"), xe = "Arguments" == s$2(/* @__PURE__ */ function() {
      return arguments;
    }()), be$2 = me$1 ? s$2 : function(t2) {
      var e2, n2, r2;
      return void 0 === t2 ? "Undefined" : null === t2 ? "Null" : "string" == typeof (n2 = function(t3, e3) {
        try {
          return t3[e3];
        } catch (t4) {
        }
      }(e2 = Object(t2), Se$2)) ? n2 : xe ? s$2(e2) : "Object" == (r2 = s$2(e2)) && "function" == typeof e2.callee ? "Arguments" : r2;
    }, Ee = me$1 ? {}.toString : function() {
      return "[object " + be$2(this) + "]";
    };
    me$1 || Z$1(Object.prototype, "toString", Ee, { unsafe: true });
    var we$1 = function() {
      var t2 = A$2(this), e2 = "";
      return t2.global && (e2 += "g"), t2.ignoreCase && (e2 += "i"), t2.multiline && (e2 += "m"), t2.dotAll && (e2 += "s"), t2.unicode && (e2 += "u"), t2.sticky && (e2 += "y"), e2;
    };
    function Oe$1(t2, e2) {
      return RegExp(t2, e2);
    }
    var Te$1, Ae$2, ke$1 = { UNSUPPORTED_Y: o$3(function() {
      var t2 = Oe$1("a", "y");
      return t2.lastIndex = 2, null != t2.exec("abcd");
    }), BROKEN_CARET: o$3(function() {
      var t2 = Oe$1("^r", "gy");
      return t2.lastIndex = 2, null != t2.exec("str");
    }) }, Re = RegExp.prototype.exec, Ie = String.prototype.replace, je = Re, Ce$2 = (Te$1 = /a/, Ae$2 = /b*/g, Re.call(Te$1, "a"), Re.call(Ae$2, "a"), 0 !== Te$1.lastIndex || 0 !== Ae$2.lastIndex), Le$1 = ke$1.UNSUPPORTED_Y || ke$1.BROKEN_CARET, Pe$2 = void 0 !== /()??/.exec("")[1];
    (Ce$2 || Pe$2 || Le$1) && (je = function(t2) {
      var e2, n2, r2, o3, i2 = this, u2 = Le$1 && i2.sticky, a2 = we$1.call(i2), c2 = i2.source, l2 = 0, f2 = t2;
      return u2 && (-1 === (a2 = a2.replace("y", "")).indexOf("g") && (a2 += "g"), f2 = String(t2).slice(i2.lastIndex), i2.lastIndex > 0 && (!i2.multiline || i2.multiline && "\n" !== t2[i2.lastIndex - 1]) && (c2 = "(?: " + c2 + ")", f2 = " " + f2, l2++), n2 = new RegExp("^(?:" + c2 + ")", a2)), Pe$2 && (n2 = new RegExp("^" + c2 + "$(?!\\s)", a2)), Ce$2 && (e2 = i2.lastIndex), r2 = Re.call(u2 ? n2 : i2, f2), u2 ? r2 ? (r2.input = r2.input.slice(l2), r2[0] = r2[0].slice(l2), r2.index = i2.lastIndex, i2.lastIndex += r2[0].length) : i2.lastIndex = 0 : Ce$2 && r2 && (i2.lastIndex = i2.global ? r2.index + r2[0].length : e2), Pe$2 && r2 && r2.length > 1 && Ie.call(r2[0], n2, function() {
        for (o3 = 1; o3 < arguments.length - 2; o3++)
          void 0 === arguments[o3] && (r2[o3] = void 0);
      }), r2;
    });
    var Me$1 = je;
    It$1({ target: "RegExp", proto: true, forced: /./.exec !== Me$1 }, { exec: Me$1 });
    var _e$2 = RegExp.prototype, De = _e$2.toString, Ue = o$3(function() {
      return "/a/b" != De.call({ source: "a", flags: "b" });
    }), Ne$2 = "toString" != De.name;
    (Ue || Ne$2) && Z$1(RegExp.prototype, "toString", function() {
      var t2 = A$2(this), e2 = String(t2.source), n2 = t2.flags;
      return "/" + e2 + "/" + String(void 0 === n2 && t2 instanceof RegExp && !("flags" in _e$2) ? we$1.call(t2) : n2);
    }, { unsafe: true });
    var Fe = ne$1("species"), We = !o$3(function() {
      var t2 = /./;
      return t2.exec = function() {
        var t3 = [];
        return t3.groups = { a: "7" }, t3;
      }, "7" !== "".replace(t2, "$<a>");
    }), ze$1 = "$0" === "a".replace(/./, "$0"), $e$1 = ne$1("replace"), Be = !!/./[$e$1] && "" === /./[$e$1]("a", "$0"), Ye$1 = !o$3(function() {
      var t2 = /(?:)/, e2 = t2.exec;
      t2.exec = function() {
        return e2.apply(this, arguments);
      };
      var n2 = "ab".split(t2);
      return 2 !== n2.length || "a" !== n2[0] || "b" !== n2[1];
    }), Ge = function(t2, e2, n2, r2) {
      var i2 = ne$1(t2), u2 = !o$3(function() {
        var e3 = {};
        return e3[i2] = function() {
          return 7;
        }, 7 != ""[t2](e3);
      }), a2 = u2 && !o$3(function() {
        var e3 = false, n3 = /a/;
        return "split" === t2 && ((n3 = {}).constructor = {}, n3.constructor[Fe] = function() {
          return n3;
        }, n3.flags = "", n3[i2] = /./[i2]), n3.exec = function() {
          return e3 = true, null;
        }, n3[i2](""), !e3;
      });
      if (!u2 || !a2 || "replace" === t2 && (!We || !ze$1 || Be) || "split" === t2 && !Ye$1) {
        var c2 = /./[i2], l2 = n2(i2, ""[t2], function(t3, e3, n3, r3, o3) {
          return e3.exec === Me$1 ? u2 && !o3 ? { done: true, value: c2.call(e3, n3, r3) } : { done: true, value: t3.call(n3, e3, r3) } : { done: false };
        }, { REPLACE_KEEPS_$0: ze$1, REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: Be }), f2 = l2[0], s2 = l2[1];
        Z$1(String.prototype, t2, f2), Z$1(RegExp.prototype, i2, function(t3, e3) {
          return s2.call(t3, this, e3);
        });
      }
      r2 && I(RegExp.prototype[i2], "sham", true);
    }, He$1 = ne$1("match"), Xe = function(t2) {
      var e2;
      return h$2(t2) && (void 0 !== (e2 = t2[He$1]) ? !!e2 : "RegExp" == s$2(t2));
    }, Ve$1 = function(t2) {
      if ("function" != typeof t2)
        throw TypeError(String(t2) + " is not a function");
      return t2;
    }, Ke$1 = ne$1("species"), qe$1 = function(t2) {
      return function(e2, n2) {
        var r2, o3, i2 = String(p$2(e2)), u2 = it$3(n2), a2 = i2.length;
        return u2 < 0 || u2 >= a2 ? t2 ? "" : void 0 : (r2 = i2.charCodeAt(u2)) < 55296 || r2 > 56319 || u2 + 1 === a2 || (o3 = i2.charCodeAt(u2 + 1)) < 56320 || o3 > 57343 ? t2 ? i2.charAt(u2) : r2 : t2 ? i2.slice(u2, u2 + 2) : o3 - 56320 + (r2 - 55296 << 10) + 65536;
      };
    }, Qe$1 = { codeAt: qe$1(false), charAt: qe$1(true) }, Je$1 = Qe$1.charAt, Ze$1 = function(t2, e2, n2) {
      return e2 + (n2 ? Je$1(t2, e2).length : 1);
    }, tn = function(t2, e2) {
      var n2 = t2.exec;
      if ("function" == typeof n2) {
        var r2 = n2.call(t2, e2);
        if ("object" != typeof r2)
          throw TypeError("RegExp exec method returned something other than an Object or null");
        return r2;
      }
      if ("RegExp" !== s$2(t2))
        throw TypeError("RegExp#exec called on incompatible receiver");
      return Me$1.call(t2, e2);
    }, en$1 = [].push, nn = Math.min, rn = !o$3(function() {
      return !RegExp(4294967295, "y");
    });
    Ge("split", 2, function(t2, e2, n2) {
      var r2;
      return r2 = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function(t3, n3) {
        var r3 = String(p$2(this)), o3 = void 0 === n3 ? 4294967295 : n3 >>> 0;
        if (0 === o3)
          return [];
        if (void 0 === t3)
          return [r3];
        if (!Xe(t3))
          return e2.call(r3, t3, o3);
        for (var i2, u2, a2, c2 = [], l2 = (t3.ignoreCase ? "i" : "") + (t3.multiline ? "m" : "") + (t3.unicode ? "u" : "") + (t3.sticky ? "y" : ""), f2 = 0, s2 = new RegExp(t3.source, l2 + "g"); (i2 = Me$1.call(s2, r3)) && !((u2 = s2.lastIndex) > f2 && (c2.push(r3.slice(f2, i2.index)), i2.length > 1 && i2.index < r3.length && en$1.apply(c2, i2.slice(1)), a2 = i2[0].length, f2 = u2, c2.length >= o3)); )
          s2.lastIndex === i2.index && s2.lastIndex++;
        return f2 === r3.length ? !a2 && s2.test("") || c2.push("") : c2.push(r3.slice(f2)), c2.length > o3 ? c2.slice(0, o3) : c2;
      } : "0".split(void 0, 0).length ? function(t3, n3) {
        return void 0 === t3 && 0 === n3 ? [] : e2.call(this, t3, n3);
      } : e2, [function(e3, n3) {
        var o3 = p$2(this), i2 = null == e3 ? void 0 : e3[t2];
        return void 0 !== i2 ? i2.call(e3, o3, n3) : r2.call(String(o3), e3, n3);
      }, function(t3, o3) {
        var i2 = n2(r2, t3, this, o3, r2 !== e2);
        if (i2.done)
          return i2.value;
        var u2 = A$2(t3), a2 = String(this), c2 = function(t4, e3) {
          var n3, r3 = A$2(t4).constructor;
          return void 0 === r3 || null == (n3 = A$2(r3)[Ke$1]) ? e3 : Ve$1(n3);
        }(u2, RegExp), l2 = u2.unicode, f2 = (u2.ignoreCase ? "i" : "") + (u2.multiline ? "m" : "") + (u2.unicode ? "u" : "") + (rn ? "y" : "g"), s2 = new c2(rn ? u2 : "^(?:" + u2.source + ")", f2), d2 = void 0 === o3 ? 4294967295 : o3 >>> 0;
        if (0 === d2)
          return [];
        if (0 === a2.length)
          return null === tn(s2, a2) ? [a2] : [];
        for (var v2 = 0, p2 = 0, g2 = []; p2 < a2.length; ) {
          s2.lastIndex = rn ? p2 : 0;
          var h2, y2 = tn(s2, rn ? a2 : a2.slice(p2));
          if (null === y2 || (h2 = nn(at$1(s2.lastIndex + (rn ? 0 : p2)), a2.length)) === v2)
            p2 = Ze$1(a2, p2, l2);
          else {
            if (g2.push(a2.slice(v2, p2)), g2.length === d2)
              return g2;
            for (var m2 = 1; m2 <= y2.length - 1; m2++)
              if (g2.push(y2[m2]), g2.length === d2)
                return g2;
            p2 = v2 = h2;
          }
        }
        return g2.push(a2.slice(v2)), g2;
      }];
    }, !rn);
    var on$2 = "	\n\v\f\r                　\u2028\u2029\uFEFF", un = "[" + on$2 + "]", an = RegExp("^" + un + un + "*"), cn$1 = RegExp(un + un + "*$"), ln = function(t2) {
      return function(e2) {
        var n2 = String(p$2(e2));
        return 1 & t2 && (n2 = n2.replace(an, "")), 2 & t2 && (n2 = n2.replace(cn$1, "")), n2;
      };
    }, fn = { start: ln(1), end: ln(2), trim: ln(3) }, sn = fn.trim;
    It$1({ target: "String", proto: true, forced: function(t2) {
      return o$3(function() {
        return !!on$2[t2]() || "​᠎" != "​᠎"[t2]() || on$2[t2].name !== t2;
      });
    }("trim") }, { trim: function() {
      return sn(this);
    } });
    var dn = de$3("slice"), vn = Mt$1("slice", { ACCESSORS: true, 0: 0, 1: 2 }), pn = ne$1("species"), gn = [].slice, hn = Math.max;
    It$1({ target: "Array", proto: true, forced: !dn || !vn }, { slice: function(t2, e2) {
      var n2, r2, o3, i2 = g$4(this), u2 = at$1(i2.length), a2 = ft$2(t2, u2), c2 = ft$2(void 0 === e2 ? u2 : e2, u2);
      if (qt$2(i2) && ("function" != typeof (n2 = i2.constructor) || n2 !== Array && !qt$2(n2.prototype) ? h$2(n2) && null === (n2 = n2[pn]) && (n2 = void 0) : n2 = void 0, n2 === Array || void 0 === n2))
        return gn.call(i2, a2, c2);
      for (r2 = new (void 0 === n2 ? Array : n2)(hn(c2 - a2, 0)), o3 = 0; a2 < c2; a2++, o3++)
        a2 in i2 && ie(r2, o3, i2[a2]);
      return r2.length = o3, r2;
    } });
    var yn = Object.keys || function(t2) {
      return pt$2(t2, gt$2);
    }, mn = o$3(function() {
      yn(1);
    });
    It$1({ target: "Object", stat: true, forced: mn }, { keys: function(t2) {
      return yn(Kt$1(t2));
    } });
    var Sn, xn = function(t2) {
      if (Xe(t2))
        throw TypeError("The method doesn't accept regular expressions");
      return t2;
    }, bn = ne$1("match"), En = T$1.f, wn = "".startsWith, On = Math.min, Tn = function(t2) {
      var e2 = /./;
      try {
        "/./"[t2](e2);
      } catch (n2) {
        try {
          return e2[bn] = false, "/./"[t2](e2);
        } catch (t3) {
        }
      }
      return false;
    }("startsWith"), An = !(Tn || (Sn = En(String.prototype, "startsWith"), !Sn || Sn.writable));
    function kn(t2) {
      return (kn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
        return typeof t3;
      } : function(t3) {
        return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
      })(t2);
    }
    It$1({ target: "String", proto: true, forced: !An && !Tn }, { startsWith: function(t2) {
      var e2 = String(p$2(this));
      xn(t2);
      var n2 = at$1(On(arguments.length > 1 ? arguments[1] : void 0, e2.length)), r2 = String(t2);
      return wn ? wn.call(e2, r2, n2) : e2.slice(n2, n2 + r2.length) === r2;
    } });
    var jn = function(t2) {
      return "string" == typeof t2;
    }, Mn = function(t2) {
      return null !== t2 && "object" === kn(t2);
    }, Vn = function() {
      function t2() {
        Wt$1(this, t2);
      }
      return $t$2(t2, null, [{ key: "isWindow", value: function(t3) {
        return t3 === window;
      } }, { key: "addEventListener", value: function(t3, e2, n2) {
        var r2 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
        t3 && e2 && n2 && t3.addEventListener(e2, n2, r2);
      } }, { key: "removeEventListener", value: function(t3, e2, n2) {
        var r2 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
        t3 && e2 && n2 && t3.removeEventListener(e2, n2, r2);
      } }, { key: "triggerDragEvent", value: function(e2, n2) {
        var r2 = false, o3 = function(t3) {
          var e3;
          null === (e3 = n2.drag) || void 0 === e3 || e3.call(n2, t3);
        }, i2 = function e3(i3) {
          var u2;
          t2.removeEventListener(document, "mousemove", o3), t2.removeEventListener(document, "mouseup", e3), document.onselectstart = null, document.ondragstart = null, r2 = false, null === (u2 = n2.end) || void 0 === u2 || u2.call(n2, i3);
        };
        t2.addEventListener(e2, "mousedown", function(e3) {
          var u2;
          r2 || (document.onselectstart = function() {
            return false;
          }, document.ondragstart = function() {
            return false;
          }, t2.addEventListener(document, "mousemove", o3), t2.addEventListener(document, "mouseup", i2), r2 = true, null === (u2 = n2.start) || void 0 === u2 || u2.call(n2, e3));
        });
      } }, { key: "getBoundingClientRect", value: function(t3) {
        return t3 && Mn(t3) && 1 === t3.nodeType ? t3.getBoundingClientRect() : null;
      } }, { key: "hasClass", value: function(t3, e2) {
        return !!(t3 && Mn(t3) && jn(e2) && 1 === t3.nodeType) && t3.classList.contains(e2.trim());
      } }, { key: "addClass", value: function(e2, n2) {
        if (e2 && Mn(e2) && jn(n2) && 1 === e2.nodeType && (n2 = n2.trim(), !t2.hasClass(e2, n2))) {
          var r2 = e2.className;
          e2.className = r2 ? r2 + " " + n2 : n2;
        }
      } }, { key: "removeClass", value: function(t3, e2) {
        if (t3 && Mn(t3) && jn(e2) && 1 === t3.nodeType && "string" == typeof t3.className) {
          e2 = e2.trim();
          for (var n2 = t3.className.trim().split(" "), r2 = n2.length - 1; r2 >= 0; r2--)
            n2[r2] = n2[r2].trim(), n2[r2] && n2[r2] !== e2 || n2.splice(r2, 1);
          t3.className = n2.join(" ");
        }
      } }, { key: "toggleClass", value: function(t3, e2, n2) {
        t3 && Mn(t3) && jn(e2) && 1 === t3.nodeType && t3.classList.toggle(e2, n2);
      } }, { key: "replaceClass", value: function(e2, n2, r2) {
        e2 && Mn(e2) && jn(n2) && jn(r2) && 1 === e2.nodeType && (n2 = n2.trim(), r2 = r2.trim(), t2.removeClass(e2, n2), t2.addClass(e2, r2));
      } }, { key: "getScrollTop", value: function(t3) {
        var e2 = "scrollTop" in t3 ? t3.scrollTop : t3.pageYOffset;
        return Math.max(e2, 0);
      } }, { key: "setScrollTop", value: function(t3, e2) {
        "scrollTop" in t3 ? t3.scrollTop = e2 : t3.scrollTo(t3.scrollX, e2);
      } }, { key: "getRootScrollTop", value: function() {
        return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
      } }, { key: "setRootScrollTop", value: function(e2) {
        t2.setScrollTop(window, e2), t2.setScrollTop(document.body, e2);
      } }, { key: "getElementTop", value: function(e2, n2) {
        if (t2.isWindow(e2))
          return 0;
        var r2 = n2 ? t2.getScrollTop(n2) : t2.getRootScrollTop();
        return e2.getBoundingClientRect().top + r2;
      } }, { key: "getVisibleHeight", value: function(e2) {
        return t2.isWindow(e2) ? e2.innerHeight : e2.getBoundingClientRect().height;
      } }, { key: "isHidden", value: function(t3) {
        if (!t3)
          return false;
        var e2 = window.getComputedStyle(t3), n2 = "none" === e2.display, r2 = null === t3.offsetParent && "fixed" !== e2.position;
        return n2 || r2;
      } }, { key: "triggerEvent", value: function(t3, e2) {
        if ("createEvent" in document) {
          var n2 = document.createEvent("HTMLEvents");
          n2.initEvent(e2, false, true), t3.dispatchEvent(n2);
        }
      } }, { key: "calcAngle", value: function(t3, e2) {
        var n2 = t3.getBoundingClientRect(), r2 = n2.left + n2.width / 2, o3 = n2.top + n2.height / 2, i2 = Math.abs(r2 - e2.clientX), u2 = Math.abs(o3 - e2.clientY), a2 = u2 / Math.sqrt(Math.pow(i2, 2) + Math.pow(u2, 2)), c2 = Math.acos(a2), l2 = Math.floor(180 / (Math.PI / c2));
        return e2.clientX > r2 && e2.clientY > o3 && (l2 = 180 - l2), e2.clientX == r2 && e2.clientY > o3 && (l2 = 180), e2.clientX > r2 && e2.clientY == o3 && (l2 = 90), e2.clientX < r2 && e2.clientY > o3 && (l2 = 180 + l2), e2.clientX < r2 && e2.clientY == o3 && (l2 = 270), e2.clientX < r2 && e2.clientY < o3 && (l2 = 360 - l2), l2;
      } }, { key: "querySelector", value: function(t3, e2) {
        return e2 ? e2.querySelector(t3) : document.querySelector(t3);
      } }, { key: "createElement", value: function(t3) {
        for (var e2 = document.createElement(t3), n2 = arguments.length, r2 = new Array(n2 > 1 ? n2 - 1 : 0), o3 = 1; o3 < n2; o3++)
          r2[o3 - 1] = arguments[o3];
        for (var i2 = 0; i2 < r2.length; i2++)
          r2[i2] && e2.classList.add(r2[i2]);
        return e2;
      } }, { key: "appendChild", value: function(t3) {
        for (var e2 = 0; e2 < (arguments.length <= 1 ? 0 : arguments.length - 1); e2++)
          t3.appendChild(e2 + 1 < 1 || arguments.length <= e2 + 1 ? void 0 : arguments[e2 + 1]);
      } }, { key: "getWindow", value: function(t3) {
        if ("[object Window]" !== t3.toString()) {
          var e2 = t3.ownerDocument;
          return e2 && e2.defaultView || window;
        }
        return t3;
      } }, { key: "isElement", value: function(t3) {
        return t3 instanceof this.getWindow(t3).Element || t3 instanceof Element;
      } }, { key: "isHTMLElement", value: function(t3) {
        return t3 instanceof this.getWindow(t3).HTMLElement || t3 instanceof HTMLElement;
      } }, { key: "isShadowRoot", value: function(t3) {
        return "undefined" != typeof ShadowRoot && (t3 instanceof this.getWindow(t3).ShadowRoot || t3 instanceof ShadowRoot);
      } }, { key: "getWindowScroll", value: function(t3) {
        var e2 = this.getWindow(t3);
        return { scrollLeft: e2.pageXOffset || 0, scrollTop: e2.pageYOffset || 0 };
      } }]), t2;
    }(), Kn = Math.floor, qn = "".replace, Qn = /\$([$&'`]|\d\d?|<[^>]*>)/g, Jn = /\$([$&'`]|\d\d?)/g, Zn = function(t2, e2, n2, r2, o3, i2) {
      var u2 = n2 + t2.length, a2 = r2.length, c2 = Jn;
      return void 0 !== o3 && (o3 = Kt$1(o3), c2 = Qn), qn.call(i2, c2, function(i3, c3) {
        var l2;
        switch (c3.charAt(0)) {
          case "$":
            return "$";
          case "&":
            return t2;
          case "`":
            return e2.slice(0, n2);
          case "'":
            return e2.slice(u2);
          case "<":
            l2 = o3[c3.slice(1, -1)];
            break;
          default:
            var f2 = +c3;
            if (0 === f2)
              return i3;
            if (f2 > a2) {
              var s2 = Kn(f2 / 10);
              return 0 === s2 ? i3 : s2 <= a2 ? void 0 === r2[s2 - 1] ? c3.charAt(1) : r2[s2 - 1] + c3.charAt(1) : i3;
            }
            l2 = r2[f2 - 1];
        }
        return void 0 === l2 ? "" : l2;
      });
    }, tr = Math.max, er = Math.min;
    Ge("replace", 2, function(t2, e2, n2, r2) {
      var o3 = r2.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE, i2 = r2.REPLACE_KEEPS_$0, u2 = o3 ? "$" : "$0";
      return [function(n3, r3) {
        var o4 = p$2(this), i3 = null == n3 ? void 0 : n3[t2];
        return void 0 !== i3 ? i3.call(n3, o4, r3) : e2.call(String(o4), n3, r3);
      }, function(t3, r3) {
        if (!o3 && i2 || "string" == typeof r3 && -1 === r3.indexOf(u2)) {
          var a2 = n2(e2, t3, this, r3);
          if (a2.done)
            return a2.value;
        }
        var c2 = A$2(t3), l2 = String(this), f2 = "function" == typeof r3;
        f2 || (r3 = String(r3));
        var s2 = c2.global;
        if (s2) {
          var d2 = c2.unicode;
          c2.lastIndex = 0;
        }
        for (var v2 = []; ; ) {
          var p2 = tn(c2, l2);
          if (null === p2)
            break;
          if (v2.push(p2), !s2)
            break;
          "" === String(p2[0]) && (c2.lastIndex = Ze$1(l2, at$1(c2.lastIndex), d2));
        }
        for (var g2, h2 = "", y2 = 0, m2 = 0; m2 < v2.length; m2++) {
          p2 = v2[m2];
          for (var S2 = String(p2[0]), x2 = tr(er(it$3(p2.index), l2.length), 0), b2 = [], E2 = 1; E2 < p2.length; E2++)
            b2.push(void 0 === (g2 = p2[E2]) ? g2 : String(g2));
          var w2 = p2.groups;
          if (f2) {
            var O2 = [S2].concat(b2, x2, l2);
            void 0 !== w2 && O2.push(w2);
            var T2 = String(r3.apply(void 0, O2));
          } else
            T2 = Zn(S2, l2, x2, b2, w2, r3);
          x2 >= y2 && (h2 += l2.slice(y2, x2) + T2, y2 = x2 + S2.length);
        }
        return h2 + l2.slice(y2);
      }];
    });
    (function() {
      function t2() {
        Wt$1(this, t2);
      }
      return $t$2(t2, null, [{ key: "camelize", value: function(t3) {
        return t3.replace(/-(\w)/g, function(t4, e2) {
          return e2 ? e2.toUpperCase() : "";
        });
      } }, { key: "capitalize", value: function(t3) {
        return t3.charAt(0).toUpperCase() + t3.slice(1);
      } }]), t2;
    })();
    (function() {
      function t2() {
        Wt$1(this, t2);
      }
      return $t$2(t2, null, [{ key: "_clone", value: function() {
      } }]), t2;
    })();
    var or = ne$1("isConcatSpreadable"), ir = fe$2 >= 51 || !o$3(function() {
      var t2 = [];
      return t2[or] = false, t2.concat()[0] !== t2;
    }), ur = de$3("concat"), ar = function(t2) {
      if (!h$2(t2))
        return false;
      var e2 = t2[or];
      return void 0 !== e2 ? !!e2 : qt$2(t2);
    };
    It$1({ target: "Array", proto: true, forced: !ir || !ur }, { concat: function(t2) {
      var e2, n2, r2, o3, i2, u2 = Kt$1(this), a2 = oe(u2, 0), c2 = 0;
      for (e2 = -1, r2 = arguments.length; e2 < r2; e2++)
        if (ar(i2 = -1 === e2 ? u2 : arguments[e2])) {
          if (c2 + (o3 = at$1(i2.length)) > 9007199254740991)
            throw TypeError("Maximum allowed index exceeded");
          for (n2 = 0; n2 < o3; n2++, c2++)
            n2 in i2 && ie(a2, c2, i2[n2]);
        } else {
          if (c2 >= 9007199254740991)
            throw TypeError("Maximum allowed index exceeded");
          ie(a2, c2++, i2);
        }
      return a2.length = c2, a2;
    } });
    var cr, lr = function(t2, e2, n2) {
      if (Ve$1(t2), void 0 === e2)
        return t2;
      switch (n2) {
        case 0:
          return function() {
            return t2.call(e2);
          };
        case 1:
          return function(n3) {
            return t2.call(e2, n3);
          };
        case 2:
          return function(n3, r2) {
            return t2.call(e2, n3, r2);
          };
        case 3:
          return function(n3, r2, o3) {
            return t2.call(e2, n3, r2, o3);
          };
      }
      return function() {
        return t2.apply(e2, arguments);
      };
    }, fr$1 = [].push, sr = function(t2) {
      var e2 = 1 == t2, n2 = 2 == t2, r2 = 3 == t2, o3 = 4 == t2, i2 = 6 == t2, u2 = 7 == t2, a2 = 5 == t2 || i2;
      return function(c2, l2, f2, s2) {
        for (var d2, p2, g2 = Kt$1(c2), h2 = v$3(g2), y2 = lr(l2, f2, 3), m2 = at$1(h2.length), S2 = 0, x2 = s2 || oe, b2 = e2 ? x2(c2, m2) : n2 || u2 ? x2(c2, 0) : void 0; m2 > S2; S2++)
          if ((a2 || S2 in h2) && (p2 = y2(d2 = h2[S2], S2, g2), t2))
            if (e2)
              b2[S2] = p2;
            else if (p2)
              switch (t2) {
                case 3:
                  return true;
                case 5:
                  return d2;
                case 6:
                  return S2;
                case 2:
                  fr$1.call(b2, d2);
              }
            else
              switch (t2) {
                case 4:
                  return false;
                case 7:
                  fr$1.call(b2, d2);
              }
        return i2 ? -1 : r2 || o3 ? o3 : b2;
      };
    }, dr = { forEach: sr(0), map: sr(1), filter: sr(2), some: sr(3), every: sr(4), find: sr(5), findIndex: sr(6), filterOut: sr(7) }, vr = i$2 ? Object.defineProperties : function(t2, e2) {
      A$2(t2);
      for (var n2, r2 = yn(e2), o3 = r2.length, i2 = 0; o3 > i2; )
        R$1.f(t2, n2 = r2[i2++], e2[n2]);
      return t2;
    }, pr = nt$1("document", "documentElement"), gr = Y$1("IE_PROTO"), hr = function() {
    }, yr = function(t2) {
      return "<script>" + t2 + "<\/script>";
    }, mr = function() {
      try {
        cr = document.domain && new ActiveXObject("htmlfile");
      } catch (t3) {
      }
      var t2, e2;
      mr = cr ? function(t3) {
        t3.write(yr("")), t3.close();
        var e3 = t3.parentWindow.Object;
        return t3 = null, e3;
      }(cr) : ((e2 = E$1("iframe")).style.display = "none", pr.appendChild(e2), e2.src = String("javascript:"), (t2 = e2.contentWindow.document).open(), t2.write(yr("document.F=Object")), t2.close(), t2.F);
      for (var n2 = gt$2.length; n2--; )
        delete mr.prototype[gt$2[n2]];
      return mr();
    };
    G$1[gr] = true;
    var Sr = Object.create || function(t2, e2) {
      var n2;
      return null !== t2 ? (hr.prototype = A$2(t2), n2 = new hr(), hr.prototype = null, n2[gr] = t2) : n2 = mr(), void 0 === e2 ? n2 : vr(n2, e2);
    }, xr = ne$1("unscopables"), br = Array.prototype;
    null == br[xr] && R$1.f(br, xr, { configurable: true, value: Sr(null) });
    var Er = function(t2) {
      br[xr][t2] = true;
    }, wr = dr.find, Or = true, Tr = Mt$1("find");
    "find" in [] && Array(1).find(function() {
      Or = false;
    }), It$1({ target: "Array", proto: true, forced: Or || !Tr }, { find: function(t2) {
      return wr(this, t2, arguments.length > 1 ? arguments[1] : void 0);
    } }), Er("find");
    var Ar = dr.findIndex, kr$1 = true, Rr = Mt$1("findIndex");
    "findIndex" in [] && Array(1).findIndex(function() {
      kr$1 = false;
    }), It$1({ target: "Array", proto: true, forced: kr$1 || !Rr }, { findIndex: function(t2) {
      return Ar(this, t2, arguments.length > 1 ? arguments[1] : void 0);
    } }), Er("findIndex");
    var Ir = function(t2, e2, n2, r2, o3, i2, u2, a2) {
      for (var c2, l2 = o3, f2 = 0, s2 = !!u2 && lr(u2, a2, 3); f2 < r2; ) {
        if (f2 in n2) {
          if (c2 = s2 ? s2(n2[f2], f2, e2) : n2[f2], i2 > 0 && qt$2(c2))
            l2 = Ir(t2, e2, c2, at$1(c2.length), l2, i2 - 1) - 1;
          else {
            if (l2 >= 9007199254740991)
              throw TypeError("Exceed the acceptable array length");
            t2[l2] = c2;
          }
          l2++;
        }
        f2++;
      }
      return l2;
    }, jr = Ir;
    It$1({ target: "Array", proto: true }, { flat: function() {
      var t2 = arguments.length ? arguments[0] : void 0, e2 = Kt$1(this), n2 = at$1(e2.length), r2 = oe(e2, 0);
      return r2.length = jr(r2, e2, e2, n2, 0, void 0 === t2 ? 1 : it$3(t2)), r2;
    } });
    var Cr = function(t2) {
      var e2 = t2.return;
      if (void 0 !== e2)
        return A$2(e2.call(t2)).value;
    }, Lr = function(t2, e2, n2, r2) {
      try {
        return r2 ? e2(A$2(n2)[0], n2[1]) : e2(n2);
      } catch (e3) {
        throw Cr(t2), e3;
      }
    }, Pr = {}, Mr = ne$1("iterator"), _r = Array.prototype, Dr = function(t2) {
      return void 0 !== t2 && (Pr.Array === t2 || _r[Mr] === t2);
    }, Ur = ne$1("iterator"), Nr = function(t2) {
      if (null != t2)
        return t2[Ur] || t2["@@iterator"] || Pr[be$2(t2)];
    }, Fr = ne$1("iterator"), Wr = false;
    try {
      var zr = 0, $r = { next: function() {
        return { done: !!zr++ };
      }, return: function() {
        Wr = true;
      } };
      $r[Fr] = function() {
        return this;
      }, Array.from($r, function() {
        throw 2;
      });
    } catch (t2) {
    }
    var Br = function(t2, e2) {
      if (!Wr)
        return false;
      var n2 = false;
      try {
        var r2 = {};
        r2[Fr] = function() {
          return { next: function() {
            return { done: n2 = true };
          } };
        }, t2(r2);
      } catch (t3) {
      }
      return n2;
    }, Yr = !Br(function(t2) {
      Array.from(t2);
    });
    It$1({ target: "Array", stat: true, forced: Yr }, { from: function(t2) {
      var e2, n2, r2, o3, i2, u2, a2 = Kt$1(t2), c2 = "function" == typeof this ? this : Array, l2 = arguments.length, f2 = l2 > 1 ? arguments[1] : void 0, s2 = void 0 !== f2, d2 = Nr(a2), v2 = 0;
      if (s2 && (f2 = lr(f2, l2 > 2 ? arguments[2] : void 0, 2)), null == d2 || c2 == Array && Dr(d2))
        for (n2 = new c2(e2 = at$1(a2.length)); e2 > v2; v2++)
          u2 = s2 ? f2(a2[v2], v2) : a2[v2], ie(n2, v2, u2);
      else
        for (i2 = (o3 = d2.call(a2)).next, n2 = new c2(); !(r2 = i2.call(o3)).done; v2++)
          u2 = s2 ? Lr(o3, f2, [r2.value, v2], true) : r2.value, ie(n2, v2, u2);
      return n2.length = v2, n2;
    } });
    var Gr = function(t2) {
      return function(e2, n2, r2, o3) {
        Ve$1(n2);
        var i2 = Kt$1(e2), u2 = v$3(i2), a2 = at$1(i2.length), c2 = t2 ? a2 - 1 : 0, l2 = t2 ? -1 : 1;
        if (r2 < 2)
          for (; ; ) {
            if (c2 in u2) {
              o3 = u2[c2], c2 += l2;
              break;
            }
            if (c2 += l2, t2 ? c2 < 0 : a2 <= c2)
              throw TypeError("Reduce of empty array with no initial value");
          }
        for (; t2 ? c2 >= 0 : a2 > c2; c2 += l2)
          c2 in u2 && (o3 = n2(o3, u2[c2], c2, i2));
        return o3;
      };
    }, Hr = { left: Gr(false), right: Gr(true) }, Xr = "process" == s$2(r$2.process), Vr = Hr.left, Kr = jt$1("reduce"), qr = Mt$1("reduce", { 1: 0 });
    It$1({ target: "Array", proto: true, forced: !Kr || !qr || !Xr && fe$2 > 79 && fe$2 < 83 }, { reduce: function(t2) {
      return Vr(this, t2, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
    } }), Er("flat");
    var Qr, Jr, Zr, to$1 = !o$3(function() {
      return Object.isExtensible(Object.preventExtensions({}));
    }), eo$1 = e(function(t2) {
      var e2 = R$1.f, n2 = $$1("meta"), r2 = 0, o3 = Object.isExtensible || function() {
        return true;
      }, i2 = function(t3) {
        e2(t3, n2, { value: { objectID: "O" + ++r2, weakData: {} } });
      }, u2 = t2.exports = { REQUIRED: false, fastKey: function(t3, e3) {
        if (!h$2(t3))
          return "symbol" == typeof t3 ? t3 : ("string" == typeof t3 ? "S" : "P") + t3;
        if (!S$4(t3, n2)) {
          if (!o3(t3))
            return "F";
          if (!e3)
            return "E";
          i2(t3);
        }
        return t3[n2].objectID;
      }, getWeakData: function(t3, e3) {
        if (!S$4(t3, n2)) {
          if (!o3(t3))
            return true;
          if (!e3)
            return false;
          i2(t3);
        }
        return t3[n2].weakData;
      }, onFreeze: function(t3) {
        return to$1 && u2.REQUIRED && o3(t3) && !S$4(t3, n2) && i2(t3), t3;
      } };
      G$1[n2] = true;
    }), no$1 = function(t2, e2) {
      this.stopped = t2, this.result = e2;
    }, ro$1 = function(t2, e2, n2) {
      var r2, o3, i2, u2, a2, c2, l2, f2 = n2 && n2.that, s2 = !(!n2 || !n2.AS_ENTRIES), d2 = !(!n2 || !n2.IS_ITERATOR), v2 = !(!n2 || !n2.INTERRUPTED), p2 = lr(e2, f2, 1 + s2 + v2), g2 = function(t3) {
        return r2 && Cr(r2), new no$1(true, t3);
      }, h2 = function(t3) {
        return s2 ? (A$2(t3), v2 ? p2(t3[0], t3[1], g2) : p2(t3[0], t3[1])) : v2 ? p2(t3, g2) : p2(t3);
      };
      if (d2)
        r2 = t2;
      else {
        if ("function" != typeof (o3 = Nr(t2)))
          throw TypeError("Target is not iterable");
        if (Dr(o3)) {
          for (i2 = 0, u2 = at$1(t2.length); u2 > i2; i2++)
            if ((a2 = h2(t2[i2])) && a2 instanceof no$1)
              return a2;
          return new no$1(false);
        }
        r2 = o3.call(t2);
      }
      for (c2 = r2.next; !(l2 = c2.call(r2)).done; ) {
        try {
          a2 = h2(l2.value);
        } catch (t3) {
          throw Cr(r2), t3;
        }
        if ("object" == typeof a2 && a2 && a2 instanceof no$1)
          return a2;
      }
      return new no$1(false);
    }, oo$1 = function(t2, e2, n2) {
      if (!(t2 instanceof e2))
        throw TypeError("Incorrect " + (n2 ? n2 + " " : "") + "invocation");
      return t2;
    }, io$1 = R$1.f, uo$1 = ne$1("toStringTag"), ao$1 = function(t2, e2, n2) {
      t2 && !S$4(t2 = n2 ? t2 : t2.prototype, uo$1) && io$1(t2, uo$1, { configurable: true, value: e2 });
    }, co$1 = Object.setPrototypeOf || ("__proto__" in {} ? function() {
      var t2, e2 = false, n2 = {};
      try {
        (t2 = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(n2, []), e2 = n2 instanceof Array;
      } catch (t3) {
      }
      return function(n3, r2) {
        return A$2(n3), function(t3) {
          if (!h$2(t3) && null !== t3)
            throw TypeError("Can't set " + String(t3) + " as a prototype");
        }(r2), e2 ? t2.call(n3, r2) : n3.__proto__ = r2, n3;
      };
    }() : void 0), lo$1 = function(t2, e2, n2) {
      for (var r2 in e2)
        Z$1(t2, r2, e2[r2], n2);
      return t2;
    }, fo$1 = !o$3(function() {
      function t2() {
      }
      return t2.prototype.constructor = null, Object.getPrototypeOf(new t2()) !== t2.prototype;
    }), so$1 = Y$1("IE_PROTO"), vo$1 = Object.prototype, po$1 = fo$1 ? Object.getPrototypeOf : function(t2) {
      return t2 = Kt$1(t2), S$4(t2, so$1) ? t2[so$1] : "function" == typeof t2.constructor && t2 instanceof t2.constructor ? t2.constructor.prototype : t2 instanceof Object ? vo$1 : null;
    }, go$1 = ne$1("iterator"), ho$1 = false;
    [].keys && ("next" in (Zr = [].keys()) ? (Jr = po$1(po$1(Zr))) !== Object.prototype && (Qr = Jr) : ho$1 = true), (null == Qr || o$3(function() {
      var t2 = {};
      return Qr[go$1].call(t2) !== t2;
    })) && (Qr = {}), S$4(Qr, go$1) || I(Qr, go$1, function() {
      return this;
    });
    var yo$1 = { IteratorPrototype: Qr, BUGGY_SAFARI_ITERATORS: ho$1 }, mo$1 = yo$1.IteratorPrototype, So$1 = function() {
      return this;
    }, xo = yo$1.IteratorPrototype, bo$1 = yo$1.BUGGY_SAFARI_ITERATORS, Eo$1 = ne$1("iterator"), wo$1 = function() {
      return this;
    }, Oo$1 = function(t2, e2, n2, r2, o3, i2, u2) {
      !function(t3, e3, n3) {
        var r3 = e3 + " Iterator";
        t3.prototype = Sr(mo$1, { next: l$2(1, n3) }), ao$1(t3, r3, false), Pr[r3] = So$1;
      }(n2, e2, r2);
      var a2, c2, f2, s2 = function(t3) {
        if (t3 === o3 && h2)
          return h2;
        if (!bo$1 && t3 in p2)
          return p2[t3];
        switch (t3) {
          case "keys":
          case "values":
          case "entries":
            return function() {
              return new n2(this, t3);
            };
        }
        return function() {
          return new n2(this);
        };
      }, d2 = e2 + " Iterator", v2 = false, p2 = t2.prototype, g2 = p2[Eo$1] || p2["@@iterator"] || o3 && p2[o3], h2 = !bo$1 && g2 || s2(o3), y2 = "Array" == e2 && p2.entries || g2;
      if (y2 && (a2 = po$1(y2.call(new t2())), xo !== Object.prototype && a2.next && (po$1(a2) !== xo && (co$1 ? co$1(a2, xo) : "function" != typeof a2[Eo$1] && I(a2, Eo$1, wo$1)), ao$1(a2, d2, true))), "values" == o3 && g2 && "values" !== g2.name && (v2 = true, h2 = function() {
        return g2.call(this);
      }), p2[Eo$1] !== h2 && I(p2, Eo$1, h2), Pr[e2] = h2, o3)
        if (c2 = { values: s2("values"), keys: i2 ? h2 : s2("keys"), entries: s2("entries") }, u2)
          for (f2 in c2)
            (bo$1 || v2 || !(f2 in p2)) && Z$1(p2, f2, c2[f2]);
        else
          It$1({ target: e2, proto: true, forced: bo$1 || v2 }, c2);
      return c2;
    }, To$1 = ne$1("species"), Ao$1 = R$1.f, ko$1 = eo$1.fastKey, Ro$1 = J$1.set, Io$1 = J$1.getterFor;
    !function(t2, e2, n2) {
      var i2 = -1 !== t2.indexOf("Map"), u2 = -1 !== t2.indexOf("Weak"), a2 = i2 ? "set" : "add", c2 = r$2[t2], l2 = c2 && c2.prototype, f2 = c2, s2 = {}, d2 = function(t3) {
        var e3 = l2[t3];
        Z$1(l2, t3, "add" == t3 ? function(t4) {
          return e3.call(this, 0 === t4 ? 0 : t4), this;
        } : "delete" == t3 ? function(t4) {
          return !(u2 && !h$2(t4)) && e3.call(this, 0 === t4 ? 0 : t4);
        } : "get" == t3 ? function(t4) {
          return u2 && !h$2(t4) ? void 0 : e3.call(this, 0 === t4 ? 0 : t4);
        } : "has" == t3 ? function(t4) {
          return !(u2 && !h$2(t4)) && e3.call(this, 0 === t4 ? 0 : t4);
        } : function(t4, n3) {
          return e3.call(this, 0 === t4 ? 0 : t4, n3), this;
        });
      };
      if (kt$1(t2, "function" != typeof c2 || !(u2 || l2.forEach && !o$3(function() {
        new c2().entries().next();
      }))))
        f2 = n2.getConstructor(e2, t2, i2, a2), eo$1.REQUIRED = true;
      else if (kt$1(t2, true)) {
        var v2 = new f2(), p2 = v2[a2](u2 ? {} : -0, 1) != v2, g2 = o$3(function() {
          v2.has(1);
        }), y2 = Br(function(t3) {
          new c2(t3);
        }), m2 = !u2 && o$3(function() {
          for (var t3 = new c2(), e3 = 5; e3--; )
            t3[a2](e3, e3);
          return !t3.has(-0);
        });
        y2 || ((f2 = e2(function(e3, n3) {
          oo$1(e3, f2, t2);
          var r2 = function(t3, e4, n4) {
            var r3, o3;
            return co$1 && "function" == typeof (r3 = e4.constructor) && r3 !== n4 && h$2(o3 = r3.prototype) && o3 !== n4.prototype && co$1(t3, o3), t3;
          }(new c2(), e3, f2);
          return null != n3 && ro$1(n3, r2[a2], { that: r2, AS_ENTRIES: i2 }), r2;
        })).prototype = l2, l2.constructor = f2), (g2 || m2) && (d2("delete"), d2("has"), i2 && d2("get")), (m2 || p2) && d2(a2), u2 && l2.clear && delete l2.clear;
      }
      s2[t2] = f2, It$1({ global: true, forced: f2 != c2 }, s2), ao$1(f2, t2), u2 || n2.setStrong(f2, t2, i2);
    }("Set", function(t2) {
      return function() {
        return t2(this, arguments.length ? arguments[0] : void 0);
      };
    }, { getConstructor: function(t2, e2, n2, r2) {
      var o3 = t2(function(t3, u3) {
        oo$1(t3, o3, e2), Ro$1(t3, { type: e2, index: Sr(null), first: void 0, last: void 0, size: 0 }), i$2 || (t3.size = 0), null != u3 && ro$1(u3, t3[r2], { that: t3, AS_ENTRIES: n2 });
      }), u2 = Io$1(e2), a2 = function(t3, e3, n3) {
        var r3, o4, a3 = u2(t3), l2 = c2(t3, e3);
        return l2 ? l2.value = n3 : (a3.last = l2 = { index: o4 = ko$1(e3, true), key: e3, value: n3, previous: r3 = a3.last, next: void 0, removed: false }, a3.first || (a3.first = l2), r3 && (r3.next = l2), i$2 ? a3.size++ : t3.size++, "F" !== o4 && (a3.index[o4] = l2)), t3;
      }, c2 = function(t3, e3) {
        var n3, r3 = u2(t3), o4 = ko$1(e3);
        if ("F" !== o4)
          return r3.index[o4];
        for (n3 = r3.first; n3; n3 = n3.next)
          if (n3.key == e3)
            return n3;
      };
      return lo$1(o3.prototype, { clear: function() {
        for (var t3 = u2(this), e3 = t3.index, n3 = t3.first; n3; )
          n3.removed = true, n3.previous && (n3.previous = n3.previous.next = void 0), delete e3[n3.index], n3 = n3.next;
        t3.first = t3.last = void 0, i$2 ? t3.size = 0 : this.size = 0;
      }, delete: function(t3) {
        var e3 = this, n3 = u2(e3), r3 = c2(e3, t3);
        if (r3) {
          var o4 = r3.next, a3 = r3.previous;
          delete n3.index[r3.index], r3.removed = true, a3 && (a3.next = o4), o4 && (o4.previous = a3), n3.first == r3 && (n3.first = o4), n3.last == r3 && (n3.last = a3), i$2 ? n3.size-- : e3.size--;
        }
        return !!r3;
      }, forEach: function(t3) {
        for (var e3, n3 = u2(this), r3 = lr(t3, arguments.length > 1 ? arguments[1] : void 0, 3); e3 = e3 ? e3.next : n3.first; )
          for (r3(e3.value, e3.key, this); e3 && e3.removed; )
            e3 = e3.previous;
      }, has: function(t3) {
        return !!c2(this, t3);
      } }), lo$1(o3.prototype, n2 ? { get: function(t3) {
        var e3 = c2(this, t3);
        return e3 && e3.value;
      }, set: function(t3, e3) {
        return a2(this, 0 === t3 ? 0 : t3, e3);
      } } : { add: function(t3) {
        return a2(this, t3 = 0 === t3 ? 0 : t3, t3);
      } }), i$2 && Ao$1(o3.prototype, "size", { get: function() {
        return u2(this).size;
      } }), o3;
    }, setStrong: function(t2, e2, n2) {
      var r2 = e2 + " Iterator", o3 = Io$1(e2), u2 = Io$1(r2);
      Oo$1(t2, e2, function(t3, e3) {
        Ro$1(this, { type: r2, target: t3, state: o3(t3), kind: e3, last: void 0 });
      }, function() {
        for (var t3 = u2(this), e3 = t3.kind, n3 = t3.last; n3 && n3.removed; )
          n3 = n3.previous;
        return t3.target && (t3.last = n3 = n3 ? n3.next : t3.state.first) ? "keys" == e3 ? { value: n3.key, done: false } : "values" == e3 ? { value: n3.value, done: false } : { value: [n3.key, n3.value], done: false } : (t3.target = void 0, { value: void 0, done: true });
      }, n2 ? "entries" : "values", !n2, true), function(t3) {
        var e3 = nt$1(t3), n3 = R$1.f;
        i$2 && e3 && !e3[To$1] && n3(e3, To$1, { configurable: true, get: function() {
          return this;
        } });
      }(e2);
    } });
    var jo$1 = Qe$1.charAt, Co$1 = J$1.set, Lo$1 = J$1.getterFor("String Iterator");
    Oo$1(String, "String", function(t2) {
      Co$1(this, { type: "String Iterator", string: String(t2), index: 0 });
    }, function() {
      var t2, e2 = Lo$1(this), n2 = e2.string, r2 = e2.index;
      return r2 >= n2.length ? { value: void 0, done: true } : (t2 = jo$1(n2, r2), e2.index += t2.length, { value: t2, done: false });
    });
    var Po$1 = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 }, Mo$1 = J$1.set, _o$1 = J$1.getterFor("Array Iterator"), Do$1 = Oo$1(Array, "Array", function(t2, e2) {
      Mo$1(this, { type: "Array Iterator", target: g$4(t2), index: 0, kind: e2 });
    }, function() {
      var t2 = _o$1(this), e2 = t2.target, n2 = t2.kind, r2 = t2.index++;
      return !e2 || r2 >= e2.length ? (t2.target = void 0, { value: void 0, done: true }) : "keys" == n2 ? { value: r2, done: false } : "values" == n2 ? { value: e2[r2], done: false } : { value: [r2, e2[r2]], done: false };
    }, "values");
    Pr.Arguments = Pr.Array, Er("keys"), Er("values"), Er("entries");
    var Uo$1 = ne$1("iterator"), No$1 = ne$1("toStringTag"), Fo$1 = Do$1.values;
    for (var Wo$1 in Po$1) {
      var zo$1 = r$2[Wo$1], $o$1 = zo$1 && zo$1.prototype;
      if ($o$1) {
        if ($o$1[Uo$1] !== Fo$1)
          try {
            I($o$1, Uo$1, Fo$1);
          } catch (t2) {
            $o$1[Uo$1] = Fo$1;
          }
        if ($o$1[No$1] || I($o$1, No$1, Wo$1), Po$1[Wo$1]) {
          for (var Bo$1 in Do$1)
            if ($o$1[Bo$1] !== Do$1[Bo$1])
              try {
                I($o$1, Bo$1, Do$1[Bo$1]);
              } catch (t2) {
                $o$1[Bo$1] = Do$1[Bo$1];
              }
        }
      }
    }
    (function() {
      function t2() {
        Wt$1(this, t2);
      }
      return $t$2(t2, null, [{ key: "deduplicate", value: function(t3) {
        return Array.from(new Set(t3));
      } }, { key: "flat", value: function(e2) {
        return e2.reduce(function(e3, n2) {
          var r2 = Array.isArray(n2) ? t2.flat(n2) : n2;
          return e3.concat(r2);
        }, []);
      } }, { key: "find", value: function(t3, e2) {
        return t3.find(e2);
      } }, { key: "findIndex", value: function(t3, e2) {
        return t3.findIndex(e2);
      } }]), t2;
    })();
    (function() {
      function t2() {
        Wt$1(this, t2);
      }
      return $t$2(t2, null, [{ key: "today", value: function() {
        return /* @__PURE__ */ new Date();
      } }]), t2;
    })();
    (function() {
      function t2() {
        Wt$1(this, t2);
      }
      return $t$2(t2, null, [{ key: "range", value: function(t3, e2, n2) {
        return Math.min(Math.max(t3, e2), n2);
      } }, { key: "clamp", value: function(t3, e2, n2) {
        return e2 < n2 ? t3 < e2 ? e2 : t3 > n2 ? n2 : t3 : t3 < n2 ? n2 : t3 > e2 ? e2 : t3;
      } }]), t2;
    })();
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var Symbol$1 = root.Symbol;
    var objectProto$9 = Object.prototype;
    var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
    var nativeObjectToString$1 = objectProto$9.toString;
    var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty$7.call(value, symToStringTag$1), tag = value[symToStringTag$1];
      try {
        value[symToStringTag$1] = void 0;
        var unmasked = true;
      } catch (e2) {
      }
      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }
    var objectProto$8 = Object.prototype;
    var nativeObjectToString = objectProto$8.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var isArray = Array.isArray;
    function isObject$1(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function identity(value) {
      return value;
    }
    var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject$1(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid2 ? "Symbol(src)_1." + uid2 : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var funcProto$2 = Function.prototype;
    var funcToString$2 = funcProto$2.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString$2.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto$1 = Function.prototype, objectProto$7 = Object.prototype;
    var funcToString$1 = funcProto$1.toString;
    var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString$1.call(hasOwnProperty$6).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject$1(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function getValue(object, key2) {
      return object == null ? void 0 : object[key2];
    }
    function getNative(object, key2) {
      var value = getValue(object, key2);
      return baseIsNative(value) ? value : void 0;
    }
    var objectCreate = Object.create;
    var baseCreate = /* @__PURE__ */ function() {
      function object() {
      }
      return function(proto) {
        if (!isObject$1(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function copyArray(source, array) {
      var index2 = -1, length = source.length;
      array || (array = Array(length));
      while (++index2 < length) {
        array[index2] = source[index2];
      }
      return array;
    }
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    function constant(value) {
      return function() {
        return value;
      };
    }
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e2) {
      }
    }();
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    var setToString = shortOut(baseSetToString);
    var MAX_SAFE_INTEGER$1 = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$1 : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function baseAssignValue(object, key2, value) {
      if (key2 == "__proto__" && defineProperty) {
        defineProperty(object, key2, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key2] = value;
      }
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var objectProto$6 = Object.prototype;
    var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
    function assignValue(object, key2, value) {
      var objValue = object[key2];
      if (!(hasOwnProperty$5.call(object, key2) && eq(objValue, value)) || value === void 0 && !(key2 in object)) {
        baseAssignValue(object, key2, value);
      }
    }
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index2 = -1, length = props.length;
      while (++index2 < length) {
        var key2 = props[index2];
        var newValue = void 0;
        if (newValue === void 0) {
          newValue = source[key2];
        }
        if (isNew) {
          baseAssignValue(object, key2, newValue);
        } else {
          assignValue(object, key2, newValue);
        }
      }
      return object;
    }
    var nativeMax = Math.max;
    function overRest(func, start2, transform2) {
      start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);
      return function() {
        var args = arguments, index2 = -1, length = nativeMax(args.length - start2, 0), array = Array(length);
        while (++index2 < length) {
          array[index2] = args[start2 + index2];
        }
        index2 = -1;
        var otherArgs = Array(start2 + 1);
        while (++index2 < start2) {
          otherArgs[index2] = args[index2];
        }
        otherArgs[start2] = transform2(array);
        return apply(func, this, otherArgs);
      };
    }
    function baseRest(func, start2) {
      return setToString(overRest(func, start2, identity), func + "");
    }
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isIterateeCall(value, index2, object) {
      if (!isObject$1(object)) {
        return false;
      }
      var type = typeof index2;
      if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
        return eq(object[index2], value);
      }
      return false;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index2 < length) {
          var source = sources[index2];
          if (source) {
            assigner(object, source, index2, customizer);
          }
        }
        return object;
      });
    }
    var objectProto$5 = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$5;
      return value === proto;
    }
    function baseTimes(n2, iteratee) {
      var index2 = -1, result = Array(n2);
      while (++index2 < n2) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    var argsTag$1 = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag$1;
    }
    var objectProto$4 = Object.prototype;
    var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
    var propertyIsEnumerable = objectProto$4.propertyIsEnumerable;
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty$4.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    function stubFalse() {
      return false;
    }
    var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
    var Buffer$2 = moduleExports$2 ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer$2 ? Buffer$2.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag$1 = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag$1] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
    var freeProcess = moduleExports$1 && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e2) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key2 in value) {
        if (!(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
        isIndex(key2, length)))) {
          result.push(key2);
        }
      }
      return result;
    }
    function overArg(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key2 in Object(object)) {
          result.push(key2);
        }
      }
      return result;
    }
    var objectProto$3 = Object.prototype;
    var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject$1(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key2 in object) {
        if (!(key2 == "constructor" && (isProto || !hasOwnProperty$3.call(object, key2)))) {
          result.push(key2);
        }
      }
      return result;
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeysIn(object);
    }
    var nativeCreate = getNative(Object, "create");
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key2) {
      var result = this.has(key2) && delete this.__data__[key2];
      this.size -= result ? 1 : 0;
      return result;
    }
    var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
    var objectProto$2 = Object.prototype;
    var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
    function hashGet(key2) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key2];
        return result === HASH_UNDEFINED$1 ? void 0 : result;
      }
      return hasOwnProperty$2.call(data, key2) ? data[key2] : void 0;
    }
    var objectProto$1 = Object.prototype;
    var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
    function hashHas(key2) {
      var data = this.__data__;
      return nativeCreate ? data[key2] !== void 0 : hasOwnProperty$1.call(data, key2);
    }
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function hashSet(key2, value) {
      var data = this.__data__;
      this.size += this.has(key2) ? 0 : 1;
      data[key2] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    function Hash(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function assocIndexOf(array, key2) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key2)) {
          return length;
        }
      }
      return -1;
    }
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key2) {
      var data = this.__data__, index2 = assocIndexOf(data, key2);
      if (index2 < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index2 == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index2, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key2) {
      var data = this.__data__, index2 = assocIndexOf(data, key2);
      return index2 < 0 ? void 0 : data[index2][1];
    }
    function listCacheHas(key2) {
      return assocIndexOf(this.__data__, key2) > -1;
    }
    function listCacheSet(key2, value) {
      var data = this.__data__, index2 = assocIndexOf(data, key2);
      if (index2 < 0) {
        ++this.size;
        data.push([key2, value]);
      } else {
        data[index2][1] = value;
      }
      return this;
    }
    function ListCache(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    var Map$1 = getNative(root, "Map");
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map$1 || ListCache)(),
        "string": new Hash()
      };
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function getMapData(map, key2) {
      var data = map.__data__;
      return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
    }
    function mapCacheDelete(key2) {
      var result = getMapData(this, key2)["delete"](key2);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key2) {
      return getMapData(this, key2).get(key2);
    }
    function mapCacheHas(key2) {
      return getMapData(this, key2).has(key2);
    }
    function mapCacheSet(key2, value) {
      var data = getMapData(this, key2), size2 = data.size;
      data.set(key2, value);
      this.size += data.size == size2 ? 0 : 1;
      return this;
    }
    function MapCache(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectTag = "[object Object]";
    var funcProto = Function.prototype, objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key2) {
      var data = this.__data__, result = data["delete"](key2);
      this.size = data.size;
      return result;
    }
    function stackGet(key2) {
      return this.__data__.get(key2);
    }
    function stackHas(key2) {
      return this.__data__.has(key2);
    }
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key2, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key2, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key2, value);
      this.size = data.size;
      return this;
    }
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer$1 = moduleExports ? root.Buffer : void 0;
    Buffer$1 ? Buffer$1.allocUnsafe : void 0;
    function cloneBuffer(buffer2, isDeep) {
      {
        return buffer2.slice();
      }
    }
    var Uint8Array$1 = root.Uint8Array;
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
      return result;
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer2 = cloneArrayBuffer(typedArray.buffer);
      return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key2 = props[++index2];
          if (iteratee(iterable[key2], key2, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    var baseFor = createBaseFor();
    function assignMergeValue(object, key2, value) {
      if (value !== void 0 && !eq(object[key2], value) || value === void 0 && !(key2 in object)) {
        baseAssignValue(object, key2, value);
      }
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function safeGet(object, key2) {
      if (key2 === "constructor" && typeof object[key2] === "function") {
        return;
      }
      if (key2 == "__proto__") {
        return;
      }
      return object[key2];
    }
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    function baseMergeDeep(object, source, key2, srcIndex, mergeFunc, customizer, stack2) {
      var objValue = safeGet(object, key2), srcValue = safeGet(source, key2), stacked = stack2.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key2, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key2 + "", object, source, stack2) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject$1(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack2.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
        stack2["delete"](srcValue);
      }
      assignMergeValue(object, key2, newValue);
    }
    function baseMerge(object, source, srcIndex, customizer, stack2) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key2) {
        stack2 || (stack2 = new Stack());
        if (isObject$1(srcValue)) {
          baseMergeDeep(object, source, key2, srcIndex, baseMerge, customizer, stack2);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key2), srcValue, key2 + "", object, source, stack2) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key2, newValue);
        }
      }, keysIn);
    }
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    var qe = Object.defineProperty;
    var Ye = (e2, t2, o3) => t2 in e2 ? qe(e2, t2, { enumerable: true, configurable: true, writable: true, value: o3 }) : e2[t2] = o3;
    var W$2 = (e2, t2, o3) => (Ye(e2, typeof t2 != "symbol" ? t2 + "" : t2, o3), o3);
    const P$2 = (e2) => Math.round(e2 * 100) / 100;
    let A$1 = class A {
      constructor(t2) {
        W$2(this, "instance");
        W$2(this, "alphaValue", 0);
        W$2(this, "redValue", 0);
        W$2(this, "greenValue", 0);
        W$2(this, "blueValue", 0);
        W$2(this, "hueValue", 0);
        W$2(this, "saturationValue", 0);
        W$2(this, "brightnessValue", 0);
        W$2(this, "hslSaturationValue", 0);
        W$2(this, "lightnessValue", 0);
        W$2(this, "initAlpha", () => {
          const t3 = this.instance.getAlpha();
          this.alphaValue = Math.min(1, t3) * 100;
        });
        W$2(this, "initLightness", () => {
          const { s: t3, l: o3 } = this.instance.toHsl();
          this.hslSaturationValue = P$2(t3), this.lightnessValue = P$2(o3);
        });
        W$2(this, "initRgb", () => {
          const { r: t3, g: o3, b: n2 } = this.instance.toRgb();
          this.redValue = P$2(t3), this.greenValue = P$2(o3), this.blueValue = P$2(n2);
        });
        W$2(this, "initHsb", () => {
          const { h: t3, s: o3, v: n2 } = this.instance.toHsv();
          this.hueValue = Math.min(360, Math.ceil(t3)), this.saturationValue = P$2(o3), this.brightnessValue = P$2(n2);
        });
        W$2(this, "toHexString", () => this.instance.toHexString());
        W$2(this, "toRgbString", () => this.instance.toRgbString());
        this.instance = tinycolor$1(t2), this.initRgb(), this.initHsb(), this.initLightness(), this.initAlpha();
      }
      toString(t2) {
        return this.instance.toString(t2);
      }
      get hex() {
        return this.instance.toHex();
      }
      set hex(t2) {
        this.instance = tinycolor$1(t2), this.initHsb(), this.initRgb(), this.initAlpha(), this.initLightness();
      }
      // 色调
      set hue(t2) {
        this.saturation === 0 && this.brightness === 0 && (this.saturationValue = 1, this.brightnessValue = 1), this.instance = tinycolor$1({
          h: P$2(t2),
          s: this.saturation,
          v: this.brightness,
          a: this.alphaValue / 100
        }), this.initRgb(), this.initLightness(), this.hueValue = P$2(t2);
      }
      get hue() {
        return this.hueValue;
      }
      // 饱和度
      set saturation(t2) {
        this.instance = tinycolor$1({
          h: this.hue,
          s: P$2(t2),
          v: this.brightness,
          a: this.alphaValue / 100
        }), this.initRgb(), this.initLightness(), this.saturationValue = P$2(t2);
      }
      get saturation() {
        return this.saturationValue;
      }
      // 明度
      set brightness(t2) {
        this.instance = tinycolor$1({
          h: this.hue,
          s: this.saturation,
          v: P$2(t2),
          a: this.alphaValue / 100
        }), this.initRgb(), this.initLightness(), this.brightnessValue = P$2(t2);
      }
      get brightness() {
        return this.brightnessValue;
      }
      // 亮度
      set lightness(t2) {
        this.instance = tinycolor$1({
          h: this.hue,
          s: this.hslSaturationValue,
          l: P$2(t2),
          a: this.alphaValue / 100
        }), this.initRgb(), this.initHsb(), this.lightnessValue = P$2(t2);
      }
      get lightness() {
        return this.lightnessValue;
      }
      // red
      set red(t2) {
        const o3 = this.instance.toRgb();
        this.instance = tinycolor$1({
          ...o3,
          r: P$2(t2),
          a: this.alphaValue / 100
        }), this.initHsb(), this.initLightness(), this.redValue = P$2(t2);
      }
      get red() {
        return this.redValue;
      }
      // green
      set green(t2) {
        const o3 = this.instance.toRgb();
        this.instance = tinycolor$1({
          ...o3,
          g: P$2(t2),
          a: this.alphaValue / 100
        }), this.initHsb(), this.initLightness(), this.greenValue = P$2(t2);
      }
      get green() {
        return this.greenValue;
      }
      // blue
      set blue(t2) {
        const o3 = this.instance.toRgb();
        this.instance = tinycolor$1({
          ...o3,
          b: P$2(t2),
          a: this.alphaValue / 100
        }), this.initHsb(), this.initLightness(), this.blueValue = P$2(t2);
      }
      get blue() {
        return this.blueValue;
      }
      // alpha
      set alpha(t2) {
        this.instance.setAlpha(t2 / 100), this.alphaValue = t2;
      }
      get alpha() {
        return this.alphaValue;
      }
      get RGB() {
        return [this.red, this.green, this.blue, parseFloat((this.alpha / 100).toFixed(2))];
      }
      get HSB() {
        return [this.hue, this.saturation, this.brightness, parseFloat((this.alpha / 100).toFixed(2))];
      }
      get HSL() {
        return [
          this.hue,
          this.hslSaturationValue,
          this.lightness,
          parseFloat((this.alpha / 100).toFixed(2))
        ];
      }
    };
    function Ae$1(e2, t2, o3, n2) {
      return `rgba(${[e2, t2, o3, n2 / 100].join(",")})`;
    }
    const ue$1 = (e2, t2, o3) => t2 < o3 ? e2 < t2 ? t2 : e2 > o3 ? o3 : e2 : e2 < o3 ? o3 : e2 > t2 ? t2 : e2, fe$1 = "color-history", Ce$1 = 8;
    const q$1 = (e2, t2) => {
      const o3 = e2.__vccOpts || e2;
      for (const [n2, i2] of t2)
        o3[n2] = i2;
      return o3;
    }, lt$1 = /* @__PURE__ */ defineComponent({
      name: "Alpha",
      props: {
        color: C$4.instanceOf(A$1),
        size: C$4.oneOf(["small", "default"]).def("default")
      },
      emits: ["change"],
      setup(e2, { emit: t2 }) {
        const o3 = ref(null), n2 = ref(null);
        let i2 = e2.color || new A$1();
        const l2 = reactive({
          red: i2.red,
          green: i2.green,
          blue: i2.blue,
          alpha: i2.alpha
        });
        watch$1(
          () => e2.color,
          (g2) => {
            g2 && (i2 = g2, merge(l2, {
              red: g2.red,
              green: g2.green,
              blue: g2.blue,
              alpha: g2.alpha
            }));
          },
          { deep: true }
        );
        const a2 = computed(() => {
          const g2 = Ae$1(l2.red, l2.green, l2.blue, 0), d2 = Ae$1(l2.red, l2.green, l2.blue, 100);
          return {
            background: `linear-gradient(to right, ${g2} , ${d2})`
          };
        }), r2 = () => {
          if (o3.value && n2.value) {
            const g2 = l2.alpha / 100, d2 = o3.value.getBoundingClientRect(), m2 = n2.value.offsetWidth;
            return Math.round(g2 * (d2.width - m2) + m2 / 2);
          }
          return 0;
        }, c2 = computed(() => ({
          left: r2() + "px",
          top: 0
        })), k2 = (g2) => {
          g2.target !== o3.value && p2(g2);
        }, p2 = (g2) => {
          if (g2.stopPropagation(), o3.value && n2.value) {
            const d2 = o3.value.getBoundingClientRect(), m2 = n2.value.offsetWidth;
            let b2 = g2.clientX - d2.left;
            b2 = Math.max(m2 / 2, b2), b2 = Math.min(b2, d2.width - m2 / 2);
            const h2 = Math.round((b2 - m2 / 2) / (d2.width - m2) * 100);
            i2.alpha = h2, l2.alpha = h2, t2("change", h2);
          }
        };
        return tryOnMounted(() => {
          const g2 = {
            drag: (d2) => {
              p2(d2);
            },
            end: (d2) => {
              p2(d2);
            }
          };
          o3.value && n2.value && Vn.triggerDragEvent(o3.value, g2);
        }), { barElement: o3, cursorElement: n2, getCursorStyle: c2, getBackgroundStyle: a2, onClickSider: k2 };
      }
    }), st$1 = (e2) => (pushScopeId("data-v-18925ba6"), e2 = e2(), popScopeId(), e2), it$2 = /* @__PURE__ */ st$1(() => /* @__PURE__ */ createBaseVNode("div", { class: "vc-alpha-slider__bar-handle" }, null, -1)), ct$1 = [
      it$2
    ];
    function ut$1(e2, t2, o3, n2, i2, l2) {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["vc-alpha-slider", "transparent", { "small-slider": e2.size === "small" }])
      }, [
        createBaseVNode("div", {
          ref: "barElement",
          class: "vc-alpha-slider__bar",
          style: normalizeStyle(e2.getBackgroundStyle),
          onClick: t2[0] || (t2[0] = (...a2) => e2.onClickSider && e2.onClickSider(...a2))
        }, [
          createBaseVNode("div", {
            class: normalizeClass(["vc-alpha-slider__bar-pointer", { "small-bar": e2.size === "small" }]),
            ref: "cursorElement",
            style: normalizeStyle(e2.getCursorStyle)
          }, ct$1, 6)
        ], 4)
      ], 2);
    }
    const ve$1 = /* @__PURE__ */ q$1(lt$1, [["render", ut$1], ["__scopeId", "data-v-18925ba6"]]);
    const dt$1 = [
      // 第一行
      [
        "#fcc02e",
        "#f67c01",
        "#e64a19",
        "#d81b43",
        "#8e24aa",
        "#512da7",
        "#1f87e8",
        "#008781",
        "#05a045"
      ],
      // 第二行
      [
        "#fed835",
        "#fb8c00",
        "#f5511e",
        "#eb1d4e",
        "#9c28b1",
        "#5d35b0",
        "#2097f3",
        "#029688",
        "#4cb050"
      ],
      // 第三行
      [
        "#ffeb3c",
        "#ffa727",
        "#fe5722",
        "#eb4165",
        "#aa47bc",
        "#673bb7",
        "#42a5f6",
        "#26a59a",
        "#83c683"
      ],
      // 第四行
      [
        "#fff176",
        "#ffb74e",
        "#ff8a66",
        "#f1627e",
        "#b968c7",
        "#7986cc",
        "#64b5f6",
        "#80cbc4",
        "#a5d6a7"
      ],
      // 第五行
      [
        "#fff59c",
        "#ffcc80",
        "#ffab91",
        "#fb879e",
        "#cf93d9",
        "#9ea8db",
        "#90caf8",
        "#b2dfdc",
        "#c8e6ca"
      ],
      // 最后一行
      [
        "transparent",
        "#ffffff",
        "#dedede",
        "#a9a9a9",
        "#4b4b4b",
        "#353535",
        "#212121",
        "#000000",
        "advance"
      ]
    ], gt$1 = /* @__PURE__ */ defineComponent({
      name: "Palette",
      emits: ["change"],
      setup(e2, { emit: t2 }) {
        return { palettes: dt$1, computedBgStyle: (i2) => i2 === "transparent" ? i2 : i2 === "advance" ? {} : { background: tinycolor$1(i2).toRgbString() }, onColorChange: (i2) => {
          t2("change", i2);
        } };
      }
    }), ht$1 = { class: "vc-compact" }, pt$1 = ["onClick"];
    function ft$1(e2, t2, o3, n2, i2, l2) {
      return openBlock(), createElementBlock("div", ht$1, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(e2.palettes, (a2, r2) => (openBlock(), createElementBlock("div", {
          key: r2,
          class: "vc-compact__row"
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(a2, (c2, k2) => (openBlock(), createElementBlock("div", {
            key: k2,
            class: "vc-compact__color-cube--wrap",
            onClick: (p2) => e2.onColorChange(c2)
          }, [
            createBaseVNode("div", {
              class: normalizeClass([
                "vc-compact__color_cube",
                {
                  advance: c2 === "advance",
                  transparent: c2 === "transparent"
                }
              ]),
              style: normalizeStyle(e2.computedBgStyle(c2))
            }, null, 6)
          ], 8, pt$1))), 128))
        ]))), 128))
      ]);
    }
    const Ke = /* @__PURE__ */ q$1(gt$1, [["render", ft$1], ["__scopeId", "data-v-b969fd48"]]);
    const Ct$1 = /* @__PURE__ */ defineComponent({
      name: "Board",
      props: {
        color: C$4.instanceOf(A$1),
        round: C$4.bool.def(false),
        hide: C$4.bool.def(true)
      },
      emits: ["change"],
      setup(e2, { emit: t2 }) {
        var y2, f2, w2;
        const o3 = getCurrentInstance(), n2 = {
          h: ((y2 = e2.color) == null ? void 0 : y2.hue) || 0,
          s: 1,
          v: 1
        }, i2 = new A$1(n2).toHexString(), l2 = reactive({
          hueColor: i2,
          saturation: ((f2 = e2.color) == null ? void 0 : f2.saturation) || 0,
          brightness: ((w2 = e2.color) == null ? void 0 : w2.brightness) || 0
        }), a2 = ref(0), r2 = ref(0), c2 = ref(), k2 = computed(() => ({
          top: a2.value + "px",
          left: r2.value + "px"
        })), p2 = () => {
          if (o3) {
            const S2 = o3.vnode.el;
            r2.value = l2.saturation * (S2 == null ? void 0 : S2.clientWidth), a2.value = (1 - l2.brightness) * (S2 == null ? void 0 : S2.clientHeight);
          }
        };
        let g2 = false;
        const d2 = (S2) => {
          g2 = true, h2(S2);
        }, m2 = (S2) => {
          g2 && h2(S2);
        }, b2 = () => {
          g2 = false;
        }, h2 = (S2) => {
          if (o3) {
            const F2 = o3.vnode.el, E2 = F2 == null ? void 0 : F2.getBoundingClientRect();
            let L2 = S2.clientX - E2.left, U2 = S2.clientY - E2.top;
            L2 = ue$1(L2, 0, E2.width), U2 = ue$1(U2, 0, E2.height);
            const J2 = L2 / E2.width, X2 = ue$1(-(U2 / E2.height) + 1, 0, 1);
            r2.value = L2, a2.value = U2, l2.saturation = J2, l2.brightness = X2, t2("change", J2, X2);
          }
        };
        return tryOnMounted(() => {
          o3 && o3.vnode.el && c2.value && nextTick(() => {
            p2();
          });
        }), whenever(
          () => e2.color,
          (S2) => {
            merge(l2, {
              hueColor: new A$1({ h: S2.hue, s: 1, v: 1 }).toHexString(),
              saturation: S2.saturation,
              brightness: S2.brightness
            }), p2();
          },
          { deep: true }
        ), { state: l2, cursorElement: c2, getCursorStyle: k2, onClickBoard: d2, onDrag: m2, onDragEnd: b2 };
      }
    }), be$1 = (e2) => (pushScopeId("data-v-7f0cdcdf"), e2 = e2(), popScopeId(), e2), vt$1 = /* @__PURE__ */ be$1(() => /* @__PURE__ */ createBaseVNode("div", { class: "vc-saturation__white" }, null, -1)), bt$1 = /* @__PURE__ */ be$1(() => /* @__PURE__ */ createBaseVNode("div", { class: "vc-saturation__black" }, null, -1)), yt$1 = /* @__PURE__ */ be$1(() => /* @__PURE__ */ createBaseVNode("div", null, null, -1)), _t$1 = [
      yt$1
    ];
    function mt$1(e2, t2, o3, n2, i2, l2) {
      return openBlock(), createElementBlock("div", {
        ref: "boardElement",
        class: normalizeClass(["vc-saturation", { "vc-saturation__chrome": e2.round, "vc-saturation__hidden": e2.hide }]),
        style: normalizeStyle({ backgroundColor: e2.state.hueColor }),
        onMousedown: t2[0] || (t2[0] = (...a2) => e2.onClickBoard && e2.onClickBoard(...a2)),
        onMousemove: t2[1] || (t2[1] = (...a2) => e2.onDrag && e2.onDrag(...a2)),
        onMouseup: t2[2] || (t2[2] = (...a2) => e2.onDragEnd && e2.onDragEnd(...a2))
      }, [
        vt$1,
        bt$1,
        createBaseVNode("div", {
          class: "vc-saturation__cursor",
          ref: "cursorElement",
          style: normalizeStyle(e2.getCursorStyle)
        }, _t$1, 4)
      ], 38);
    }
    const ye$1 = /* @__PURE__ */ q$1(Ct$1, [["render", mt$1], ["__scopeId", "data-v-7f0cdcdf"]]);
    const St$1 = /* @__PURE__ */ defineComponent({
      name: "Hue",
      props: {
        color: C$4.instanceOf(A$1),
        size: C$4.oneOf(["small", "default"]).def("default")
      },
      emits: ["change"],
      setup(e2, { emit: t2 }) {
        const o3 = ref(null), n2 = ref(null);
        let i2 = e2.color || new A$1();
        const l2 = reactive({
          hue: i2.hue || 0
        });
        watch$1(
          () => e2.color,
          (p2) => {
            p2 && (i2 = p2, merge(l2, { hue: i2.hue }));
          },
          { deep: true }
        );
        const a2 = () => {
          if (o3.value && n2.value) {
            const p2 = o3.value.getBoundingClientRect(), g2 = n2.value.offsetWidth;
            return l2.hue === 360 ? p2.width - g2 / 2 : l2.hue % 360 * (p2.width - g2) / 360 + g2 / 2;
          }
          return 0;
        }, r2 = computed(() => ({
          left: a2() + "px",
          top: 0
        })), c2 = (p2) => {
          p2.target !== o3.value && k2(p2);
        }, k2 = (p2) => {
          if (p2.stopPropagation(), o3.value && n2.value) {
            const g2 = o3.value.getBoundingClientRect(), d2 = n2.value.offsetWidth;
            let m2 = p2.clientX - g2.left;
            m2 = Math.min(m2, g2.width - d2 / 2), m2 = Math.max(d2 / 2, m2);
            const b2 = Math.round((m2 - d2 / 2) / (g2.width - d2) * 360);
            i2.hue = b2, l2.hue = b2, t2("change", b2);
          }
        };
        return tryOnMounted(() => {
          const p2 = {
            drag: (g2) => {
              k2(g2);
            },
            end: (g2) => {
              k2(g2);
            }
          };
          o3.value && n2.value && Vn.triggerDragEvent(o3.value, p2);
        }), { barElement: o3, cursorElement: n2, getCursorStyle: r2, onClickSider: c2 };
      }
    }), kt = (e2) => (pushScopeId("data-v-e1a08576"), e2 = e2(), popScopeId(), e2), $t$1 = /* @__PURE__ */ kt(() => /* @__PURE__ */ createBaseVNode("div", { class: "vc-hue-slider__bar-handle" }, null, -1)), wt$1 = [
      $t$1
    ];
    function Bt(e2, t2, o3, n2, i2, l2) {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["vc-hue-slider", { "small-slider": e2.size === "small" }])
      }, [
        createBaseVNode("div", {
          ref: "barElement",
          class: "vc-hue-slider__bar",
          onClick: t2[0] || (t2[0] = (...a2) => e2.onClickSider && e2.onClickSider(...a2))
        }, [
          createBaseVNode("div", {
            class: normalizeClass(["vc-hue-slider__bar-pointer", { "small-bar": e2.size === "small" }]),
            ref: "cursorElement",
            style: normalizeStyle(e2.getCursorStyle)
          }, wt$1, 6)
        ], 512)
      ], 2);
    }
    const _e$1 = /* @__PURE__ */ q$1(St$1, [["render", Bt], ["__scopeId", "data-v-e1a08576"]]);
    const Ht = /* @__PURE__ */ defineComponent({
      name: "Lightness",
      props: {
        color: C$4.instanceOf(A$1),
        size: C$4.oneOf(["small", "default"]).def("default")
      },
      emits: ["change"],
      setup(e2, { emit: t2 }) {
        const o3 = ref(null), n2 = ref(null);
        let i2 = e2.color || new A$1();
        const [l2, a2, r2] = i2.HSL, c2 = reactive({
          hue: l2,
          saturation: a2,
          lightness: r2
        });
        watch$1(
          () => e2.color,
          (b2) => {
            if (b2) {
              i2 = b2;
              const [h2, y2, f2] = i2.HSL;
              merge(c2, {
                hue: h2,
                saturation: y2,
                lightness: f2
              });
            }
          },
          { deep: true }
        );
        const k2 = computed(() => {
          const b2 = tinycolor$1({
            h: c2.hue,
            s: c2.saturation,
            l: 0.8
          }).toPercentageRgbString(), h2 = tinycolor$1({
            h: c2.hue,
            s: c2.saturation,
            l: 0.6
          }).toPercentageRgbString(), y2 = tinycolor$1({
            h: c2.hue,
            s: c2.saturation,
            l: 0.4
          }).toPercentageRgbString(), f2 = tinycolor$1({
            h: c2.hue,
            s: c2.saturation,
            l: 0.2
          }).toPercentageRgbString();
          return {
            background: [
              `linear-gradient(to right, rgb(255, 255, 255), ${b2}, ${h2}, ${y2}, ${f2}, rgb(0, 0, 0))`,
              `-webkit-linear-gradient(left, rgb(255, 255, 255), ${b2}, ${h2}, ${y2}, ${f2}, rgb(0, 0, 0))`,
              `-moz-linear-gradient(left, rgb(255, 255, 255), ${b2}, ${h2}, ${y2}, ${f2}, rgb(0, 0, 0))`,
              `-ms-linear-gradient(left, rgb(255, 255, 255), ${b2}, ${h2}, ${y2}, ${f2}, rgb(0, 0, 0))`
            ]
          };
        }), p2 = () => {
          if (o3.value && n2.value) {
            const b2 = c2.lightness, h2 = o3.value.getBoundingClientRect(), y2 = n2.value.offsetWidth;
            return (1 - b2) * (h2.width - y2) + y2 / 2;
          }
          return 0;
        }, g2 = computed(() => ({
          left: p2() + "px",
          top: 0
        })), d2 = (b2) => {
          b2.target !== o3.value && m2(b2);
        }, m2 = (b2) => {
          if (b2.stopPropagation(), o3.value && n2.value) {
            const h2 = o3.value.getBoundingClientRect(), y2 = n2.value.offsetWidth;
            let f2 = b2.clientX - h2.left;
            f2 = Math.max(y2 / 2, f2), f2 = Math.min(f2, h2.width - y2 / 2);
            const w2 = 1 - (f2 - y2 / 2) / (h2.width - y2);
            i2.lightness = w2, t2("change", w2);
          }
        };
        return tryOnMounted(() => {
          const b2 = {
            drag: (h2) => {
              m2(h2);
            },
            end: (h2) => {
              m2(h2);
            }
          };
          o3.value && n2.value && Vn.triggerDragEvent(o3.value, b2);
        }), { barElement: o3, cursorElement: n2, getCursorStyle: g2, getBackgroundStyle: k2, onClickSider: d2 };
      }
    }), Rt = (e2) => (pushScopeId("data-v-94a50a9e"), e2 = e2(), popScopeId(), e2), At = /* @__PURE__ */ Rt(() => /* @__PURE__ */ createBaseVNode("div", { class: "vc-lightness-slider__bar-handle" }, null, -1)), Pt$1 = [
      At
    ];
    function Vt(e2, t2, o3, n2, i2, l2) {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["vc-lightness-slider", { "small-slider": e2.size === "small" }])
      }, [
        createBaseVNode("div", {
          ref: "barElement",
          class: "vc-lightness-slider__bar",
          style: normalizeStyle(e2.getBackgroundStyle),
          onClick: t2[0] || (t2[0] = (...a2) => e2.onClickSider && e2.onClickSider(...a2))
        }, [
          createBaseVNode("div", {
            class: normalizeClass(["vc-lightness-slider__bar-pointer", { "small-bar": e2.size === "small" }]),
            ref: "cursorElement",
            style: normalizeStyle(e2.getCursorStyle)
          }, Pt$1, 6)
        ], 4)
      ], 2);
    }
    const Le = /* @__PURE__ */ q$1(Ht, [["render", Vt], ["__scopeId", "data-v-94a50a9e"]]);
    const Mt = /* @__PURE__ */ defineComponent({
      name: "History",
      props: {
        colors: C$4.arrayOf(String).def(() => []),
        round: C$4.bool.def(false)
      },
      emits: ["change"],
      setup(e2, { emit: t2 }) {
        return { onColorSelect: (n2) => {
          t2("change", n2);
        } };
      }
    }), Et = {
      key: 0,
      class: "vc-colorPicker__record"
    }, It = { class: "color-list" }, Kt = ["onClick"];
    function Lt(e2, t2, o3, n2, i2, l2) {
      return e2.colors && e2.colors.length > 0 ? (openBlock(), createElementBlock("div", Et, [
        createBaseVNode("div", It, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(e2.colors, (a2, r2) => (openBlock(), createElementBlock("div", {
            key: r2,
            class: normalizeClass(["color-item", "transparent", { "color-item__round": e2.round }]),
            onClick: (c2) => e2.onColorSelect(a2)
          }, [
            createBaseVNode("div", {
              class: "color-item__display",
              style: normalizeStyle({ backgroundColor: a2 })
            }, null, 4)
          ], 10, Kt))), 128))
        ])
      ])) : createCommentVNode("", true);
    }
    const me = /* @__PURE__ */ q$1(Mt, [["render", Lt], ["__scopeId", "data-v-0f657238"]]);
    const Nt = /* @__PURE__ */ defineComponent({
      name: "Display",
      props: {
        color: C$4.instanceOf(A$1),
        disableAlpha: C$4.bool.def(false)
      },
      emits: ["update:color", "change"],
      setup(e2, { emit: t2 }) {
        var m2, b2, h2, y2;
        const { copy: o3, copied: n2, isSupported: i2 } = useClipboard(), l2 = ref("hex"), a2 = reactive({
          color: e2.color,
          hex: (m2 = e2.color) == null ? void 0 : m2.hex,
          alpha: Math.round(((b2 = e2.color) == null ? void 0 : b2.alpha) || 100),
          rgba: (h2 = e2.color) == null ? void 0 : h2.RGB,
          previewBgColor: (y2 = e2.color) == null ? void 0 : y2.toRgbString()
        }), r2 = computed(() => ({
          background: a2.previewBgColor
        })), c2 = () => {
          l2.value = l2.value === "rgba" ? "hex" : "rgba";
        }, k2 = useDebounceFn((f2) => {
          if (!f2.target.value)
            return;
          let w2 = parseInt(f2.target.value.replace("%", ""));
          w2 > 100 && (f2.target.value = "100", w2 = 100), w2 < 0 && (f2.target.value = "0", w2 = 0), isNaN(w2) && (f2.target.value = "100", w2 = 100), !isNaN(w2) && a2.color && (a2.color.alpha = w2), t2("change", a2.color);
        }, 300), p2 = useDebounceFn((f2, w2) => {
          if (a2.color) {
            if (l2.value === "hex") {
              const S2 = f2.target.value.replace("#", "");
              tinycolor$1(S2).isValid() ? [3, 4].includes(S2.length) && (a2.color.hex = S2) : a2.color.hex = "000000", t2("change", a2.color);
            } else if (l2.value === "rgba" && w2 === 3 && f2.target.value.toString() === "0." && a2.rgba) {
              a2.rgba[w2] = f2.target.value;
              const [S2, F2, E2, L2] = a2.rgba;
              a2.color.hex = tinycolor$1({ r: S2, g: F2, b: E2 }).toHex(), a2.color.alpha = Math.round(L2 * 100), t2("change", a2.color);
            }
          }
        }, 100), g2 = useDebounceFn((f2, w2) => {
          if (f2.target.value) {
            if (l2.value === "hex") {
              const S2 = f2.target.value.replace("#", "");
              tinycolor$1(S2).isValid() && a2.color && [6, 8].includes(S2.length) && (a2.color.hex = S2);
            } else if (w2 !== void 0 && a2.rgba && a2.color) {
              if (f2.target.value < 0 && (f2.target.value = 0), w2 === 3 && ((f2.target.value > 1 || isNaN(f2.target.value)) && (f2.target.value = 1), f2.target.value.toString() === "0."))
                return;
              w2 < 3 && f2.target.value > 255 && (f2.target.value = 255), a2.rgba[w2] = f2.target.value;
              const [S2, F2, E2, L2] = a2.rgba;
              a2.color.hex = tinycolor$1({ r: S2, g: F2, b: E2 }).toHex(), a2.color.alpha = Math.round(L2 * 100);
            }
            t2("change", a2.color);
          }
        }, 300), d2 = () => {
          if (i2 && a2.color) {
            const f2 = l2.value === "hex" ? a2.color.toString(a2.color.alpha === 100 ? "hex6" : "hex8") : a2.color.toRgbString();
            o3(f2 || "");
          }
        };
        return whenever(
          () => e2.color,
          (f2) => {
            f2 && (a2.color = f2, a2.alpha = Math.round(a2.color.alpha), a2.hex = a2.color.hex, a2.rgba = a2.color.RGB);
          },
          { deep: true }
        ), whenever(
          () => a2.color,
          () => {
            a2.color && (a2.previewBgColor = a2.color.toRgbString());
          },
          { deep: true }
        ), {
          state: a2,
          getBgColorStyle: r2,
          inputType: l2,
          copied: n2,
          onInputTypeChange: c2,
          onAlphaBlur: k2,
          onInputChange: g2,
          onBlurChange: p2,
          onCopyColorStr: d2
        };
      }
    }), Wt = { class: "vc-display" }, Dt = { class: "vc-current-color vc-transparent" }, Tt$1 = {
      key: 0,
      class: "copy-text"
    }, Ot = {
      key: 0,
      style: { display: "flex", flex: "1", gap: "4px", height: "100%" }
    }, zt$1 = { class: "vc-color-input" }, Gt = {
      key: 0,
      class: "vc-alpha-input"
    }, Ft = ["value"], Xt = {
      key: 1,
      style: { display: "flex", flex: "1", gap: "4px", height: "100%" }
    }, qt$1 = ["value", "onInput", "onBlur"];
    function Yt(e2, t2, o3, n2, i2, l2) {
      return openBlock(), createElementBlock("div", Wt, [
        createBaseVNode("div", Dt, [
          createBaseVNode("div", {
            class: "color-cube",
            style: normalizeStyle(e2.getBgColorStyle),
            onClick: t2[0] || (t2[0] = (...a2) => e2.onCopyColorStr && e2.onCopyColorStr(...a2))
          }, [
            e2.copied ? (openBlock(), createElementBlock("span", Tt$1, "Copied!")) : createCommentVNode("", true)
          ], 4)
        ]),
        e2.inputType === "hex" ? (openBlock(), createElementBlock("div", Ot, [
          createBaseVNode("div", zt$1, [
            withDirectives(createBaseVNode("input", {
              "onUpdate:modelValue": t2[1] || (t2[1] = (a2) => e2.state.hex = a2),
              maxlength: "8",
              onInput: t2[2] || (t2[2] = (...a2) => e2.onInputChange && e2.onInputChange(...a2)),
              onBlur: t2[3] || (t2[3] = (...a2) => e2.onBlurChange && e2.onBlurChange(...a2))
            }, null, 544), [
              [vModelText, e2.state.hex]
            ])
          ]),
          e2.disableAlpha ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", Gt, [
            createBaseVNode("input", {
              class: "vc-alpha-input__inner",
              value: e2.state.alpha,
              onInput: t2[4] || (t2[4] = (...a2) => e2.onAlphaBlur && e2.onAlphaBlur(...a2))
            }, null, 40, Ft),
            createTextVNode("% ")
          ]))
        ])) : e2.state.rgba ? (openBlock(), createElementBlock("div", Xt, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(e2.state.rgba, (a2, r2) => (openBlock(), createElementBlock("div", {
            class: "vc-color-input",
            key: r2
          }, [
            createBaseVNode("input", {
              value: a2,
              onInput: (c2) => e2.onInputChange(c2, r2),
              onBlur: (c2) => e2.onBlurChange(c2, r2)
            }, null, 40, qt$1)
          ]))), 128))
        ])) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: "vc-input-toggle",
          onClick: t2[5] || (t2[5] = (...a2) => e2.onInputTypeChange && e2.onInputTypeChange(...a2))
        }, toDisplayString$2(e2.inputType), 1)
      ]);
    }
    const Se$1 = /* @__PURE__ */ q$1(Nt, [["render", Yt], ["__scopeId", "data-v-7334ac20"]]);
    const Ut = /* @__PURE__ */ defineComponent({
      name: "FkColorPicker",
      components: { Display: Se$1, Alpha: ve$1, Palette: Ke, Board: ye$1, Hue: _e$1, Lightness: Le, History: me },
      props: {
        color: C$4.instanceOf(A$1),
        disableHistory: C$4.bool.def(false),
        roundHistory: C$4.bool.def(false),
        disableAlpha: C$4.bool.def(false)
      },
      emits: ["update:color", "change", "advanceChange"],
      setup(e2, { emit: t2 }) {
        const o3 = e2.color || new A$1(), n2 = reactive({
          color: o3,
          hex: o3.toHexString(),
          rgb: o3.toRgbString()
        }), i2 = ref(false), l2 = computed(() => ({ background: n2.rgb })), a2 = () => {
          i2.value = false, t2("advanceChange", false);
        }, r2 = useLocalStorage(fe$1, [], {}), c2 = useDebounceFn(() => {
          if (e2.disableHistory)
            return;
          const h2 = n2.color.toRgbString();
          if (r2.value = r2.value.filter((y2) => !tinycolor$1.equals(y2, h2)), !r2.value.includes(h2)) {
            for (; r2.value.length > Ce$1; )
              r2.value.pop();
            r2.value.unshift(h2);
          }
        }, 500), k2 = (h2) => {
          h2 === "advance" ? (i2.value = true, t2("advanceChange", true)) : (n2.color.hex = h2, t2("advanceChange", false));
        }, p2 = (h2) => {
          n2.color.alpha = h2;
        }, g2 = (h2) => {
          n2.color.hue = h2;
        }, d2 = (h2, y2) => {
          n2.color.saturation = h2, n2.color.brightness = y2;
        }, m2 = (h2) => {
          n2.color.lightness = h2;
        }, b2 = (h2) => {
          const f2 = h2.target.value.replace("#", "");
          tinycolor$1(f2).isValid() && (n2.color.hex = f2);
        };
        return whenever(
          () => e2.color,
          (h2) => {
            h2 && (n2.color = h2);
          },
          { deep: true }
        ), whenever(
          () => n2.color,
          () => {
            n2.hex = n2.color.hex, n2.rgb = n2.color.toRgbString(), c2(), t2("update:color", n2.color), t2("change", n2.color);
          },
          { deep: true }
        ), {
          state: n2,
          advancePanelShow: i2,
          onBack: a2,
          onCompactChange: k2,
          onAlphaChange: p2,
          onHueChange: g2,
          onBoardChange: d2,
          onLightChange: m2,
          onInputChange: b2,
          previewStyle: l2,
          historyColors: r2
        };
      }
    }), jt = (e2) => (pushScopeId("data-v-48e3c224"), e2 = e2(), popScopeId(), e2), Zt = { class: "vc-fk-colorPicker" }, Jt = { class: "vc-fk-colorPicker__inner" }, Qt = { class: "vc-fk-colorPicker__header" }, xt = /* @__PURE__ */ jt(() => /* @__PURE__ */ createBaseVNode("div", { class: "back" }, null, -1)), eo = [
      xt
    ];
    function to(e2, t2, o3, n2, i2, l2) {
      const a2 = resolveComponent("Palette"), r2 = resolveComponent("Board"), c2 = resolveComponent("Hue"), k2 = resolveComponent("Lightness"), p2 = resolveComponent("Alpha"), g2 = resolveComponent("Display"), d2 = resolveComponent("History");
      return openBlock(), createElementBlock("div", Zt, [
        createBaseVNode("div", Jt, [
          createBaseVNode("div", Qt, [
            e2.advancePanelShow ? (openBlock(), createElementBlock("span", {
              key: 0,
              style: { cursor: "pointer" },
              onClick: t2[0] || (t2[0] = (...m2) => e2.onBack && e2.onBack(...m2))
            }, eo)) : createCommentVNode("", true)
          ]),
          e2.advancePanelShow ? createCommentVNode("", true) : (openBlock(), createBlock(a2, {
            key: 0,
            onChange: e2.onCompactChange
          }, null, 8, ["onChange"])),
          e2.advancePanelShow ? (openBlock(), createBlock(r2, {
            key: 1,
            color: e2.state.color,
            onChange: e2.onBoardChange
          }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
          e2.advancePanelShow ? (openBlock(), createBlock(c2, {
            key: 2,
            color: e2.state.color,
            onChange: e2.onHueChange
          }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
          e2.advancePanelShow ? createCommentVNode("", true) : (openBlock(), createBlock(k2, {
            key: 3,
            color: e2.state.color,
            onChange: e2.onLightChange
          }, null, 8, ["color", "onChange"])),
          e2.disableAlpha ? createCommentVNode("", true) : (openBlock(), createBlock(p2, {
            key: 4,
            color: e2.state.color,
            onChange: e2.onAlphaChange
          }, null, 8, ["color", "onChange"])),
          createVNode(g2, {
            color: e2.state.color,
            "disable-alpha": e2.disableAlpha
          }, null, 8, ["color", "disable-alpha"]),
          e2.disableHistory ? createCommentVNode("", true) : (openBlock(), createBlock(d2, {
            key: 5,
            round: e2.roundHistory,
            colors: e2.historyColors,
            onChange: e2.onCompactChange
          }, null, 8, ["round", "colors", "onChange"]))
        ])
      ]);
    }
    const Pe$1 = /* @__PURE__ */ q$1(Ut, [["render", to], ["__scopeId", "data-v-48e3c224"]]);
    const oo = /* @__PURE__ */ defineComponent({
      name: "ChromeColorPicker",
      components: { Display: Se$1, Alpha: ve$1, Board: ye$1, Hue: _e$1, History: me },
      props: {
        color: C$4.instanceOf(A$1),
        disableHistory: C$4.bool.def(false),
        roundHistory: C$4.bool.def(false),
        disableAlpha: C$4.bool.def(false)
      },
      emits: ["update:color", "change"],
      setup(e2, { emit: t2 }) {
        const o3 = e2.color || new A$1(), n2 = reactive({
          color: o3,
          hex: o3.toHexString(),
          rgb: o3.toRgbString()
        }), i2 = computed(() => ({ background: n2.rgb })), l2 = useLocalStorage(fe$1, [], {}), a2 = useDebounceFn(() => {
          if (e2.disableHistory)
            return;
          const d2 = n2.color.toRgbString();
          if (l2.value = l2.value.filter((m2) => !tinycolor$1.equals(m2, d2)), !l2.value.includes(d2)) {
            for (; l2.value.length > Ce$1; )
              l2.value.pop();
            l2.value.unshift(d2);
          }
        }, 500), r2 = (d2) => {
          n2.color.alpha = d2;
        }, c2 = (d2) => {
          n2.color.hue = d2;
        }, k2 = (d2) => {
          d2.hex !== void 0 && (n2.color.hex = d2.hex), d2.alpha !== void 0 && (n2.color.alpha = d2.alpha);
        }, p2 = (d2, m2) => {
          n2.color.saturation = d2, n2.color.brightness = m2;
        }, g2 = (d2) => {
          d2 !== "advance" && (n2.color.hex = d2);
        };
        return whenever(
          () => e2.color,
          (d2) => {
            d2 && (n2.color = d2);
          },
          { deep: true }
        ), whenever(
          () => n2.color,
          () => {
            n2.hex = n2.color.hex, n2.rgb = n2.color.toRgbString(), a2(), t2("update:color", n2.color), t2("change", n2.color);
          },
          { deep: true }
        ), {
          state: n2,
          previewStyle: i2,
          historyColors: l2,
          onAlphaChange: r2,
          onHueChange: c2,
          onBoardChange: p2,
          onInputChange: k2,
          onCompactChange: g2
        };
      }
    }), no = { class: "vc-chrome-colorPicker" }, ao = { class: "vc-chrome-colorPicker-body" }, ro = { class: "chrome-controls" }, lo = { class: "chrome-sliders" };
    function so(e2, t2, o3, n2, i2, l2) {
      const a2 = resolveComponent("Board"), r2 = resolveComponent("Hue"), c2 = resolveComponent("Alpha"), k2 = resolveComponent("Display"), p2 = resolveComponent("History");
      return openBlock(), createElementBlock("div", no, [
        createVNode(a2, {
          round: true,
          hide: false,
          color: e2.state.color,
          onChange: e2.onBoardChange
        }, null, 8, ["color", "onChange"]),
        createBaseVNode("div", ao, [
          createBaseVNode("div", ro, [
            createBaseVNode("div", lo, [
              createVNode(r2, {
                size: "small",
                color: e2.state.color,
                onChange: e2.onHueChange
              }, null, 8, ["color", "onChange"]),
              e2.disableAlpha ? createCommentVNode("", true) : (openBlock(), createBlock(c2, {
                key: 0,
                size: "small",
                color: e2.state.color,
                onChange: e2.onAlphaChange
              }, null, 8, ["color", "onChange"]))
            ])
          ]),
          createVNode(k2, {
            color: e2.state.color,
            "disable-alpha": e2.disableAlpha
          }, null, 8, ["color", "disable-alpha"]),
          e2.disableHistory ? createCommentVNode("", true) : (openBlock(), createBlock(p2, {
            key: 0,
            round: e2.roundHistory,
            colors: e2.historyColors,
            onChange: e2.onCompactChange
          }, null, 8, ["round", "colors", "onChange"]))
        ])
      ]);
    }
    const Ve = /* @__PURE__ */ q$1(oo, [["render", so], ["__scopeId", "data-v-2611d66c"]]), ke = "Vue3ColorPickerProvider", io = (e2, t2) => {
      const o3 = e2.getBoundingClientRect(), n2 = o3.left + o3.width / 2, i2 = o3.top + o3.height / 2, l2 = Math.abs(n2 - t2.clientX), a2 = Math.abs(i2 - t2.clientY), r2 = Math.sqrt(Math.pow(l2, 2) + Math.pow(a2, 2)), c2 = a2 / r2, k2 = Math.acos(c2);
      let p2 = Math.floor(180 / (Math.PI / k2));
      return t2.clientX > n2 && t2.clientY > i2 && (p2 = 180 - p2), t2.clientX == n2 && t2.clientY > i2 && (p2 = 180), t2.clientX > n2 && t2.clientY == i2 && (p2 = 90), t2.clientX < n2 && t2.clientY > i2 && (p2 = 180 + p2), t2.clientX < n2 && t2.clientY == i2 && (p2 = 270), t2.clientX < n2 && t2.clientY < i2 && (p2 = 360 - p2), p2;
    };
    let de$2 = false;
    const co = (e2, t2) => {
      const o3 = function(i2) {
        var l2;
        (l2 = t2.drag) == null || l2.call(t2, i2);
      }, n2 = function(i2) {
        var l2;
        document.removeEventListener("mousemove", o3, false), document.removeEventListener("mouseup", n2, false), document.onselectstart = null, document.ondragstart = null, de$2 = false, (l2 = t2.end) == null || l2.call(t2, i2);
      };
      e2 && e2.addEventListener("mousedown", (i2) => {
        var l2;
        de$2 || (document.onselectstart = () => false, document.ondragstart = () => false, document.addEventListener("mousemove", o3, false), document.addEventListener("mouseup", n2, false), de$2 = true, (l2 = t2.start) == null || l2.call(t2, i2));
      });
    };
    const uo = {
      angle: {
        type: Number,
        default: 0
      },
      size: {
        type: Number,
        default: 16,
        validator: (e2) => e2 >= 16
      },
      borderWidth: {
        type: Number,
        default: 1,
        validator: (e2) => e2 >= 1
      },
      borderColor: {
        type: String,
        default: "#666"
      }
    }, go = /* @__PURE__ */ defineComponent({
      name: "Angle",
      props: uo,
      emits: ["update:angle", "change"],
      setup(e2, {
        emit: t2
      }) {
        const o3 = ref(null), n2 = ref(0);
        watch$1(() => e2.angle, (r2) => {
          n2.value = r2;
        });
        const i2 = () => {
          let r2 = Number(n2.value);
          isNaN(r2) || (r2 = r2 > 360 || r2 < 0 ? e2.angle : r2, n2.value = r2 === 360 ? 0 : r2, t2("update:angle", n2.value), t2("change", n2.value));
        }, l2 = computed(() => ({
          width: e2.size + "px",
          height: e2.size + "px",
          borderWidth: e2.borderWidth + "px",
          borderColor: e2.borderColor,
          transform: `rotate(${n2.value}deg)`
        })), a2 = (r2) => {
          o3.value && (n2.value = io(o3.value, r2) % 360, i2());
        };
        return onMounted(() => {
          const r2 = {
            drag: (c2) => {
              a2(c2);
            },
            end: (c2) => {
              a2(c2);
            }
          };
          o3.value && co(o3.value, r2);
        }), () => createVNode("div", {
          class: "bee-angle"
        }, [createVNode("div", {
          class: "bee-angle__round",
          ref: o3,
          style: l2.value
        }, null)]);
      }
    });
    const ho = /* @__PURE__ */ defineComponent({
      name: "GradientColorPicker",
      components: { Angle: go, Display: Se$1, Alpha: ve$1, Palette: Ke, Board: ye$1, Hue: _e$1, Lightness: Le, History: me },
      props: {
        startColor: C$4.instanceOf(A$1).isRequired,
        endColor: C$4.instanceOf(A$1).isRequired,
        startColorStop: C$4.number.def(0),
        endColorStop: C$4.number.def(100),
        angle: C$4.number.def(0),
        type: C$4.oneOf(["linear", "radial"]).def("linear"),
        disableHistory: C$4.bool.def(false),
        roundHistory: C$4.bool.def(false),
        disableAlpha: C$4.bool.def(false),
        pickerType: C$4.oneOf(["fk", "chrome"]).def("fk")
      },
      emits: [
        "update:startColor",
        "update:endColor",
        "update:angle",
        "update:startColorStop",
        "update:endColorStop",
        "startColorChange",
        "endColorChange",
        "advanceChange",
        "angleChange",
        "startColorStopChange",
        "endColorStopChange",
        "typeChange"
      ],
      setup(e2, { emit: t2 }) {
        const o3 = reactive({
          startActive: true,
          startColor: e2.startColor,
          endColor: e2.endColor,
          startColorStop: e2.startColorStop,
          endColorStop: e2.endColorStop,
          angle: e2.angle,
          type: e2.type,
          // rgba
          startColorRgba: e2.startColor.toRgbString(),
          endColorRgba: e2.endColor.toRgbString()
        }), n2 = inject(ke), i2 = ref(e2.pickerType === "chrome"), l2 = ref(), a2 = ref(), r2 = ref();
        watch$1(
          () => [e2.startColor, e2.endColor, e2.angle],
          (s2) => {
            o3.startColor = s2[0], o3.endColor = s2[1], o3.angle = s2[2];
          }
        ), watch$1(
          () => e2.type,
          (s2) => {
            o3.type = s2;
          }
        );
        const c2 = computed({
          get: () => o3.startActive ? o3.startColor : o3.endColor,
          set: (s2) => {
            if (o3.startActive) {
              o3.startColor = s2;
              return;
            }
            o3.endColor = s2;
          }
        }), k2 = computed(() => {
          if (r2.value && l2.value) {
            const s2 = o3.startColorStop / 100, _2 = r2.value.getBoundingClientRect(), H2 = l2.value.offsetWidth;
            return Math.round(s2 * (_2.width - H2) + H2 / 2);
          }
          return 0;
        }), p2 = computed(() => {
          if (r2.value && a2.value) {
            const s2 = o3.endColorStop / 100, _2 = r2.value.getBoundingClientRect(), H2 = a2.value.offsetWidth;
            return Math.round(s2 * (_2.width - H2) + H2 / 2);
          }
          return 0;
        }), g2 = computed(() => {
          let s2 = `background: linear-gradient(${o3.angle}deg, ${o3.startColorRgba} ${o3.startColorStop}%, ${o3.endColorRgba} ${o3.endColorStop}%)`;
          return o3.type === "radial" && (s2 = `background: radial-gradient(circle, ${o3.startColorRgba} ${o3.startColorStop}%, ${o3.endColorRgba} ${o3.endColorStop}%)`), s2;
        }), d2 = (s2) => {
          var _2;
          if (o3.startActive = true, r2.value && l2.value) {
            const H2 = (_2 = r2.value) == null ? void 0 : _2.getBoundingClientRect();
            let N2 = s2.clientX - H2.left;
            N2 = Math.max(l2.value.offsetWidth / 2, N2), N2 = Math.min(N2, H2.width - l2.value.offsetWidth / 2), o3.startColorStop = Math.round(
              (N2 - l2.value.offsetWidth / 2) / (H2.width - l2.value.offsetWidth) * 100
            ), t2("update:startColorStop", o3.startColorStop), t2("startColorStopChange", o3.startColorStop);
          }
        }, m2 = (s2) => {
          var _2;
          if (o3.startActive = false, r2.value && a2.value) {
            const H2 = (_2 = r2.value) == null ? void 0 : _2.getBoundingClientRect();
            let N2 = s2.clientX - H2.left;
            N2 = Math.max(a2.value.offsetWidth / 2, N2), N2 = Math.min(N2, H2.width - a2.value.offsetWidth / 2), o3.endColorStop = Math.round(
              (N2 - a2.value.offsetWidth / 2) / (H2.width - a2.value.offsetWidth) * 100
            ), t2("update:endColorStop", o3.endColorStop), t2("endColorStopChange", o3.endColorStop);
          }
        }, b2 = (s2) => {
          const _2 = s2.target, H2 = parseInt(_2.value.replace("°", ""));
          isNaN(H2) || (o3.angle = H2 % 360), t2("update:angle", o3.angle), t2("angleChange", o3.angle);
        }, h2 = (s2) => {
          o3.angle = s2, t2("update:angle", o3.angle), t2("angleChange", o3.angle);
        }, y2 = (s2) => {
          s2 === "advance" ? (i2.value = true, t2("advanceChange", true)) : (c2.value.hex = s2, t2("advanceChange", false)), L2();
        }, f2 = (s2) => {
          c2.value.alpha = s2, L2();
        }, w2 = (s2) => {
          c2.value.hue = s2, L2();
        }, S2 = (s2, _2) => {
          c2.value.saturation = s2, c2.value.brightness = _2, L2();
        }, F2 = (s2) => {
          c2.value.lightness = s2, L2();
        }, E2 = () => {
          L2();
        }, L2 = () => {
          o3.startActive ? (t2("update:startColor", o3.startColor), t2("startColorChange", o3.startColor)) : (t2("update:endColor", o3.endColor), t2("endColorChange", o3.endColor));
        }, U2 = () => {
          i2.value = false, t2("advanceChange", false);
        }, J2 = () => {
          o3.type = o3.type === "linear" ? "radial" : "linear", t2("typeChange", o3.type);
        }, X2 = useLocalStorage(fe$1, [], {}), ce2 = useDebounceFn(() => {
          if (e2.disableHistory)
            return;
          const s2 = c2.value.toRgbString();
          if (X2.value = X2.value.filter((_2) => !tinycolor$1.equals(_2, s2)), !X2.value.includes(s2)) {
            for (; X2.value.length > Ce$1; )
              X2.value.pop();
            X2.value.unshift(s2);
          }
        }, 500);
        return tryOnMounted(() => {
          a2.value && l2.value && (Vn.triggerDragEvent(a2.value, {
            drag: (s2) => {
              m2(s2);
            },
            end: (s2) => {
              m2(s2);
            }
          }), Vn.triggerDragEvent(l2.value, {
            drag: (s2) => {
              d2(s2);
            },
            end: (s2) => {
              d2(s2);
            }
          }));
        }), whenever(
          () => o3.startColor,
          (s2) => {
            o3.startColorRgba = s2.toRgbString();
          },
          { deep: true }
        ), whenever(
          () => o3.endColor,
          (s2) => {
            o3.endColorRgba = s2.toRgbString();
          },
          { deep: true }
        ), whenever(
          () => c2.value,
          () => {
            ce2();
          },
          { deep: true }
        ), {
          startGradientRef: l2,
          stopGradientRef: a2,
          colorRangeRef: r2,
          state: o3,
          currentColor: c2,
          getStartColorLeft: k2,
          getEndColorLeft: p2,
          gradientBg: g2,
          advancePanelShow: i2,
          onDegreeBlur: b2,
          onCompactChange: y2,
          onAlphaChange: f2,
          onHueChange: w2,
          onBoardChange: S2,
          onLightChange: F2,
          historyColors: X2,
          onBack: U2,
          onDegreeChange: h2,
          onDisplayChange: E2,
          onTypeChange: J2,
          lang: n2 == null ? void 0 : n2.lang
        };
      }
    }), Ne$1 = (e2) => (pushScopeId("data-v-c4d6d6ea"), e2 = e2(), popScopeId(), e2), po = { class: "vc-gradient-picker" }, fo = { class: "vc-gradient-picker__header" }, Co = { class: "vc-gradient__types" }, vo = { class: "vc-gradient-wrap__types" }, bo = { class: "vc-picker-degree-input vc-degree-input" }, yo = { class: "vc-degree-input__control" }, _o = ["value"], mo = { class: "vc-degree-input__panel" }, So = { class: "vc-degree-input__disk" }, ko = { class: "vc-gradient-picker__body" }, $o = {
      class: "vc-color-range",
      ref: "colorRangeRef"
    }, wo = { class: "vc-color-range__container" }, Bo = { class: "vc-gradient__stop__container" }, Ho = ["title"], Ro = /* @__PURE__ */ Ne$1(() => /* @__PURE__ */ createBaseVNode("span", { class: "vc-gradient__stop--inner" }, null, -1)), Ao = [
      Ro
    ], Po = ["title"], Vo = /* @__PURE__ */ Ne$1(() => /* @__PURE__ */ createBaseVNode("span", { class: "vc-gradient__stop--inner" }, null, -1)), Mo = [
      Vo
    ];
    function Eo(e2, t2, o3, n2, i2, l2) {
      var b2, h2;
      const a2 = resolveComponent("Angle"), r2 = resolveComponent("Board"), c2 = resolveComponent("Hue"), k2 = resolveComponent("Palette"), p2 = resolveComponent("Lightness"), g2 = resolveComponent("Alpha"), d2 = resolveComponent("Display"), m2 = resolveComponent("History");
      return openBlock(), createElementBlock("div", po, [
        createBaseVNode("div", fo, [
          createBaseVNode("div", null, [
            withDirectives(createBaseVNode("div", {
              class: "back",
              style: { cursor: "pointer" },
              onClick: t2[0] || (t2[0] = (...y2) => e2.onBack && e2.onBack(...y2))
            }, null, 512), [
              [vShow, e2.pickerType === "fk" && e2.advancePanelShow]
            ])
          ]),
          createBaseVNode("div", Co, [
            createBaseVNode("div", vo, [
              (openBlock(), createElementBlock(Fragment, null, renderList(["linear", "radial"], (y2) => createBaseVNode("div", {
                class: normalizeClass(["vc-gradient__type", { active: e2.state.type === y2 }]),
                key: y2,
                onClick: t2[1] || (t2[1] = (...f2) => e2.onTypeChange && e2.onTypeChange(...f2))
              }, toDisplayString$2(e2.lang ? e2.lang[y2] : y2), 3)), 64))
            ]),
            withDirectives(createBaseVNode("div", bo, [
              createBaseVNode("div", yo, [
                createBaseVNode("input", {
                  value: e2.state.angle,
                  onBlur: t2[2] || (t2[2] = (...y2) => e2.onDegreeBlur && e2.onDegreeBlur(...y2))
                }, null, 40, _o),
                createTextVNode("deg ")
              ]),
              createBaseVNode("div", mo, [
                createBaseVNode("div", So, [
                  createVNode(a2, {
                    angle: e2.state.angle,
                    "onUpdate:angle": t2[3] || (t2[3] = (y2) => e2.state.angle = y2),
                    size: 40,
                    onChange: e2.onDegreeChange
                  }, null, 8, ["angle", "onChange"])
                ])
              ])
            ], 512), [
              [vShow, e2.state.type === "linear"]
            ])
          ])
        ]),
        createBaseVNode("div", ko, [
          createBaseVNode("div", $o, [
            createBaseVNode("div", wo, [
              createBaseVNode("div", {
                class: "vc-background",
                style: normalizeStyle(e2.gradientBg)
              }, null, 4),
              createBaseVNode("div", Bo, [
                createBaseVNode("div", {
                  class: normalizeClass(["vc-gradient__stop", {
                    "vc-gradient__stop--current": e2.state.startActive
                  }]),
                  ref: "startGradientRef",
                  title: (b2 = e2.lang) == null ? void 0 : b2.start,
                  style: normalizeStyle({ left: e2.getStartColorLeft + "px", backgroundColor: e2.state.startColorRgba })
                }, Ao, 14, Ho),
                createBaseVNode("div", {
                  class: normalizeClass(["vc-gradient__stop", {
                    "vc-gradient__stop--current": !e2.state.startActive
                  }]),
                  ref: "stopGradientRef",
                  title: (h2 = e2.lang) == null ? void 0 : h2.end,
                  style: normalizeStyle({ left: e2.getEndColorLeft + "px", backgroundColor: e2.state.endColorRgba })
                }, Mo, 14, Po)
              ])
            ])
          ], 512)
        ]),
        e2.advancePanelShow ? (openBlock(), createBlock(r2, {
          key: 0,
          color: e2.currentColor,
          onChange: e2.onBoardChange
        }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
        e2.advancePanelShow ? (openBlock(), createBlock(c2, {
          key: 1,
          color: e2.currentColor,
          onChange: e2.onHueChange
        }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
        e2.advancePanelShow ? createCommentVNode("", true) : (openBlock(), createBlock(k2, {
          key: 2,
          onChange: e2.onCompactChange
        }, null, 8, ["onChange"])),
        e2.advancePanelShow ? createCommentVNode("", true) : (openBlock(), createBlock(p2, {
          key: 3,
          color: e2.currentColor,
          onChange: e2.onLightChange
        }, null, 8, ["color", "onChange"])),
        e2.disableAlpha ? createCommentVNode("", true) : (openBlock(), createBlock(g2, {
          key: 4,
          color: e2.currentColor,
          onChange: e2.onAlphaChange
        }, null, 8, ["color", "onChange"])),
        createVNode(d2, {
          color: e2.currentColor,
          "disable-alpha": e2.disableAlpha,
          onChange: e2.onDisplayChange
        }, null, 8, ["color", "disable-alpha", "onChange"]),
        e2.disableHistory ? createCommentVNode("", true) : (openBlock(), createBlock(m2, {
          key: 5,
          round: e2.roundHistory,
          colors: e2.historyColors,
          onChange: e2.onCompactChange
        }, null, 8, ["round", "colors", "onChange"]))
      ]);
    }
    const Me = /* @__PURE__ */ q$1(ho, [["render", Eo], ["__scopeId", "data-v-c4d6d6ea"]]);
    const Io = /* @__PURE__ */ defineComponent({
      name: "WrapContainer",
      props: {
        theme: C$4.oneOf(["white", "black"]).def("white"),
        showTab: C$4.bool.def(false),
        activeKey: C$4.oneOf(["pure", "gradient"]).def("pure")
      },
      emits: ["update:activeKey", "change"],
      setup(e2, { emit: t2 }) {
        const o3 = reactive({
          activeKey: e2.activeKey
        }), n2 = inject(ke), i2 = (l2) => {
          o3.activeKey = l2, t2("update:activeKey", l2), t2("change", l2);
        };
        return whenever(
          () => e2.activeKey,
          (l2) => {
            o3.activeKey = l2;
          }
        ), { state: o3, onActiveKeyChange: i2, lang: n2 == null ? void 0 : n2.lang };
      }
    }), Ko = { class: "vc-colorpicker--container" }, Lo = {
      key: 0,
      class: "vc-colorpicker--tabs"
    }, No = { class: "vc-colorpicker--tabs__inner" }, Wo = { class: "vc-btn__content" }, Do = { class: "vc-btn__content" };
    function To(e2, t2, o3, n2, i2, l2) {
      var a2, r2;
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["vc-colorpicker", e2.theme])
      }, [
        createBaseVNode("div", Ko, [
          e2.showTab ? (openBlock(), createElementBlock("div", Lo, [
            createBaseVNode("div", No, [
              createBaseVNode("div", {
                class: normalizeClass([
                  "vc-colorpicker--tabs__btn",
                  {
                    "vc-btn-active": e2.state.activeKey === "pure"
                  }
                ]),
                onClick: t2[0] || (t2[0] = (c2) => e2.onActiveKeyChange("pure"))
              }, [
                createBaseVNode("button", null, [
                  createBaseVNode("div", Wo, toDisplayString$2((a2 = e2.lang) == null ? void 0 : a2.pure), 1)
                ])
              ], 2),
              createBaseVNode("div", {
                class: normalizeClass([
                  "vc-colorpicker--tabs__btn",
                  {
                    "vc-btn-active": e2.state.activeKey === "gradient"
                  }
                ]),
                onClick: t2[1] || (t2[1] = (c2) => e2.onActiveKeyChange("gradient"))
              }, [
                createBaseVNode("button", null, [
                  createBaseVNode("div", Do, toDisplayString$2((r2 = e2.lang) == null ? void 0 : r2.gradient), 1)
                ])
              ], 2),
              createBaseVNode("div", {
                class: "vc-colorpicker--tabs__bg",
                style: normalizeStyle({
                  width: "50%",
                  left: `calc(${e2.state.activeKey === "gradient" ? 50 : 0}%)`
                })
              }, null, 4)
            ])
          ])) : createCommentVNode("", true),
          renderSlot(e2.$slots, "default", {}, void 0, true)
        ])
      ], 2);
    }
    const Oo = /* @__PURE__ */ q$1(Io, [["render", To], ["__scopeId", "data-v-0492277d"]]), zo = {
      start: "Start",
      end: "End",
      pure: "Pure",
      gradient: "Gradient",
      linear: "linear",
      radial: "radial"
    }, Go = {
      start: "开始",
      end: "结束",
      pure: "纯色",
      gradient: "渐变",
      linear: "线性",
      radial: "径向"
    }, Fo = {
      En: zo,
      "ZH-cn": Go
    };
    const Xo = {
      isWidget: C$4.bool.def(false),
      pickerType: C$4.oneOf(["fk", "chrome"]).def("fk"),
      shape: C$4.oneOf(["circle", "square"]).def("square"),
      pureColor: {
        type: [String, Object],
        default: "#000000"
      },
      gradientColor: C$4.string.def(
        "linear-gradient(90deg, rgba(255, 255, 255, 1) 0%, rgba(0, 0, 0, 1) 100%)"
      ),
      format: {
        type: String,
        default: "rgb"
      },
      disableAlpha: C$4.bool.def(false),
      disableHistory: C$4.bool.def(false),
      roundHistory: C$4.bool.def(false),
      useType: C$4.oneOf(["pure", "gradient", "both"]).def("pure"),
      activeKey: C$4.oneOf(["pure", "gradient"]).def("pure"),
      lang: {
        type: String,
        default: "ZH-cn"
      },
      zIndex: C$4.number.def(9999),
      pickerContainer: {
        type: [String, HTMLElement],
        default: "body"
      },
      debounce: C$4.number.def(100),
      theme: C$4.oneOf(["white", "black"]).def("white"),
      blurClose: C$4.bool.def(false),
      defaultPopup: C$4.bool.def(false)
    }, qo = /* @__PURE__ */ defineComponent({
      name: "ColorPicker",
      components: { FkColorPicker: Pe$1, ChromeColorPicker: Ve, GradientColorPicker: Me, WrapContainer: Oo },
      inheritAttrs: false,
      props: Xo,
      emits: [
        "update:pureColor",
        "pureColorChange",
        "update:gradientColor",
        "gradientColorChange",
        "update:activeKey",
        "activeKeyChange"
      ],
      setup(e2, { emit: t2 }) {
        provide(ke, {
          lang: computed(() => Fo[e2.lang || "ZH-cn"])
        });
        const o3 = !!useSlots().extra, n2 = reactive({
          pureColor: e2.pureColor || "",
          activeKey: e2.useType === "gradient" ? "gradient" : e2.activeKey,
          //  "pure" | "gradient"
          isAdvanceMode: false
        }), i2 = new A$1("#000"), l2 = new A$1("#000"), a2 = new A$1(n2.pureColor), r2 = reactive({
          startColor: i2,
          endColor: l2,
          startColorStop: 0,
          endColorStop: 100,
          angle: 0,
          type: "linear",
          gradientColor: e2.gradientColor
        }), c2 = ref(a2), k2 = ref(e2.defaultPopup), p2 = ref(null), g2 = ref(null);
        let d2 = null;
        const m2 = computed(() => ({
          background: n2.activeKey !== "gradient" ? tinycolor$1(n2.pureColor).toRgbString() : r2.gradientColor
        })), b2 = computed(() => n2.activeKey === "gradient" ? Me.name : e2.pickerType === "fk" ? Pe$1.name : Ve.name), h2 = (s2) => {
          n2.isAdvanceMode = s2;
        }, y2 = computed(() => {
          const s2 = {
            disableAlpha: e2.disableAlpha,
            disableHistory: e2.disableHistory,
            roundHistory: e2.roundHistory,
            pickerType: e2.pickerType
          };
          return n2.activeKey === "gradient" ? {
            ...s2,
            startColor: r2.startColor,
            endColor: r2.endColor,
            angle: r2.angle,
            type: r2.type,
            startColorStop: r2.startColorStop,
            endColorStop: r2.endColorStop,
            onStartColorChange: (_2) => {
              r2.startColor = _2, E2();
            },
            onEndColorChange: (_2) => {
              r2.endColor = _2, E2();
            },
            onStartColorStopChange: (_2) => {
              r2.startColorStop = _2, E2();
            },
            onEndColorStopChange: (_2) => {
              r2.endColorStop = _2, E2();
            },
            onAngleChange: (_2) => {
              r2.angle = _2, E2();
            },
            onTypeChange: (_2) => {
              r2.type = _2, E2();
            },
            onAdvanceChange: h2
          } : {
            ...s2,
            disableAlpha: e2.disableAlpha,
            disableHistory: e2.disableHistory,
            roundHistory: e2.roundHistory,
            color: c2.value,
            onChange: J2,
            onAdvanceChange: h2
          };
        }), f2 = () => {
          k2.value = true, d2 ? d2.update() : U2();
        }, w2 = () => {
          k2.value = false;
        }, S2 = useDebounceFn(() => {
          !e2.isWidget && e2.blurClose && w2();
        }, 100);
        onClickOutside(g2, () => {
          w2();
        });
        const F2 = () => {
          var s2, _2, H2, N2;
          try {
            const [z2] = parse(r2.gradientColor);
            if (z2 && z2.type.includes("gradient") && z2.colorStops.length >= 2) {
              const $e2 = z2.colorStops[0], we2 = z2.colorStops[1];
              r2.startColorStop = Number((s2 = $e2.length) == null ? void 0 : s2.value) || 0, r2.endColorStop = Number((_2 = we2.length) == null ? void 0 : _2.value) || 0, z2.type === "linear-gradient" && ((H2 = z2.orientation) == null ? void 0 : H2.type) === "angular" && (r2.angle = Number((N2 = z2.orientation) == null ? void 0 : N2.value) || 0), r2.type = z2.type.split("-")[0];
              const [We2, De2, Te2, Oe2] = $e2.value, [ze2, Ge2, Fe2, Xe2] = we2.value;
              r2.startColor = new A$1({
                r: Number(We2),
                g: Number(De2),
                b: Number(Te2),
                a: Number(Oe2)
              }), r2.endColor = new A$1({
                r: Number(ze2),
                g: Number(Ge2),
                b: Number(Fe2),
                a: Number(Xe2)
              });
            }
          } catch (z2) {
            console.log(`[Parse Color]: ${z2}`);
          }
        }, E2 = useDebounceFn(() => {
          const s2 = L2();
          try {
            r2.gradientColor = stringify(s2), t2("update:gradientColor", r2.gradientColor), t2("gradientColorChange", r2.gradientColor);
          } catch (_2) {
            console.log(_2);
          }
        }, e2.debounce), L2 = () => {
          const s2 = [], _2 = r2.startColor.RGB.map((z2) => z2.toString()), H2 = r2.endColor.RGB.map((z2) => z2.toString()), N2 = [
            {
              type: "rgba",
              value: [_2[0], _2[1], _2[2], _2[3]],
              length: { value: r2.startColorStop + "", type: "%" }
            },
            {
              type: "rgba",
              value: [H2[0], H2[1], H2[2], H2[3]],
              length: { value: r2.endColorStop + "", type: "%" }
            }
          ];
          return r2.type === "linear" ? s2.push({
            type: "linear-gradient",
            orientation: { type: "angular", value: r2.angle + "" },
            colorStops: N2
          }) : r2.type === "radial" && s2.push({
            type: "radial-gradient",
            orientation: [{ type: "shape", value: "circle" }],
            colorStops: N2
          }), s2;
        }, U2 = () => {
          p2.value && g2.value && (d2 = createPopper(p2.value, g2.value, {
            placement: "auto",
            modifiers: [
              {
                name: "offset",
                options: {
                  offset: [0, 8]
                }
              },
              {
                name: "flip",
                options: {
                  allowedAutoPlacements: ["top", "bottom", "left", "right"],
                  rootBoundary: "viewport"
                }
              }
            ]
          }));
        }, J2 = (s2) => {
          c2.value = s2, n2.pureColor = s2.toString(e2.format), X2();
        }, X2 = useDebounceFn(() => {
          t2("update:pureColor", n2.pureColor), t2("pureColorChange", n2.pureColor);
        }, e2.debounce), ce2 = (s2) => {
          n2.activeKey = s2, t2("update:activeKey", s2), t2("activeKeyChange", s2);
        };
        return tryOnMounted(() => {
          F2(), d2 || U2();
        }), whenever(
          () => e2.gradientColor,
          (s2) => {
            s2 != r2.gradientColor && (r2.gradientColor = s2);
          }
        ), whenever(
          () => r2.gradientColor,
          () => {
            F2();
          }
        ), whenever(
          () => e2.activeKey,
          (s2) => {
            n2.activeKey = s2;
          }
        ), whenever(
          () => e2.useType,
          (s2) => {
            n2.activeKey !== "gradient" && s2 === "gradient" ? n2.activeKey = "gradient" : n2.activeKey = "pure";
          }
        ), whenever(
          () => e2.pureColor,
          (s2) => {
            tinycolor$1.equals(s2, n2.pureColor) || (n2.pureColor = s2, c2.value = new A$1(s2));
          },
          { deep: true }
        ), {
          colorCubeRef: p2,
          pickerRef: g2,
          showPicker: k2,
          colorInstance: c2,
          getBgColorStyle: m2,
          getComponentName: b2,
          getBindArgs: y2,
          state: n2,
          hasExtra: o3,
          onColorChange: J2,
          onShowPicker: f2,
          onActiveKeyChange: ce2,
          onAutoClose: S2
        };
      }
    }), Yo = {
      key: 0,
      class: "vc-color-extra"
    }, Uo = {
      key: 0,
      class: "vc-color-extra"
    };
    function jo(e2, t2, o3, n2, i2, l2) {
      const a2 = resolveComponent("WrapContainer");
      return openBlock(), createElementBlock(Fragment, null, [
        e2.isWidget ? (openBlock(), createBlock(a2, {
          key: 0,
          "active-key": e2.state.activeKey,
          "onUpdate:activeKey": t2[0] || (t2[0] = (r2) => e2.state.activeKey = r2),
          "show-tab": e2.useType === "both",
          style: normalizeStyle({ zIndex: e2.zIndex }),
          theme: e2.theme,
          onChange: e2.onActiveKeyChange
        }, {
          default: withCtx(() => [
            (openBlock(), createBlock(resolveDynamicComponent(e2.getComponentName), mergeProps({ key: e2.getComponentName }, e2.getBindArgs), null, 16)),
            e2.hasExtra ? (openBlock(), createElementBlock("div", Yo, [
              renderSlot(e2.$slots, "extra", {}, void 0, true)
            ])) : createCommentVNode("", true)
          ]),
          _: 3
        }, 8, ["active-key", "show-tab", "style", "theme", "onChange"])) : createCommentVNode("", true),
        e2.isWidget ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createBaseVNode("div", {
            class: normalizeClass(["vc-color-wrap transparent", { round: e2.shape === "circle" }]),
            ref: "colorCubeRef"
          }, [
            createBaseVNode("div", {
              class: "current-color",
              style: normalizeStyle(e2.getBgColorStyle),
              onClick: t2[1] || (t2[1] = (...r2) => e2.onShowPicker && e2.onShowPicker(...r2))
            }, null, 4)
          ], 2),
          (openBlock(), createBlock(Teleport, { to: e2.pickerContainer }, [
            withDirectives(createBaseVNode("div", {
              ref: "pickerRef",
              style: normalizeStyle({ zIndex: e2.zIndex }),
              onMouseleave: t2[3] || (t2[3] = (...r2) => e2.onAutoClose && e2.onAutoClose(...r2))
            }, [
              e2.showPicker ? (openBlock(), createBlock(a2, {
                key: 0,
                "show-tab": e2.useType === "both" && !e2.state.isAdvanceMode,
                theme: e2.theme,
                "active-key": e2.state.activeKey,
                "onUpdate:activeKey": t2[2] || (t2[2] = (r2) => e2.state.activeKey = r2),
                onChange: e2.onActiveKeyChange
              }, {
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(e2.getComponentName), mergeProps({ key: e2.getComponentName }, e2.getBindArgs), null, 16)),
                  e2.hasExtra ? (openBlock(), createElementBlock("div", Uo, [
                    renderSlot(e2.$slots, "extra", {}, void 0, true)
                  ])) : createCommentVNode("", true)
                ]),
                _: 3
              }, 8, ["show-tab", "theme", "active-key", "onChange"])) : createCommentVNode("", true)
            ], 36), [
              [vShow, e2.showPicker]
            ])
          ], 8, ["to"]))
        ], 64))
      ], 64);
    }
    const re$1 = /* @__PURE__ */ q$1(qo, [["render", jo], ["__scopeId", "data-v-354ca836"]]);
    const _sfc_main$x = {
      components: {
        VueFinalModal: Ro$2,
        VueDragResize,
        ColorPicker: re$1
      },
      data() {
        return {
          width: 0,
          height: 0,
          top: 100,
          left: 0,
          initalHeight: 400,
          initalLeft: 400,
          renderProperties: [],
          rangeValue: {},
          fontValue: {},
          booleanValue: {}
        };
      },
      computed: {
        // other computed properties
        // ...
        // gives access to this.counterStore and this.userStore
        ...mapStores(usePreferenceStore),
        // // gives read access to this.count and this.double
        ...mapState(usePreferenceStore, ["showPrefModal", "showPrefModalGroup", "styleDefault", "showPrefModalGroup", "fontFamilies"]),
        // array of the pssobile groups from the stlyes
        possilbleGroups() {
          return [...new Set(Object.keys(this.styleDefault).map((v2) => {
            return this.styleDefault[v2].group;
          }))];
        }
      },
      watch: {
        // whenever question changes, this function will run
        showPrefModal(newVal, oldVal) {
          console.log(newVal, oldVal);
        }
      },
      methods: {
        dragResize: function(newRect) {
          this.width = newRect.width;
          this.height = newRect.height;
          this.top = newRect.top;
          this.left = newRect.left;
          this.$refs.preferenceContent.style.height = newRect.height + "px";
        },
        onSelectElement(event2) {
          const tagName = event2.target.tagName;
          if (tagName === "INPUT" || tagName === "TEXTAREA" || tagName === "SELECT") {
            event2.stopPropagation();
          }
        },
        colorChange: function(x2) {
          console.log(x2);
        },
        loadPrefGroup: function(event2) {
          if (event2) {
            this.preferenceStore.setShowPrefModalGroup(event2.target.value);
          }
          this.renderProperties = [];
          this.allOptionsCounter++;
          console.log(this.renderProperties);
          for (let k2 in this.styleDefault) {
            if (this.styleDefault[k2].group == this.showPrefModalGroup) {
              let o3 = Object.assign({}, this.styleDefault[k2]);
              o3.id = k2;
              if (o3.type == "number") {
                this.rangeValue[o3.id] = o3.value;
              } else if (o3.type == "font") {
                this.fontValue[o3.id] = o3.value;
              } else if (o3.type == "boolean") {
                this.booleanValue[o3.id] = o3.value;
              }
              this.renderProperties.push(o3);
            }
          }
          console.log(this.renderProperties);
          console.log(this.rangeValue);
        },
        changeColor: function(color, id2) {
          console.log(color, id2);
          this.preferenceStore.setValue(id2, color);
        },
        rangeValueChange: function() {
          for (let id2 in this.rangeValue) {
            this.preferenceStore.setValue(id2, parseFloat(this.rangeValue[id2]));
          }
        },
        fontValueChange: function(event2) {
          for (let id2 in this.fontValue) {
            this.preferenceStore.setValue(id2, event2.target.value);
          }
        },
        booleanValueChange: function() {
          for (let id2 in this.booleanValue) {
            console.log(id2, this.booleanValue[id2]);
            this.preferenceStore.setValue(id2, this.booleanValue[id2]);
          }
        }
      },
      mounted() {
        this.$nextTick(() => {
          this.loadPrefGroup();
          this.$nextTick(() => {
            this.$refs.preferenceContent.style.height = this.initalHeight + "px";
          });
        });
      }
    };
    const _hoisted_1$G = ["selected"];
    const _hoisted_2$x = { class: "option" };
    const _hoisted_3$t = { class: "option-title" };
    const _hoisted_4$s = { class: "option-title-header" };
    const _hoisted_5$m = { class: "option-title-desc" };
    const _hoisted_6$k = { class: "option-control" };
    const _hoisted_7$i = ["onUpdate:modelValue", "min", "max", "step"];
    const _hoisted_8$e = ["onUpdate:modelValue"];
    const _hoisted_9$d = ["selected"];
    const _hoisted_10$c = ["onUpdate:modelValue"];
    function _sfc_render$v(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_color_picker = resolveComponent("color-picker");
      const _component_VueDragResize = resolveComponent("VueDragResize");
      const _component_VueFinalModal = resolveComponent("VueFinalModal");
      return openBlock(), createBlock(_component_VueFinalModal, {
        "display-directive": "show",
        "hide-overlay": true,
        "overlay-transition": "vfm-fade"
      }, {
        default: withCtx(() => [
          createVNode(_component_VueDragResize, {
            "is-active": true,
            w: 600,
            h: $data.initalHeight,
            x: $data.initalLeft,
            class: "preference-modal",
            onResizing: $options.dragResize,
            onDragging: $options.dragResize,
            sticks: ["br"],
            stickSize: 22
          }, {
            default: withCtx(() => [
              createBaseVNode("div", {
                id: "preference-content",
                ref: "preferenceContent",
                onMousedown: _cache[5] || (_cache[5] = ($event) => $options.onSelectElement($event)),
                onTouchstart: _cache[6] || (_cache[6] = ($event) => $options.onSelectElement($event))
              }, [
                createBaseVNode("h3", null, [
                  createTextVNode("Preferences - "),
                  createBaseVNode("select", {
                    onChange: _cache[0] || (_cache[0] = ($event) => $options.loadPrefGroup($event))
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList($options.possilbleGroups, (group) => {
                      return openBlock(), createElementBlock("option", {
                        selected: _ctx.showPrefModalGroup == group
                      }, toDisplayString$2(group), 9, _hoisted_1$G);
                    }), 256))
                  ], 32)
                ]),
                createBaseVNode("button", {
                  class: "close-button",
                  onPointerup: _cache[1] || (_cache[1] = ($event) => _ctx.preferenceStore.togglePrefModal())
                }, "X", 32),
                (openBlock(true), createElementBlock(Fragment, null, renderList($data.renderProperties, (option) => {
                  return openBlock(), createElementBlock("div", {
                    key: _ctx.showPrefModalGroup + "_" + option.id
                  }, [
                    createBaseVNode("div", _hoisted_2$x, [
                      createBaseVNode("div", _hoisted_3$t, [
                        createBaseVNode("div", _hoisted_4$s, toDisplayString$2(option.descShort), 1),
                        createBaseVNode("div", _hoisted_5$m, toDisplayString$2(option.desc), 1)
                      ]),
                      createBaseVNode("div", _hoisted_6$k, [
                        option.type === "color" ? (openBlock(), createBlock(_component_color_picker, {
                          key: 0,
                          pureColor: option.value,
                          format: "hex8",
                          "onUpdate:pureColor": ($event) => $options.changeColor($event, option.id)
                        }, null, 8, ["pureColor", "onUpdate:pureColor"])) : option.type === "number" ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                          createTextVNode(toDisplayString$2($data.rangeValue[option.id]) + " ", 1),
                          withDirectives(createBaseVNode("input", {
                            onInput: _cache[2] || (_cache[2] = (...args) => $options.rangeValueChange && $options.rangeValueChange(...args)),
                            type: "range",
                            "onUpdate:modelValue": ($event) => $data.rangeValue[option.id] = $event,
                            min: option.range[0],
                            max: option.range[1],
                            step: option.step
                          }, null, 40, _hoisted_7$i), [
                            [vModelText, $data.rangeValue[option.id]]
                          ])
                        ], 64)) : option.type === "font" ? withDirectives((openBlock(), createElementBlock("select", {
                          key: 2,
                          onInput: _cache[3] || (_cache[3] = ($event) => $options.fontValueChange($event)),
                          "onUpdate:modelValue": ($event) => $data.fontValue[option.id] = $event
                        }, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.fontFamilies, (font) => {
                            return openBlock(), createElementBlock("option", {
                              selected: font == option.value
                            }, toDisplayString$2(font), 9, _hoisted_9$d);
                          }), 256))
                        ], 40, _hoisted_8$e)), [
                          [vModelSelect, $data.fontValue[option.id]]
                        ]) : option.type === "boolean" ? withDirectives((openBlock(), createElementBlock("input", {
                          key: 3,
                          type: "checkbox",
                          class: "checkbox-option",
                          onChange: _cache[4] || (_cache[4] = (...args) => $options.booleanValueChange && $options.booleanValueChange(...args)),
                          "onUpdate:modelValue": ($event) => $data.booleanValue[option.id] = $event
                        }, null, 40, _hoisted_10$c)), [
                          [vModelCheckbox, $data.booleanValue[option.id]]
                        ]) : createCommentVNode("", true)
                      ])
                    ])
                  ]);
                }), 128))
              ], 544)
            ]),
            _: 1
          }, 8, ["h", "x", "onResizing", "onDragging"])
        ]),
        _: 1
      });
    }
    const PreferenceModal = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["render", _sfc_render$v], ["__scopeId", "data-v-39639dc7"]]);
    const _sfc_main$w = {
      components: {
        VueFinalModal: Ro$2,
        VueDragResize
      },
      data() {
        return {
          width: 0,
          height: 0,
          top: 100,
          left: 0,
          iDontHaveACode: false,
          initalHeight: 400,
          initalLeft: window.innerWidth / 2 - 450
        };
      },
      computed: {
        // other computed properties
        // ...
        // gives access to this.counterStore and this.userStore
        // ...mapStores(usePreferenceStore),
        // ...mapState(usePreferenceStore, ['debugModalData']),
        ...mapWritableState(usePreferenceStore, ["showLoginModal", "catInitals", "catCode"])
      },
      methods: {
        done: function() {
          if (!this.catInitals || this.catInitals.trim() == "") {
            alert("You must provide a name");
            return false;
          }
          if (!this.catCode || this.catCode.trim() == "") {
            alert("You must provide a cataloging code id");
            return false;
          }
          window.localStorage.setItem("marva-catInitals", this.catInitals);
          if (this.catCode && this.catCode.trim() != "") {
            window.localStorage.setItem("marva-catCode", this.catCode);
          }
          this.showLoginModal = false;
        },
        dragResize: function(newRect) {
          this.width = newRect.width;
          this.height = newRect.height;
          this.top = newRect.top;
          this.left = newRect.left;
          this.$refs.loginContent.style.height = newRect.height + "px";
        },
        onSelectElement(event2) {
          const tagName = event2.target.tagName;
          if (tagName === "INPUT" || tagName === "TEXTAREA" || tagName === "SELECT") {
            event2.stopPropagation();
          }
        }
      },
      mounted() {
        this.$nextTick(() => {
          console.log(this.$refs.catInitals);
          window.setTimeout(() => {
            this.$refs.catInitals.focus();
          }, 10);
        });
      }
    };
    const _withScopeId$c = (n2) => (pushScopeId("data-v-83f7db71"), n2 = n2(), popScopeId(), n2);
    const _hoisted_1$F = /* @__PURE__ */ _withScopeId$c(() => /* @__PURE__ */ createBaseVNode("h1", null, "Hello! Before you start...", -1));
    const _hoisted_2$w = /* @__PURE__ */ _withScopeId$c(() => /* @__PURE__ */ createBaseVNode("div", null, "Please enter a name to associate records with you, this is internal to Marva.", -1));
    const _hoisted_3$s = /* @__PURE__ */ _withScopeId$c(() => /* @__PURE__ */ createBaseVNode("div", null, "Please enter your unique cataloging code which will appear in distributed records .", -1));
    const _hoisted_4$r = { style: { "margin-top": "0.4em", "font-size": "0.9em" } };
    const _hoisted_5$l = {
      key: 0,
      style: { "margin-top": "0" }
    };
    function _sfc_render$u(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_VueDragResize = resolveComponent("VueDragResize");
      const _component_VueFinalModal = resolveComponent("VueFinalModal");
      return openBlock(), createBlock(_component_VueFinalModal, {
        "display-directive": "show",
        "hide-overlay": false,
        "overlay-transition": "vfm-fade",
        "click-to-close": false,
        "esc-to-close": false
      }, {
        default: withCtx(() => [
          createVNode(_component_VueDragResize, {
            "is-active": true,
            w: 900,
            h: $data.initalHeight,
            x: $data.initalLeft,
            class: "login-modal",
            onResizing: $options.dragResize,
            onDragging: $options.dragResize,
            sticks: ["br"],
            stickSize: 22
          }, {
            default: withCtx(() => [
              createBaseVNode("div", {
                id: "login-content",
                ref: "loginContent",
                onMousedown: _cache[4] || (_cache[4] = ($event) => $options.onSelectElement($event)),
                onTouchstart: _cache[5] || (_cache[5] = ($event) => $options.onSelectElement($event))
              }, [
                _hoisted_1$F,
                _hoisted_2$w,
                withDirectives(createBaseVNode("input", {
                  placeholder: "User Name",
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.catInitals = $event),
                  ref: "catInitals",
                  type: "text"
                }, null, 512), [
                  [vModelText, _ctx.catInitals]
                ]),
                _hoisted_3$s,
                withDirectives(createBaseVNode("input", {
                  placeholder: "Cataloging Code",
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.catCode = $event),
                  ref: "catCode",
                  type: "text"
                }, null, 512), [
                  [vModelText, _ctx.catCode]
                ]),
                createBaseVNode("div", _hoisted_4$r, [
                  createBaseVNode("a", {
                    href: "#",
                    onClick: _cache[2] || (_cache[2] = (event2) => {
                      $data.iDontHaveACode = true;
                      event2.preventDefault();
                    })
                  }, "I don't have a code")
                ]),
                $data.iDontHaveACode ? (openBlock(), createElementBlock("div", _hoisted_5$l, "If you don't have a Voyager ID and just want to test you can use your email username or makeup a unqiue identifier.")) : createCommentVNode("", true),
                createBaseVNode("div", null, [
                  createBaseVNode("button", {
                    onClick: _cache[3] || (_cache[3] = (...args) => $options.done && $options.done(...args))
                  }, "Done")
                ])
              ], 544)
            ]),
            _: 1
          }, 8, ["h", "x", "onResizing", "onDragging"])
        ]),
        _: 1
      });
    }
    const LoginModal = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["render", _sfc_render$u], ["__scopeId", "data-v-83f7db71"]]);
    const _sfc_main$v = {
      components: {
        VueFinalModal: Ro$2,
        VueDragResize
      },
      data() {
        return {
          width: 0,
          height: 0,
          top: 100,
          left: 0,
          initalHeight: 800,
          initalLeft: 400,
          allLanguages: {}
        };
      },
      computed: {
        // other computed properties
        // ...
        // gives access to this.counterStore and this.userStore
        // ...mapStores(usePreferenceStore),
        ...mapStores(useConfigStore),
        ...mapWritableState(usePreferenceStore, ["showScriptshifterConfigModal", "scriptShifterOptions"])
      },
      watch: {
        // showDebugModal(newVal, oldVal) {
        //   console.log(newVal,oldVal)
        //   // if (newVal === true){
        //   //   this.loadPrefGroup()
        //   // }
        // }
      },
      methods: {
        dragResize: function(newRect) {
          this.width = newRect.width;
          this.height = newRect.height;
          this.top = newRect.top;
          this.left = newRect.left;
          this.$refs.debugContent.style.height = newRect.height + "px";
        },
        onSelectElement(event2) {
          const tagName = event2.target.tagName;
          if (tagName === "INPUT" || tagName === "TEXTAREA" || tagName === "SELECT") {
            event2.stopPropagation();
          }
        },
        updateLocalStorage(event2) {
          console.log(this.allLanguages);
          let current = window.localStorage.getItem("marva-scriptShifterOptions");
          if (current) {
            current = JSON.parse(current);
          } else {
            current = {};
          }
          for (let x2 in this.allLanguages) {
            if (this.allLanguages[x2].s2r || this.allLanguages[x2].r2s) {
              current[x2] = this.allLanguages[x2];
            } else {
              if (current[x2]) {
                delete current[x2];
              }
            }
          }
          window.localStorage.setItem("marva-scriptShifterOptions", JSON.stringify(current));
          this.scriptShifterOptions = JSON.parse(JSON.stringify(current));
        }
      },
      async created() {
        this.allLanguages = {};
      },
      async mounted() {
      }
    };
    const _withScopeId$b = (n2) => (pushScopeId("data-v-5e772e14"), n2 = n2(), popScopeId(), n2);
    const _hoisted_1$E = { class: "menu-buttons" };
    const _hoisted_2$v = /* @__PURE__ */ _withScopeId$b(() => /* @__PURE__ */ createBaseVNode("p", null, [
      /* @__PURE__ */ createTextVNode("Visit "),
      /* @__PURE__ */ createBaseVNode("a", {
        href: "https://bibframe.org/scriptshifter",
        target: "_blank"
      }, "bibframe.org/scriptshifter"),
      /* @__PURE__ */ createTextVNode(" to test these languages.")
    ], -1));
    const _hoisted_3$r = /* @__PURE__ */ _withScopeId$b(() => /* @__PURE__ */ createBaseVNode("hr", { style: { "margin-top": "1em", "margin-bottom": "1em" } }, null, -1));
    const _hoisted_4$q = /* @__PURE__ */ _withScopeId$b(() => /* @__PURE__ */ createBaseVNode("thead", null, [
      /* @__PURE__ */ createBaseVNode("th", null, "Name"),
      /* @__PURE__ */ createBaseVNode("th", null, "Script to Roman"),
      /* @__PURE__ */ createBaseVNode("th", null, "Roman to Script")
    ], -1));
    const _hoisted_5$k = { style: { "width": "66%" } };
    const _hoisted_6$j = /* @__PURE__ */ _withScopeId$b(() => /* @__PURE__ */ createBaseVNode("br", null, null, -1));
    const _hoisted_7$h = { style: { "font-size": "90%" } };
    const _hoisted_8$d = { style: { "text-align": "center" } };
    const _hoisted_9$c = ["onUpdate:modelValue"];
    const _hoisted_10$b = { style: { "text-align": "center" } };
    const _hoisted_11$b = ["onUpdate:modelValue"];
    function _sfc_render$t(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_VueDragResize = resolveComponent("VueDragResize");
      const _component_VueFinalModal = resolveComponent("VueFinalModal");
      return openBlock(), createBlock(_component_VueFinalModal, {
        "display-directive": "show",
        "hide-overlay": true,
        "overlay-transition": "vfm-fade"
      }, {
        default: withCtx(() => [
          createVNode(_component_VueDragResize, {
            "is-active": true,
            w: 800,
            h: $data.initalHeight,
            x: $data.initalLeft,
            class: "debug-modal",
            onResizing: $options.dragResize,
            onDragging: $options.dragResize,
            sticks: ["br"],
            stickSize: 22
          }, {
            default: withCtx(() => [
              createBaseVNode("div", {
                id: "debug-content",
                ref: "debugContent",
                onMousedown: _cache[3] || (_cache[3] = ($event) => $options.onSelectElement($event)),
                onTouchstart: _cache[4] || (_cache[4] = ($event) => $options.onSelectElement($event))
              }, [
                createBaseVNode("div", _hoisted_1$E, [
                  createBaseVNode("button", {
                    class: "close-button",
                    onPointerup: _cache[0] || (_cache[0] = ($event) => _ctx.showScriptshifterConfigModal = false)
                  }, "X", 32)
                ]),
                _hoisted_2$v,
                _hoisted_3$r,
                createBaseVNode("table", null, [
                  _hoisted_4$q,
                  (openBlock(true), createElementBlock(Fragment, null, renderList($data.allLanguages, (l2) => {
                    return openBlock(), createElementBlock("tr", null, [
                      createBaseVNode("td", _hoisted_5$k, [
                        createTextVNode(toDisplayString$2(l2.name) + " ", 1),
                        l2.description ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                          _hoisted_6$j,
                          createBaseVNode("span", _hoisted_7$h, toDisplayString$2(l2.description), 1)
                        ], 64)) : createCommentVNode("", true)
                      ]),
                      createBaseVNode("td", _hoisted_8$d, [
                        withDirectives(createBaseVNode("input", {
                          type: "checkbox",
                          onChange: _cache[1] || (_cache[1] = (...args) => $options.updateLocalStorage && $options.updateLocalStorage(...args)),
                          "onUpdate:modelValue": ($event) => l2.s2r = $event
                        }, null, 40, _hoisted_9$c), [
                          [vModelCheckbox, l2.s2r]
                        ])
                      ]),
                      createBaseVNode("td", _hoisted_10$b, [
                        withDirectives(createBaseVNode("input", {
                          type: "checkbox",
                          onChange: _cache[2] || (_cache[2] = (...args) => $options.updateLocalStorage && $options.updateLocalStorage(...args)),
                          "onUpdate:modelValue": ($event) => l2.r2s = $event
                        }, null, 40, _hoisted_11$b), [
                          [vModelCheckbox, l2.r2s]
                        ])
                      ])
                    ]);
                  }), 256))
                ])
              ], 544)
            ]),
            _: 1
          }, 8, ["h", "x", "onResizing", "onDragging"])
        ]),
        _: 1
      });
    }
    const ScriptshifterConfigModal = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["render", _sfc_render$t], ["__scopeId", "data-v-5e772e14"]]);
    const _sfc_main$u = {
      components: {
        LoadingModal,
        PreferenceModal,
        LoginModal,
        ScriptshifterConfigModal
      },
      data() {
        return {
          count: 0
        };
      },
      computed: {
        // other computed properties
        // ...
        // gives access to this.counterStore and this.userStore
        ...mapStores(useConfigStore, useProfileStore, usePreferenceStore),
        // // gives read access to this.count and this.double
        ...mapState(useProfileStore, ["profilesLoaded", "showPostModal"]),
        ...mapState(usePreferenceStore, ["showPrefModal", "catCode"]),
        ...mapWritableState(usePreferenceStore, ["showLoginModal", "showScriptshifterConfigModal"]),
        showLocalPreferenceModal: {
          get() {
            return this.showPrefModal;
          },
          set() {
            this.preferenceStore.togglePrefModal();
          }
        }
      },
      methods: {
        increment() {
          this.count++;
        }
      },
      async mounted() {
        console.log(`The initial count is `);
        console.log(this.configStore.versionMajor);
        console.log(useConfigStore().returnUrls.ldpjs + "ldp/");
        console.log(this.profilesLoaded);
        this.preferenceStore.initalize();
        if (!this.catCode) {
          this.showLoginModal = true;
        }
        await this.profileStore.buildProfiles();
      }
    };
    function _sfc_render$s(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_RouterView = resolveComponent("RouterView");
      const _component_LoadingModal = resolveComponent("LoadingModal");
      const _component_PreferenceModal = resolveComponent("PreferenceModal");
      const _component_LoginModal = resolveComponent("LoginModal");
      const _component_ScriptshifterConfigModal = resolveComponent("ScriptshifterConfigModal");
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(_component_RouterView),
        createVNode(_component_LoadingModal),
        $options.showLocalPreferenceModal == true ? (openBlock(), createBlock(_component_PreferenceModal, {
          key: 0,
          modelValue: $options.showLocalPreferenceModal,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $options.showLocalPreferenceModal = $event)
        }, null, 8, ["modelValue"])) : createCommentVNode("", true),
        _ctx.showLoginModal == true ? (openBlock(), createBlock(_component_LoginModal, {
          key: 1,
          modelValue: _ctx.showLoginModal,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.showLoginModal = $event)
        }, null, 8, ["modelValue"])) : createCommentVNode("", true),
        _ctx.showScriptshifterConfigModal == true ? (openBlock(), createBlock(_component_ScriptshifterConfigModal, {
          key: 2,
          modelValue: _ctx.showScriptshifterConfigModal,
          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.showScriptshifterConfigModal = $event)
        }, null, 8, ["modelValue"])) : createCommentVNode("", true)
      ], 64);
    }
    const App = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["render", _sfc_render$s], ["__scopeId", "data-v-b0ed1b79"]]);
    const M$1 = {
      name: "splitpanes",
      emits: ["ready", "resize", "resized", "pane-click", "pane-maximize", "pane-add", "pane-remove", "splitter-click"],
      props: {
        horizontal: { type: Boolean },
        pushOtherPanes: { type: Boolean, default: true },
        dblClickSplitter: { type: Boolean, default: true },
        rtl: { type: Boolean, default: false },
        firstSplitter: { type: Boolean }
      },
      provide() {
        return {
          requestUpdate: this.requestUpdate,
          onPaneAdd: this.onPaneAdd,
          onPaneRemove: this.onPaneRemove,
          onPaneClick: this.onPaneClick
        };
      },
      data: () => ({
        container: null,
        ready: false,
        panes: [],
        touch: {
          mouseDown: false,
          dragging: false,
          activeSplitter: null
        },
        splitterTaps: {
          splitter: null,
          timeoutId: null
        }
      }),
      computed: {
        panesCount() {
          return this.panes.length;
        },
        indexedPanes() {
          return this.panes.reduce((e2, i2) => (e2[i2.id] = i2) && e2, {});
        }
      },
      methods: {
        updatePaneComponents() {
          this.panes.forEach((e2) => {
            e2.update && e2.update({
              [this.horizontal ? "height" : "width"]: `${this.indexedPanes[e2.id].size}%`
            });
          });
        },
        bindEvents() {
          document.addEventListener("mousemove", this.onMouseMove, { passive: false }), document.addEventListener("mouseup", this.onMouseUp), "ontouchstart" in window && (document.addEventListener("touchmove", this.onMouseMove, { passive: false }), document.addEventListener("touchend", this.onMouseUp));
        },
        unbindEvents() {
          document.removeEventListener("mousemove", this.onMouseMove, { passive: false }), document.removeEventListener("mouseup", this.onMouseUp), "ontouchstart" in window && (document.removeEventListener("touchmove", this.onMouseMove, { passive: false }), document.removeEventListener("touchend", this.onMouseUp));
        },
        onMouseDown(e2, i2) {
          this.bindEvents(), this.touch.mouseDown = true, this.touch.activeSplitter = i2;
        },
        onMouseMove(e2) {
          this.touch.mouseDown && (e2.preventDefault(), this.touch.dragging = true, this.calculatePanesSize(this.getCurrentMouseDrag(e2)), this.$emit("resize", this.panes.map((i2) => ({ min: i2.min, max: i2.max, size: i2.size }))));
        },
        onMouseUp() {
          this.touch.dragging && this.$emit("resized", this.panes.map((e2) => ({ min: e2.min, max: e2.max, size: e2.size }))), this.touch.mouseDown = false, setTimeout(() => {
            this.touch.dragging = false, this.unbindEvents();
          }, 100);
        },
        onSplitterClick(e2, i2) {
          "ontouchstart" in window && (e2.preventDefault(), this.dblClickSplitter && (this.splitterTaps.splitter === i2 ? (clearTimeout(this.splitterTaps.timeoutId), this.splitterTaps.timeoutId = null, this.onSplitterDblClick(e2, i2), this.splitterTaps.splitter = null) : (this.splitterTaps.splitter = i2, this.splitterTaps.timeoutId = setTimeout(() => {
            this.splitterTaps.splitter = null;
          }, 500)))), this.touch.dragging || this.$emit("splitter-click", this.panes[i2]);
        },
        onSplitterDblClick(e2, i2) {
          let s2 = 0;
          this.panes = this.panes.map((n2, t2) => (n2.size = t2 === i2 ? n2.max : n2.min, t2 !== i2 && (s2 += n2.min), n2)), this.panes[i2].size -= s2, this.$emit("pane-maximize", this.panes[i2]), this.$emit("resized", this.panes.map((n2) => ({ min: n2.min, max: n2.max, size: n2.size })));
        },
        onPaneClick(e2, i2) {
          this.$emit("pane-click", this.indexedPanes[i2]);
        },
        getCurrentMouseDrag(e2) {
          const i2 = this.container.getBoundingClientRect(), { clientX: s2, clientY: n2 } = "ontouchstart" in window && e2.touches ? e2.touches[0] : e2;
          return {
            x: s2 - i2.left,
            y: n2 - i2.top
          };
        },
        getCurrentDragPercentage(e2) {
          e2 = e2[this.horizontal ? "y" : "x"];
          const i2 = this.container[this.horizontal ? "clientHeight" : "clientWidth"];
          return this.rtl && !this.horizontal && (e2 = i2 - e2), e2 * 100 / i2;
        },
        calculatePanesSize(e2) {
          const i2 = this.touch.activeSplitter;
          let s2 = {
            prevPanesSize: this.sumPrevPanesSize(i2),
            nextPanesSize: this.sumNextPanesSize(i2),
            prevReachedMinPanes: 0,
            nextReachedMinPanes: 0
          };
          const n2 = 0 + (this.pushOtherPanes ? 0 : s2.prevPanesSize), t2 = 100 - (this.pushOtherPanes ? 0 : s2.nextPanesSize), a2 = Math.max(Math.min(this.getCurrentDragPercentage(e2), t2), n2);
          let r2 = [i2, i2 + 1], o3 = this.panes[r2[0]] || null, h2 = this.panes[r2[1]] || null;
          const l2 = o3.max < 100 && a2 >= o3.max + s2.prevPanesSize, u2 = h2.max < 100 && a2 <= 100 - (h2.max + this.sumNextPanesSize(i2 + 1));
          if (l2 || u2) {
            l2 ? (o3.size = o3.max, h2.size = Math.max(100 - o3.max - s2.prevPanesSize - s2.nextPanesSize, 0)) : (o3.size = Math.max(100 - h2.max - s2.prevPanesSize - this.sumNextPanesSize(i2 + 1), 0), h2.size = h2.max);
            return;
          }
          if (this.pushOtherPanes) {
            const d2 = this.doPushOtherPanes(s2, a2);
            if (!d2)
              return;
            ({ sums: s2, panesToResize: r2 } = d2), o3 = this.panes[r2[0]] || null, h2 = this.panes[r2[1]] || null;
          }
          o3 !== null && (o3.size = Math.min(Math.max(a2 - s2.prevPanesSize - s2.prevReachedMinPanes, o3.min), o3.max)), h2 !== null && (h2.size = Math.min(Math.max(100 - a2 - s2.nextPanesSize - s2.nextReachedMinPanes, h2.min), h2.max));
        },
        doPushOtherPanes(e2, i2) {
          const s2 = this.touch.activeSplitter, n2 = [s2, s2 + 1];
          return i2 < e2.prevPanesSize + this.panes[n2[0]].min && (n2[0] = this.findPrevExpandedPane(s2).index, e2.prevReachedMinPanes = 0, n2[0] < s2 && this.panes.forEach((t2, a2) => {
            a2 > n2[0] && a2 <= s2 && (t2.size = t2.min, e2.prevReachedMinPanes += t2.min);
          }), e2.prevPanesSize = this.sumPrevPanesSize(n2[0]), n2[0] === void 0) ? (e2.prevReachedMinPanes = 0, this.panes[0].size = this.panes[0].min, this.panes.forEach((t2, a2) => {
            a2 > 0 && a2 <= s2 && (t2.size = t2.min, e2.prevReachedMinPanes += t2.min);
          }), this.panes[n2[1]].size = 100 - e2.prevReachedMinPanes - this.panes[0].min - e2.prevPanesSize - e2.nextPanesSize, null) : i2 > 100 - e2.nextPanesSize - this.panes[n2[1]].min && (n2[1] = this.findNextExpandedPane(s2).index, e2.nextReachedMinPanes = 0, n2[1] > s2 + 1 && this.panes.forEach((t2, a2) => {
            a2 > s2 && a2 < n2[1] && (t2.size = t2.min, e2.nextReachedMinPanes += t2.min);
          }), e2.nextPanesSize = this.sumNextPanesSize(n2[1] - 1), n2[1] === void 0) ? (e2.nextReachedMinPanes = 0, this.panes[this.panesCount - 1].size = this.panes[this.panesCount - 1].min, this.panes.forEach((t2, a2) => {
            a2 < this.panesCount - 1 && a2 >= s2 + 1 && (t2.size = t2.min, e2.nextReachedMinPanes += t2.min);
          }), this.panes[n2[0]].size = 100 - e2.prevPanesSize - e2.nextReachedMinPanes - this.panes[this.panesCount - 1].min - e2.nextPanesSize, null) : { sums: e2, panesToResize: n2 };
        },
        sumPrevPanesSize(e2) {
          return this.panes.reduce((i2, s2, n2) => i2 + (n2 < e2 ? s2.size : 0), 0);
        },
        sumNextPanesSize(e2) {
          return this.panes.reduce((i2, s2, n2) => i2 + (n2 > e2 + 1 ? s2.size : 0), 0);
        },
        findPrevExpandedPane(e2) {
          return [...this.panes].reverse().find((s2) => s2.index < e2 && s2.size > s2.min) || {};
        },
        findNextExpandedPane(e2) {
          return this.panes.find((s2) => s2.index > e2 + 1 && s2.size > s2.min) || {};
        },
        checkSplitpanesNodes() {
          Array.from(this.container.children).forEach((i2) => {
            const s2 = i2.classList.contains("splitpanes__pane"), n2 = i2.classList.contains("splitpanes__splitter");
            !s2 && !n2 && (i2.parentNode.removeChild(i2), console.warn("Splitpanes: Only <pane> elements are allowed at the root of <splitpanes>. One of your DOM nodes was removed."));
          });
        },
        addSplitter(e2, i2, s2 = false) {
          const n2 = e2 - 1, t2 = document.createElement("div");
          t2.classList.add("splitpanes__splitter"), s2 || (t2.onmousedown = (a2) => this.onMouseDown(a2, n2), typeof window < "u" && "ontouchstart" in window && (t2.ontouchstart = (a2) => this.onMouseDown(a2, n2)), t2.onclick = (a2) => this.onSplitterClick(a2, n2 + 1)), this.dblClickSplitter && (t2.ondblclick = (a2) => this.onSplitterDblClick(a2, n2 + 1)), i2.parentNode.insertBefore(t2, i2);
        },
        removeSplitter(e2) {
          e2.onmousedown = void 0, e2.onclick = void 0, e2.ondblclick = void 0, e2.parentNode.removeChild(e2);
        },
        redoSplitters() {
          const e2 = Array.from(this.container.children);
          e2.forEach((s2) => {
            s2.className.includes("splitpanes__splitter") && this.removeSplitter(s2);
          });
          let i2 = 0;
          e2.forEach((s2) => {
            s2.className.includes("splitpanes__pane") && (!i2 && this.firstSplitter ? this.addSplitter(i2, s2, true) : i2 && this.addSplitter(i2, s2), i2++);
          });
        },
        requestUpdate({ target: e2, ...i2 }) {
          const s2 = this.indexedPanes[e2._.uid];
          Object.entries(i2).forEach(([n2, t2]) => s2[n2] = t2);
        },
        onPaneAdd(e2) {
          let i2 = -1;
          Array.from(e2.$el.parentNode.children).some((t2) => (t2.className.includes("splitpanes__pane") && i2++, t2 === e2.$el));
          const s2 = parseFloat(e2.minSize), n2 = parseFloat(e2.maxSize);
          this.panes.splice(i2, 0, {
            id: e2._.uid,
            index: i2,
            min: isNaN(s2) ? 0 : s2,
            max: isNaN(n2) ? 100 : n2,
            size: e2.size === null ? null : parseFloat(e2.size),
            givenSize: e2.size,
            update: e2.update
          }), this.panes.forEach((t2, a2) => t2.index = a2), this.ready && this.$nextTick(() => {
            this.redoSplitters(), this.resetPaneSizes({ addedPane: this.panes[i2] }), this.$emit("pane-add", { index: i2, panes: this.panes.map((t2) => ({ min: t2.min, max: t2.max, size: t2.size })) });
          });
        },
        onPaneRemove(e2) {
          const i2 = this.panes.findIndex((n2) => n2.id === e2._.uid), s2 = this.panes.splice(i2, 1)[0];
          this.panes.forEach((n2, t2) => n2.index = t2), this.$nextTick(() => {
            this.redoSplitters(), this.resetPaneSizes({ removedPane: { ...s2, index: i2 } }), this.$emit("pane-remove", { removed: s2, panes: this.panes.map((n2) => ({ min: n2.min, max: n2.max, size: n2.size })) });
          });
        },
        resetPaneSizes(e2 = {}) {
          !e2.addedPane && !e2.removedPane ? this.initialPanesSizing() : this.panes.some((i2) => i2.givenSize !== null || i2.min || i2.max < 100) ? this.equalizeAfterAddOrRemove(e2) : this.equalize(), this.ready && this.$emit("resized", this.panes.map((i2) => ({ min: i2.min, max: i2.max, size: i2.size })));
        },
        equalize() {
          const e2 = 100 / this.panesCount;
          let i2 = 0;
          const s2 = [], n2 = [];
          this.panes.forEach((t2) => {
            t2.size = Math.max(Math.min(e2, t2.max), t2.min), i2 -= t2.size, t2.size >= t2.max && s2.push(t2.id), t2.size <= t2.min && n2.push(t2.id);
          }), i2 > 0.1 && this.readjustSizes(i2, s2, n2);
        },
        initialPanesSizing() {
          let e2 = 100;
          const i2 = [], s2 = [];
          let n2 = 0;
          this.panes.forEach((a2) => {
            e2 -= a2.size, a2.size !== null && n2++, a2.size >= a2.max && i2.push(a2.id), a2.size <= a2.min && s2.push(a2.id);
          });
          let t2 = 100;
          e2 > 0.1 && (this.panes.forEach((a2) => {
            a2.size === null && (a2.size = Math.max(Math.min(e2 / (this.panesCount - n2), a2.max), a2.min)), t2 -= a2.size;
          }), t2 > 0.1 && this.readjustSizes(e2, i2, s2));
        },
        equalizeAfterAddOrRemove({ addedPane: e2, removedPane: i2 } = {}) {
          let s2 = 100 / this.panesCount, n2 = 0;
          const t2 = [], a2 = [];
          e2 && e2.givenSize !== null && (s2 = (100 - e2.givenSize) / (this.panesCount - 1)), this.panes.forEach((r2) => {
            n2 -= r2.size, r2.size >= r2.max && t2.push(r2.id), r2.size <= r2.min && a2.push(r2.id);
          }), !(Math.abs(n2) < 0.1) && (this.panes.forEach((r2) => {
            e2 && e2.givenSize !== null && e2.id === r2.id || (r2.size = Math.max(Math.min(s2, r2.max), r2.min)), n2 -= r2.size, r2.size >= r2.max && t2.push(r2.id), r2.size <= r2.min && a2.push(r2.id);
          }), n2 > 0.1 && this.readjustSizes(n2, t2, a2));
        },
        readjustSizes(e2, i2, s2) {
          let n2;
          e2 > 0 ? n2 = e2 / (this.panesCount - i2.length) : n2 = e2 / (this.panesCount - s2.length), this.panes.forEach((t2, a2) => {
            if (e2 > 0 && !i2.includes(t2.id)) {
              const r2 = Math.max(Math.min(t2.size + n2, t2.max), t2.min), o3 = r2 - t2.size;
              e2 -= o3, t2.size = r2;
            } else if (!s2.includes(t2.id)) {
              const r2 = Math.max(Math.min(t2.size + n2, t2.max), t2.min), o3 = r2 - t2.size;
              e2 -= o3, t2.size = r2;
            }
            t2.update({
              [this.horizontal ? "height" : "width"]: `${this.indexedPanes[t2.id].size}%`
            });
          }), Math.abs(e2) > 0.1 && this.$nextTick(() => {
            this.ready && console.warn("Splitpanes: Could not resize panes correctly due to their constraints.");
          });
        }
      },
      watch: {
        panes: {
          deep: true,
          immediate: false,
          handler() {
            this.updatePaneComponents();
          }
        },
        horizontal() {
          this.updatePaneComponents();
        },
        firstSplitter() {
          this.redoSplitters();
        },
        dblClickSplitter(e2) {
          [...this.container.querySelectorAll(".splitpanes__splitter")].forEach((s2, n2) => {
            s2.ondblclick = e2 ? (t2) => this.onSplitterDblClick(t2, n2) : void 0;
          });
        }
      },
      beforeUnmount() {
        this.ready = false;
      },
      mounted() {
        this.container = this.$refs.container, this.checkSplitpanesNodes(), this.redoSplitters(), this.resetPaneSizes(), this.$emit("ready"), this.ready = true;
      },
      render() {
        return h$4(
          "div",
          {
            ref: "container",
            class: [
              "splitpanes",
              `splitpanes--${this.horizontal ? "horizontal" : "vertical"}`,
              {
                "splitpanes--dragging": this.touch.dragging
              }
            ]
          },
          this.$slots.default()
        );
      }
    }, S$3 = (e2, i2) => {
      const s2 = e2.__vccOpts || e2;
      for (const [n2, t2] of i2)
        s2[n2] = t2;
      return s2;
    }, x$2 = {
      name: "pane",
      inject: ["requestUpdate", "onPaneAdd", "onPaneRemove", "onPaneClick"],
      props: {
        size: { type: [Number, String], default: null },
        minSize: { type: [Number, String], default: 0 },
        maxSize: { type: [Number, String], default: 100 }
      },
      data: () => ({
        style: {}
      }),
      mounted() {
        this.onPaneAdd(this);
      },
      beforeUnmount() {
        this.onPaneRemove(this);
      },
      methods: {
        update(e2) {
          this.style = e2;
        }
      },
      computed: {
        sizeNumber() {
          return this.size || this.size === 0 ? parseFloat(this.size) : null;
        },
        minSizeNumber() {
          return parseFloat(this.minSize);
        },
        maxSizeNumber() {
          return parseFloat(this.maxSize);
        }
      },
      watch: {
        sizeNumber(e2) {
          this.requestUpdate({ target: this, size: e2 });
        },
        minSizeNumber(e2) {
          this.requestUpdate({ target: this, min: e2 });
        },
        maxSizeNumber(e2) {
          this.requestUpdate({ target: this, max: e2 });
        }
      }
    };
    function P$1(e2, i2, s2, n2, t2, a2) {
      return openBlock(), createElementBlock("div", {
        class: "splitpanes__pane",
        onClick: i2[0] || (i2[0] = (r2) => a2.onPaneClick(r2, e2._.uid)),
        style: normalizeStyle(e2.style)
      }, [
        renderSlot(e2.$slots, "default")
      ], 4);
    }
    const g$3 = /* @__PURE__ */ S$3(x$2, [["render", P$1]]);
    const umbrella_with_rain_drops = "☔";
    const coffee = "☕";
    const aries = "♈";
    const taurus = "♉";
    const sagittarius = "♐";
    const capricorn = "♑";
    const aquarius = "♒";
    const pisces = "♓";
    const anchor = "⚓";
    const white_check_mark = "✅";
    const sparkles = "✨";
    const question = "❓";
    const grey_question = "❔";
    const grey_exclamation = "❕";
    const exclamation = "❗";
    const heavy_exclamation_mark = "❗";
    const heavy_plus_sign = "➕";
    const heavy_minus_sign = "➖";
    const heavy_division_sign = "➗";
    const hash = "#️⃣";
    const keycap_star = "*️⃣";
    const zero = "0️⃣";
    const one = "1️⃣";
    const two = "2️⃣";
    const three = "3️⃣";
    const four = "4️⃣";
    const five = "5️⃣";
    const six = "6️⃣";
    const seven = "7️⃣";
    const eight = "8️⃣";
    const nine = "9️⃣";
    const copyright = "©️";
    const registered = "®️";
    const mahjong = "🀄";
    const black_joker = "🃏";
    const a$2 = "🅰️";
    const b$3 = "🅱️";
    const o2 = "🅾️";
    const parking = "🅿️";
    const ab = "🆎";
    const cl = "🆑";
    const cool = "🆒";
    const free = "🆓";
    const id = "🆔";
    const ng = "🆖";
    const ok = "🆗";
    const sos = "🆘";
    const up = "🆙";
    const vs = "🆚";
    const cn = "🇨🇳";
    const de$1 = "🇩🇪";
    const es = "🇪🇸";
    const fr = "🇫🇷";
    const gb = "🇬🇧";
    const uk = "🇬🇧";
    const it$1 = "🇮🇹";
    const jp = "🇯🇵";
    const kr = "🇰🇷";
    const ru = "🇷🇺";
    const us = "🇺🇸";
    const koko = "🈁";
    const sa = "🈂️";
    const u7121 = "🈚";
    const u6307 = "🈯";
    const u7981 = "🈲";
    const u7a7a = "🈳";
    const u5408 = "🈴";
    const u6e80 = "🈵";
    const u6709 = "🈶";
    const u6708 = "🈷️";
    const u7533 = "🈸";
    const u5272 = "🈹";
    const u55b6 = "🈺";
    const ideograph_advantage = "🉐";
    const accept = "🉑";
    const cyclone = "🌀";
    const foggy = "🌁";
    const closed_umbrella = "🌂";
    const night_with_stars = "🌃";
    const sunrise_over_mountains = "🌄";
    const sunrise = "🌅";
    const city_sunset = "🌆";
    const city_sunrise = "🌇";
    const rainbow = "🌈";
    const bridge_at_night = "🌉";
    const ocean = "🌊";
    const volcano = "🌋";
    const milky_way = "🌌";
    const earth_africa = "🌍";
    const earth_americas = "🌎";
    const earth_asia = "🌏";
    const globe_with_meridians = "🌐";
    const new_moon = "🌑";
    const waxing_crescent_moon = "🌒";
    const first_quarter_moon = "🌓";
    const moon = "🌔";
    const waxing_gibbous_moon = "🌔";
    const full_moon = "🌕";
    const waning_gibbous_moon = "🌖";
    const last_quarter_moon = "🌗";
    const waning_crescent_moon = "🌘";
    const crescent_moon = "🌙";
    const new_moon_with_face = "🌚";
    const first_quarter_moon_with_face = "🌛";
    const last_quarter_moon_with_face = "🌜";
    const full_moon_with_face = "🌝";
    const sun_with_face = "🌞";
    const star2 = "🌟";
    const stars = "🌠";
    const thermometer = "🌡️";
    const mostly_sunny = "🌤️";
    const sun_small_cloud = "🌤️";
    const barely_sunny = "🌥️";
    const sun_behind_cloud = "🌥️";
    const partly_sunny_rain = "🌦️";
    const sun_behind_rain_cloud = "🌦️";
    const rain_cloud = "🌧️";
    const snow_cloud = "🌨️";
    const lightning = "🌩️";
    const lightning_cloud = "🌩️";
    const tornado = "🌪️";
    const tornado_cloud = "🌪️";
    const fog = "🌫️";
    const wind_blowing_face = "🌬️";
    const hotdog = "🌭";
    const taco = "🌮";
    const burrito = "🌯";
    const chestnut = "🌰";
    const seedling = "🌱";
    const evergreen_tree = "🌲";
    const deciduous_tree = "🌳";
    const palm_tree = "🌴";
    const cactus = "🌵";
    const hot_pepper = "🌶️";
    const tulip = "🌷";
    const cherry_blossom = "🌸";
    const rose = "🌹";
    const hibiscus = "🌺";
    const sunflower = "🌻";
    const blossom = "🌼";
    const corn = "🌽";
    const ear_of_rice = "🌾";
    const herb = "🌿";
    const four_leaf_clover = "🍀";
    const maple_leaf = "🍁";
    const fallen_leaf = "🍂";
    const leaves = "🍃";
    const mushroom = "🍄";
    const tomato = "🍅";
    const eggplant = "🍆";
    const grapes = "🍇";
    const melon = "🍈";
    const watermelon = "🍉";
    const tangerine = "🍊";
    const lemon = "🍋";
    const banana = "🍌";
    const pineapple = "🍍";
    const apple = "🍎";
    const green_apple = "🍏";
    const pear = "🍐";
    const peach = "🍑";
    const cherries = "🍒";
    const strawberry = "🍓";
    const hamburger = "🍔";
    const pizza = "🍕";
    const meat_on_bone = "🍖";
    const poultry_leg = "🍗";
    const rice_cracker = "🍘";
    const rice_ball = "🍙";
    const rice = "🍚";
    const curry = "🍛";
    const ramen = "🍜";
    const spaghetti = "🍝";
    const bread = "🍞";
    const fries = "🍟";
    const sweet_potato = "🍠";
    const dango = "🍡";
    const oden = "🍢";
    const sushi = "🍣";
    const fried_shrimp = "🍤";
    const fish_cake = "🍥";
    const icecream = "🍦";
    const shaved_ice = "🍧";
    const ice_cream = "🍨";
    const doughnut = "🍩";
    const cookie = "🍪";
    const chocolate_bar = "🍫";
    const candy = "🍬";
    const lollipop = "🍭";
    const custard = "🍮";
    const honey_pot = "🍯";
    const cake = "🍰";
    const bento = "🍱";
    const stew = "🍲";
    const fried_egg = "🍳";
    const cooking = "🍳";
    const fork_and_knife = "🍴";
    const tea = "🍵";
    const sake = "🍶";
    const wine_glass = "🍷";
    const cocktail = "🍸";
    const tropical_drink = "🍹";
    const beer = "🍺";
    const beers = "🍻";
    const baby_bottle = "🍼";
    const knife_fork_plate = "🍽️";
    const champagne = "🍾";
    const popcorn = "🍿";
    const ribbon = "🎀";
    const gift = "🎁";
    const birthday = "🎂";
    const jack_o_lantern = "🎃";
    const christmas_tree = "🎄";
    const santa = "🎅";
    const fireworks = "🎆";
    const sparkler = "🎇";
    const balloon = "🎈";
    const tada = "🎉";
    const confetti_ball = "🎊";
    const tanabata_tree = "🎋";
    const crossed_flags = "🎌";
    const bamboo = "🎍";
    const dolls = "🎎";
    const flags = "🎏";
    const wind_chime = "🎐";
    const rice_scene = "🎑";
    const school_satchel = "🎒";
    const mortar_board = "🎓";
    const medal = "🎖️";
    const reminder_ribbon = "🎗️";
    const studio_microphone = "🎙️";
    const level_slider = "🎚️";
    const control_knobs = "🎛️";
    const film_frames = "🎞️";
    const admission_tickets = "🎟️";
    const carousel_horse = "🎠";
    const ferris_wheel = "🎡";
    const roller_coaster = "🎢";
    const fishing_pole_and_fish = "🎣";
    const microphone = "🎤";
    const movie_camera = "🎥";
    const cinema = "🎦";
    const headphones = "🎧";
    const art = "🎨";
    const tophat = "🎩";
    const circus_tent = "🎪";
    const ticket = "🎫";
    const clapper = "🎬";
    const performing_arts = "🎭";
    const video_game = "🎮";
    const dart = "🎯";
    const slot_machine = "🎰";
    const game_die = "🎲";
    const bowling = "🎳";
    const flower_playing_cards = "🎴";
    const musical_note = "🎵";
    const notes = "🎶";
    const saxophone = "🎷";
    const guitar = "🎸";
    const musical_keyboard = "🎹";
    const trumpet = "🎺";
    const violin = "🎻";
    const musical_score = "🎼";
    const running_shirt_with_sash = "🎽";
    const tennis = "🎾";
    const ski = "🎿";
    const basketball = "🏀";
    const checkered_flag = "🏁";
    const snowboarder = "🏂";
    const runner = "🏃‍♂️";
    const running = "🏃‍♂️";
    const surfer = "🏄‍♂️";
    const sports_medal = "🏅";
    const trophy = "🏆";
    const horse_racing = "🏇";
    const football = "🏈";
    const rugby_football = "🏉";
    const swimmer = "🏊‍♂️";
    const weight_lifter = "🏋️‍♂️";
    const golfer = "🏌️‍♂️";
    const racing_motorcycle = "🏍️";
    const racing_car = "🏎️";
    const cricket_bat_and_ball = "🏏";
    const volleyball = "🏐";
    const field_hockey_stick_and_ball = "🏑";
    const ice_hockey_stick_and_puck = "🏒";
    const table_tennis_paddle_and_ball = "🏓";
    const snow_capped_mountain = "🏔️";
    const camping = "🏕️";
    const beach_with_umbrella = "🏖️";
    const building_construction = "🏗️";
    const house_buildings = "🏘️";
    const cityscape = "🏙️";
    const derelict_house_building = "🏚️";
    const classical_building = "🏛️";
    const desert = "🏜️";
    const desert_island = "🏝️";
    const national_park = "🏞️";
    const stadium = "🏟️";
    const house = "🏠";
    const house_with_garden = "🏡";
    const office = "🏢";
    const post_office = "🏣";
    const european_post_office = "🏤";
    const hospital = "🏥";
    const bank = "🏦";
    const atm = "🏧";
    const hotel = "🏨";
    const love_hotel = "🏩";
    const convenience_store = "🏪";
    const school = "🏫";
    const department_store = "🏬";
    const factory = "🏭";
    const izakaya_lantern = "🏮";
    const lantern = "🏮";
    const japanese_castle = "🏯";
    const european_castle = "🏰";
    const transgender_flag = "🏳️‍⚧️";
    const waving_white_flag = "🏳️";
    const pirate_flag = "🏴‍☠️";
    const waving_black_flag = "🏴";
    const rosette = "🏵️";
    const label = "🏷️";
    const badminton_racquet_and_shuttlecock = "🏸";
    const bow_and_arrow = "🏹";
    const amphora = "🏺";
    const rat = "🐀";
    const mouse2 = "🐁";
    const ox = "🐂";
    const water_buffalo = "🐃";
    const cow2 = "🐄";
    const tiger2 = "🐅";
    const leopard = "🐆";
    const rabbit2 = "🐇";
    const black_cat = "🐈‍⬛";
    const cat2 = "🐈";
    const dragon = "🐉";
    const crocodile = "🐊";
    const whale2 = "🐋";
    const snail = "🐌";
    const snake = "🐍";
    const racehorse = "🐎";
    const ram = "🐏";
    const goat = "🐐";
    const sheep = "🐑";
    const monkey = "🐒";
    const rooster = "🐓";
    const chicken = "🐔";
    const service_dog = "🐕‍🦺";
    const dog2 = "🐕";
    const pig2 = "🐖";
    const boar = "🐗";
    const elephant = "🐘";
    const octopus = "🐙";
    const shell = "🐚";
    const bug = "🐛";
    const ant = "🐜";
    const bee = "🐝";
    const honeybee = "🐝";
    const ladybug = "🐞";
    const lady_beetle = "🐞";
    const fish = "🐟";
    const tropical_fish = "🐠";
    const blowfish = "🐡";
    const turtle = "🐢";
    const hatching_chick = "🐣";
    const baby_chick = "🐤";
    const hatched_chick = "🐥";
    const bird = "🐦";
    const penguin = "🐧";
    const koala = "🐨";
    const poodle = "🐩";
    const dromedary_camel = "🐪";
    const camel = "🐫";
    const dolphin = "🐬";
    const flipper = "🐬";
    const mouse = "🐭";
    const cow = "🐮";
    const tiger = "🐯";
    const rabbit = "🐰";
    const cat = "🐱";
    const dragon_face = "🐲";
    const whale = "🐳";
    const horse = "🐴";
    const monkey_face = "🐵";
    const dog = "🐶";
    const pig = "🐷";
    const frog = "🐸";
    const hamster = "🐹";
    const wolf = "🐺";
    const polar_bear = "🐻‍❄️";
    const bear = "🐻";
    const panda_face = "🐼";
    const pig_nose = "🐽";
    const feet = "🐾";
    const paw_prints = "🐾";
    const chipmunk = "🐿️";
    const eyes = "👀";
    const eye = "👁️";
    const ear = "👂";
    const nose = "👃";
    const lips = "👄";
    const tongue = "👅";
    const point_up_2 = "👆";
    const point_down = "👇";
    const point_left = "👈";
    const point_right = "👉";
    const facepunch = "👊";
    const punch = "👊";
    const wave = "👋";
    const ok_hand = "👌";
    const thumbsup = "👍";
    const thumbsdown = "👎";
    const clap = "👏";
    const open_hands = "👐";
    const crown = "👑";
    const womans_hat = "👒";
    const eyeglasses = "👓";
    const necktie = "👔";
    const shirt = "👕";
    const tshirt = "👕";
    const jeans = "👖";
    const dress = "👗";
    const kimono = "👘";
    const bikini = "👙";
    const womans_clothes = "👚";
    const purse = "👛";
    const handbag = "👜";
    const pouch = "👝";
    const mans_shoe = "👞";
    const shoe = "👞";
    const athletic_shoe = "👟";
    const high_heel = "👠";
    const sandal = "👡";
    const boot = "👢";
    const footprints = "👣";
    const bust_in_silhouette = "👤";
    const busts_in_silhouette = "👥";
    const boy = "👦";
    const girl = "👧";
    const man_feeding_baby = "👨‍🍼";
    const family = "👨‍👩‍👦";
    const man_with_probing_cane = "👨‍🦯";
    const red_haired_man = "👨‍🦰";
    const curly_haired_man = "👨‍🦱";
    const bald_man = "👨‍🦲";
    const white_haired_man = "👨‍🦳";
    const man_in_motorized_wheelchair = "👨‍🦼";
    const man_in_manual_wheelchair = "👨‍🦽";
    const man = "👨";
    const woman_feeding_baby = "👩‍🍼";
    const woman_with_probing_cane = "👩‍🦯";
    const red_haired_woman = "👩‍🦰";
    const curly_haired_woman = "👩‍🦱";
    const bald_woman = "👩‍🦲";
    const white_haired_woman = "👩‍🦳";
    const woman_in_motorized_wheelchair = "👩‍🦼";
    const woman_in_manual_wheelchair = "👩‍🦽";
    const woman = "👩";
    const man_and_woman_holding_hands = "👫";
    const woman_and_man_holding_hands = "👫";
    const couple = "👫";
    const two_men_holding_hands = "👬";
    const men_holding_hands = "👬";
    const two_women_holding_hands = "👭";
    const women_holding_hands = "👭";
    const cop = "👮‍♂️";
    const dancers = "👯‍♀️";
    const woman_with_veil = "👰‍♀️";
    const man_with_veil = "👰‍♂️";
    const bride_with_veil = "👰";
    const person_with_blond_hair = "👱‍♂️";
    const man_with_gua_pi_mao = "👲";
    const man_with_turban = "👳‍♂️";
    const older_man = "👴";
    const older_woman = "👵";
    const baby = "👶";
    const construction_worker = "👷‍♂️";
    const princess = "👸";
    const japanese_ogre = "👹";
    const japanese_goblin = "👺";
    const ghost = "👻";
    const angel = "👼";
    const alien = "👽";
    const space_invader = "👾";
    const imp = "👿";
    const skull = "💀";
    const information_desk_person = "💁‍♀️";
    const guardsman = "💂‍♂️";
    const dancer = "💃";
    const lipstick = "💄";
    const nail_care = "💅";
    const massage = "💆‍♀️";
    const haircut = "💇‍♀️";
    const barber = "💈";
    const syringe = "💉";
    const pill = "💊";
    const kiss = "💋";
    const love_letter = "💌";
    const ring = "💍";
    const gem = "💎";
    const couplekiss = "💏";
    const bouquet = "💐";
    const couple_with_heart = "💑";
    const wedding = "💒";
    const heartbeat = "💓";
    const broken_heart = "💔";
    const two_hearts = "💕";
    const sparkling_heart = "💖";
    const heartpulse = "💗";
    const cupid = "💘";
    const blue_heart = "💙";
    const green_heart = "💚";
    const yellow_heart = "💛";
    const purple_heart = "💜";
    const gift_heart = "💝";
    const revolving_hearts = "💞";
    const heart_decoration = "💟";
    const diamond_shape_with_a_dot_inside = "💠";
    const bulb = "💡";
    const anger = "💢";
    const bomb = "💣";
    const zzz = "💤";
    const boom = "💥";
    const collision = "💥";
    const sweat_drops = "💦";
    const droplet = "💧";
    const dash = "💨";
    const hankey = "💩";
    const poop = "💩";
    const shit = "💩";
    const muscle = "💪";
    const dizzy = "💫";
    const speech_balloon = "💬";
    const thought_balloon = "💭";
    const white_flower = "💮";
    const moneybag = "💰";
    const currency_exchange = "💱";
    const heavy_dollar_sign = "💲";
    const credit_card = "💳";
    const yen = "💴";
    const dollar = "💵";
    const euro = "💶";
    const pound = "💷";
    const money_with_wings = "💸";
    const chart = "💹";
    const seat = "💺";
    const computer = "💻";
    const briefcase = "💼";
    const minidisc = "💽";
    const floppy_disk = "💾";
    const cd = "💿";
    const dvd = "📀";
    const file_folder = "📁";
    const open_file_folder = "📂";
    const page_with_curl = "📃";
    const page_facing_up = "📄";
    const date = "📅";
    const calendar = "📆";
    const card_index = "📇";
    const chart_with_upwards_trend = "📈";
    const chart_with_downwards_trend = "📉";
    const bar_chart = "📊";
    const clipboard = "📋";
    const pushpin = "📌";
    const round_pushpin = "📍";
    const paperclip = "📎";
    const straight_ruler = "📏";
    const triangular_ruler = "📐";
    const bookmark_tabs = "📑";
    const ledger = "📒";
    const notebook = "📓";
    const notebook_with_decorative_cover = "📔";
    const closed_book = "📕";
    const book = "📖";
    const open_book = "📖";
    const green_book = "📗";
    const blue_book = "📘";
    const orange_book = "📙";
    const books = "📚";
    const name_badge = "📛";
    const scroll = "📜";
    const memo = "📝";
    const pencil = "📝";
    const telephone_receiver = "📞";
    const pager = "📟";
    const fax = "📠";
    const satellite_antenna = "📡";
    const loudspeaker = "📢";
    const mega = "📣";
    const outbox_tray = "📤";
    const inbox_tray = "📥";
    const incoming_envelope = "📨";
    const envelope_with_arrow = "📩";
    const mailbox_closed = "📪";
    const mailbox = "📫";
    const mailbox_with_mail = "📬";
    const mailbox_with_no_mail = "📭";
    const postbox = "📮";
    const postal_horn = "📯";
    const newspaper = "📰";
    const iphone = "📱";
    const calling = "📲";
    const vibration_mode = "📳";
    const mobile_phone_off = "📴";
    const no_mobile_phones = "📵";
    const signal_strength = "📶";
    const camera = "📷";
    const camera_with_flash = "📸";
    const video_camera = "📹";
    const tv = "📺";
    const radio = "📻";
    const vhs = "📼";
    const film_projector = "📽️";
    const prayer_beads = "📿";
    const twisted_rightwards_arrows = "🔀";
    const repeat = "🔁";
    const repeat_one = "🔂";
    const arrows_clockwise = "🔃";
    const arrows_counterclockwise = "🔄";
    const low_brightness = "🔅";
    const high_brightness = "🔆";
    const mute = "🔇";
    const speaker = "🔈";
    const sound = "🔉";
    const loud_sound = "🔊";
    const battery = "🔋";
    const electric_plug = "🔌";
    const mag = "🔍";
    const mag_right = "🔎";
    const lock_with_ink_pen = "🔏";
    const closed_lock_with_key = "🔐";
    const key = "🔑";
    const lock = "🔒";
    const unlock = "🔓";
    const bell = "🔔";
    const no_bell = "🔕";
    const bookmark = "🔖";
    const link = "🔗";
    const radio_button = "🔘";
    const back = "🔙";
    const end = "🔚";
    const on$1 = "🔛";
    const soon = "🔜";
    const top = "🔝";
    const underage = "🔞";
    const keycap_ten = "🔟";
    const capital_abcd = "🔠";
    const abcd = "🔡";
    const symbols = "🔣";
    const abc = "🔤";
    const fire = "🔥";
    const flashlight = "🔦";
    const wrench = "🔧";
    const hammer = "🔨";
    const nut_and_bolt = "🔩";
    const hocho = "🔪";
    const knife = "🔪";
    const gun = "🔫";
    const microscope = "🔬";
    const telescope = "🔭";
    const crystal_ball = "🔮";
    const six_pointed_star = "🔯";
    const beginner = "🔰";
    const trident = "🔱";
    const black_square_button = "🔲";
    const white_square_button = "🔳";
    const red_circle = "🔴";
    const large_blue_circle = "🔵";
    const large_orange_diamond = "🔶";
    const large_blue_diamond = "🔷";
    const small_orange_diamond = "🔸";
    const small_blue_diamond = "🔹";
    const small_red_triangle = "🔺";
    const small_red_triangle_down = "🔻";
    const arrow_up_small = "🔼";
    const arrow_down_small = "🔽";
    const om_symbol = "🕉️";
    const dove_of_peace = "🕊️";
    const kaaba = "🕋";
    const mosque = "🕌";
    const synagogue = "🕍";
    const menorah_with_nine_branches = "🕎";
    const clock1 = "🕐";
    const clock2 = "🕑";
    const clock3 = "🕒";
    const clock4 = "🕓";
    const clock5 = "🕔";
    const clock6 = "🕕";
    const clock7 = "🕖";
    const clock8 = "🕗";
    const clock9 = "🕘";
    const clock10 = "🕙";
    const clock11 = "🕚";
    const clock12 = "🕛";
    const clock130 = "🕜";
    const clock230 = "🕝";
    const clock330 = "🕞";
    const clock430 = "🕟";
    const clock530 = "🕠";
    const clock630 = "🕡";
    const clock730 = "🕢";
    const clock830 = "🕣";
    const clock930 = "🕤";
    const clock1030 = "🕥";
    const clock1130 = "🕦";
    const clock1230 = "🕧";
    const candle = "🕯️";
    const mantelpiece_clock = "🕰️";
    const hole = "🕳️";
    const man_in_business_suit_levitating = "🕴️";
    const sleuth_or_spy = "🕵️‍♂️";
    const dark_sunglasses = "🕶️";
    const spider = "🕷️";
    const spider_web = "🕸️";
    const joystick = "🕹️";
    const man_dancing = "🕺";
    const linked_paperclips = "🖇️";
    const lower_left_ballpoint_pen = "🖊️";
    const lower_left_fountain_pen = "🖋️";
    const lower_left_paintbrush = "🖌️";
    const lower_left_crayon = "🖍️";
    const raised_hand_with_fingers_splayed = "🖐️";
    const middle_finger = "🖕";
    const reversed_hand_with_middle_finger_extended = "🖕";
    const black_heart = "🖤";
    const desktop_computer = "🖥️";
    const printer = "🖨️";
    const three_button_mouse = "🖱️";
    const trackball = "🖲️";
    const frame_with_picture = "🖼️";
    const card_index_dividers = "🗂️";
    const card_file_box = "🗃️";
    const file_cabinet = "🗄️";
    const wastebasket = "🗑️";
    const spiral_note_pad = "🗒️";
    const spiral_calendar_pad = "🗓️";
    const compression = "🗜️";
    const old_key = "🗝️";
    const rolled_up_newspaper = "🗞️";
    const dagger_knife = "🗡️";
    const speaking_head_in_silhouette = "🗣️";
    const left_speech_bubble = "🗨️";
    const right_anger_bubble = "🗯️";
    const ballot_box_with_ballot = "🗳️";
    const world_map = "🗺️";
    const mount_fuji = "🗻";
    const tokyo_tower = "🗼";
    const statue_of_liberty = "🗽";
    const japan = "🗾";
    const moyai = "🗿";
    const grinning = "😀";
    const grin = "😁";
    const joy = "😂";
    const smiley = "😃";
    const smile = "😄";
    const sweat_smile = "😅";
    const laughing = "😆";
    const satisfied = "😆";
    const innocent = "😇";
    const smiling_imp = "😈";
    const wink = "😉";
    const blush = "😊";
    const yum = "😋";
    const relieved = "😌";
    const heart_eyes = "😍";
    const sunglasses = "😎";
    const smirk = "😏";
    const neutral_face = "😐";
    const expressionless = "😑";
    const unamused = "😒";
    const sweat = "😓";
    const pensive = "😔";
    const confused = "😕";
    const confounded = "😖";
    const kissing = "😗";
    const kissing_heart = "😘";
    const kissing_smiling_eyes = "😙";
    const kissing_closed_eyes = "😚";
    const stuck_out_tongue = "😛";
    const stuck_out_tongue_winking_eye = "😜";
    const stuck_out_tongue_closed_eyes = "😝";
    const disappointed = "😞";
    const worried = "😟";
    const angry = "😠";
    const rage = "😡";
    const cry = "😢";
    const persevere = "😣";
    const triumph = "😤";
    const disappointed_relieved = "😥";
    const frowning = "😦";
    const anguished = "😧";
    const fearful = "😨";
    const weary = "😩";
    const sleepy = "😪";
    const tired_face = "😫";
    const grimacing = "😬";
    const sob = "😭";
    const face_exhaling = "😮‍💨";
    const open_mouth = "😮";
    const hushed = "😯";
    const cold_sweat = "😰";
    const scream = "😱";
    const astonished = "😲";
    const flushed = "😳";
    const sleeping = "😴";
    const face_with_spiral_eyes = "😵‍💫";
    const dizzy_face = "😵";
    const face_in_clouds = "😶‍🌫️";
    const no_mouth = "😶";
    const mask = "😷";
    const smile_cat = "😸";
    const joy_cat = "😹";
    const smiley_cat = "😺";
    const heart_eyes_cat = "😻";
    const smirk_cat = "😼";
    const kissing_cat = "😽";
    const pouting_cat = "😾";
    const crying_cat_face = "😿";
    const scream_cat = "🙀";
    const slightly_frowning_face = "🙁";
    const slightly_smiling_face = "🙂";
    const upside_down_face = "🙃";
    const face_with_rolling_eyes = "🙄";
    const no_good = "🙅‍♀️";
    const ok_woman = "🙆‍♀️";
    const bow = "🙇‍♂️";
    const see_no_evil = "🙈";
    const hear_no_evil = "🙉";
    const speak_no_evil = "🙊";
    const raising_hand = "🙋‍♀️";
    const raised_hands = "🙌";
    const person_frowning = "🙍‍♀️";
    const person_with_pouting_face = "🙎‍♀️";
    const pray = "🙏";
    const rocket = "🚀";
    const helicopter = "🚁";
    const steam_locomotive = "🚂";
    const railway_car = "🚃";
    const bullettrain_side = "🚄";
    const bullettrain_front = "🚅";
    const train2 = "🚆";
    const metro = "🚇";
    const light_rail = "🚈";
    const station = "🚉";
    const tram = "🚊";
    const train = "🚋";
    const bus = "🚌";
    const oncoming_bus = "🚍";
    const trolleybus = "🚎";
    const busstop = "🚏";
    const minibus = "🚐";
    const ambulance = "🚑";
    const fire_engine = "🚒";
    const police_car = "🚓";
    const oncoming_police_car = "🚔";
    const taxi = "🚕";
    const oncoming_taxi = "🚖";
    const car = "🚗";
    const red_car = "🚗";
    const oncoming_automobile = "🚘";
    const blue_car = "🚙";
    const truck = "🚚";
    const articulated_lorry = "🚛";
    const tractor = "🚜";
    const monorail = "🚝";
    const mountain_railway = "🚞";
    const suspension_railway = "🚟";
    const mountain_cableway = "🚠";
    const aerial_tramway = "🚡";
    const ship = "🚢";
    const rowboat = "🚣‍♂️";
    const speedboat = "🚤";
    const traffic_light = "🚥";
    const vertical_traffic_light = "🚦";
    const construction = "🚧";
    const rotating_light = "🚨";
    const triangular_flag_on_post = "🚩";
    const door = "🚪";
    const no_entry_sign = "🚫";
    const smoking = "🚬";
    const no_smoking = "🚭";
    const put_litter_in_its_place = "🚮";
    const do_not_litter = "🚯";
    const potable_water = "🚰";
    const bike = "🚲";
    const no_bicycles = "🚳";
    const bicyclist = "🚴‍♂️";
    const mountain_bicyclist = "🚵‍♂️";
    const walking = "🚶‍♂️";
    const no_pedestrians = "🚷";
    const children_crossing = "🚸";
    const mens = "🚹";
    const womens = "🚺";
    const restroom = "🚻";
    const baby_symbol = "🚼";
    const toilet = "🚽";
    const wc = "🚾";
    const shower = "🚿";
    const bath = "🛀";
    const bathtub = "🛁";
    const passport_control = "🛂";
    const customs = "🛃";
    const baggage_claim = "🛄";
    const left_luggage = "🛅";
    const couch_and_lamp = "🛋️";
    const sleeping_accommodation = "🛌";
    const shopping_bags = "🛍️";
    const bellhop_bell = "🛎️";
    const bed = "🛏️";
    const place_of_worship = "🛐";
    const octagonal_sign = "🛑";
    const shopping_trolley = "🛒";
    const hindu_temple = "🛕";
    const hut = "🛖";
    const elevator = "🛗";
    const hammer_and_wrench = "🛠️";
    const shield = "🛡️";
    const oil_drum = "🛢️";
    const motorway = "🛣️";
    const railway_track = "🛤️";
    const motor_boat = "🛥️";
    const small_airplane = "🛩️";
    const airplane_departure = "🛫";
    const airplane_arriving = "🛬";
    const satellite = "🛰️";
    const passenger_ship = "🛳️";
    const scooter = "🛴";
    const motor_scooter = "🛵";
    const canoe = "🛶";
    const sled = "🛷";
    const flying_saucer = "🛸";
    const skateboard = "🛹";
    const auto_rickshaw = "🛺";
    const pickup_truck = "🛻";
    const roller_skate = "🛼";
    const large_orange_circle = "🟠";
    const large_yellow_circle = "🟡";
    const large_green_circle = "🟢";
    const large_purple_circle = "🟣";
    const large_brown_circle = "🟤";
    const large_red_square = "🟥";
    const large_blue_square = "🟦";
    const large_orange_square = "🟧";
    const large_yellow_square = "🟨";
    const large_green_square = "🟩";
    const large_purple_square = "🟪";
    const large_brown_square = "🟫";
    const pinched_fingers = "🤌";
    const white_heart = "🤍";
    const brown_heart = "🤎";
    const pinching_hand = "🤏";
    const zipper_mouth_face = "🤐";
    const money_mouth_face = "🤑";
    const face_with_thermometer = "🤒";
    const nerd_face = "🤓";
    const thinking_face = "🤔";
    const face_with_head_bandage = "🤕";
    const robot_face = "🤖";
    const hugging_face = "🤗";
    const the_horns = "🤘";
    const sign_of_the_horns = "🤘";
    const call_me_hand = "🤙";
    const raised_back_of_hand = "🤚";
    const handshake = "🤝";
    const crossed_fingers = "🤞";
    const hand_with_index_and_middle_fingers_crossed = "🤞";
    const i_love_you_hand_sign = "🤟";
    const face_with_cowboy_hat = "🤠";
    const clown_face = "🤡";
    const nauseated_face = "🤢";
    const rolling_on_the_floor_laughing = "🤣";
    const drooling_face = "🤤";
    const lying_face = "🤥";
    const face_palm = "🤦";
    const sneezing_face = "🤧";
    const face_with_raised_eyebrow = "🤨";
    const face_with_one_eyebrow_raised = "🤨";
    const grinning_face_with_star_eyes = "🤩";
    const zany_face = "🤪";
    const grinning_face_with_one_large_and_one_small_eye = "🤪";
    const shushing_face = "🤫";
    const face_with_finger_covering_closed_lips = "🤫";
    const face_with_symbols_on_mouth = "🤬";
    const serious_face_with_symbols_covering_mouth = "🤬";
    const face_with_hand_over_mouth = "🤭";
    const smiling_face_with_smiling_eyes_and_hand_covering_mouth = "🤭";
    const face_vomiting = "🤮";
    const face_with_open_mouth_vomiting = "🤮";
    const exploding_head = "🤯";
    const shocked_face_with_exploding_head = "🤯";
    const pregnant_woman = "🤰";
    const palms_up_together = "🤲";
    const selfie = "🤳";
    const prince = "🤴";
    const woman_in_tuxedo = "🤵‍♀️";
    const man_in_tuxedo = "🤵‍♂️";
    const person_in_tuxedo = "🤵";
    const mrs_claus = "🤶";
    const mother_christmas = "🤶";
    const shrug = "🤷";
    const person_doing_cartwheel = "🤸";
    const juggling = "🤹";
    const fencer = "🤺";
    const wrestlers = "🤼";
    const water_polo = "🤽";
    const handball = "🤾";
    const diving_mask = "🤿";
    const wilted_flower = "🥀";
    const drum_with_drumsticks = "🥁";
    const clinking_glasses = "🥂";
    const tumbler_glass = "🥃";
    const spoon = "🥄";
    const goal_net = "🥅";
    const first_place_medal = "🥇";
    const second_place_medal = "🥈";
    const third_place_medal = "🥉";
    const boxing_glove = "🥊";
    const martial_arts_uniform = "🥋";
    const curling_stone = "🥌";
    const lacrosse = "🥍";
    const softball = "🥎";
    const flying_disc = "🥏";
    const croissant = "🥐";
    const avocado = "🥑";
    const cucumber = "🥒";
    const bacon = "🥓";
    const potato = "🥔";
    const carrot = "🥕";
    const baguette_bread = "🥖";
    const green_salad = "🥗";
    const shallow_pan_of_food = "🥘";
    const stuffed_flatbread = "🥙";
    const egg = "🥚";
    const glass_of_milk = "🥛";
    const peanuts = "🥜";
    const kiwifruit = "🥝";
    const pancakes = "🥞";
    const dumpling = "🥟";
    const fortune_cookie = "🥠";
    const takeout_box = "🥡";
    const chopsticks = "🥢";
    const bowl_with_spoon = "🥣";
    const cup_with_straw = "🥤";
    const coconut = "🥥";
    const broccoli = "🥦";
    const pie = "🥧";
    const pretzel = "🥨";
    const cut_of_meat = "🥩";
    const sandwich = "🥪";
    const canned_food = "🥫";
    const leafy_green = "🥬";
    const mango = "🥭";
    const moon_cake = "🥮";
    const bagel = "🥯";
    const smiling_face_with_3_hearts = "🥰";
    const yawning_face = "🥱";
    const smiling_face_with_tear = "🥲";
    const partying_face = "🥳";
    const woozy_face = "🥴";
    const hot_face = "🥵";
    const cold_face = "🥶";
    const ninja = "🥷";
    const disguised_face = "🥸";
    const pleading_face = "🥺";
    const sari = "🥻";
    const lab_coat = "🥼";
    const goggles = "🥽";
    const hiking_boot = "🥾";
    const womans_flat_shoe = "🥿";
    const crab = "🦀";
    const lion_face = "🦁";
    const scorpion = "🦂";
    const turkey = "🦃";
    const unicorn_face = "🦄";
    const eagle = "🦅";
    const duck = "🦆";
    const bat = "🦇";
    const shark = "🦈";
    const owl = "🦉";
    const fox_face = "🦊";
    const butterfly = "🦋";
    const deer = "🦌";
    const gorilla = "🦍";
    const lizard = "🦎";
    const rhinoceros = "🦏";
    const shrimp = "🦐";
    const squid = "🦑";
    const giraffe_face = "🦒";
    const zebra_face = "🦓";
    const hedgehog = "🦔";
    const sauropod = "🦕";
    const cricket = "🦗";
    const kangaroo = "🦘";
    const llama = "🦙";
    const peacock = "🦚";
    const hippopotamus = "🦛";
    const parrot = "🦜";
    const raccoon = "🦝";
    const lobster = "🦞";
    const mosquito = "🦟";
    const microbe = "🦠";
    const badger = "🦡";
    const swan = "🦢";
    const mammoth = "🦣";
    const dodo = "🦤";
    const sloth = "🦥";
    const otter = "🦦";
    const orangutan = "🦧";
    const skunk = "🦨";
    const flamingo = "🦩";
    const oyster = "🦪";
    const beaver = "🦫";
    const bison = "🦬";
    const seal = "🦭";
    const guide_dog = "🦮";
    const probing_cane = "🦯";
    const bone = "🦴";
    const leg = "🦵";
    const foot = "🦶";
    const tooth = "🦷";
    const female_superhero = "🦸‍♀️";
    const male_superhero = "🦸‍♂️";
    const superhero = "🦸";
    const female_supervillain = "🦹‍♀️";
    const male_supervillain = "🦹‍♂️";
    const supervillain = "🦹";
    const safety_vest = "🦺";
    const ear_with_hearing_aid = "🦻";
    const motorized_wheelchair = "🦼";
    const manual_wheelchair = "🦽";
    const mechanical_arm = "🦾";
    const mechanical_leg = "🦿";
    const cheese_wedge = "🧀";
    const cupcake = "🧁";
    const salt = "🧂";
    const beverage_box = "🧃";
    const garlic = "🧄";
    const onion = "🧅";
    const falafel = "🧆";
    const waffle = "🧇";
    const butter = "🧈";
    const mate_drink = "🧉";
    const ice_cube = "🧊";
    const bubble_tea = "🧋";
    const woman_standing = "🧍‍♀️";
    const man_standing = "🧍‍♂️";
    const standing_person = "🧍";
    const woman_kneeling = "🧎‍♀️";
    const man_kneeling = "🧎‍♂️";
    const kneeling_person = "🧎";
    const deaf_woman = "🧏‍♀️";
    const deaf_man = "🧏‍♂️";
    const deaf_person = "🧏";
    const face_with_monocle = "🧐";
    const farmer = "🧑‍🌾";
    const cook = "🧑‍🍳";
    const person_feeding_baby = "🧑‍🍼";
    const mx_claus = "🧑‍🎄";
    const student = "🧑‍🎓";
    const singer = "🧑‍🎤";
    const artist = "🧑‍🎨";
    const teacher = "🧑‍🏫";
    const factory_worker = "🧑‍🏭";
    const technologist = "🧑‍💻";
    const office_worker = "🧑‍💼";
    const mechanic = "🧑‍🔧";
    const scientist = "🧑‍🔬";
    const astronaut = "🧑‍🚀";
    const firefighter = "🧑‍🚒";
    const people_holding_hands = "🧑‍🤝‍🧑";
    const person_with_probing_cane = "🧑‍🦯";
    const red_haired_person = "🧑‍🦰";
    const curly_haired_person = "🧑‍🦱";
    const bald_person = "🧑‍🦲";
    const white_haired_person = "🧑‍🦳";
    const person_in_motorized_wheelchair = "🧑‍🦼";
    const person_in_manual_wheelchair = "🧑‍🦽";
    const health_worker = "🧑‍⚕️";
    const judge = "🧑‍⚖️";
    const pilot = "🧑‍✈️";
    const adult = "🧑";
    const child = "🧒";
    const older_adult = "🧓";
    const woman_with_beard = "🧔‍♀️";
    const man_with_beard = "🧔‍♂️";
    const bearded_person = "🧔";
    const person_with_headscarf = "🧕";
    const woman_in_steamy_room = "🧖‍♀️";
    const man_in_steamy_room = "🧖‍♂️";
    const person_in_steamy_room = "🧖‍♂️";
    const woman_climbing = "🧗‍♀️";
    const person_climbing = "🧗‍♀️";
    const man_climbing = "🧗‍♂️";
    const woman_in_lotus_position = "🧘‍♀️";
    const person_in_lotus_position = "🧘‍♀️";
    const man_in_lotus_position = "🧘‍♂️";
    const female_mage = "🧙‍♀️";
    const mage = "🧙‍♀️";
    const male_mage = "🧙‍♂️";
    const female_fairy = "🧚‍♀️";
    const fairy = "🧚‍♀️";
    const male_fairy = "🧚‍♂️";
    const female_vampire = "🧛‍♀️";
    const vampire = "🧛‍♀️";
    const male_vampire = "🧛‍♂️";
    const mermaid = "🧜‍♀️";
    const merman = "🧜‍♂️";
    const merperson = "🧜‍♂️";
    const female_elf = "🧝‍♀️";
    const male_elf = "🧝‍♂️";
    const elf = "🧝‍♂️";
    const female_genie = "🧞‍♀️";
    const male_genie = "🧞‍♂️";
    const genie = "🧞‍♂️";
    const female_zombie = "🧟‍♀️";
    const male_zombie = "🧟‍♂️";
    const zombie = "🧟‍♂️";
    const brain = "🧠";
    const orange_heart = "🧡";
    const billed_cap = "🧢";
    const scarf = "🧣";
    const gloves = "🧤";
    const coat = "🧥";
    const socks = "🧦";
    const red_envelope = "🧧";
    const firecracker = "🧨";
    const jigsaw = "🧩";
    const test_tube = "🧪";
    const petri_dish = "🧫";
    const dna = "🧬";
    const compass = "🧭";
    const abacus = "🧮";
    const fire_extinguisher = "🧯";
    const toolbox = "🧰";
    const bricks = "🧱";
    const magnet = "🧲";
    const luggage = "🧳";
    const lotion_bottle = "🧴";
    const thread = "🧵";
    const yarn = "🧶";
    const safety_pin = "🧷";
    const teddy_bear = "🧸";
    const broom = "🧹";
    const basket = "🧺";
    const roll_of_paper = "🧻";
    const soap = "🧼";
    const sponge = "🧽";
    const receipt = "🧾";
    const nazar_amulet = "🧿";
    const ballet_shoes = "🩰";
    const briefs = "🩲";
    const shorts = "🩳";
    const thong_sandal = "🩴";
    const drop_of_blood = "🩸";
    const adhesive_bandage = "🩹";
    const stethoscope = "🩺";
    const kite = "🪁";
    const parachute = "🪂";
    const boomerang = "🪃";
    const magic_wand = "🪄";
    const pinata = "🪅";
    const nesting_dolls = "🪆";
    const ringed_planet = "🪐";
    const chair = "🪑";
    const razor = "🪒";
    const axe = "🪓";
    const diya_lamp = "🪔";
    const banjo = "🪕";
    const military_helmet = "🪖";
    const accordion = "🪗";
    const long_drum = "🪘";
    const coin = "🪙";
    const carpentry_saw = "🪚";
    const screwdriver = "🪛";
    const ladder = "🪜";
    const hook = "🪝";
    const mirror = "🪞";
    const window$1 = "🪟";
    const plunger = "🪠";
    const sewing_needle = "🪡";
    const knot = "🪢";
    const bucket = "🪣";
    const mouse_trap = "🪤";
    const toothbrush = "🪥";
    const headstone = "🪦";
    const placard = "🪧";
    const rock = "🪨";
    const fly = "🪰";
    const worm = "🪱";
    const beetle = "🪲";
    const cockroach = "🪳";
    const potted_plant = "🪴";
    const wood = "🪵";
    const feather = "🪶";
    const anatomical_heart = "🫀";
    const lungs = "🫁";
    const people_hugging = "🫂";
    const blueberries = "🫐";
    const bell_pepper = "🫑";
    const olive = "🫒";
    const flatbread = "🫓";
    const tamale = "🫔";
    const fondue = "🫕";
    const teapot = "🫖";
    const bangbang = "‼️";
    const interrobang = "⁉️";
    const tm = "™️";
    const information_source = "ℹ️";
    const left_right_arrow = "↔️";
    const arrow_up_down = "↕️";
    const arrow_upper_left = "↖️";
    const arrow_upper_right = "↗️";
    const arrow_lower_right = "↘️";
    const arrow_lower_left = "↙️";
    const leftwards_arrow_with_hook = "↩️";
    const arrow_right_hook = "↪️";
    const watch = "⌚";
    const hourglass = "⌛";
    const keyboard = "⌨️";
    const eject = "⏏️";
    const fast_forward = "⏩";
    const rewind = "⏪";
    const arrow_double_up = "⏫";
    const arrow_double_down = "⏬";
    const black_right_pointing_double_triangle_with_vertical_bar = "⏭️";
    const black_left_pointing_double_triangle_with_vertical_bar = "⏮️";
    const black_right_pointing_triangle_with_double_vertical_bar = "⏯️";
    const alarm_clock = "⏰";
    const stopwatch = "⏱️";
    const timer_clock = "⏲️";
    const hourglass_flowing_sand = "⏳";
    const double_vertical_bar = "⏸️";
    const black_square_for_stop = "⏹️";
    const black_circle_for_record = "⏺️";
    const m$3 = "Ⓜ️";
    const black_small_square = "▪️";
    const white_small_square = "▫️";
    const arrow_forward = "▶️";
    const arrow_backward = "◀️";
    const white_medium_square = "◻️";
    const black_medium_square = "◼️";
    const white_medium_small_square = "◽";
    const black_medium_small_square = "◾";
    const sunny = "☀️";
    const cloud = "☁️";
    const umbrella = "☂️";
    const snowman = "☃️";
    const comet = "☄️";
    const phone = "☎️";
    const telephone = "☎️";
    const ballot_box_with_check = "☑️";
    const shamrock = "☘️";
    const point_up = "☝️";
    const skull_and_crossbones = "☠️";
    const radioactive_sign = "☢️";
    const biohazard_sign = "☣️";
    const orthodox_cross = "☦️";
    const star_and_crescent = "☪️";
    const peace_symbol = "☮️";
    const yin_yang = "☯️";
    const wheel_of_dharma = "☸️";
    const white_frowning_face = "☹️";
    const relaxed = "☺️";
    const female_sign = "♀️";
    const male_sign = "♂️";
    const gemini = "♊";
    const cancer = "♋";
    const leo = "♌";
    const virgo = "♍";
    const libra = "♎";
    const scorpius = "♏";
    const chess_pawn = "♟️";
    const spades = "♠️";
    const clubs = "♣️";
    const hearts = "♥️";
    const diamonds = "♦️";
    const hotsprings = "♨️";
    const recycle = "♻️";
    const infinity = "♾️";
    const wheelchair = "♿";
    const hammer_and_pick = "⚒️";
    const crossed_swords = "⚔️";
    const medical_symbol = "⚕️";
    const staff_of_aesculapius = "⚕️";
    const scales = "⚖️";
    const alembic = "⚗️";
    const gear = "⚙️";
    const atom_symbol = "⚛️";
    const fleur_de_lis = "⚜️";
    const warning = "⚠️";
    const zap = "⚡";
    const transgender_symbol = "⚧️";
    const white_circle = "⚪";
    const black_circle = "⚫";
    const coffin = "⚰️";
    const funeral_urn = "⚱️";
    const soccer = "⚽";
    const baseball = "⚾";
    const snowman_without_snow = "⛄";
    const partly_sunny = "⛅";
    const thunder_cloud_and_rain = "⛈️";
    const ophiuchus = "⛎";
    const pick = "⛏️";
    const helmet_with_white_cross = "⛑️";
    const chains = "⛓️";
    const no_entry = "⛔";
    const shinto_shrine = "⛩️";
    const church = "⛪";
    const mountain = "⛰️";
    const umbrella_on_ground = "⛱️";
    const fountain = "⛲";
    const golf = "⛳";
    const ferry = "⛴️";
    const boat = "⛵";
    const sailboat = "⛵";
    const skier = "⛷️";
    const ice_skate = "⛸️";
    const person_with_ball = "⛹️‍♂️";
    const tent = "⛺";
    const fuelpump = "⛽";
    const scissors = "✂️";
    const airplane = "✈️";
    const email = "✉️";
    const envelope = "✉️";
    const fist = "✊";
    const hand = "✋";
    const raised_hand = "✋";
    const v$2 = "✌️";
    const writing_hand = "✍️";
    const pencil2 = "✏️";
    const black_nib = "✒️";
    const heavy_check_mark = "✔️";
    const heavy_multiplication_x = "✖️";
    const latin_cross = "✝️";
    const star_of_david = "✡️";
    const eight_spoked_asterisk = "✳️";
    const eight_pointed_black_star = "✴️";
    const snowflake = "❄️";
    const sparkle = "❇️";
    const x$1 = "❌";
    const negative_squared_cross_mark = "❎";
    const heavy_heart_exclamation_mark_ornament = "❣️";
    const heart_on_fire = "❤️‍🔥";
    const mending_heart = "❤️‍🩹";
    const heart = "❤️";
    const arrow_right = "➡️";
    const curly_loop = "➰";
    const loop = "➿";
    const arrow_heading_up = "⤴️";
    const arrow_heading_down = "⤵️";
    const arrow_left = "⬅️";
    const arrow_up = "⬆️";
    const arrow_down = "⬇️";
    const black_large_square = "⬛";
    const white_large_square = "⬜";
    const star = "⭐";
    const o$2 = "⭕";
    const wavy_dash = "〰️";
    const part_alternation_mark = "〽️";
    const congratulations = "㊗️";
    const secret = "㊙️";
    const emoji = {
      "100": "💯",
      "1234": "🔢",
      umbrella_with_rain_drops,
      coffee,
      aries,
      taurus,
      sagittarius,
      capricorn,
      aquarius,
      pisces,
      anchor,
      white_check_mark,
      sparkles,
      question,
      grey_question,
      grey_exclamation,
      exclamation,
      heavy_exclamation_mark,
      heavy_plus_sign,
      heavy_minus_sign,
      heavy_division_sign,
      hash,
      keycap_star,
      zero,
      one,
      two,
      three,
      four,
      five,
      six,
      seven,
      eight,
      nine,
      copyright,
      registered,
      mahjong,
      black_joker,
      a: a$2,
      b: b$3,
      o2,
      parking,
      ab,
      cl,
      cool,
      free,
      id,
      "new": "🆕",
      ng,
      ok,
      sos,
      up,
      vs,
      "flag-ac": "🇦🇨",
      "flag-ad": "🇦🇩",
      "flag-ae": "🇦🇪",
      "flag-af": "🇦🇫",
      "flag-ag": "🇦🇬",
      "flag-ai": "🇦🇮",
      "flag-al": "🇦🇱",
      "flag-am": "🇦🇲",
      "flag-ao": "🇦🇴",
      "flag-aq": "🇦🇶",
      "flag-ar": "🇦🇷",
      "flag-as": "🇦🇸",
      "flag-at": "🇦🇹",
      "flag-au": "🇦🇺",
      "flag-aw": "🇦🇼",
      "flag-ax": "🇦🇽",
      "flag-az": "🇦🇿",
      "flag-ba": "🇧🇦",
      "flag-bb": "🇧🇧",
      "flag-bd": "🇧🇩",
      "flag-be": "🇧🇪",
      "flag-bf": "🇧🇫",
      "flag-bg": "🇧🇬",
      "flag-bh": "🇧🇭",
      "flag-bi": "🇧🇮",
      "flag-bj": "🇧🇯",
      "flag-bl": "🇧🇱",
      "flag-bm": "🇧🇲",
      "flag-bn": "🇧🇳",
      "flag-bo": "🇧🇴",
      "flag-bq": "🇧🇶",
      "flag-br": "🇧🇷",
      "flag-bs": "🇧🇸",
      "flag-bt": "🇧🇹",
      "flag-bv": "🇧🇻",
      "flag-bw": "🇧🇼",
      "flag-by": "🇧🇾",
      "flag-bz": "🇧🇿",
      "flag-ca": "🇨🇦",
      "flag-cc": "🇨🇨",
      "flag-cd": "🇨🇩",
      "flag-cf": "🇨🇫",
      "flag-cg": "🇨🇬",
      "flag-ch": "🇨🇭",
      "flag-ci": "🇨🇮",
      "flag-ck": "🇨🇰",
      "flag-cl": "🇨🇱",
      "flag-cm": "🇨🇲",
      cn,
      "flag-cn": "🇨🇳",
      "flag-co": "🇨🇴",
      "flag-cp": "🇨🇵",
      "flag-cr": "🇨🇷",
      "flag-cu": "🇨🇺",
      "flag-cv": "🇨🇻",
      "flag-cw": "🇨🇼",
      "flag-cx": "🇨🇽",
      "flag-cy": "🇨🇾",
      "flag-cz": "🇨🇿",
      de: de$1,
      "flag-de": "🇩🇪",
      "flag-dg": "🇩🇬",
      "flag-dj": "🇩🇯",
      "flag-dk": "🇩🇰",
      "flag-dm": "🇩🇲",
      "flag-do": "🇩🇴",
      "flag-dz": "🇩🇿",
      "flag-ea": "🇪🇦",
      "flag-ec": "🇪🇨",
      "flag-ee": "🇪🇪",
      "flag-eg": "🇪🇬",
      "flag-eh": "🇪🇭",
      "flag-er": "🇪🇷",
      es,
      "flag-es": "🇪🇸",
      "flag-et": "🇪🇹",
      "flag-eu": "🇪🇺",
      "flag-fi": "🇫🇮",
      "flag-fj": "🇫🇯",
      "flag-fk": "🇫🇰",
      "flag-fm": "🇫🇲",
      "flag-fo": "🇫🇴",
      fr,
      "flag-fr": "🇫🇷",
      "flag-ga": "🇬🇦",
      gb,
      uk,
      "flag-gb": "🇬🇧",
      "flag-gd": "🇬🇩",
      "flag-ge": "🇬🇪",
      "flag-gf": "🇬🇫",
      "flag-gg": "🇬🇬",
      "flag-gh": "🇬🇭",
      "flag-gi": "🇬🇮",
      "flag-gl": "🇬🇱",
      "flag-gm": "🇬🇲",
      "flag-gn": "🇬🇳",
      "flag-gp": "🇬🇵",
      "flag-gq": "🇬🇶",
      "flag-gr": "🇬🇷",
      "flag-gs": "🇬🇸",
      "flag-gt": "🇬🇹",
      "flag-gu": "🇬🇺",
      "flag-gw": "🇬🇼",
      "flag-gy": "🇬🇾",
      "flag-hk": "🇭🇰",
      "flag-hm": "🇭🇲",
      "flag-hn": "🇭🇳",
      "flag-hr": "🇭🇷",
      "flag-ht": "🇭🇹",
      "flag-hu": "🇭🇺",
      "flag-ic": "🇮🇨",
      "flag-id": "🇮🇩",
      "flag-ie": "🇮🇪",
      "flag-il": "🇮🇱",
      "flag-im": "🇮🇲",
      "flag-in": "🇮🇳",
      "flag-io": "🇮🇴",
      "flag-iq": "🇮🇶",
      "flag-ir": "🇮🇷",
      "flag-is": "🇮🇸",
      it: it$1,
      "flag-it": "🇮🇹",
      "flag-je": "🇯🇪",
      "flag-jm": "🇯🇲",
      "flag-jo": "🇯🇴",
      jp,
      "flag-jp": "🇯🇵",
      "flag-ke": "🇰🇪",
      "flag-kg": "🇰🇬",
      "flag-kh": "🇰🇭",
      "flag-ki": "🇰🇮",
      "flag-km": "🇰🇲",
      "flag-kn": "🇰🇳",
      "flag-kp": "🇰🇵",
      kr,
      "flag-kr": "🇰🇷",
      "flag-kw": "🇰🇼",
      "flag-ky": "🇰🇾",
      "flag-kz": "🇰🇿",
      "flag-la": "🇱🇦",
      "flag-lb": "🇱🇧",
      "flag-lc": "🇱🇨",
      "flag-li": "🇱🇮",
      "flag-lk": "🇱🇰",
      "flag-lr": "🇱🇷",
      "flag-ls": "🇱🇸",
      "flag-lt": "🇱🇹",
      "flag-lu": "🇱🇺",
      "flag-lv": "🇱🇻",
      "flag-ly": "🇱🇾",
      "flag-ma": "🇲🇦",
      "flag-mc": "🇲🇨",
      "flag-md": "🇲🇩",
      "flag-me": "🇲🇪",
      "flag-mf": "🇲🇫",
      "flag-mg": "🇲🇬",
      "flag-mh": "🇲🇭",
      "flag-mk": "🇲🇰",
      "flag-ml": "🇲🇱",
      "flag-mm": "🇲🇲",
      "flag-mn": "🇲🇳",
      "flag-mo": "🇲🇴",
      "flag-mp": "🇲🇵",
      "flag-mq": "🇲🇶",
      "flag-mr": "🇲🇷",
      "flag-ms": "🇲🇸",
      "flag-mt": "🇲🇹",
      "flag-mu": "🇲🇺",
      "flag-mv": "🇲🇻",
      "flag-mw": "🇲🇼",
      "flag-mx": "🇲🇽",
      "flag-my": "🇲🇾",
      "flag-mz": "🇲🇿",
      "flag-na": "🇳🇦",
      "flag-nc": "🇳🇨",
      "flag-ne": "🇳🇪",
      "flag-nf": "🇳🇫",
      "flag-ng": "🇳🇬",
      "flag-ni": "🇳🇮",
      "flag-nl": "🇳🇱",
      "flag-no": "🇳🇴",
      "flag-np": "🇳🇵",
      "flag-nr": "🇳🇷",
      "flag-nu": "🇳🇺",
      "flag-nz": "🇳🇿",
      "flag-om": "🇴🇲",
      "flag-pa": "🇵🇦",
      "flag-pe": "🇵🇪",
      "flag-pf": "🇵🇫",
      "flag-pg": "🇵🇬",
      "flag-ph": "🇵🇭",
      "flag-pk": "🇵🇰",
      "flag-pl": "🇵🇱",
      "flag-pm": "🇵🇲",
      "flag-pn": "🇵🇳",
      "flag-pr": "🇵🇷",
      "flag-ps": "🇵🇸",
      "flag-pt": "🇵🇹",
      "flag-pw": "🇵🇼",
      "flag-py": "🇵🇾",
      "flag-qa": "🇶🇦",
      "flag-re": "🇷🇪",
      "flag-ro": "🇷🇴",
      "flag-rs": "🇷🇸",
      ru,
      "flag-ru": "🇷🇺",
      "flag-rw": "🇷🇼",
      "flag-sa": "🇸🇦",
      "flag-sb": "🇸🇧",
      "flag-sc": "🇸🇨",
      "flag-sd": "🇸🇩",
      "flag-se": "🇸🇪",
      "flag-sg": "🇸🇬",
      "flag-sh": "🇸🇭",
      "flag-si": "🇸🇮",
      "flag-sj": "🇸🇯",
      "flag-sk": "🇸🇰",
      "flag-sl": "🇸🇱",
      "flag-sm": "🇸🇲",
      "flag-sn": "🇸🇳",
      "flag-so": "🇸🇴",
      "flag-sr": "🇸🇷",
      "flag-ss": "🇸🇸",
      "flag-st": "🇸🇹",
      "flag-sv": "🇸🇻",
      "flag-sx": "🇸🇽",
      "flag-sy": "🇸🇾",
      "flag-sz": "🇸🇿",
      "flag-ta": "🇹🇦",
      "flag-tc": "🇹🇨",
      "flag-td": "🇹🇩",
      "flag-tf": "🇹🇫",
      "flag-tg": "🇹🇬",
      "flag-th": "🇹🇭",
      "flag-tj": "🇹🇯",
      "flag-tk": "🇹🇰",
      "flag-tl": "🇹🇱",
      "flag-tm": "🇹🇲",
      "flag-tn": "🇹🇳",
      "flag-to": "🇹🇴",
      "flag-tr": "🇹🇷",
      "flag-tt": "🇹🇹",
      "flag-tv": "🇹🇻",
      "flag-tw": "🇹🇼",
      "flag-tz": "🇹🇿",
      "flag-ua": "🇺🇦",
      "flag-ug": "🇺🇬",
      "flag-um": "🇺🇲",
      "flag-un": "🇺🇳",
      us,
      "flag-us": "🇺🇸",
      "flag-uy": "🇺🇾",
      "flag-uz": "🇺🇿",
      "flag-va": "🇻🇦",
      "flag-vc": "🇻🇨",
      "flag-ve": "🇻🇪",
      "flag-vg": "🇻🇬",
      "flag-vi": "🇻🇮",
      "flag-vn": "🇻🇳",
      "flag-vu": "🇻🇺",
      "flag-wf": "🇼🇫",
      "flag-ws": "🇼🇸",
      "flag-xk": "🇽🇰",
      "flag-ye": "🇾🇪",
      "flag-yt": "🇾🇹",
      "flag-za": "🇿🇦",
      "flag-zm": "🇿🇲",
      "flag-zw": "🇿🇼",
      koko,
      sa,
      u7121,
      u6307,
      u7981,
      u7a7a,
      u5408,
      u6e80,
      u6709,
      u6708,
      u7533,
      u5272,
      u55b6,
      ideograph_advantage,
      accept,
      cyclone,
      foggy,
      closed_umbrella,
      night_with_stars,
      sunrise_over_mountains,
      sunrise,
      city_sunset,
      city_sunrise,
      rainbow,
      bridge_at_night,
      ocean,
      volcano,
      milky_way,
      earth_africa,
      earth_americas,
      earth_asia,
      globe_with_meridians,
      new_moon,
      waxing_crescent_moon,
      first_quarter_moon,
      moon,
      waxing_gibbous_moon,
      full_moon,
      waning_gibbous_moon,
      last_quarter_moon,
      waning_crescent_moon,
      crescent_moon,
      new_moon_with_face,
      first_quarter_moon_with_face,
      last_quarter_moon_with_face,
      full_moon_with_face,
      sun_with_face,
      star2,
      stars,
      thermometer,
      mostly_sunny,
      sun_small_cloud,
      barely_sunny,
      sun_behind_cloud,
      partly_sunny_rain,
      sun_behind_rain_cloud,
      rain_cloud,
      snow_cloud,
      lightning,
      lightning_cloud,
      tornado,
      tornado_cloud,
      fog,
      wind_blowing_face,
      hotdog,
      taco,
      burrito,
      chestnut,
      seedling,
      evergreen_tree,
      deciduous_tree,
      palm_tree,
      cactus,
      hot_pepper,
      tulip,
      cherry_blossom,
      rose,
      hibiscus,
      sunflower,
      blossom,
      corn,
      ear_of_rice,
      herb,
      four_leaf_clover,
      maple_leaf,
      fallen_leaf,
      leaves,
      mushroom,
      tomato,
      eggplant,
      grapes,
      melon,
      watermelon,
      tangerine,
      lemon,
      banana,
      pineapple,
      apple,
      green_apple,
      pear,
      peach,
      cherries,
      strawberry,
      hamburger,
      pizza,
      meat_on_bone,
      poultry_leg,
      rice_cracker,
      rice_ball,
      rice,
      curry,
      ramen,
      spaghetti,
      bread,
      fries,
      sweet_potato,
      dango,
      oden,
      sushi,
      fried_shrimp,
      fish_cake,
      icecream,
      shaved_ice,
      ice_cream,
      doughnut,
      cookie,
      chocolate_bar,
      candy,
      lollipop,
      custard,
      honey_pot,
      cake,
      bento,
      stew,
      fried_egg,
      cooking,
      fork_and_knife,
      tea,
      sake,
      wine_glass,
      cocktail,
      tropical_drink,
      beer,
      beers,
      baby_bottle,
      knife_fork_plate,
      champagne,
      popcorn,
      ribbon,
      gift,
      birthday,
      jack_o_lantern,
      christmas_tree,
      santa,
      fireworks,
      sparkler,
      balloon,
      tada,
      confetti_ball,
      tanabata_tree,
      crossed_flags,
      bamboo,
      dolls,
      flags,
      wind_chime,
      rice_scene,
      school_satchel,
      mortar_board,
      medal,
      reminder_ribbon,
      studio_microphone,
      level_slider,
      control_knobs,
      film_frames,
      admission_tickets,
      carousel_horse,
      ferris_wheel,
      roller_coaster,
      fishing_pole_and_fish,
      microphone,
      movie_camera,
      cinema,
      headphones,
      art,
      tophat,
      circus_tent,
      ticket,
      clapper,
      performing_arts,
      video_game,
      dart,
      slot_machine,
      "8ball": "🎱",
      game_die,
      bowling,
      flower_playing_cards,
      musical_note,
      notes,
      saxophone,
      guitar,
      musical_keyboard,
      trumpet,
      violin,
      musical_score,
      running_shirt_with_sash,
      tennis,
      ski,
      basketball,
      checkered_flag,
      snowboarder,
      "woman-running": "🏃‍♀️",
      "man-running": "🏃‍♂️",
      runner,
      running,
      "woman-surfing": "🏄‍♀️",
      "man-surfing": "🏄‍♂️",
      surfer,
      sports_medal,
      trophy,
      horse_racing,
      football,
      rugby_football,
      "woman-swimming": "🏊‍♀️",
      "man-swimming": "🏊‍♂️",
      swimmer,
      "woman-lifting-weights": "🏋️‍♀️",
      "man-lifting-weights": "🏋️‍♂️",
      weight_lifter,
      "woman-golfing": "🏌️‍♀️",
      "man-golfing": "🏌️‍♂️",
      golfer,
      racing_motorcycle,
      racing_car,
      cricket_bat_and_ball,
      volleyball,
      field_hockey_stick_and_ball,
      ice_hockey_stick_and_puck,
      table_tennis_paddle_and_ball,
      snow_capped_mountain,
      camping,
      beach_with_umbrella,
      building_construction,
      house_buildings,
      cityscape,
      derelict_house_building,
      classical_building,
      desert,
      desert_island,
      national_park,
      stadium,
      house,
      house_with_garden,
      office,
      post_office,
      european_post_office,
      hospital,
      bank,
      atm,
      hotel,
      love_hotel,
      convenience_store,
      school,
      department_store,
      factory,
      izakaya_lantern,
      lantern,
      japanese_castle,
      european_castle,
      "rainbow-flag": "🏳️‍🌈",
      transgender_flag,
      waving_white_flag,
      pirate_flag,
      "flag-england": "🏴󠁧󠁢󠁥󠁮󠁧󠁿",
      "flag-scotland": "🏴󠁧󠁢󠁳󠁣󠁴󠁿",
      "flag-wales": "🏴󠁧󠁢󠁷󠁬󠁳󠁿",
      waving_black_flag,
      rosette,
      label,
      badminton_racquet_and_shuttlecock,
      bow_and_arrow,
      amphora,
      "skin-tone-2": "🏻",
      "skin-tone-3": "🏼",
      "skin-tone-4": "🏽",
      "skin-tone-5": "🏾",
      "skin-tone-6": "🏿",
      rat,
      mouse2,
      ox,
      water_buffalo,
      cow2,
      tiger2,
      leopard,
      rabbit2,
      black_cat,
      cat2,
      dragon,
      crocodile,
      whale2,
      snail,
      snake,
      racehorse,
      ram,
      goat,
      sheep,
      monkey,
      rooster,
      chicken,
      service_dog,
      dog2,
      pig2,
      boar,
      elephant,
      octopus,
      shell,
      bug,
      ant,
      bee,
      honeybee,
      ladybug,
      lady_beetle,
      fish,
      tropical_fish,
      blowfish,
      turtle,
      hatching_chick,
      baby_chick,
      hatched_chick,
      bird,
      penguin,
      koala,
      poodle,
      dromedary_camel,
      camel,
      dolphin,
      flipper,
      mouse,
      cow,
      tiger,
      rabbit,
      cat,
      dragon_face,
      whale,
      horse,
      monkey_face,
      dog,
      pig,
      frog,
      hamster,
      wolf,
      polar_bear,
      bear,
      panda_face,
      pig_nose,
      feet,
      paw_prints,
      chipmunk,
      eyes,
      "eye-in-speech-bubble": "👁️‍🗨️",
      eye,
      ear,
      nose,
      lips,
      tongue,
      point_up_2,
      point_down,
      point_left,
      point_right,
      facepunch,
      punch,
      wave,
      ok_hand,
      "+1": "👍",
      thumbsup,
      "-1": "👎",
      thumbsdown,
      clap,
      open_hands,
      crown,
      womans_hat,
      eyeglasses,
      necktie,
      shirt,
      tshirt,
      jeans,
      dress,
      kimono,
      bikini,
      womans_clothes,
      purse,
      handbag,
      pouch,
      mans_shoe,
      shoe,
      athletic_shoe,
      high_heel,
      sandal,
      boot,
      footprints,
      bust_in_silhouette,
      busts_in_silhouette,
      boy,
      girl,
      "male-farmer": "👨‍🌾",
      "male-cook": "👨‍🍳",
      man_feeding_baby,
      "male-student": "👨‍🎓",
      "male-singer": "👨‍🎤",
      "male-artist": "👨‍🎨",
      "male-teacher": "👨‍🏫",
      "male-factory-worker": "👨‍🏭",
      "man-boy-boy": "👨‍👦‍👦",
      "man-boy": "👨‍👦",
      "man-girl-boy": "👨‍👧‍👦",
      "man-girl-girl": "👨‍👧‍👧",
      "man-girl": "👨‍👧",
      "man-man-boy": "👨‍👨‍👦",
      "man-man-boy-boy": "👨‍👨‍👦‍👦",
      "man-man-girl": "👨‍👨‍👧",
      "man-man-girl-boy": "👨‍👨‍👧‍👦",
      "man-man-girl-girl": "👨‍👨‍👧‍👧",
      "man-woman-boy": "👨‍👩‍👦",
      family,
      "man-woman-boy-boy": "👨‍👩‍👦‍👦",
      "man-woman-girl": "👨‍👩‍👧",
      "man-woman-girl-boy": "👨‍👩‍👧‍👦",
      "man-woman-girl-girl": "👨‍👩‍👧‍👧",
      "male-technologist": "👨‍💻",
      "male-office-worker": "👨‍💼",
      "male-mechanic": "👨‍🔧",
      "male-scientist": "👨‍🔬",
      "male-astronaut": "👨‍🚀",
      "male-firefighter": "👨‍🚒",
      man_with_probing_cane,
      red_haired_man,
      curly_haired_man,
      bald_man,
      white_haired_man,
      man_in_motorized_wheelchair,
      man_in_manual_wheelchair,
      "male-doctor": "👨‍⚕️",
      "male-judge": "👨‍⚖️",
      "male-pilot": "👨‍✈️",
      "man-heart-man": "👨‍❤️‍👨",
      "man-kiss-man": "👨‍❤️‍💋‍👨",
      man,
      "female-farmer": "👩‍🌾",
      "female-cook": "👩‍🍳",
      woman_feeding_baby,
      "female-student": "👩‍🎓",
      "female-singer": "👩‍🎤",
      "female-artist": "👩‍🎨",
      "female-teacher": "👩‍🏫",
      "female-factory-worker": "👩‍🏭",
      "woman-boy-boy": "👩‍👦‍👦",
      "woman-boy": "👩‍👦",
      "woman-girl-boy": "👩‍👧‍👦",
      "woman-girl-girl": "👩‍👧‍👧",
      "woman-girl": "👩‍👧",
      "woman-woman-boy": "👩‍👩‍👦",
      "woman-woman-boy-boy": "👩‍👩‍👦‍👦",
      "woman-woman-girl": "👩‍👩‍👧",
      "woman-woman-girl-boy": "👩‍👩‍👧‍👦",
      "woman-woman-girl-girl": "👩‍👩‍👧‍👧",
      "female-technologist": "👩‍💻",
      "female-office-worker": "👩‍💼",
      "female-mechanic": "👩‍🔧",
      "female-scientist": "👩‍🔬",
      "female-astronaut": "👩‍🚀",
      "female-firefighter": "👩‍🚒",
      woman_with_probing_cane,
      red_haired_woman,
      curly_haired_woman,
      bald_woman,
      white_haired_woman,
      woman_in_motorized_wheelchair,
      woman_in_manual_wheelchair,
      "female-doctor": "👩‍⚕️",
      "female-judge": "👩‍⚖️",
      "female-pilot": "👩‍✈️",
      "woman-heart-man": "👩‍❤️‍👨",
      "woman-heart-woman": "👩‍❤️‍👩",
      "woman-kiss-man": "👩‍❤️‍💋‍👨",
      "woman-kiss-woman": "👩‍❤️‍💋‍👩",
      woman,
      man_and_woman_holding_hands,
      woman_and_man_holding_hands,
      couple,
      two_men_holding_hands,
      men_holding_hands,
      two_women_holding_hands,
      women_holding_hands,
      "female-police-officer": "👮‍♀️",
      "male-police-officer": "👮‍♂️",
      cop,
      "women-with-bunny-ears-partying": "👯‍♀️",
      "woman-with-bunny-ears-partying": "👯‍♀️",
      dancers,
      "men-with-bunny-ears-partying": "👯‍♂️",
      "man-with-bunny-ears-partying": "👯‍♂️",
      woman_with_veil,
      man_with_veil,
      bride_with_veil,
      "blond-haired-woman": "👱‍♀️",
      "blond-haired-man": "👱‍♂️",
      person_with_blond_hair,
      man_with_gua_pi_mao,
      "woman-wearing-turban": "👳‍♀️",
      "man-wearing-turban": "👳‍♂️",
      man_with_turban,
      older_man,
      older_woman,
      baby,
      "female-construction-worker": "👷‍♀️",
      "male-construction-worker": "👷‍♂️",
      construction_worker,
      princess,
      japanese_ogre,
      japanese_goblin,
      ghost,
      angel,
      alien,
      space_invader,
      imp,
      skull,
      "woman-tipping-hand": "💁‍♀️",
      information_desk_person,
      "man-tipping-hand": "💁‍♂️",
      "female-guard": "💂‍♀️",
      "male-guard": "💂‍♂️",
      guardsman,
      dancer,
      lipstick,
      nail_care,
      "woman-getting-massage": "💆‍♀️",
      massage,
      "man-getting-massage": "💆‍♂️",
      "woman-getting-haircut": "💇‍♀️",
      haircut,
      "man-getting-haircut": "💇‍♂️",
      barber,
      syringe,
      pill,
      kiss,
      love_letter,
      ring,
      gem,
      couplekiss,
      bouquet,
      couple_with_heart,
      wedding,
      heartbeat,
      broken_heart,
      two_hearts,
      sparkling_heart,
      heartpulse,
      cupid,
      blue_heart,
      green_heart,
      yellow_heart,
      purple_heart,
      gift_heart,
      revolving_hearts,
      heart_decoration,
      diamond_shape_with_a_dot_inside,
      bulb,
      anger,
      bomb,
      zzz,
      boom,
      collision,
      sweat_drops,
      droplet,
      dash,
      hankey,
      poop,
      shit,
      muscle,
      dizzy,
      speech_balloon,
      thought_balloon,
      white_flower,
      moneybag,
      currency_exchange,
      heavy_dollar_sign,
      credit_card,
      yen,
      dollar,
      euro,
      pound,
      money_with_wings,
      chart,
      seat,
      computer,
      briefcase,
      minidisc,
      floppy_disk,
      cd,
      dvd,
      file_folder,
      open_file_folder,
      page_with_curl,
      page_facing_up,
      date,
      calendar,
      card_index,
      chart_with_upwards_trend,
      chart_with_downwards_trend,
      bar_chart,
      clipboard,
      pushpin,
      round_pushpin,
      paperclip,
      straight_ruler,
      triangular_ruler,
      bookmark_tabs,
      ledger,
      notebook,
      notebook_with_decorative_cover,
      closed_book,
      book,
      open_book,
      green_book,
      blue_book,
      orange_book,
      books,
      name_badge,
      scroll,
      memo,
      pencil,
      telephone_receiver,
      pager,
      fax,
      satellite_antenna,
      loudspeaker,
      mega,
      outbox_tray,
      inbox_tray,
      "package": "📦",
      "e-mail": "📧",
      incoming_envelope,
      envelope_with_arrow,
      mailbox_closed,
      mailbox,
      mailbox_with_mail,
      mailbox_with_no_mail,
      postbox,
      postal_horn,
      newspaper,
      iphone,
      calling,
      vibration_mode,
      mobile_phone_off,
      no_mobile_phones,
      signal_strength,
      camera,
      camera_with_flash,
      video_camera,
      tv,
      radio,
      vhs,
      film_projector,
      prayer_beads,
      twisted_rightwards_arrows,
      repeat,
      repeat_one,
      arrows_clockwise,
      arrows_counterclockwise,
      low_brightness,
      high_brightness,
      mute,
      speaker,
      sound,
      loud_sound,
      battery,
      electric_plug,
      mag,
      mag_right,
      lock_with_ink_pen,
      closed_lock_with_key,
      key,
      lock,
      unlock,
      bell,
      no_bell,
      bookmark,
      link,
      radio_button,
      back,
      end,
      on: on$1,
      soon,
      top,
      underage,
      keycap_ten,
      capital_abcd,
      abcd,
      symbols,
      abc,
      fire,
      flashlight,
      wrench,
      hammer,
      nut_and_bolt,
      hocho,
      knife,
      gun,
      microscope,
      telescope,
      crystal_ball,
      six_pointed_star,
      beginner,
      trident,
      black_square_button,
      white_square_button,
      red_circle,
      large_blue_circle,
      large_orange_diamond,
      large_blue_diamond,
      small_orange_diamond,
      small_blue_diamond,
      small_red_triangle,
      small_red_triangle_down,
      arrow_up_small,
      arrow_down_small,
      om_symbol,
      dove_of_peace,
      kaaba,
      mosque,
      synagogue,
      menorah_with_nine_branches,
      clock1,
      clock2,
      clock3,
      clock4,
      clock5,
      clock6,
      clock7,
      clock8,
      clock9,
      clock10,
      clock11,
      clock12,
      clock130,
      clock230,
      clock330,
      clock430,
      clock530,
      clock630,
      clock730,
      clock830,
      clock930,
      clock1030,
      clock1130,
      clock1230,
      candle,
      mantelpiece_clock,
      hole,
      man_in_business_suit_levitating,
      "female-detective": "🕵️‍♀️",
      "male-detective": "🕵️‍♂️",
      sleuth_or_spy,
      dark_sunglasses,
      spider,
      spider_web,
      joystick,
      man_dancing,
      linked_paperclips,
      lower_left_ballpoint_pen,
      lower_left_fountain_pen,
      lower_left_paintbrush,
      lower_left_crayon,
      raised_hand_with_fingers_splayed,
      middle_finger,
      reversed_hand_with_middle_finger_extended,
      "spock-hand": "🖖",
      black_heart,
      desktop_computer,
      printer,
      three_button_mouse,
      trackball,
      frame_with_picture,
      card_index_dividers,
      card_file_box,
      file_cabinet,
      wastebasket,
      spiral_note_pad,
      spiral_calendar_pad,
      compression,
      old_key,
      rolled_up_newspaper,
      dagger_knife,
      speaking_head_in_silhouette,
      left_speech_bubble,
      right_anger_bubble,
      ballot_box_with_ballot,
      world_map,
      mount_fuji,
      tokyo_tower,
      statue_of_liberty,
      japan,
      moyai,
      grinning,
      grin,
      joy,
      smiley,
      smile,
      sweat_smile,
      laughing,
      satisfied,
      innocent,
      smiling_imp,
      wink,
      blush,
      yum,
      relieved,
      heart_eyes,
      sunglasses,
      smirk,
      neutral_face,
      expressionless,
      unamused,
      sweat,
      pensive,
      confused,
      confounded,
      kissing,
      kissing_heart,
      kissing_smiling_eyes,
      kissing_closed_eyes,
      stuck_out_tongue,
      stuck_out_tongue_winking_eye,
      stuck_out_tongue_closed_eyes,
      disappointed,
      worried,
      angry,
      rage,
      cry,
      persevere,
      triumph,
      disappointed_relieved,
      frowning,
      anguished,
      fearful,
      weary,
      sleepy,
      tired_face,
      grimacing,
      sob,
      face_exhaling,
      open_mouth,
      hushed,
      cold_sweat,
      scream,
      astonished,
      flushed,
      sleeping,
      face_with_spiral_eyes,
      dizzy_face,
      face_in_clouds,
      no_mouth,
      mask,
      smile_cat,
      joy_cat,
      smiley_cat,
      heart_eyes_cat,
      smirk_cat,
      kissing_cat,
      pouting_cat,
      crying_cat_face,
      scream_cat,
      slightly_frowning_face,
      slightly_smiling_face,
      upside_down_face,
      face_with_rolling_eyes,
      "woman-gesturing-no": "🙅‍♀️",
      no_good,
      "man-gesturing-no": "🙅‍♂️",
      "woman-gesturing-ok": "🙆‍♀️",
      ok_woman,
      "man-gesturing-ok": "🙆‍♂️",
      "woman-bowing": "🙇‍♀️",
      "man-bowing": "🙇‍♂️",
      bow,
      see_no_evil,
      hear_no_evil,
      speak_no_evil,
      "woman-raising-hand": "🙋‍♀️",
      raising_hand,
      "man-raising-hand": "🙋‍♂️",
      raised_hands,
      "woman-frowning": "🙍‍♀️",
      person_frowning,
      "man-frowning": "🙍‍♂️",
      "woman-pouting": "🙎‍♀️",
      person_with_pouting_face,
      "man-pouting": "🙎‍♂️",
      pray,
      rocket,
      helicopter,
      steam_locomotive,
      railway_car,
      bullettrain_side,
      bullettrain_front,
      train2,
      metro,
      light_rail,
      station,
      tram,
      train,
      bus,
      oncoming_bus,
      trolleybus,
      busstop,
      minibus,
      ambulance,
      fire_engine,
      police_car,
      oncoming_police_car,
      taxi,
      oncoming_taxi,
      car,
      red_car,
      oncoming_automobile,
      blue_car,
      truck,
      articulated_lorry,
      tractor,
      monorail,
      mountain_railway,
      suspension_railway,
      mountain_cableway,
      aerial_tramway,
      ship,
      "woman-rowing-boat": "🚣‍♀️",
      "man-rowing-boat": "🚣‍♂️",
      rowboat,
      speedboat,
      traffic_light,
      vertical_traffic_light,
      construction,
      rotating_light,
      triangular_flag_on_post,
      door,
      no_entry_sign,
      smoking,
      no_smoking,
      put_litter_in_its_place,
      do_not_litter,
      potable_water,
      "non-potable_water": "🚱",
      bike,
      no_bicycles,
      "woman-biking": "🚴‍♀️",
      "man-biking": "🚴‍♂️",
      bicyclist,
      "woman-mountain-biking": "🚵‍♀️",
      "man-mountain-biking": "🚵‍♂️",
      mountain_bicyclist,
      "woman-walking": "🚶‍♀️",
      "man-walking": "🚶‍♂️",
      walking,
      no_pedestrians,
      children_crossing,
      mens,
      womens,
      restroom,
      baby_symbol,
      toilet,
      wc,
      shower,
      bath,
      bathtub,
      passport_control,
      customs,
      baggage_claim,
      left_luggage,
      couch_and_lamp,
      sleeping_accommodation,
      shopping_bags,
      bellhop_bell,
      bed,
      place_of_worship,
      octagonal_sign,
      shopping_trolley,
      hindu_temple,
      hut,
      elevator,
      hammer_and_wrench,
      shield,
      oil_drum,
      motorway,
      railway_track,
      motor_boat,
      small_airplane,
      airplane_departure,
      airplane_arriving,
      satellite,
      passenger_ship,
      scooter,
      motor_scooter,
      canoe,
      sled,
      flying_saucer,
      skateboard,
      auto_rickshaw,
      pickup_truck,
      roller_skate,
      large_orange_circle,
      large_yellow_circle,
      large_green_circle,
      large_purple_circle,
      large_brown_circle,
      large_red_square,
      large_blue_square,
      large_orange_square,
      large_yellow_square,
      large_green_square,
      large_purple_square,
      large_brown_square,
      pinched_fingers,
      white_heart,
      brown_heart,
      pinching_hand,
      zipper_mouth_face,
      money_mouth_face,
      face_with_thermometer,
      nerd_face,
      thinking_face,
      face_with_head_bandage,
      robot_face,
      hugging_face,
      the_horns,
      sign_of_the_horns,
      call_me_hand,
      raised_back_of_hand,
      "left-facing_fist": "🤛",
      "right-facing_fist": "🤜",
      handshake,
      crossed_fingers,
      hand_with_index_and_middle_fingers_crossed,
      i_love_you_hand_sign,
      face_with_cowboy_hat,
      clown_face,
      nauseated_face,
      rolling_on_the_floor_laughing,
      drooling_face,
      lying_face,
      "woman-facepalming": "🤦‍♀️",
      "man-facepalming": "🤦‍♂️",
      face_palm,
      sneezing_face,
      face_with_raised_eyebrow,
      face_with_one_eyebrow_raised,
      "star-struck": "🤩",
      grinning_face_with_star_eyes,
      zany_face,
      grinning_face_with_one_large_and_one_small_eye,
      shushing_face,
      face_with_finger_covering_closed_lips,
      face_with_symbols_on_mouth,
      serious_face_with_symbols_covering_mouth,
      face_with_hand_over_mouth,
      smiling_face_with_smiling_eyes_and_hand_covering_mouth,
      face_vomiting,
      face_with_open_mouth_vomiting,
      exploding_head,
      shocked_face_with_exploding_head,
      pregnant_woman,
      "breast-feeding": "🤱",
      palms_up_together,
      selfie,
      prince,
      woman_in_tuxedo,
      man_in_tuxedo,
      person_in_tuxedo,
      mrs_claus,
      mother_christmas,
      "woman-shrugging": "🤷‍♀️",
      "man-shrugging": "🤷‍♂️",
      shrug,
      "woman-cartwheeling": "🤸‍♀️",
      "man-cartwheeling": "🤸‍♂️",
      person_doing_cartwheel,
      "woman-juggling": "🤹‍♀️",
      "man-juggling": "🤹‍♂️",
      juggling,
      fencer,
      "woman-wrestling": "🤼‍♀️",
      "man-wrestling": "🤼‍♂️",
      wrestlers,
      "woman-playing-water-polo": "🤽‍♀️",
      "man-playing-water-polo": "🤽‍♂️",
      water_polo,
      "woman-playing-handball": "🤾‍♀️",
      "man-playing-handball": "🤾‍♂️",
      handball,
      diving_mask,
      wilted_flower,
      drum_with_drumsticks,
      clinking_glasses,
      tumbler_glass,
      spoon,
      goal_net,
      first_place_medal,
      second_place_medal,
      third_place_medal,
      boxing_glove,
      martial_arts_uniform,
      curling_stone,
      lacrosse,
      softball,
      flying_disc,
      croissant,
      avocado,
      cucumber,
      bacon,
      potato,
      carrot,
      baguette_bread,
      green_salad,
      shallow_pan_of_food,
      stuffed_flatbread,
      egg,
      glass_of_milk,
      peanuts,
      kiwifruit,
      pancakes,
      dumpling,
      fortune_cookie,
      takeout_box,
      chopsticks,
      bowl_with_spoon,
      cup_with_straw,
      coconut,
      broccoli,
      pie,
      pretzel,
      cut_of_meat,
      sandwich,
      canned_food,
      leafy_green,
      mango,
      moon_cake,
      bagel,
      smiling_face_with_3_hearts,
      yawning_face,
      smiling_face_with_tear,
      partying_face,
      woozy_face,
      hot_face,
      cold_face,
      ninja,
      disguised_face,
      pleading_face,
      sari,
      lab_coat,
      goggles,
      hiking_boot,
      womans_flat_shoe,
      crab,
      lion_face,
      scorpion,
      turkey,
      unicorn_face,
      eagle,
      duck,
      bat,
      shark,
      owl,
      fox_face,
      butterfly,
      deer,
      gorilla,
      lizard,
      rhinoceros,
      shrimp,
      squid,
      giraffe_face,
      zebra_face,
      hedgehog,
      sauropod,
      "t-rex": "🦖",
      cricket,
      kangaroo,
      llama,
      peacock,
      hippopotamus,
      parrot,
      raccoon,
      lobster,
      mosquito,
      microbe,
      badger,
      swan,
      mammoth,
      dodo,
      sloth,
      otter,
      orangutan,
      skunk,
      flamingo,
      oyster,
      beaver,
      bison,
      seal,
      guide_dog,
      probing_cane,
      bone,
      leg,
      foot,
      tooth,
      female_superhero,
      male_superhero,
      superhero,
      female_supervillain,
      male_supervillain,
      supervillain,
      safety_vest,
      ear_with_hearing_aid,
      motorized_wheelchair,
      manual_wheelchair,
      mechanical_arm,
      mechanical_leg,
      cheese_wedge,
      cupcake,
      salt,
      beverage_box,
      garlic,
      onion,
      falafel,
      waffle,
      butter,
      mate_drink,
      ice_cube,
      bubble_tea,
      woman_standing,
      man_standing,
      standing_person,
      woman_kneeling,
      man_kneeling,
      kneeling_person,
      deaf_woman,
      deaf_man,
      deaf_person,
      face_with_monocle,
      farmer,
      cook,
      person_feeding_baby,
      mx_claus,
      student,
      singer,
      artist,
      teacher,
      factory_worker,
      technologist,
      office_worker,
      mechanic,
      scientist,
      astronaut,
      firefighter,
      people_holding_hands,
      person_with_probing_cane,
      red_haired_person,
      curly_haired_person,
      bald_person,
      white_haired_person,
      person_in_motorized_wheelchair,
      person_in_manual_wheelchair,
      health_worker,
      judge,
      pilot,
      adult,
      child,
      older_adult,
      woman_with_beard,
      man_with_beard,
      bearded_person,
      person_with_headscarf,
      woman_in_steamy_room,
      man_in_steamy_room,
      person_in_steamy_room,
      woman_climbing,
      person_climbing,
      man_climbing,
      woman_in_lotus_position,
      person_in_lotus_position,
      man_in_lotus_position,
      female_mage,
      mage,
      male_mage,
      female_fairy,
      fairy,
      male_fairy,
      female_vampire,
      vampire,
      male_vampire,
      mermaid,
      merman,
      merperson,
      female_elf,
      male_elf,
      elf,
      female_genie,
      male_genie,
      genie,
      female_zombie,
      male_zombie,
      zombie,
      brain,
      orange_heart,
      billed_cap,
      scarf,
      gloves,
      coat,
      socks,
      red_envelope,
      firecracker,
      jigsaw,
      test_tube,
      petri_dish,
      dna,
      compass,
      abacus,
      fire_extinguisher,
      toolbox,
      bricks,
      magnet,
      luggage,
      lotion_bottle,
      thread,
      yarn,
      safety_pin,
      teddy_bear,
      broom,
      basket,
      roll_of_paper,
      soap,
      sponge,
      receipt,
      nazar_amulet,
      ballet_shoes,
      "one-piece_swimsuit": "🩱",
      briefs,
      shorts,
      thong_sandal,
      drop_of_blood,
      adhesive_bandage,
      stethoscope,
      "yo-yo": "🪀",
      kite,
      parachute,
      boomerang,
      magic_wand,
      pinata,
      nesting_dolls,
      ringed_planet,
      chair,
      razor,
      axe,
      diya_lamp,
      banjo,
      military_helmet,
      accordion,
      long_drum,
      coin,
      carpentry_saw,
      screwdriver,
      ladder,
      hook,
      mirror,
      window: window$1,
      plunger,
      sewing_needle,
      knot,
      bucket,
      mouse_trap,
      toothbrush,
      headstone,
      placard,
      rock,
      fly,
      worm,
      beetle,
      cockroach,
      potted_plant,
      wood,
      feather,
      anatomical_heart,
      lungs,
      people_hugging,
      blueberries,
      bell_pepper,
      olive,
      flatbread,
      tamale,
      fondue,
      teapot,
      bangbang,
      interrobang,
      tm,
      information_source,
      left_right_arrow,
      arrow_up_down,
      arrow_upper_left,
      arrow_upper_right,
      arrow_lower_right,
      arrow_lower_left,
      leftwards_arrow_with_hook,
      arrow_right_hook,
      watch,
      hourglass,
      keyboard,
      eject,
      fast_forward,
      rewind,
      arrow_double_up,
      arrow_double_down,
      black_right_pointing_double_triangle_with_vertical_bar,
      black_left_pointing_double_triangle_with_vertical_bar,
      black_right_pointing_triangle_with_double_vertical_bar,
      alarm_clock,
      stopwatch,
      timer_clock,
      hourglass_flowing_sand,
      double_vertical_bar,
      black_square_for_stop,
      black_circle_for_record,
      m: m$3,
      black_small_square,
      white_small_square,
      arrow_forward,
      arrow_backward,
      white_medium_square,
      black_medium_square,
      white_medium_small_square,
      black_medium_small_square,
      sunny,
      cloud,
      umbrella,
      snowman,
      comet,
      phone,
      telephone,
      ballot_box_with_check,
      shamrock,
      point_up,
      skull_and_crossbones,
      radioactive_sign,
      biohazard_sign,
      orthodox_cross,
      star_and_crescent,
      peace_symbol,
      yin_yang,
      wheel_of_dharma,
      white_frowning_face,
      relaxed,
      female_sign,
      male_sign,
      gemini,
      cancer,
      leo,
      virgo,
      libra,
      scorpius,
      chess_pawn,
      spades,
      clubs,
      hearts,
      diamonds,
      hotsprings,
      recycle,
      infinity,
      wheelchair,
      hammer_and_pick,
      crossed_swords,
      medical_symbol,
      staff_of_aesculapius,
      scales,
      alembic,
      gear,
      atom_symbol,
      fleur_de_lis,
      warning,
      zap,
      transgender_symbol,
      white_circle,
      black_circle,
      coffin,
      funeral_urn,
      soccer,
      baseball,
      snowman_without_snow,
      partly_sunny,
      thunder_cloud_and_rain,
      ophiuchus,
      pick,
      helmet_with_white_cross,
      chains,
      no_entry,
      shinto_shrine,
      church,
      mountain,
      umbrella_on_ground,
      fountain,
      golf,
      ferry,
      boat,
      sailboat,
      skier,
      ice_skate,
      "woman-bouncing-ball": "⛹️‍♀️",
      "man-bouncing-ball": "⛹️‍♂️",
      person_with_ball,
      tent,
      fuelpump,
      scissors,
      airplane,
      email,
      envelope,
      fist,
      hand,
      raised_hand,
      v: v$2,
      writing_hand,
      pencil2,
      black_nib,
      heavy_check_mark,
      heavy_multiplication_x,
      latin_cross,
      star_of_david,
      eight_spoked_asterisk,
      eight_pointed_black_star,
      snowflake,
      sparkle,
      x: x$1,
      negative_squared_cross_mark,
      heavy_heart_exclamation_mark_ornament,
      heart_on_fire,
      mending_heart,
      heart,
      arrow_right,
      curly_loop,
      loop,
      arrow_heading_up,
      arrow_heading_down,
      arrow_left,
      arrow_up,
      arrow_down,
      black_large_square,
      white_large_square,
      star,
      o: o$2,
      wavy_dash,
      part_alternation_mark,
      congratulations,
      secret
    };
    const scriptRel = "modulepreload";
    const assetsURL = function(dep) {
      return "/bfe2/quartz/" + dep;
    };
    const seen = {};
    const __vitePreload = function preload(baseModule, deps, importerUrl) {
      let promise = Promise.resolve();
      if (deps && deps.length > 0) {
        document.getElementsByTagName("link");
        const cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
        const cspNonce = (cspNonceMeta == null ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta == null ? void 0 : cspNonceMeta.getAttribute("nonce"));
        promise = Promise.all(deps.map((dep) => {
          dep = assetsURL(dep);
          if (dep in seen)
            return;
          seen[dep] = true;
          const isCss = dep.endsWith(".css");
          const cssSelector = isCss ? '[rel="stylesheet"]' : "";
          if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
            return;
          }
          const link2 = document.createElement("link");
          link2.rel = isCss ? "stylesheet" : scriptRel;
          if (!isCss) {
            link2.as = "script";
            link2.crossOrigin = "";
          }
          link2.href = dep;
          if (cspNonce) {
            link2.setAttribute("nonce", cspNonce);
          }
          document.head.appendChild(link2);
          if (isCss) {
            return new Promise((res, rej) => {
              link2.addEventListener("load", res);
              link2.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
            });
          }
        }));
      }
      return promise.then(() => baseModule()).catch((err) => {
        const e2 = new Event("vite:preloadError", { cancelable: true });
        e2.payload = err;
        window.dispatchEvent(e2);
        if (!e2.defaultPrevented) {
          throw err;
        }
      });
    };
    const isff = typeof navigator !== "undefined" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : false;
    function addEvent(object, event2, method, useCapture) {
      if (object.addEventListener) {
        object.addEventListener(event2, method, useCapture);
      } else if (object.attachEvent) {
        object.attachEvent("on".concat(event2), method);
      }
    }
    function removeEvent(object, event2, method, useCapture) {
      if (object.removeEventListener) {
        object.removeEventListener(event2, method, useCapture);
      } else if (object.detachEvent) {
        object.detachEvent("on".concat(event2), method);
      }
    }
    function getMods(modifier, key2) {
      const mods = key2.slice(0, key2.length - 1);
      for (let i2 = 0; i2 < mods.length; i2++)
        mods[i2] = modifier[mods[i2].toLowerCase()];
      return mods;
    }
    function getKeys(key2) {
      if (typeof key2 !== "string")
        key2 = "";
      key2 = key2.replace(/\s/g, "");
      const keys = key2.split(",");
      let index2 = keys.lastIndexOf("");
      for (; index2 >= 0; ) {
        keys[index2 - 1] += ",";
        keys.splice(index2, 1);
        index2 = keys.lastIndexOf("");
      }
      return keys;
    }
    function compareArray(a1, a2) {
      const arr1 = a1.length >= a2.length ? a1 : a2;
      const arr2 = a1.length >= a2.length ? a2 : a1;
      let isIndex2 = true;
      for (let i2 = 0; i2 < arr1.length; i2++) {
        if (arr2.indexOf(arr1[i2]) === -1)
          isIndex2 = false;
      }
      return isIndex2;
    }
    const _keyMap = {
      backspace: 8,
      "⌫": 8,
      tab: 9,
      clear: 12,
      enter: 13,
      "↩": 13,
      return: 13,
      esc: 27,
      escape: 27,
      space: 32,
      left: 37,
      up: 38,
      right: 39,
      down: 40,
      del: 46,
      delete: 46,
      ins: 45,
      insert: 45,
      home: 36,
      end: 35,
      pageup: 33,
      pagedown: 34,
      capslock: 20,
      num_0: 96,
      num_1: 97,
      num_2: 98,
      num_3: 99,
      num_4: 100,
      num_5: 101,
      num_6: 102,
      num_7: 103,
      num_8: 104,
      num_9: 105,
      num_multiply: 106,
      num_add: 107,
      num_enter: 108,
      num_subtract: 109,
      num_decimal: 110,
      num_divide: 111,
      "⇪": 20,
      ",": 188,
      ".": 190,
      "/": 191,
      "`": 192,
      "-": isff ? 173 : 189,
      "=": isff ? 61 : 187,
      ";": isff ? 59 : 186,
      "'": 222,
      "[": 219,
      "]": 221,
      "\\": 220
    };
    const _modifier = {
      // shiftKey
      "⇧": 16,
      shift: 16,
      // altKey
      "⌥": 18,
      alt: 18,
      option: 18,
      // ctrlKey
      "⌃": 17,
      ctrl: 17,
      control: 17,
      // metaKey
      "⌘": 91,
      cmd: 91,
      command: 91
    };
    const modifierMap = {
      16: "shiftKey",
      18: "altKey",
      17: "ctrlKey",
      91: "metaKey",
      shiftKey: 16,
      ctrlKey: 17,
      altKey: 18,
      metaKey: 91
    };
    const _mods = {
      16: false,
      18: false,
      17: false,
      91: false
    };
    const _handlers = {};
    for (let k2 = 1; k2 < 20; k2++) {
      _keyMap["f".concat(k2)] = 111 + k2;
    }
    let _downKeys = [];
    let winListendFocus = null;
    let _scope = "all";
    const elementEventMap = /* @__PURE__ */ new Map();
    const code = (x2) => _keyMap[x2.toLowerCase()] || _modifier[x2.toLowerCase()] || x2.toUpperCase().charCodeAt(0);
    const getKey = (x2) => Object.keys(_keyMap).find((k2) => _keyMap[k2] === x2);
    const getModifier = (x2) => Object.keys(_modifier).find((k2) => _modifier[k2] === x2);
    function setScope(scope) {
      _scope = scope || "all";
    }
    function getScope() {
      return _scope || "all";
    }
    function getPressedKeyCodes() {
      return _downKeys.slice(0);
    }
    function getPressedKeyString() {
      return _downKeys.map((c2) => getKey(c2) || getModifier(c2) || String.fromCharCode(c2));
    }
    function getAllKeyCodes() {
      const result = [];
      Object.keys(_handlers).forEach((k2) => {
        _handlers[k2].forEach((_ref) => {
          let {
            key: key2,
            scope,
            mods,
            shortcut
          } = _ref;
          result.push({
            scope,
            shortcut,
            mods,
            keys: key2.split("+").map((v2) => code(v2))
          });
        });
      });
      return result;
    }
    function filter(event2) {
      const target = event2.target || event2.srcElement;
      const {
        tagName
      } = target;
      let flag = true;
      const isInput2 = tagName === "INPUT" && !["checkbox", "radio", "range", "button", "file", "reset", "submit", "color"].includes(target.type);
      if (target.isContentEditable || (isInput2 || tagName === "TEXTAREA" || tagName === "SELECT") && !target.readOnly) {
        flag = false;
      }
      return flag;
    }
    function isPressed(keyCode) {
      if (typeof keyCode === "string") {
        keyCode = code(keyCode);
      }
      return _downKeys.indexOf(keyCode) !== -1;
    }
    function deleteScope(scope, newScope) {
      let handlers2;
      let i2;
      if (!scope)
        scope = getScope();
      for (const key2 in _handlers) {
        if (Object.prototype.hasOwnProperty.call(_handlers, key2)) {
          handlers2 = _handlers[key2];
          for (i2 = 0; i2 < handlers2.length; ) {
            if (handlers2[i2].scope === scope) {
              const deleteItems = handlers2.splice(i2, 1);
              deleteItems.forEach((_ref2) => {
                let {
                  element
                } = _ref2;
                return removeKeyEvent(element);
              });
            } else {
              i2++;
            }
          }
        }
      }
      if (getScope() === scope)
        setScope(newScope || "all");
    }
    function clearModifier(event2) {
      let key2 = event2.keyCode || event2.which || event2.charCode;
      const i2 = _downKeys.indexOf(key2);
      if (i2 >= 0) {
        _downKeys.splice(i2, 1);
      }
      if (event2.key && event2.key.toLowerCase() === "meta") {
        _downKeys.splice(0, _downKeys.length);
      }
      if (key2 === 93 || key2 === 224)
        key2 = 91;
      if (key2 in _mods) {
        _mods[key2] = false;
        for (const k2 in _modifier)
          if (_modifier[k2] === key2)
            hotkeys[k2] = false;
      }
    }
    function unbind(keysInfo) {
      if (typeof keysInfo === "undefined") {
        Object.keys(_handlers).forEach((key2) => {
          Array.isArray(_handlers[key2]) && _handlers[key2].forEach((info) => eachUnbind(info));
          delete _handlers[key2];
        });
        removeKeyEvent(null);
      } else if (Array.isArray(keysInfo)) {
        keysInfo.forEach((info) => {
          if (info.key)
            eachUnbind(info);
        });
      } else if (typeof keysInfo === "object") {
        if (keysInfo.key)
          eachUnbind(keysInfo);
      } else if (typeof keysInfo === "string") {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        let [scope, method] = args;
        if (typeof scope === "function") {
          method = scope;
          scope = "";
        }
        eachUnbind({
          key: keysInfo,
          scope,
          method,
          splitKey: "+"
        });
      }
    }
    const eachUnbind = (_ref3) => {
      let {
        key: key2,
        scope,
        method,
        splitKey = "+"
      } = _ref3;
      const multipleKeys = getKeys(key2);
      multipleKeys.forEach((originKey) => {
        const unbindKeys = originKey.split(splitKey);
        const len = unbindKeys.length;
        const lastKey = unbindKeys[len - 1];
        const keyCode = lastKey === "*" ? "*" : code(lastKey);
        if (!_handlers[keyCode])
          return;
        if (!scope)
          scope = getScope();
        const mods = len > 1 ? getMods(_modifier, unbindKeys) : [];
        const unbindElements = [];
        _handlers[keyCode] = _handlers[keyCode].filter((record) => {
          const isMatchingMethod = method ? record.method === method : true;
          const isUnbind = isMatchingMethod && record.scope === scope && compareArray(record.mods, mods);
          if (isUnbind)
            unbindElements.push(record.element);
          return !isUnbind;
        });
        unbindElements.forEach((element) => removeKeyEvent(element));
      });
    };
    function eventHandler(event2, handler, scope, element) {
      if (handler.element !== element) {
        return;
      }
      let modifiersMatch;
      if (handler.scope === scope || handler.scope === "all") {
        modifiersMatch = handler.mods.length > 0;
        for (const y2 in _mods) {
          if (Object.prototype.hasOwnProperty.call(_mods, y2)) {
            if (!_mods[y2] && handler.mods.indexOf(+y2) > -1 || _mods[y2] && handler.mods.indexOf(+y2) === -1) {
              modifiersMatch = false;
            }
          }
        }
        if (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch || handler.shortcut === "*") {
          handler.keys = [];
          handler.keys = handler.keys.concat(_downKeys);
          if (handler.method(event2, handler) === false) {
            if (event2.preventDefault)
              event2.preventDefault();
            else
              event2.returnValue = false;
            if (event2.stopPropagation)
              event2.stopPropagation();
            if (event2.cancelBubble)
              event2.cancelBubble = true;
          }
        }
      }
    }
    function dispatch(event2, element) {
      const asterisk = _handlers["*"];
      let key2 = event2.keyCode || event2.which || event2.charCode;
      if (!hotkeys.filter.call(this, event2))
        return;
      if (key2 === 93 || key2 === 224)
        key2 = 91;
      if (_downKeys.indexOf(key2) === -1 && key2 !== 229)
        _downKeys.push(key2);
      ["ctrlKey", "altKey", "shiftKey", "metaKey"].forEach((keyName) => {
        const keyNum = modifierMap[keyName];
        if (event2[keyName] && _downKeys.indexOf(keyNum) === -1) {
          _downKeys.push(keyNum);
        } else if (!event2[keyName] && _downKeys.indexOf(keyNum) > -1) {
          _downKeys.splice(_downKeys.indexOf(keyNum), 1);
        } else if (keyName === "metaKey" && event2[keyName] && _downKeys.length === 3) {
          if (!(event2.ctrlKey || event2.shiftKey || event2.altKey)) {
            _downKeys = _downKeys.slice(_downKeys.indexOf(keyNum));
          }
        }
      });
      if (key2 in _mods) {
        _mods[key2] = true;
        for (const k2 in _modifier) {
          if (_modifier[k2] === key2)
            hotkeys[k2] = true;
        }
        if (!asterisk)
          return;
      }
      for (const e2 in _mods) {
        if (Object.prototype.hasOwnProperty.call(_mods, e2)) {
          _mods[e2] = event2[modifierMap[e2]];
        }
      }
      if (event2.getModifierState && !(event2.altKey && !event2.ctrlKey) && event2.getModifierState("AltGraph")) {
        if (_downKeys.indexOf(17) === -1) {
          _downKeys.push(17);
        }
        if (_downKeys.indexOf(18) === -1) {
          _downKeys.push(18);
        }
        _mods[17] = true;
        _mods[18] = true;
      }
      const scope = getScope();
      if (asterisk) {
        for (let i2 = 0; i2 < asterisk.length; i2++) {
          if (asterisk[i2].scope === scope && (event2.type === "keydown" && asterisk[i2].keydown || event2.type === "keyup" && asterisk[i2].keyup)) {
            eventHandler(event2, asterisk[i2], scope, element);
          }
        }
      }
      if (!(key2 in _handlers))
        return;
      const handlerKey = _handlers[key2];
      const keyLen = handlerKey.length;
      for (let i2 = 0; i2 < keyLen; i2++) {
        if (event2.type === "keydown" && handlerKey[i2].keydown || event2.type === "keyup" && handlerKey[i2].keyup) {
          if (handlerKey[i2].key) {
            const record = handlerKey[i2];
            const {
              splitKey
            } = record;
            const keyShortcut = record.key.split(splitKey);
            const _downKeysCurrent = [];
            for (let a2 = 0; a2 < keyShortcut.length; a2++) {
              _downKeysCurrent.push(code(keyShortcut[a2]));
            }
            if (_downKeysCurrent.sort().join("") === _downKeys.sort().join("")) {
              eventHandler(event2, record, scope, element);
            }
          }
        }
      }
    }
    function hotkeys(key2, option, method) {
      _downKeys = [];
      const keys = getKeys(key2);
      let mods = [];
      let scope = "all";
      let element = document;
      let i2 = 0;
      let keyup = false;
      let keydown = true;
      let splitKey = "+";
      let capture = false;
      let single = false;
      if (method === void 0 && typeof option === "function") {
        method = option;
      }
      if (Object.prototype.toString.call(option) === "[object Object]") {
        if (option.scope)
          scope = option.scope;
        if (option.element)
          element = option.element;
        if (option.keyup)
          keyup = option.keyup;
        if (option.keydown !== void 0)
          keydown = option.keydown;
        if (option.capture !== void 0)
          capture = option.capture;
        if (typeof option.splitKey === "string")
          splitKey = option.splitKey;
        if (option.single === true)
          single = true;
      }
      if (typeof option === "string")
        scope = option;
      if (single)
        unbind(key2, scope);
      for (; i2 < keys.length; i2++) {
        key2 = keys[i2].split(splitKey);
        mods = [];
        if (key2.length > 1)
          mods = getMods(_modifier, key2);
        key2 = key2[key2.length - 1];
        key2 = key2 === "*" ? "*" : code(key2);
        if (!(key2 in _handlers))
          _handlers[key2] = [];
        _handlers[key2].push({
          keyup,
          keydown,
          scope,
          mods,
          shortcut: keys[i2],
          method,
          key: keys[i2],
          splitKey,
          element
        });
      }
      if (typeof element !== "undefined" && window) {
        if (!elementEventMap.has(element)) {
          const keydownListener = function() {
            let event2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;
            return dispatch(event2, element);
          };
          const keyupListenr = function() {
            let event2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;
            dispatch(event2, element);
            clearModifier(event2);
          };
          elementEventMap.set(element, {
            keydownListener,
            keyupListenr,
            capture
          });
          addEvent(element, "keydown", keydownListener, capture);
          addEvent(element, "keyup", keyupListenr, capture);
        }
        if (!winListendFocus) {
          const listener = () => {
            _downKeys = [];
          };
          winListendFocus = {
            listener,
            capture
          };
          addEvent(window, "focus", listener, capture);
        }
      }
    }
    function trigger(shortcut) {
      let scope = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "all";
      Object.keys(_handlers).forEach((key2) => {
        const dataList = _handlers[key2].filter((item) => item.scope === scope && item.shortcut === shortcut);
        dataList.forEach((data) => {
          if (data && data.method) {
            data.method();
          }
        });
      });
    }
    function removeKeyEvent(element) {
      const values = Object.values(_handlers).flat();
      const findindex = values.findIndex((_ref4) => {
        let {
          element: el
        } = _ref4;
        return el === element;
      });
      if (findindex < 0) {
        const {
          keydownListener,
          keyupListenr,
          capture
        } = elementEventMap.get(element) || {};
        if (keydownListener && keyupListenr) {
          removeEvent(element, "keyup", keyupListenr, capture);
          removeEvent(element, "keydown", keydownListener, capture);
          elementEventMap.delete(element);
        }
      }
      if (values.length <= 0 || elementEventMap.size <= 0) {
        const eventKeys = Object.keys(elementEventMap);
        eventKeys.forEach((el) => {
          const {
            keydownListener,
            keyupListenr,
            capture
          } = elementEventMap.get(el) || {};
          if (keydownListener && keyupListenr) {
            removeEvent(el, "keyup", keyupListenr, capture);
            removeEvent(el, "keydown", keydownListener, capture);
            elementEventMap.delete(el);
          }
        });
        elementEventMap.clear();
        Object.keys(_handlers).forEach((key2) => delete _handlers[key2]);
        if (winListendFocus) {
          const {
            listener,
            capture
          } = winListendFocus;
          removeEvent(window, "focus", listener, capture);
          winListendFocus = null;
        }
      }
    }
    const _api = {
      getPressedKeyString,
      setScope,
      getScope,
      deleteScope,
      getPressedKeyCodes,
      getAllKeyCodes,
      isPressed,
      filter,
      trigger,
      unbind,
      keyMap: _keyMap,
      modifier: _modifier,
      modifierMap
    };
    for (const a2 in _api) {
      if (Object.prototype.hasOwnProperty.call(_api, a2)) {
        hotkeys[a2] = _api[a2];
      }
    }
    if (typeof window !== "undefined") {
      const _hotkeys = window.hotkeys;
      hotkeys.noConflict = (deep) => {
        if (deep && window.hotkeys === hotkeys) {
          window.hotkeys = _hotkeys;
        }
        return hotkeys;
      };
      window.hotkeys = hotkeys;
    }
    hotkeys.filter = function() {
      return true;
    };
    const hotkey_manager = {
      props: {
        item: {
          type: Object,
          required: true
        }
      },
      computed: {
        isMacLike: () => /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform),
        hotkey() {
          let s2 = this.item.hotkey;
          if (typeof s2 != "string")
            return false;
          s2 = s2.toUpperCase();
          s2 = s2.replace(/(shift|⇧)\+/ig, this.isMacLike ? "⇧" : "Shift+");
          s2 = s2.replace(/(control|ctrl|⌃)\+/ig, this.isMacLike ? "⌃" : "Ctrl+");
          s2 = s2.replace(/(option|alt|⌥)\+/ig, this.isMacLike ? "⌥" : "Alt+");
          s2 = s2.replace(/(cmd|command|⌘)\+/ig, this.isMacLike ? "⌘" : "Cmd+");
          return s2;
        }
      },
      methods: {
        update_hotkey(new_hotkey, old_hotkey) {
          if (old_hotkey)
            hotkeys.unbind(old_hotkey, this.hotkey_fn);
          if (new_hotkey)
            hotkeys(new_hotkey, this.hotkey_fn);
        },
        hotkey_fn(event2, handler) {
          event2.preventDefault();
          if (this.item.click && !this.item.disabled)
            this.item.click(event2, handler);
        }
      },
      watch: {
        "item.hotkey": {
          handler: "update_hotkey",
          immediate: true
        }
      },
      beforeUnmount() {
        if (this.item.hotkey)
          hotkeys.unbind(this.item.hotkey, this.hotkey_fn);
      }
    };
    const _sfc_main$t = {
      mixins: [hotkey_manager],
      components: {
        BarMenu: /* @__PURE__ */ defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => BarMenu$1), true ? void 0 : void 0))
        // because of circular reference
      },
      props: {
        item: {
          type: Object,
          required: true
        }
      },
      methods: {
        click(e2) {
          if (this.item.click && !this.item.disabled)
            this.item.click(e2);
          else if (!this.$refs.menu || !e2.composedPath || !e2.composedPath().includes(this.$refs.menu.$el)) {
            e2.stopPropagation();
          }
        },
        get_emoji: (emoji_name) => emoji_name in emoji ? emoji[emoji_name] : "",
        get_component(is) {
          if (is && !Array.isArray(is) && typeof is == "object")
            return is;
          else
            return "bar-menu";
        }
      }
    };
    const _hoisted_1$D = ["title"];
    const _hoisted_2$u = {
      key: 1,
      class: "material-icons icon"
    };
    const _hoisted_3$q = {
      key: 1,
      class: "emoji"
    };
    const _hoisted_4$p = {
      key: 2,
      class: "label"
    };
    const _hoisted_5$j = ["innerHTML"];
    const _hoisted_6$i = {
      key: 4,
      class: "hotkey"
    };
    const _hoisted_7$g = ["innerHTML"];
    const _hoisted_8$c = {
      key: 6,
      class: "material-icons chevron"
    };
    function _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["bar-menu-item", { disabled: $props.item.disabled, active: $props.item.active }]),
        onMousedown: _cache[0] || (_cache[0] = (e2) => e2.preventDefault()),
        onClick: _cache[1] || (_cache[1] = (...args) => $options.click && $options.click(...args)),
        title: $props.item.title,
        style: normalizeStyle({ height: $props.item.height + "px" })
      }, [
        $props.item.icon ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          typeof $props.item.icon == "object" ? (openBlock(), createBlock(resolveDynamicComponent($props.item.icon), {
            key: 0,
            class: "icon"
          })) : (openBlock(), createElementBlock("span", _hoisted_2$u, toDisplayString$2($props.item.icon), 1))
        ], 64)) : createCommentVNode("", true),
        $props.item.emoji ? (openBlock(), createElementBlock("span", _hoisted_3$q, toDisplayString$2($options.get_emoji($props.item.emoji)), 1)) : createCommentVNode("", true),
        $props.item.text ? (openBlock(), createElementBlock("span", _hoisted_4$p, toDisplayString$2($props.item.text), 1)) : createCommentVNode("", true),
        $props.item.html ? (openBlock(), createElementBlock("span", {
          key: 3,
          class: "label",
          innerHTML: $props.item.html
        }, null, 8, _hoisted_5$j)) : createCommentVNode("", true),
        $props.item.hotkey ? (openBlock(), createElementBlock("span", _hoisted_6$i, toDisplayString$2(_ctx.hotkey), 1)) : createCommentVNode("", true),
        $props.item.menu && $props.item.custom_chevron ? (openBlock(), createElementBlock("span", {
          key: 5,
          class: "chevron",
          innerHTML: $props.item.custom_chevron
        }, null, 8, _hoisted_7$g)) : $props.item.menu ? (openBlock(), createElementBlock("span", _hoisted_8$c, "chevron_right")) : createCommentVNode("", true),
        $props.item.menu ? (openBlock(), createBlock(resolveDynamicComponent($options.get_component($props.item.menu)), {
          key: 7,
          ref: "menu",
          class: normalizeClass(["menu", $props.item.menu_class]),
          menu: $props.item.menu,
          id: $props.item.menu_id,
          width: $props.item.menu_width,
          height: $props.item.menu_height
        }, null, 8, ["menu", "class", "id", "width", "height"])) : createCommentVNode("", true)
      ], 46, _hoisted_1$D);
    }
    const BarMenuItem = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["render", _sfc_render$r]]);
    const _sfc_main$s = {};
    const _hoisted_1$C = { class: "bar-menu-separator" };
    function _sfc_render$q(_ctx, _cache) {
      return openBlock(), createElementBlock("div", _hoisted_1$C);
    }
    const BarMenuSeparator = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["render", _sfc_render$q]]);
    const _sfc_main$r = {
      components: {
        BarMenuItem,
        BarMenuSeparator
      },
      props: {
        menu: {
          type: Array,
          required: true
        },
        width: Number,
        height: Number
      },
      methods: {
        get_component(is) {
          if (typeof is == "object")
            return is;
          else if (typeof is == "string")
            return "bar-menu-" + is;
          else
            return "bar-menu-item";
        }
      }
    };
    const _hoisted_1$B = { class: "bar-menu" };
    const _hoisted_2$t = /* @__PURE__ */ createBaseVNode("div", { class: "extended-hover-zone" }, null, -1);
    function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$B, [
        _hoisted_2$t,
        createBaseVNode("div", {
          class: "bar-menu-items",
          style: normalizeStyle({
            width: $props.width + "px",
            minWidth: $props.width + "px",
            maxHeight: $props.height + "px",
            overflow: $props.height ? "auto" : "visible"
          })
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.menu, (item, index2) => {
            return openBlock(), createBlock(resolveDynamicComponent($options.get_component(item.is)), {
              item,
              class: normalizeClass(item.class),
              id: item.id,
              key: "menu-" + index2
            }, null, 8, ["item", "class", "id"]);
          }), 128))
        ], 4)
      ]);
    }
    const BarMenu = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["render", _sfc_render$p]]);
    const BarMenu$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      default: BarMenu
    }, Symbol.toStringTag, { value: "Module" }));
    const _sfc_main$q = {
      mixins: [hotkey_manager],
      components: {
        BarMenu
      },
      props: {
        item: {
          type: Object,
          required: true
        },
        is_open: Boolean
      },
      computed: {
        is_menu() {
          return this.item.menu ? true : false;
        },
        button_class() {
          const open = this.is_open && this.is_menu;
          const active = this.item.active;
          const disabled = this.item.disabled;
          return { open, active, disabled };
        },
        title() {
          if (this.item.title) {
            let title = this.item.title;
            if (this.hotkey)
              title += " (" + this.hotkey + ")";
            return title;
          } else
            return null;
        }
      },
      methods: {
        get_emoji: (emoji_name) => emoji_name in emoji ? emoji[emoji_name] : "",
        get_component(is) {
          if (is && !Array.isArray(is) && typeof is == "object")
            return is;
          else
            return "bar-menu";
        }
      }
    };
    const _hoisted_1$A = ["title"];
    const _hoisted_2$s = {
      key: 1,
      class: "material-icons icon"
    };
    const _hoisted_3$p = {
      key: 1,
      class: "emoji"
    };
    const _hoisted_4$o = {
      key: 2,
      class: "label"
    };
    const _hoisted_5$i = ["innerHTML"];
    const _hoisted_6$h = {
      key: 4,
      class: "material-icons chevron"
    };
    const _hoisted_7$f = ["innerHTML"];
    function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["bar-button", $options.button_class]),
        title: $options.title,
        onMousedown: _cache[0] || (_cache[0] = (e2) => e2.preventDefault()),
        onClick: _cache[1] || (_cache[1] = (e2) => $props.item.click && !$props.item.disabled ? $props.item.click(e2) : e2.stopPropagation())
      }, [
        $props.item.icon ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          typeof $props.item.icon == "object" ? (openBlock(), createBlock(resolveDynamicComponent($props.item.icon), {
            key: 0,
            class: "icon"
          })) : (openBlock(), createElementBlock("span", _hoisted_2$s, toDisplayString$2($props.item.icon), 1))
        ], 64)) : createCommentVNode("", true),
        $props.item.emoji ? (openBlock(), createElementBlock("span", _hoisted_3$p, toDisplayString$2($options.get_emoji($props.item.emoji)), 1)) : createCommentVNode("", true),
        $props.item.text ? (openBlock(), createElementBlock("span", _hoisted_4$o, toDisplayString$2($props.item.text), 1)) : createCommentVNode("", true),
        $props.item.html ? (openBlock(), createElementBlock("span", {
          key: 3,
          class: "label",
          innerHTML: $props.item.html
        }, null, 8, _hoisted_5$i)) : createCommentVNode("", true),
        $props.item.chevron === true ? (openBlock(), createElementBlock("span", _hoisted_6$h, "expand_more")) : $props.item.chevron ? (openBlock(), createElementBlock("span", {
          key: 5,
          class: "chevron",
          innerHTML: $props.item.chevron
        }, null, 8, _hoisted_7$f)) : createCommentVNode("", true),
        $props.item.menu ? (openBlock(), createBlock(resolveDynamicComponent($options.get_component($props.item.menu)), {
          key: 6,
          class: normalizeClass(["menu", $props.item.menu_class]),
          menu: $props.item.menu,
          id: $props.item.menu_id,
          width: $props.item.menu_width,
          height: $props.item.menu_height
        }, null, 8, ["menu", "class", "id", "width", "height"])) : createCommentVNode("", true)
      ], 42, _hoisted_1$A);
    }
    const BarButtonGeneric = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["render", _sfc_render$o]]);
    const prefix = "";
    function styleInject(css2, ref2) {
      if (ref2 === void 0)
        ref2 = {};
      var insertAt = ref2.insertAt;
      if (!css2 || typeof document === "undefined") {
        return;
      }
      var head = document.head || document.getElementsByTagName("head")[0];
      var style = document.createElement("style");
      style.type = "text/css";
      if (insertAt === "top") {
        if (head.firstChild) {
          head.insertBefore(style, head.firstChild);
        } else {
          head.appendChild(style);
        }
      } else {
        head.appendChild(style);
      }
      if (style.styleSheet) {
        style.styleSheet.cssText = css2;
      } else {
        style.appendChild(document.createTextNode(css2));
      }
    }
    const install = function(app2, options) {
      const { componentPrefix = prefix } = options || {};
      app2.component(`${componentPrefix}${this.name}`, this);
    };
    const _checkboardCache = {};
    var script$d = {
      name: "Checkboard",
      props: {
        size: {
          type: [Number, String],
          default: 8
        },
        white: {
          type: String,
          default: "#fff"
        },
        grey: {
          type: String,
          default: "#e6e6e6"
        }
      },
      computed: {
        bgStyle() {
          return {
            "background-image": `url(${getCheckboard(this.white, this.grey, this.size)})`
          };
        }
      }
    };
    function renderCheckboard(c1, c2, size2) {
      if (typeof document === "undefined")
        return null;
      const canvas = document.createElement("canvas");
      canvas.width = canvas.height = size2 * 2;
      const ctx = canvas.getContext("2d");
      if (!ctx)
        return null;
      ctx.fillStyle = c1;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = c2;
      ctx.fillRect(0, 0, size2, size2);
      ctx.translate(size2, size2);
      ctx.fillRect(0, 0, size2, size2);
      return canvas.toDataURL();
    }
    function getCheckboard(c1, c2, size2) {
      const key2 = `${c1},${c2},${size2}`;
      if (_checkboardCache[key2])
        return _checkboardCache[key2];
      const checkboard = renderCheckboard(c1, c2, size2);
      _checkboardCache[key2] = checkboard;
      return checkboard;
    }
    function render$d(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock(
        "div",
        {
          class: "vc-checkerboard",
          style: normalizeStyle($options.bgStyle)
        },
        null,
        4
        /* STYLE */
      );
    }
    var css_248z$d = ".vc-checkerboard{background-size:contain;bottom:0;left:0;position:absolute;right:0;top:0}";
    styleInject(css_248z$d);
    script$d.render = render$d;
    script$d.__file = "src/components/checkboard/checkboard.vue";
    script$d.install = install;
    var script$c = {
      name: "Alpha",
      components: {
        Checkboard: script$d
      },
      props: {
        value: Object,
        onChange: Function
      },
      computed: {
        colors() {
          return this.value;
        },
        gradientColor() {
          const { rgba } = this.colors;
          const rgbStr = [rgba.r, rgba.g, rgba.b].join(",");
          return `linear-gradient(to right, rgba(${rgbStr}, 0) 0%, rgba(${rgbStr}, 1) 100%)`;
        }
      },
      methods: {
        handleChange(e2, skip) {
          !skip && e2.preventDefault();
          const { container } = this.$refs;
          if (!container) {
            return;
          }
          const containerWidth = container.clientWidth;
          const xOffset = container.getBoundingClientRect().left + window.pageXOffset;
          const pageX = e2.pageX || (e2.touches ? e2.touches[0].pageX : 0);
          const left2 = pageX - xOffset;
          let a2;
          if (left2 < 0)
            a2 = 0;
          else if (left2 > containerWidth)
            a2 = 1;
          else
            a2 = Math.round(left2 * 100 / containerWidth) / 100;
          if (this.colors.a !== a2) {
            this.$emit("change", {
              h: this.colors.hsl.h,
              s: this.colors.hsl.s,
              l: this.colors.hsl.l,
              a: a2,
              source: "rgba"
            });
          }
        },
        handleMouseDown(e2) {
          this.handleChange(e2, true);
          window.addEventListener("mousemove", this.handleChange);
          window.addEventListener("mouseup", this.handleMouseUp);
        },
        handleMouseUp() {
          this.unbindEventListeners();
        },
        unbindEventListeners() {
          window.removeEventListener("mousemove", this.handleChange);
          window.removeEventListener("mouseup", this.handleMouseUp);
        }
      }
    };
    const _hoisted_1$z = { class: "vc-alpha" };
    const _hoisted_2$r = { class: "vc-alpha-checkboard-wrap" };
    const _hoisted_3$o = /* @__PURE__ */ createBaseVNode(
      "div",
      { class: "vc-alpha-picker" },
      null,
      -1
      /* HOISTED */
    );
    const _hoisted_4$n = [
      _hoisted_3$o
    ];
    function render$c(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Checkboard = resolveComponent("Checkboard");
      return openBlock(), createElementBlock("div", _hoisted_1$z, [
        createBaseVNode("div", _hoisted_2$r, [
          createVNode(_component_Checkboard)
        ]),
        createBaseVNode(
          "div",
          {
            class: "vc-alpha-gradient",
            style: normalizeStyle({ background: $options.gradientColor })
          },
          null,
          4
          /* STYLE */
        ),
        createBaseVNode(
          "div",
          {
            ref: "container",
            class: "vc-alpha-container",
            onMousedown: _cache[0] || (_cache[0] = (...args) => $options.handleMouseDown && $options.handleMouseDown(...args)),
            onTouchmove: _cache[1] || (_cache[1] = (...args) => $options.handleChange && $options.handleChange(...args)),
            onTouchstart: _cache[2] || (_cache[2] = (...args) => $options.handleChange && $options.handleChange(...args))
          },
          [
            createBaseVNode(
              "div",
              {
                class: "vc-alpha-pointer",
                style: normalizeStyle({ left: `${$options.colors.a * 100}%` })
              },
              _hoisted_4$n,
              4
              /* STYLE */
            )
          ],
          544
          /* HYDRATE_EVENTS, NEED_PATCH */
        )
      ]);
    }
    var css_248z$c = ".vc-alpha,.vc-alpha-checkboard-wrap{bottom:0;left:0;position:absolute;right:0;top:0}.vc-alpha-checkboard-wrap{overflow:hidden}.vc-alpha-gradient{bottom:0;left:0;position:absolute;right:0;top:0}.vc-alpha-container{cursor:pointer;height:100%;margin:0 3px;position:relative;z-index:2}.vc-alpha-pointer{position:absolute;z-index:2}.vc-alpha-picker{background:#fff;border-radius:1px;box-shadow:0 0 2px rgba(0,0,0,.6);cursor:pointer;height:8px;margin-top:1px;transform:translateX(-2px);width:4px}";
    styleInject(css_248z$c);
    script$c.render = render$c;
    script$c.__file = "src/components/alpha/alpha.vue";
    script$c.install = install;
    function bound01(n2, max2) {
      if (isOnePointZero(n2)) {
        n2 = "100%";
      }
      var isPercent = isPercentage(n2);
      n2 = max2 === 360 ? n2 : Math.min(max2, Math.max(0, parseFloat(n2)));
      if (isPercent) {
        n2 = parseInt(String(n2 * max2), 10) / 100;
      }
      if (Math.abs(n2 - max2) < 1e-6) {
        return 1;
      }
      if (max2 === 360) {
        n2 = (n2 < 0 ? n2 % max2 + max2 : n2 % max2) / parseFloat(String(max2));
      } else {
        n2 = n2 % max2 / parseFloat(String(max2));
      }
      return n2;
    }
    function clamp01(val) {
      return Math.min(1, Math.max(0, val));
    }
    function isOnePointZero(n2) {
      return typeof n2 === "string" && n2.indexOf(".") !== -1 && parseFloat(n2) === 1;
    }
    function isPercentage(n2) {
      return typeof n2 === "string" && n2.indexOf("%") !== -1;
    }
    function boundAlpha(a2) {
      a2 = parseFloat(a2);
      if (isNaN(a2) || a2 < 0 || a2 > 1) {
        a2 = 1;
      }
      return a2;
    }
    function convertToPercentage(n2) {
      if (n2 <= 1) {
        return "".concat(Number(n2) * 100, "%");
      }
      return n2;
    }
    function pad2(c2) {
      return c2.length === 1 ? "0" + c2 : String(c2);
    }
    function rgbToRgb(r2, g2, b2) {
      return {
        r: bound01(r2, 255) * 255,
        g: bound01(g2, 255) * 255,
        b: bound01(b2, 255) * 255
      };
    }
    function rgbToHsl(r2, g2, b2) {
      r2 = bound01(r2, 255);
      g2 = bound01(g2, 255);
      b2 = bound01(b2, 255);
      var max2 = Math.max(r2, g2, b2);
      var min2 = Math.min(r2, g2, b2);
      var h2 = 0;
      var s2 = 0;
      var l2 = (max2 + min2) / 2;
      if (max2 === min2) {
        s2 = 0;
        h2 = 0;
      } else {
        var d2 = max2 - min2;
        s2 = l2 > 0.5 ? d2 / (2 - max2 - min2) : d2 / (max2 + min2);
        switch (max2) {
          case r2:
            h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
            break;
          case g2:
            h2 = (b2 - r2) / d2 + 2;
            break;
          case b2:
            h2 = (r2 - g2) / d2 + 4;
            break;
        }
        h2 /= 6;
      }
      return { h: h2, s: s2, l: l2 };
    }
    function hue2rgb(p2, q2, t2) {
      if (t2 < 0) {
        t2 += 1;
      }
      if (t2 > 1) {
        t2 -= 1;
      }
      if (t2 < 1 / 6) {
        return p2 + (q2 - p2) * (6 * t2);
      }
      if (t2 < 1 / 2) {
        return q2;
      }
      if (t2 < 2 / 3) {
        return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
      }
      return p2;
    }
    function hslToRgb(h2, s2, l2) {
      var r2;
      var g2;
      var b2;
      h2 = bound01(h2, 360);
      s2 = bound01(s2, 100);
      l2 = bound01(l2, 100);
      if (s2 === 0) {
        g2 = l2;
        b2 = l2;
        r2 = l2;
      } else {
        var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
        var p2 = 2 * l2 - q2;
        r2 = hue2rgb(p2, q2, h2 + 1 / 3);
        g2 = hue2rgb(p2, q2, h2);
        b2 = hue2rgb(p2, q2, h2 - 1 / 3);
      }
      return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
    }
    function rgbToHsv(r2, g2, b2) {
      r2 = bound01(r2, 255);
      g2 = bound01(g2, 255);
      b2 = bound01(b2, 255);
      var max2 = Math.max(r2, g2, b2);
      var min2 = Math.min(r2, g2, b2);
      var h2 = 0;
      var v2 = max2;
      var d2 = max2 - min2;
      var s2 = max2 === 0 ? 0 : d2 / max2;
      if (max2 === min2) {
        h2 = 0;
      } else {
        switch (max2) {
          case r2:
            h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
            break;
          case g2:
            h2 = (b2 - r2) / d2 + 2;
            break;
          case b2:
            h2 = (r2 - g2) / d2 + 4;
            break;
        }
        h2 /= 6;
      }
      return { h: h2, s: s2, v: v2 };
    }
    function hsvToRgb(h2, s2, v2) {
      h2 = bound01(h2, 360) * 6;
      s2 = bound01(s2, 100);
      v2 = bound01(v2, 100);
      var i2 = Math.floor(h2);
      var f2 = h2 - i2;
      var p2 = v2 * (1 - s2);
      var q2 = v2 * (1 - f2 * s2);
      var t2 = v2 * (1 - (1 - f2) * s2);
      var mod = i2 % 6;
      var r2 = [v2, q2, p2, p2, t2, v2][mod];
      var g2 = [t2, v2, v2, q2, p2, p2][mod];
      var b2 = [p2, p2, t2, v2, v2, q2][mod];
      return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
    }
    function rgbToHex(r2, g2, b2, allow3Char) {
      var hex = [
        pad2(Math.round(r2).toString(16)),
        pad2(Math.round(g2).toString(16)),
        pad2(Math.round(b2).toString(16))
      ];
      if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
      }
      return hex.join("");
    }
    function rgbaToHex(r2, g2, b2, a2, allow4Char) {
      var hex = [
        pad2(Math.round(r2).toString(16)),
        pad2(Math.round(g2).toString(16)),
        pad2(Math.round(b2).toString(16)),
        pad2(convertDecimalToHex(a2))
      ];
      if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
      }
      return hex.join("");
    }
    function convertDecimalToHex(d2) {
      return Math.round(parseFloat(d2) * 255).toString(16);
    }
    function convertHexToDecimal(h2) {
      return parseIntFromHex(h2) / 255;
    }
    function parseIntFromHex(val) {
      return parseInt(val, 16);
    }
    function numberInputToObject(color) {
      return {
        r: color >> 16,
        g: (color & 65280) >> 8,
        b: color & 255
      };
    }
    var names = {
      aliceblue: "#f0f8ff",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      aquamarine: "#7fffd4",
      azure: "#f0ffff",
      beige: "#f5f5dc",
      bisque: "#ffe4c4",
      black: "#000000",
      blanchedalmond: "#ffebcd",
      blue: "#0000ff",
      blueviolet: "#8a2be2",
      brown: "#a52a2a",
      burlywood: "#deb887",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      cornflowerblue: "#6495ed",
      cornsilk: "#fff8dc",
      crimson: "#dc143c",
      cyan: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkgray: "#a9a9a9",
      darkgreen: "#006400",
      darkgrey: "#a9a9a9",
      darkkhaki: "#bdb76b",
      darkmagenta: "#8b008b",
      darkolivegreen: "#556b2f",
      darkorange: "#ff8c00",
      darkorchid: "#9932cc",
      darkred: "#8b0000",
      darksalmon: "#e9967a",
      darkseagreen: "#8fbc8f",
      darkslateblue: "#483d8b",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      darkturquoise: "#00ced1",
      darkviolet: "#9400d3",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1e90ff",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      forestgreen: "#228b22",
      fuchsia: "#ff00ff",
      gainsboro: "#dcdcdc",
      ghostwhite: "#f8f8ff",
      goldenrod: "#daa520",
      gold: "#ffd700",
      gray: "#808080",
      green: "#008000",
      greenyellow: "#adff2f",
      grey: "#808080",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      ivory: "#fffff0",
      khaki: "#f0e68c",
      lavenderblush: "#fff0f5",
      lavender: "#e6e6fa",
      lawngreen: "#7cfc00",
      lemonchiffon: "#fffacd",
      lightblue: "#add8e6",
      lightcoral: "#f08080",
      lightcyan: "#e0ffff",
      lightgoldenrodyellow: "#fafad2",
      lightgray: "#d3d3d3",
      lightgreen: "#90ee90",
      lightgrey: "#d3d3d3",
      lightpink: "#ffb6c1",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      lightskyblue: "#87cefa",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      lightsteelblue: "#b0c4de",
      lightyellow: "#ffffe0",
      lime: "#00ff00",
      limegreen: "#32cd32",
      linen: "#faf0e6",
      magenta: "#ff00ff",
      maroon: "#800000",
      mediumaquamarine: "#66cdaa",
      mediumblue: "#0000cd",
      mediumorchid: "#ba55d3",
      mediumpurple: "#9370db",
      mediumseagreen: "#3cb371",
      mediumslateblue: "#7b68ee",
      mediumspringgreen: "#00fa9a",
      mediumturquoise: "#48d1cc",
      mediumvioletred: "#c71585",
      midnightblue: "#191970",
      mintcream: "#f5fffa",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      navajowhite: "#ffdead",
      navy: "#000080",
      oldlace: "#fdf5e6",
      olive: "#808000",
      olivedrab: "#6b8e23",
      orange: "#ffa500",
      orangered: "#ff4500",
      orchid: "#da70d6",
      palegoldenrod: "#eee8aa",
      palegreen: "#98fb98",
      paleturquoise: "#afeeee",
      palevioletred: "#db7093",
      papayawhip: "#ffefd5",
      peachpuff: "#ffdab9",
      peru: "#cd853f",
      pink: "#ffc0cb",
      plum: "#dda0dd",
      powderblue: "#b0e0e6",
      purple: "#800080",
      rebeccapurple: "#663399",
      red: "#ff0000",
      rosybrown: "#bc8f8f",
      royalblue: "#4169e1",
      saddlebrown: "#8b4513",
      salmon: "#fa8072",
      sandybrown: "#f4a460",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      sienna: "#a0522d",
      silver: "#c0c0c0",
      skyblue: "#87ceeb",
      slateblue: "#6a5acd",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#fffafa",
      springgreen: "#00ff7f",
      steelblue: "#4682b4",
      tan: "#d2b48c",
      teal: "#008080",
      thistle: "#d8bfd8",
      tomato: "#ff6347",
      turquoise: "#40e0d0",
      violet: "#ee82ee",
      wheat: "#f5deb3",
      white: "#ffffff",
      whitesmoke: "#f5f5f5",
      yellow: "#ffff00",
      yellowgreen: "#9acd32"
    };
    function inputToRGB(color) {
      var rgb = { r: 0, g: 0, b: 0 };
      var a2 = 1;
      var s2 = null;
      var v2 = null;
      var l2 = null;
      var ok2 = false;
      var format2 = false;
      if (typeof color === "string") {
        color = stringInputToObject(color);
      }
      if (typeof color === "object") {
        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
          rgb = rgbToRgb(color.r, color.g, color.b);
          ok2 = true;
          format2 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
          s2 = convertToPercentage(color.s);
          v2 = convertToPercentage(color.v);
          rgb = hsvToRgb(color.h, s2, v2);
          ok2 = true;
          format2 = "hsv";
        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
          s2 = convertToPercentage(color.s);
          l2 = convertToPercentage(color.l);
          rgb = hslToRgb(color.h, s2, l2);
          ok2 = true;
          format2 = "hsl";
        }
        if (Object.prototype.hasOwnProperty.call(color, "a")) {
          a2 = color.a;
        }
      }
      a2 = boundAlpha(a2);
      return {
        ok: ok2,
        format: color.format || format2,
        r: Math.min(255, Math.max(rgb.r, 0)),
        g: Math.min(255, Math.max(rgb.g, 0)),
        b: Math.min(255, Math.max(rgb.b, 0)),
        a: a2
      };
    }
    var CSS_INTEGER = "[-\\+]?\\d+%?";
    var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
    var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
    var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
    var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
    var matchers = {
      CSS_UNIT: new RegExp(CSS_UNIT),
      rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
      rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
      hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
      hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
      hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
      hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
      hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
      hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
    function stringInputToObject(color) {
      color = color.trim().toLowerCase();
      if (color.length === 0) {
        return false;
      }
      var named = false;
      if (names[color]) {
        color = names[color];
        named = true;
      } else if (color === "transparent") {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
      }
      var match = matchers.rgb.exec(color);
      if (match) {
        return { r: match[1], g: match[2], b: match[3] };
      }
      match = matchers.rgba.exec(color);
      if (match) {
        return { r: match[1], g: match[2], b: match[3], a: match[4] };
      }
      match = matchers.hsl.exec(color);
      if (match) {
        return { h: match[1], s: match[2], l: match[3] };
      }
      match = matchers.hsla.exec(color);
      if (match) {
        return { h: match[1], s: match[2], l: match[3], a: match[4] };
      }
      match = matchers.hsv.exec(color);
      if (match) {
        return { h: match[1], s: match[2], v: match[3] };
      }
      match = matchers.hsva.exec(color);
      if (match) {
        return { h: match[1], s: match[2], v: match[3], a: match[4] };
      }
      match = matchers.hex8.exec(color);
      if (match) {
        return {
          r: parseIntFromHex(match[1]),
          g: parseIntFromHex(match[2]),
          b: parseIntFromHex(match[3]),
          a: convertHexToDecimal(match[4]),
          format: named ? "name" : "hex8"
        };
      }
      match = matchers.hex6.exec(color);
      if (match) {
        return {
          r: parseIntFromHex(match[1]),
          g: parseIntFromHex(match[2]),
          b: parseIntFromHex(match[3]),
          format: named ? "name" : "hex"
        };
      }
      match = matchers.hex4.exec(color);
      if (match) {
        return {
          r: parseIntFromHex(match[1] + match[1]),
          g: parseIntFromHex(match[2] + match[2]),
          b: parseIntFromHex(match[3] + match[3]),
          a: convertHexToDecimal(match[4] + match[4]),
          format: named ? "name" : "hex8"
        };
      }
      match = matchers.hex3.exec(color);
      if (match) {
        return {
          r: parseIntFromHex(match[1] + match[1]),
          g: parseIntFromHex(match[2] + match[2]),
          b: parseIntFromHex(match[3] + match[3]),
          format: named ? "name" : "hex"
        };
      }
      return false;
    }
    function isValidCSSUnit(color) {
      return Boolean(matchers.CSS_UNIT.exec(String(color)));
    }
    var TinyColor = (
      /** @class */
      function() {
        function TinyColor2(color, opts) {
          if (color === void 0) {
            color = "";
          }
          if (opts === void 0) {
            opts = {};
          }
          var _a;
          if (color instanceof TinyColor2) {
            return color;
          }
          if (typeof color === "number") {
            color = numberInputToObject(color);
          }
          this.originalInput = color;
          var rgb = inputToRGB(color);
          this.originalInput = color;
          this.r = rgb.r;
          this.g = rgb.g;
          this.b = rgb.b;
          this.a = rgb.a;
          this.roundA = Math.round(100 * this.a) / 100;
          this.format = (_a = opts.format) !== null && _a !== void 0 ? _a : rgb.format;
          this.gradientType = opts.gradientType;
          if (this.r < 1) {
            this.r = Math.round(this.r);
          }
          if (this.g < 1) {
            this.g = Math.round(this.g);
          }
          if (this.b < 1) {
            this.b = Math.round(this.b);
          }
          this.isValid = rgb.ok;
        }
        TinyColor2.prototype.isDark = function() {
          return this.getBrightness() < 128;
        };
        TinyColor2.prototype.isLight = function() {
          return !this.isDark();
        };
        TinyColor2.prototype.getBrightness = function() {
          var rgb = this.toRgb();
          return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
        };
        TinyColor2.prototype.getLuminance = function() {
          var rgb = this.toRgb();
          var R2;
          var G2;
          var B2;
          var RsRGB = rgb.r / 255;
          var GsRGB = rgb.g / 255;
          var BsRGB = rgb.b / 255;
          if (RsRGB <= 0.03928) {
            R2 = RsRGB / 12.92;
          } else {
            R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
          }
          if (GsRGB <= 0.03928) {
            G2 = GsRGB / 12.92;
          } else {
            G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
          }
          if (BsRGB <= 0.03928) {
            B2 = BsRGB / 12.92;
          } else {
            B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
          }
          return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
        };
        TinyColor2.prototype.getAlpha = function() {
          return this.a;
        };
        TinyColor2.prototype.setAlpha = function(alpha) {
          this.a = boundAlpha(alpha);
          this.roundA = Math.round(100 * this.a) / 100;
          return this;
        };
        TinyColor2.prototype.isMonochrome = function() {
          var s2 = this.toHsl().s;
          return s2 === 0;
        };
        TinyColor2.prototype.toHsv = function() {
          var hsv = rgbToHsv(this.r, this.g, this.b);
          return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
        };
        TinyColor2.prototype.toHsvString = function() {
          var hsv = rgbToHsv(this.r, this.g, this.b);
          var h2 = Math.round(hsv.h * 360);
          var s2 = Math.round(hsv.s * 100);
          var v2 = Math.round(hsv.v * 100);
          return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%)") : "hsva(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%, ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toHsl = function() {
          var hsl = rgbToHsl(this.r, this.g, this.b);
          return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
        };
        TinyColor2.prototype.toHslString = function() {
          var hsl = rgbToHsl(this.r, this.g, this.b);
          var h2 = Math.round(hsl.h * 360);
          var s2 = Math.round(hsl.s * 100);
          var l2 = Math.round(hsl.l * 100);
          return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%)") : "hsla(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%, ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toHex = function(allow3Char) {
          if (allow3Char === void 0) {
            allow3Char = false;
          }
          return rgbToHex(this.r, this.g, this.b, allow3Char);
        };
        TinyColor2.prototype.toHexString = function(allow3Char) {
          if (allow3Char === void 0) {
            allow3Char = false;
          }
          return "#" + this.toHex(allow3Char);
        };
        TinyColor2.prototype.toHex8 = function(allow4Char) {
          if (allow4Char === void 0) {
            allow4Char = false;
          }
          return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
        };
        TinyColor2.prototype.toHex8String = function(allow4Char) {
          if (allow4Char === void 0) {
            allow4Char = false;
          }
          return "#" + this.toHex8(allow4Char);
        };
        TinyColor2.prototype.toHexShortString = function(allowShortChar) {
          if (allowShortChar === void 0) {
            allowShortChar = false;
          }
          return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
        };
        TinyColor2.prototype.toRgb = function() {
          return {
            r: Math.round(this.r),
            g: Math.round(this.g),
            b: Math.round(this.b),
            a: this.a
          };
        };
        TinyColor2.prototype.toRgbString = function() {
          var r2 = Math.round(this.r);
          var g2 = Math.round(this.g);
          var b2 = Math.round(this.b);
          return this.a === 1 ? "rgb(".concat(r2, ", ").concat(g2, ", ").concat(b2, ")") : "rgba(".concat(r2, ", ").concat(g2, ", ").concat(b2, ", ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toPercentageRgb = function() {
          var fmt = function(x2) {
            return "".concat(Math.round(bound01(x2, 255) * 100), "%");
          };
          return {
            r: fmt(this.r),
            g: fmt(this.g),
            b: fmt(this.b),
            a: this.a
          };
        };
        TinyColor2.prototype.toPercentageRgbString = function() {
          var rnd = function(x2) {
            return Math.round(bound01(x2, 255) * 100);
          };
          return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
        };
        TinyColor2.prototype.toName = function() {
          if (this.a === 0) {
            return "transparent";
          }
          if (this.a < 1) {
            return false;
          }
          var hex = "#" + rgbToHex(this.r, this.g, this.b, false);
          for (var _i = 0, _a = Object.entries(names); _i < _a.length; _i++) {
            var _b = _a[_i], key2 = _b[0], value = _b[1];
            if (hex === value) {
              return key2;
            }
          }
          return false;
        };
        TinyColor2.prototype.toString = function(format2) {
          var formatSet = Boolean(format2);
          format2 = format2 !== null && format2 !== void 0 ? format2 : this.format;
          var formattedString = false;
          var hasAlpha = this.a < 1 && this.a >= 0;
          var needsAlphaFormat = !formatSet && hasAlpha && (format2.startsWith("hex") || format2 === "name");
          if (needsAlphaFormat) {
            if (format2 === "name" && this.a === 0) {
              return this.toName();
            }
            return this.toRgbString();
          }
          if (format2 === "rgb") {
            formattedString = this.toRgbString();
          }
          if (format2 === "prgb") {
            formattedString = this.toPercentageRgbString();
          }
          if (format2 === "hex" || format2 === "hex6") {
            formattedString = this.toHexString();
          }
          if (format2 === "hex3") {
            formattedString = this.toHexString(true);
          }
          if (format2 === "hex4") {
            formattedString = this.toHex8String(true);
          }
          if (format2 === "hex8") {
            formattedString = this.toHex8String();
          }
          if (format2 === "name") {
            formattedString = this.toName();
          }
          if (format2 === "hsl") {
            formattedString = this.toHslString();
          }
          if (format2 === "hsv") {
            formattedString = this.toHsvString();
          }
          return formattedString || this.toHexString();
        };
        TinyColor2.prototype.toNumber = function() {
          return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
        };
        TinyColor2.prototype.clone = function() {
          return new TinyColor2(this.toString());
        };
        TinyColor2.prototype.lighten = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.l += amount / 100;
          hsl.l = clamp01(hsl.l);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.brighten = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var rgb = this.toRgb();
          rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
          rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
          rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
          return new TinyColor2(rgb);
        };
        TinyColor2.prototype.darken = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.l -= amount / 100;
          hsl.l = clamp01(hsl.l);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.tint = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          return this.mix("white", amount);
        };
        TinyColor2.prototype.shade = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          return this.mix("black", amount);
        };
        TinyColor2.prototype.desaturate = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.s -= amount / 100;
          hsl.s = clamp01(hsl.s);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.saturate = function(amount) {
          if (amount === void 0) {
            amount = 10;
          }
          var hsl = this.toHsl();
          hsl.s += amount / 100;
          hsl.s = clamp01(hsl.s);
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.greyscale = function() {
          return this.desaturate(100);
        };
        TinyColor2.prototype.spin = function(amount) {
          var hsl = this.toHsl();
          var hue = (hsl.h + amount) % 360;
          hsl.h = hue < 0 ? 360 + hue : hue;
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.mix = function(color, amount) {
          if (amount === void 0) {
            amount = 50;
          }
          var rgb1 = this.toRgb();
          var rgb2 = new TinyColor2(color).toRgb();
          var p2 = amount / 100;
          var rgba = {
            r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
            g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
            b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
            a: (rgb2.a - rgb1.a) * p2 + rgb1.a
          };
          return new TinyColor2(rgba);
        };
        TinyColor2.prototype.analogous = function(results, slices) {
          if (results === void 0) {
            results = 6;
          }
          if (slices === void 0) {
            slices = 30;
          }
          var hsl = this.toHsl();
          var part = 360 / slices;
          var ret = [this];
          for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
            hsl.h = (hsl.h + part) % 360;
            ret.push(new TinyColor2(hsl));
          }
          return ret;
        };
        TinyColor2.prototype.complement = function() {
          var hsl = this.toHsl();
          hsl.h = (hsl.h + 180) % 360;
          return new TinyColor2(hsl);
        };
        TinyColor2.prototype.monochromatic = function(results) {
          if (results === void 0) {
            results = 6;
          }
          var hsv = this.toHsv();
          var h2 = hsv.h;
          var s2 = hsv.s;
          var v2 = hsv.v;
          var res = [];
          var modification = 1 / results;
          while (results--) {
            res.push(new TinyColor2({ h: h2, s: s2, v: v2 }));
            v2 = (v2 + modification) % 1;
          }
          return res;
        };
        TinyColor2.prototype.splitcomplement = function() {
          var hsl = this.toHsl();
          var h2 = hsl.h;
          return [
            this,
            new TinyColor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
            new TinyColor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
          ];
        };
        TinyColor2.prototype.onBackground = function(background) {
          var fg = this.toRgb();
          var bg = new TinyColor2(background).toRgb();
          var alpha = fg.a + bg.a * (1 - fg.a);
          return new TinyColor2({
            r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
            g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
            b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
            a: alpha
          });
        };
        TinyColor2.prototype.triad = function() {
          return this.polyad(3);
        };
        TinyColor2.prototype.tetrad = function() {
          return this.polyad(4);
        };
        TinyColor2.prototype.polyad = function(n2) {
          var hsl = this.toHsl();
          var h2 = hsl.h;
          var result = [this];
          var increment = 360 / n2;
          for (var i2 = 1; i2 < n2; i2++) {
            result.push(new TinyColor2({ h: (h2 + i2 * increment) % 360, s: hsl.s, l: hsl.l }));
          }
          return result;
        };
        TinyColor2.prototype.equals = function(color) {
          return this.toRgbString() === new TinyColor2(color).toRgbString();
        };
        return TinyColor2;
      }()
    );
    function tinycolor(...args) {
      return new TinyColor(...args);
    }
    function _colorChange(data, oldHue) {
      const alpha = data && data.a;
      let color;
      if (data && data.hsl)
        color = tinycolor(data.hsl);
      else if (data && data.hex && data.hex.length > 0)
        color = tinycolor(data.hex);
      else if (data && data.hsv)
        color = tinycolor(data.hsv);
      else if (data && data.rgba)
        color = tinycolor(data.rgba);
      else if (data && data.rgb)
        color = tinycolor(data.rgb);
      else
        color = tinycolor(data);
      if (color && (color._a === void 0 || color._a === null))
        color.setAlpha(alpha || color.getAlpha());
      const hsl = color.toHsl();
      const hsv = color.toHsv();
      if (hsl.s === 0)
        hsv.h = hsl.h = data.h || data.hsl && data.hsl.h || oldHue || 0;
      if (hsv.v < 0.0164) {
        hsv.h = data.h || data.hsv && data.hsv.h || 0;
        hsv.s = data.s || data.hsv && data.hsv.s || 0;
      }
      if (hsl.l < 0.01) {
        hsl.h = data.h || data.hsl && data.hsl.h || 0;
        hsl.s = data.s || data.hsl && data.hsl.s || 0;
      }
      return {
        hsl,
        hex: color.toHexString().toUpperCase(),
        hex8: color.toHex8String().toUpperCase(),
        rgba: color.toRgb(),
        hsv,
        oldHue: data.h || oldHue || hsl.h,
        source: data.source,
        a: color.getAlpha()
      };
    }
    var colorMixin = {
      model: {
        prop: "modelValue",
        event: "update:modelValue"
      },
      props: ["modelValue"],
      data() {
        return {
          val: _colorChange(this.modelValue)
        };
      },
      computed: {
        colors: {
          get() {
            return this.val;
          },
          set(newVal) {
            this.val = newVal;
            this.$emit("update:modelValue", newVal);
          }
        }
      },
      watch: {
        modelValue(newVal) {
          this.val = _colorChange(newVal);
        }
      },
      methods: {
        colorChange(data, oldHue) {
          this.oldHue = this.colors.hsl.h;
          this.colors = _colorChange(data, oldHue || this.oldHue);
        },
        isValidHex(hex) {
          return tinycolor(hex).isValid;
        },
        simpleCheckForValidColor(data) {
          const keysToCheck = ["r", "g", "b", "a", "h", "s", "l", "v"];
          let checked = 0;
          let passed = 0;
          for (let i2 = 0; i2 < keysToCheck.length; i2++) {
            const letter = keysToCheck[i2];
            if (data[letter]) {
              checked++;
              if (!isNaN(data[letter]))
                passed++;
            }
          }
          if (checked === passed)
            return data;
        },
        paletteUpperCase(palette) {
          return palette.map((c2) => c2.toUpperCase());
        },
        isTransparent(color) {
          return tinycolor(color).getAlpha() === 0;
        }
      }
    };
    var script$b = {
      name: "EditableInput",
      props: {
        label: String,
        labelText: String,
        desc: String,
        value: [String, Number],
        max: Number,
        min: Number,
        arrowOffset: {
          type: Number,
          default: 1
        }
      },
      computed: {
        val: {
          get() {
            return this.value;
          },
          set(v2) {
            if (!(this.max === void 0) && +v2 > this.max)
              this.$refs.input.value = this.max;
            else
              return v2;
          }
        },
        labelId() {
          return `input__label__${this.label}__${Math.random().toString().slice(2, 5)}`;
        },
        labelSpanText() {
          return this.labelText || this.label;
        }
      },
      methods: {
        update(e2) {
          this.handleChange(e2.target.value);
        },
        handleChange(newVal) {
          const data = {};
          data[this.label] = newVal;
          if (data.hex === void 0 && data["#"] === void 0)
            this.$emit("change", data);
          else if (newVal.length > 5)
            this.$emit("change", data);
        },
        // **** unused
        // handleBlur (e) {
        //   console.log(e)
        // },
        handleKeyDown(e2) {
          let { val } = this;
          const number2 = Number(val);
          if (number2) {
            const amount = this.arrowOffset || 1;
            if (e2.keyCode === 38) {
              val = number2 + amount;
              this.handleChange(val);
              e2.preventDefault();
            }
            if (e2.keyCode === 40) {
              val = number2 - amount;
              this.handleChange(val);
              e2.preventDefault();
            }
          }
        }
        // **** unused
        // handleDrag (e) {
        //   console.log(e)
        // },
        // handleMouseDown (e) {
        //   console.log(e)
        // }
      }
    };
    const _hoisted_1$y = { class: "vc-editable-input" };
    const _hoisted_2$q = ["aria-labelledby"];
    const _hoisted_3$n = ["id", "for"];
    const _hoisted_4$m = { class: "vc-input__desc" };
    function render$b(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$y, [
        withDirectives(createBaseVNode("input", {
          ref: "input",
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $options.val = $event),
          "aria-labelledby": $options.labelId,
          class: "vc-input__input",
          onKeydown: _cache[1] || (_cache[1] = (...args) => $options.handleKeyDown && $options.handleKeyDown(...args)),
          onInput: _cache[2] || (_cache[2] = (...args) => $options.update && $options.update(...args))
        }, null, 40, _hoisted_2$q), [
          [vModelText, $options.val]
        ]),
        createBaseVNode("span", {
          id: $options.labelId,
          for: $props.label,
          class: "vc-input__label"
        }, toDisplayString$2($options.labelSpanText), 9, _hoisted_3$n),
        createBaseVNode(
          "span",
          _hoisted_4$m,
          toDisplayString$2($props.desc),
          1
          /* TEXT */
        )
      ]);
    }
    var css_248z$b = ".vc-editable-input{position:relative}.vc-input__input{border:0;outline:none;padding:0}.vc-input__label{text-transform:capitalize}";
    styleInject(css_248z$b);
    script$b.render = render$b;
    script$b.__file = "src/components/editable-input/editable-input.vue";
    script$b.install = install;
    function clamp$1(value, min2, max2) {
      return min2 < max2 ? value < min2 ? min2 : value > max2 ? max2 : value : value < max2 ? max2 : value > min2 ? min2 : value;
    }
    var script$a = {
      name: "Saturation",
      props: {
        value: Object
      },
      computed: {
        colors() {
          return this.value;
        },
        bgColor() {
          return `hsl(${this.colors.hsv.h}, 100%, 50%)`;
        },
        pointerTop() {
          return `${-(this.colors.hsv.v * 100) + 1 + 100}%`;
        },
        pointerLeft() {
          return `${this.colors.hsv.s * 100}%`;
        }
      },
      methods: {
        handleChange(e2, skip) {
          !skip && e2.preventDefault();
          const { container } = this.$refs;
          if (!container) {
            return;
          }
          const containerWidth = container.clientWidth;
          const containerHeight = container.clientHeight;
          const xOffset = container.getBoundingClientRect().left + window.pageXOffset;
          const yOffset = container.getBoundingClientRect().top + window.pageYOffset;
          const pageX = e2.pageX || (e2.touches ? e2.touches[0].pageX : 0);
          const pageY = e2.pageY || (e2.touches ? e2.touches[0].pageY : 0);
          const left2 = clamp$1(pageX - xOffset, 0, containerWidth);
          const top2 = clamp$1(pageY - yOffset, 0, containerHeight);
          const saturation = left2 / containerWidth;
          const bright = clamp$1(-(top2 / containerHeight) + 1, 0, 1);
          this.onChange({
            h: this.colors.hsv.h,
            s: saturation,
            v: bright,
            a: this.colors.hsv.a,
            source: "hsva"
          });
        },
        onChange(param) {
          this.$emit("change", param);
        },
        handleMouseDown(e2) {
          window.addEventListener("mousemove", this.handleChange);
          window.addEventListener("mouseup", this.handleChange);
          window.addEventListener("mouseup", this.handleMouseUp);
        },
        handleMouseUp(e2) {
          this.unbindEventListeners();
        },
        unbindEventListeners() {
          window.removeEventListener("mousemove", this.handleChange);
          window.removeEventListener("mouseup", this.handleChange);
          window.removeEventListener("mouseup", this.handleMouseUp);
        }
      }
    };
    const _hoisted_1$x = /* @__PURE__ */ createBaseVNode(
      "div",
      { class: "vc-saturation--white" },
      null,
      -1
      /* HOISTED */
    );
    const _hoisted_2$p = /* @__PURE__ */ createBaseVNode(
      "div",
      { class: "vc-saturation--black" },
      null,
      -1
      /* HOISTED */
    );
    const _hoisted_3$m = /* @__PURE__ */ createBaseVNode(
      "div",
      { class: "vc-saturation-circle" },
      null,
      -1
      /* HOISTED */
    );
    const _hoisted_4$l = [
      _hoisted_3$m
    ];
    function render$a(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock(
        "div",
        {
          ref: "container",
          class: "vc-saturation",
          style: normalizeStyle({ background: $options.bgColor }),
          onMousedown: _cache[0] || (_cache[0] = (...args) => $options.handleMouseDown && $options.handleMouseDown(...args)),
          onTouchmove: _cache[1] || (_cache[1] = (...args) => $options.handleChange && $options.handleChange(...args)),
          onTouchstart: _cache[2] || (_cache[2] = (...args) => $options.handleChange && $options.handleChange(...args))
        },
        [
          _hoisted_1$x,
          _hoisted_2$p,
          createBaseVNode(
            "div",
            {
              class: "vc-saturation-pointer",
              style: normalizeStyle({ top: $options.pointerTop, left: $options.pointerLeft })
            },
            _hoisted_4$l,
            4
            /* STYLE */
          )
        ],
        36
        /* STYLE, HYDRATE_EVENTS */
      );
    }
    var css_248z$a = ".vc-saturation,.vc-saturation--black,.vc-saturation--white{bottom:0;cursor:pointer;left:0;position:absolute;right:0;top:0}.vc-saturation--white{background:linear-gradient(90deg,#fff,hsla(0,0%,100%,0))}.vc-saturation--black{background:linear-gradient(0deg,#000,transparent)}.vc-saturation-pointer{cursor:pointer;position:absolute}.vc-saturation-circle{border-radius:50%;box-shadow:0 0 0 1.5px #fff,inset 0 0 1px 1px rgba(0,0,0,.3),0 0 1px 2px rgba(0,0,0,.4);cursor:head;height:4px;transform:translate(-2px,-2px);width:4px}";
    styleInject(css_248z$a);
    script$a.render = render$a;
    script$a.__file = "src/components/saturation/saturation.vue";
    script$a.install = install;
    var script$9 = {
      name: "Hue",
      props: {
        value: Object,
        direction: {
          type: String,
          // [horizontal | vertical]
          default: "horizontal"
        }
      },
      data() {
        return {
          oldHue: 0,
          pullDirection: ""
        };
      },
      computed: {
        colors() {
          return this.value;
        },
        directionClass() {
          return {
            "vc-hue--horizontal": this.direction === "horizontal",
            "vc-hue--vertical": this.direction === "vertical"
          };
        },
        pointerTop() {
          if (this.direction === "vertical") {
            if (this.colors.hsl.h === 0 && this.pullDirection === "right")
              return 0;
            return `${-(this.colors.hsl.h * 100 / 360) + 100}%`;
          }
          return 0;
        },
        pointerLeft() {
          if (this.direction === "vertical")
            return 0;
          if (this.colors.hsl.h === 0 && this.pullDirection === "right")
            return "100%";
          return `${this.colors.hsl.h * 100 / 360}%`;
        }
      },
      watch: {
        value: {
          handler(value, oldVal) {
            const { h: h2 } = value.hsl;
            if (h2 !== 0 && h2 - this.oldHue > 0)
              this.pullDirection = "right";
            if (h2 !== 0 && h2 - this.oldHue < 0)
              this.pullDirection = "left";
            this.oldHue = h2;
          },
          deep: true,
          immediate: true
        }
      },
      methods: {
        handleChange(e2, skip) {
          !skip && e2.preventDefault();
          const { container } = this.$refs;
          if (!container) {
            return;
          }
          const containerWidth = container.clientWidth;
          const containerHeight = container.clientHeight;
          const xOffset = container.getBoundingClientRect().left + window.pageXOffset;
          const yOffset = container.getBoundingClientRect().top + window.pageYOffset;
          const pageX = e2.pageX || (e2.touches ? e2.touches[0].pageX : 0);
          const pageY = e2.pageY || (e2.touches ? e2.touches[0].pageY : 0);
          const left2 = pageX - xOffset;
          const top2 = pageY - yOffset;
          let h2;
          let percent;
          if (this.direction === "vertical") {
            if (top2 < 0) {
              h2 = 360;
            } else if (top2 > containerHeight) {
              h2 = 0;
            } else {
              percent = -(top2 * 100 / containerHeight) + 100;
              h2 = 360 * percent / 100;
            }
            if (this.colors.hsl.h !== h2) {
              this.$emit("change", {
                h: h2,
                s: this.colors.hsl.s,
                l: this.colors.hsl.l,
                a: this.colors.hsl.a,
                source: "hsl"
              });
            }
          } else {
            if (left2 < 0) {
              h2 = 0;
            } else if (left2 > containerWidth) {
              h2 = 360;
            } else {
              percent = left2 * 100 / containerWidth;
              h2 = 360 * percent / 100;
            }
            if (this.colors.hsl.h !== h2) {
              this.$emit("change", {
                h: h2,
                s: this.colors.hsl.s,
                l: this.colors.hsl.l,
                a: this.colors.hsl.a,
                source: "hsl"
              });
            }
          }
        },
        handleMouseDown(e2) {
          this.handleChange(e2, true);
          window.addEventListener("mousemove", this.handleChange);
          window.addEventListener("mouseup", this.handleChange);
          window.addEventListener("mouseup", this.handleMouseUp);
        },
        handleMouseUp(e2) {
          this.unbindEventListeners();
        },
        unbindEventListeners() {
          window.removeEventListener("mousemove", this.handleChange);
          window.removeEventListener("mouseup", this.handleChange);
          window.removeEventListener("mouseup", this.handleMouseUp);
        }
      }
    };
    const _hoisted_1$w = ["aria-valuenow"];
    const _hoisted_2$o = /* @__PURE__ */ createBaseVNode(
      "div",
      { class: "vc-hue-picker" },
      null,
      -1
      /* HOISTED */
    );
    const _hoisted_3$l = [
      _hoisted_2$o
    ];
    function render$9(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock(
        "div",
        {
          class: normalizeClass(["vc-hue", [$options.directionClass]])
        },
        [
          createBaseVNode("div", {
            ref: "container",
            class: "vc-hue-container",
            role: "slider",
            "aria-valuenow": $options.colors.hsl.h,
            "aria-valuemin": "0",
            "aria-valuemax": "360",
            onMousedown: _cache[0] || (_cache[0] = (...args) => $options.handleMouseDown && $options.handleMouseDown(...args)),
            onTouchmove: _cache[1] || (_cache[1] = (...args) => $options.handleChange && $options.handleChange(...args)),
            onTouchstart: _cache[2] || (_cache[2] = (...args) => $options.handleChange && $options.handleChange(...args))
          }, [
            createBaseVNode(
              "div",
              {
                class: "vc-hue-pointer",
                style: normalizeStyle({ top: $options.pointerTop, left: $options.pointerLeft }),
                role: "presentation"
              },
              _hoisted_3$l,
              4
              /* STYLE */
            )
          ], 40, _hoisted_1$w)
        ],
        2
        /* CLASS */
      );
    }
    var css_248z$9 = ".vc-hue{border-radius:2px;bottom:0;left:0;position:absolute;right:0;top:0}.vc-hue--horizontal{background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.vc-hue--vertical{background:linear-gradient(0deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.vc-hue-container{cursor:pointer;height:100%;margin:0 2px;position:relative}.vc-hue-pointer{position:absolute;z-index:2}.vc-hue-picker{background:#fff;border-radius:1px;box-shadow:0 0 2px rgba(0,0,0,.6);cursor:pointer;height:8px;margin-top:1px;transform:translateX(-2px);width:4px}";
    styleInject(css_248z$9);
    script$9.render = render$9;
    script$9.__file = "src/components/hue/hue.vue";
    script$9.install = install;
    var script$8 = {
      name: "Chrome",
      components: {
        Saturation: script$a,
        Hue: script$9,
        Alpha: script$c,
        EdIn: script$b,
        Checkboard: script$d
      },
      mixins: [colorMixin],
      props: {
        disableAlpha: {
          type: Boolean,
          default: false
        },
        disableFields: {
          type: Boolean,
          default: false
        },
        format: {
          type: String,
          default: "hex"
        }
      },
      data() {
        return {
          fieldsIndex: "hex",
          highlight: false
        };
      },
      computed: {
        hsl() {
          const { h: h2, s: s2, l: l2 } = this.colors.hsl;
          return {
            h: h2.toFixed(),
            s: `${(s2 * 100).toFixed()}%`,
            l: `${(l2 * 100).toFixed()}%`
          };
        },
        activeColor() {
          const { rgba } = this.colors;
          return `rgba(${[rgba.r, rgba.g, rgba.b, rgba.a].join(",")})`;
        },
        hasAlpha() {
          return this.colors.a < 1;
        }
      },
      watch: {
        format: {
          handler(val) {
            this.fieldsIndex = val;
          },
          immediate: true
        }
      },
      methods: {
        childChange(data) {
          this.colorChange(data);
        },
        inputChange(data) {
          if (!data)
            return;
          if (data.hex) {
            this.isValidHex(data.hex) && this.colorChange({
              hex: data.hex,
              source: "hex"
            });
          } else if (data.r || data.g || data.b || data.a) {
            this.colorChange({
              r: data.r || this.colors.rgba.r,
              g: data.g || this.colors.rgba.g,
              b: data.b || this.colors.rgba.b,
              a: data.a || this.colors.rgba.a,
              source: "rgba"
            });
          } else if (data.h || data.s || data.l) {
            const s2 = data.s ? data.s.replace("%", "") / 100 : this.colors.hsl.s;
            const l2 = data.l ? data.l.replace("%", "") / 100 : this.colors.hsl.l;
            this.colorChange({
              h: data.h || this.colors.hsl.h,
              s: s2,
              l: l2,
              source: "hsl"
            });
          }
        },
        toggleViews() {
          switch (this.fieldsIndex) {
            case "hex":
              this.fieldsIndex = `rgb${this.disableAlpha ? "" : "a"}`;
              break;
            case "rgb":
            case "rgba":
              this.fieldsIndex = `hsl${this.disableAlpha ? "" : "a"}`;
              break;
            default:
              this.fieldsIndex = "hex";
              break;
          }
          this.$emit("update:format", this.fieldsIndex);
        },
        showHighlight() {
          this.highlight = true;
        },
        hideHighlight() {
          this.highlight = false;
        }
      }
    };
    const _hoisted_1$v = { class: "vc-chrome-saturation-wrap" };
    const _hoisted_2$n = { class: "vc-chrome-body" };
    const _hoisted_3$k = { class: "vc-chrome-controls" };
    const _hoisted_4$k = { class: "vc-chrome-color-wrap" };
    const _hoisted_5$h = ["aria-label"];
    const _hoisted_6$g = { class: "vc-chrome-sliders" };
    const _hoisted_7$e = { class: "vc-chrome-hue-wrap" };
    const _hoisted_8$b = {
      key: 0,
      class: "vc-chrome-alpha-wrap"
    };
    const _hoisted_9$b = {
      key: 0,
      class: "vc-chrome-fields-wrap"
    };
    const _hoisted_10$a = { class: "vc-chrome-fields" };
    const _hoisted_11$a = { class: "vc-chrome-field" };
    const _hoisted_12$a = { class: "vc-chrome-fields" };
    const _hoisted_13$a = { class: "vc-chrome-field" };
    const _hoisted_14$a = { class: "vc-chrome-field" };
    const _hoisted_15$a = { class: "vc-chrome-field" };
    const _hoisted_16$a = {
      key: 0,
      class: "vc-chrome-field"
    };
    const _hoisted_17$8 = { class: "vc-chrome-fields" };
    const _hoisted_18$7 = { class: "vc-chrome-field" };
    const _hoisted_19$7 = { class: "vc-chrome-field" };
    const _hoisted_20$7 = { class: "vc-chrome-field" };
    const _hoisted_21$7 = {
      key: 0,
      class: "vc-chrome-field"
    };
    const _hoisted_22$7 = { class: "vc-chrome-toggle-icon" };
    const _hoisted_23$6 = /* @__PURE__ */ createBaseVNode(
      "path",
      {
        fill: "#333",
        d: "M12,18.17L8.83,15L7.42,16.41L12,21L16.59,16.41L15.17,15M12,5.83L15.17,9L16.58,7.59L12,3L7.41,7.59L8.83,9L12,5.83Z"
      },
      null,
      -1
      /* HOISTED */
    );
    const _hoisted_24$5 = [
      _hoisted_23$6
    ];
    const _hoisted_25$5 = { class: "vc-chrome-toggle-icon-highlight" };
    function render$8(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Saturation = resolveComponent("Saturation");
      const _component_Checkboard = resolveComponent("Checkboard");
      const _component_Hue = resolveComponent("Hue");
      const _component_Alpha = resolveComponent("Alpha");
      const _component_EdIn = resolveComponent("EdIn");
      return openBlock(), createElementBlock(
        "div",
        {
          role: "application",
          "aria-label": "Chrome color picker",
          class: normalizeClass(["vc-chrome", [$props.disableAlpha ? "vc-chrome__disable-alpha" : ""]])
        },
        [
          createBaseVNode("div", _hoisted_1$v, [
            createVNode(_component_Saturation, {
              value: _ctx.colors,
              onChange: $options.childChange
            }, null, 8, ["value", "onChange"])
          ]),
          createBaseVNode("div", _hoisted_2$n, [
            createBaseVNode("div", _hoisted_3$k, [
              createBaseVNode("div", _hoisted_4$k, [
                createBaseVNode("div", {
                  "aria-label": `current color is ${_ctx.colors.hex}`,
                  class: "vc-chrome-active-color",
                  style: normalizeStyle({ background: $options.activeColor })
                }, null, 12, _hoisted_5$h),
                !$props.disableAlpha ? (openBlock(), createBlock(_component_Checkboard, { key: 0 })) : createCommentVNode("v-if", true)
              ]),
              createBaseVNode("div", _hoisted_6$g, [
                createBaseVNode("div", _hoisted_7$e, [
                  createVNode(_component_Hue, {
                    value: _ctx.colors,
                    onChange: $options.childChange
                  }, null, 8, ["value", "onChange"])
                ]),
                !$props.disableAlpha ? (openBlock(), createElementBlock("div", _hoisted_8$b, [
                  createVNode(_component_Alpha, {
                    value: _ctx.colors,
                    onChange: $options.childChange
                  }, null, 8, ["value", "onChange"])
                ])) : createCommentVNode("v-if", true)
              ])
            ]),
            !$props.disableFields ? (openBlock(), createElementBlock("div", _hoisted_9$b, [
              withDirectives(createBaseVNode(
                "div",
                _hoisted_10$a,
                [
                  createCommentVNode(" hex "),
                  createBaseVNode("div", _hoisted_11$a, [
                    !$options.hasAlpha ? (openBlock(), createBlock(_component_EdIn, {
                      key: 0,
                      label: "hex",
                      value: _ctx.colors.hex,
                      onChange: $options.inputChange
                    }, null, 8, ["value", "onChange"])) : createCommentVNode("v-if", true),
                    $options.hasAlpha ? (openBlock(), createBlock(_component_EdIn, {
                      key: 1,
                      label: "hex",
                      value: _ctx.colors.hex8,
                      onChange: $options.inputChange
                    }, null, 8, ["value", "onChange"])) : createCommentVNode("v-if", true)
                  ])
                ],
                512
                /* NEED_PATCH */
              ), [
                [vShow, $data.fieldsIndex === "hex"]
              ]),
              withDirectives(createBaseVNode(
                "div",
                _hoisted_12$a,
                [
                  createCommentVNode(" rgba "),
                  createBaseVNode("div", _hoisted_13$a, [
                    createVNode(_component_EdIn, {
                      label: "r",
                      value: _ctx.colors.rgba.r,
                      onChange: $options.inputChange
                    }, null, 8, ["value", "onChange"])
                  ]),
                  createBaseVNode("div", _hoisted_14$a, [
                    createVNode(_component_EdIn, {
                      label: "g",
                      value: _ctx.colors.rgba.g,
                      onChange: $options.inputChange
                    }, null, 8, ["value", "onChange"])
                  ]),
                  createBaseVNode("div", _hoisted_15$a, [
                    createVNode(_component_EdIn, {
                      label: "b",
                      value: _ctx.colors.rgba.b,
                      onChange: $options.inputChange
                    }, null, 8, ["value", "onChange"])
                  ]),
                  !$props.disableAlpha ? (openBlock(), createElementBlock("div", _hoisted_16$a, [
                    createVNode(_component_EdIn, {
                      label: "a",
                      value: _ctx.colors.a,
                      "arrow-offset": 0.01,
                      max: 1,
                      onChange: $options.inputChange
                    }, null, 8, ["value", "arrow-offset", "onChange"])
                  ])) : createCommentVNode("v-if", true)
                ],
                512
                /* NEED_PATCH */
              ), [
                [vShow, ["rgb", "rgba"].includes($data.fieldsIndex)]
              ]),
              withDirectives(createBaseVNode(
                "div",
                _hoisted_17$8,
                [
                  createCommentVNode(" hsla "),
                  createBaseVNode("div", _hoisted_18$7, [
                    createVNode(_component_EdIn, {
                      label: "h",
                      value: $options.hsl.h,
                      onChange: $options.inputChange
                    }, null, 8, ["value", "onChange"])
                  ]),
                  createBaseVNode("div", _hoisted_19$7, [
                    createVNode(_component_EdIn, {
                      label: "s",
                      value: $options.hsl.s,
                      onChange: $options.inputChange
                    }, null, 8, ["value", "onChange"])
                  ]),
                  createBaseVNode("div", _hoisted_20$7, [
                    createVNode(_component_EdIn, {
                      label: "l",
                      value: $options.hsl.l,
                      onChange: $options.inputChange
                    }, null, 8, ["value", "onChange"])
                  ]),
                  !$props.disableAlpha ? (openBlock(), createElementBlock("div", _hoisted_21$7, [
                    createVNode(_component_EdIn, {
                      label: "a",
                      value: _ctx.colors.a,
                      "arrow-offset": 0.01,
                      max: 1,
                      onChange: $options.inputChange
                    }, null, 8, ["value", "arrow-offset", "onChange"])
                  ])) : createCommentVNode("v-if", true)
                ],
                512
                /* NEED_PATCH */
              ), [
                [vShow, ["hsl", "hsla"].includes($data.fieldsIndex)]
              ]),
              createCommentVNode(" btn "),
              createBaseVNode("div", {
                class: "vc-chrome-toggle-btn",
                role: "button",
                "aria-label": "Change another color definition",
                onClick: _cache[3] || (_cache[3] = (...args) => $options.toggleViews && $options.toggleViews(...args))
              }, [
                createBaseVNode("div", _hoisted_22$7, [
                  (openBlock(), createElementBlock(
                    "svg",
                    {
                      style: { "width": "24px", "height": "24px" },
                      viewBox: "0 0 24 24",
                      onMouseover: _cache[0] || (_cache[0] = (...args) => $options.showHighlight && $options.showHighlight(...args)),
                      onMouseenter: _cache[1] || (_cache[1] = (...args) => $options.showHighlight && $options.showHighlight(...args)),
                      onMouseout: _cache[2] || (_cache[2] = (...args) => $options.hideHighlight && $options.hideHighlight(...args))
                    },
                    _hoisted_24$5,
                    32
                    /* HYDRATE_EVENTS */
                  ))
                ]),
                withDirectives(createBaseVNode(
                  "div",
                  _hoisted_25$5,
                  null,
                  512
                  /* NEED_PATCH */
                ), [
                  [vShow, $data.highlight]
                ])
              ]),
              createCommentVNode(" btn ")
            ])) : createCommentVNode("v-if", true)
          ])
        ],
        2
        /* CLASS */
      );
    }
    var css_248z$8 = ".vc-chrome{background:#fff;background-color:#fff;border-radius:2px;box-shadow:0 0 2px rgba(0,0,0,.3),0 4px 8px rgba(0,0,0,.3);box-sizing:initial;font-family:Menlo;width:225px}.vc-chrome-controls{display:flex}.vc-chrome-color-wrap{position:relative;width:36px}.vc-chrome-active-color{border-radius:15px;height:30px;overflow:hidden;position:relative;width:30px;z-index:1}.vc-chrome-color-wrap .vc-checkerboard{background-size:auto;border-radius:15px;height:30px;width:30px}.vc-chrome-sliders{flex:1}.vc-chrome-fields-wrap{display:flex;padding-top:16px}.vc-chrome-fields{display:flex;flex:1;margin-left:-6px}.vc-chrome-field{padding-left:6px;width:100%}.vc-chrome-toggle-btn{position:relative;text-align:right;width:32px}.vc-chrome-toggle-icon{cursor:pointer;margin-right:-4px;margin-top:12px;position:relative;z-index:2}.vc-chrome-toggle-icon-highlight{background:#eee;border-radius:4px;height:28px;left:12px;position:absolute;top:10px;width:24px}.vc-chrome-hue-wrap{margin-bottom:8px}.vc-chrome-alpha-wrap,.vc-chrome-hue-wrap{height:10px;position:relative}.vc-chrome-alpha-wrap .vc-alpha-gradient,.vc-chrome-hue-wrap .vc-hue{border-radius:2px}.vc-chrome-alpha-wrap .vc-alpha-picker,.vc-chrome-hue-wrap .vc-hue-picker{background-color:#f8f8f8;border-radius:6px;box-shadow:0 1px 4px 0 rgba(0,0,0,.37);height:12px;transform:translate(-6px,-2px);width:12px}.vc-chrome-body{background-color:#fff;padding:16px 16px 12px}.vc-chrome-saturation-wrap{border-radius:2px 2px 0 0;overflow:hidden;padding-bottom:55%;position:relative;width:100%}.vc-chrome-saturation-wrap .vc-saturation-circle{height:12px;width:12px}.vc-chrome-fields .vc-input__input{border:none;border-radius:2px;box-shadow:inset 0 0 0 1px #dadada;color:#333;font-size:11px;height:21px;text-align:center;width:100%}.vc-chrome-fields .vc-input__label{color:#969696;display:block;font-size:11px;line-height:11px;margin-top:12px;text-align:center;text-transform:uppercase}.vc-chrome__disable-alpha .vc-chrome-active-color{height:18px;width:18px}.vc-chrome__disable-alpha .vc-chrome-color-wrap{width:30px}.vc-chrome__disable-alpha .vc-chrome-hue-wrap{margin-bottom:4px;margin-top:4px}";
    styleInject(css_248z$8);
    script$8.render = render$8;
    script$8.__file = "src/components/chrome/chrome.vue";
    script$8.install = install;
    const defaultColors$3 = [
      "#4D4D4D",
      "#999999",
      "#FFFFFF",
      "#F44E3B",
      "#FE9200",
      "#FCDC00",
      "#DBDF00",
      "#A4DD00",
      "#68CCCA",
      "#73D8FF",
      "#AEA1FF",
      "#FDA1FF",
      "#333333",
      "#808080",
      "#CCCCCC",
      "#D33115",
      "#E27300",
      "#FCC400",
      "#B0BC00",
      "#68BC00",
      "#16A5A5",
      "#009CE0",
      "#7B64FF",
      "#FA28FF",
      "#000000",
      "#666666",
      "#B3B3B3",
      "#9F0500",
      "#C45100",
      "#FB9E00",
      "#808900",
      "#194D33",
      "#0C797D",
      "#0062B1",
      "#653294",
      "#AB149E"
    ];
    var script$7 = {
      name: "Compact",
      mixins: [colorMixin],
      props: {
        palette: {
          type: Array,
          default() {
            return defaultColors$3;
          }
        }
      },
      computed: {
        pick() {
          return this.colors.hex.toUpperCase();
        }
      },
      methods: {
        handlerClick(c2) {
          this.colorChange({
            hex: c2,
            source: "hex"
          });
        }
      }
    };
    const _hoisted_1$u = {
      role: "application",
      "aria-label": "Compact color picker",
      class: "vc-compact"
    };
    const _hoisted_2$m = {
      class: "vc-compact-colors",
      role: "listbox"
    };
    const _hoisted_3$j = ["aria-label", "aria-selected", "onClick"];
    const _hoisted_4$j = { class: "vc-compact-dot" };
    function render$7(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$u, [
        createBaseVNode("ul", _hoisted_2$m, [
          (openBlock(true), createElementBlock(
            Fragment,
            null,
            renderList(_ctx.paletteUpperCase($props.palette), (c2) => {
              return openBlock(), createElementBlock("li", {
                key: c2,
                role: "option",
                "aria-label": `color:${c2}`,
                "aria-selected": c2 === $options.pick,
                class: normalizeClass(["vc-compact-color-item", { "vc-compact-color-item--white": c2 === "#FFFFFF" }]),
                style: normalizeStyle({ background: c2 }),
                onClick: ($event) => $options.handlerClick(c2)
              }, [
                withDirectives(createBaseVNode(
                  "div",
                  _hoisted_4$j,
                  null,
                  512
                  /* NEED_PATCH */
                ), [
                  [vShow, c2 === $options.pick]
                ])
              ], 14, _hoisted_3$j);
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ])
      ]);
    }
    var css_248z$7 = ".vc-compact{background-color:#fff;border-radius:2px;box-shadow:0 2px 10px rgba(0,0,0,.12),0 2px 5px rgba(0,0,0,.16);box-sizing:border-box;padding-left:5px;padding-top:5px;width:245px}.vc-compact-colors{margin:0;overflow:hidden;padding:0}.vc-compact-color-item{cursor:pointer;float:left;height:15px;list-style:none;margin-bottom:5px;margin-right:5px;position:relative;width:15px}.vc-compact-color-item--white{box-shadow:inset 0 0 0 1px #ddd}.vc-compact-color-item--white .vc-compact-dot{background:#000}.vc-compact-dot{background:#fff;border-radius:50%;bottom:5px;left:5px;opacity:1;position:absolute;right:5px;top:5px}";
    styleInject(css_248z$7);
    script$7.render = render$7;
    script$7.__file = "src/components/compact/compact.vue";
    script$7.install = install;
    const defaultColors$2 = [
      "#FFFFFF",
      "#F2F2F2",
      "#E6E6E6",
      "#D9D9D9",
      "#CCCCCC",
      "#BFBFBF",
      "#B3B3B3",
      "#A6A6A6",
      "#999999",
      "#8C8C8C",
      "#808080",
      "#737373",
      "#666666",
      "#595959",
      "#4D4D4D",
      "#404040",
      "#333333",
      "#262626",
      "#0D0D0D",
      "#000000"
    ];
    var script$6 = {
      name: "Grayscale",
      components: {},
      mixins: [colorMixin],
      props: {
        palette: {
          type: Array,
          default() {
            return defaultColors$2;
          }
        }
      },
      computed: {
        pick() {
          return this.colors.hex.toUpperCase();
        }
      },
      methods: {
        handlerClick(c2) {
          this.colorChange({
            hex: c2,
            source: "hex"
          });
        }
      }
    };
    const _hoisted_1$t = {
      role: "application",
      "aria-label": "Grayscale color picker",
      class: "vc-grayscale"
    };
    const _hoisted_2$l = {
      class: "vc-grayscale-colors",
      role: "listbox"
    };
    const _hoisted_3$i = ["aria-label", "aria-selected", "onClick"];
    const _hoisted_4$i = { class: "vc-grayscale-dot" };
    function render$6(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$t, [
        createBaseVNode("ul", _hoisted_2$l, [
          (openBlock(true), createElementBlock(
            Fragment,
            null,
            renderList(_ctx.paletteUpperCase($props.palette), (c2) => {
              return openBlock(), createElementBlock("li", {
                key: c2,
                role: "option",
                "aria-label": `Color:${c2}`,
                "aria-selected": c2 === $options.pick,
                class: normalizeClass(["vc-grayscale-color-item", { "vc-grayscale-color-item--white": c2 === "#FFFFFF" }]),
                style: normalizeStyle({ background: c2 }),
                onClick: ($event) => $options.handlerClick(c2)
              }, [
                withDirectives(createBaseVNode(
                  "div",
                  _hoisted_4$i,
                  null,
                  512
                  /* NEED_PATCH */
                ), [
                  [vShow, c2 === $options.pick]
                ])
              ], 14, _hoisted_3$i);
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ])
      ]);
    }
    var css_248z$6 = ".vc-grayscale{background-color:#fff;border-radius:2px;box-shadow:0 2px 15px rgba(0,0,0,.12),0 2px 10px rgba(0,0,0,.16);width:125px}.vc-grayscale-colors{border-radius:2px;margin:0;overflow:hidden;padding:0}.vc-grayscale-color-item{cursor:pointer;float:left;height:25px;list-style:none;position:relative;width:25px}.vc-grayscale-color-item--white .vc-grayscale-dot{background:#000}.vc-grayscale-dot{background:#fff;border-radius:50%;height:6px;left:50%;margin:-3px 0 0 -2px;opacity:1;position:absolute;top:50%;width:6px}";
    styleInject(css_248z$6);
    script$6.render = render$6;
    script$6.__file = "src/components/grayscale/grayscale.vue";
    script$6.install = install;
    var script$5 = {
      name: "Material",
      components: {
        EdIn: script$b
      },
      mixins: [colorMixin],
      methods: {
        onChange(data) {
          if (!data)
            return;
          if (data.hex) {
            this.isValidHex(data.hex) && this.colorChange({
              hex: data.hex,
              source: "hex"
            });
          } else if (data.r || data.g || data.b) {
            this.colorChange({
              r: data.r || this.colors.rgba.r,
              g: data.g || this.colors.rgba.g,
              b: data.b || this.colors.rgba.b,
              a: data.a || this.colors.rgba.a,
              source: "rgba"
            });
          }
        }
      }
    };
    const _hoisted_1$s = {
      role: "application",
      "aria-label": "Material color picker",
      class: "vc-material"
    };
    const _hoisted_2$k = { class: "vc-material-split" };
    const _hoisted_3$h = { class: "vc-material-third" };
    const _hoisted_4$h = { class: "vc-material-third" };
    const _hoisted_5$g = { class: "vc-material-third" };
    function render$5(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_EdIn = resolveComponent("EdIn");
      return openBlock(), createElementBlock("div", _hoisted_1$s, [
        createVNode(_component_EdIn, {
          class: "vc-material-hex",
          label: "hex",
          value: _ctx.colors.hex,
          style: normalizeStyle({ borderColor: _ctx.colors.hex }),
          onChange: $options.onChange
        }, null, 8, ["value", "style", "onChange"]),
        createBaseVNode("div", _hoisted_2$k, [
          createBaseVNode("div", _hoisted_3$h, [
            createVNode(_component_EdIn, {
              label: "r",
              value: _ctx.colors.rgba.r,
              onChange: $options.onChange
            }, null, 8, ["value", "onChange"])
          ]),
          createBaseVNode("div", _hoisted_4$h, [
            createVNode(_component_EdIn, {
              label: "g",
              value: _ctx.colors.rgba.g,
              onChange: $options.onChange
            }, null, 8, ["value", "onChange"])
          ]),
          createBaseVNode("div", _hoisted_5$g, [
            createVNode(_component_EdIn, {
              label: "b",
              value: _ctx.colors.rgba.b,
              onChange: $options.onChange
            }, null, 8, ["value", "onChange"])
          ])
        ])
      ]);
    }
    var css_248z$5 = ".vc-material{background-color:#fff;border-radius:2px;box-shadow:0 2px 10px rgba(0,0,0,.12),0 2px 5px rgba(0,0,0,.16);font-family:Roboto;height:98px;padding:16px;position:relative;width:98px}.vc-material .vc-input__input{color:#333;font-size:15px;height:30px;margin-top:12px;width:100%}.vc-material .vc-input__label{color:#999;font-size:11px;left:0;position:absolute;text-transform:capitalize;top:0}.vc-material-hex{border-bottom-style:solid;border-bottom-width:2px}.vc-material-split{display:flex;margin-right:-10px;padding-top:11px}.vc-material-third{flex:1;padding-right:10px}";
    styleInject(css_248z$5);
    script$5.render = render$5;
    script$5.__file = "src/components/material/material.vue";
    script$5.install = install;
    var script$4 = {
      name: "Photoshop",
      components: {
        Saturation: script$a,
        Hue: script$9,
        EdIn: script$b
      },
      mixins: [colorMixin],
      props: {
        head: {
          type: String,
          default: "Color Picker"
        },
        disableFields: {
          type: Boolean,
          default: false
        },
        hasResetButton: {
          type: Boolean,
          default: false
        },
        acceptLabel: {
          type: String,
          default: "OK"
        },
        cancelLabel: {
          type: String,
          default: "Cancel"
        },
        resetLabel: {
          type: String,
          default: "Reset"
        },
        newLabel: {
          type: String,
          default: "new"
        },
        currentLabel: {
          type: String,
          default: "current"
        }
      },
      data() {
        return {
          currentColor: "#FFF"
        };
      },
      computed: {
        hsv() {
          const { hsv } = this.colors;
          return {
            h: hsv.h.toFixed(),
            s: (hsv.s * 100).toFixed(),
            v: (hsv.v * 100).toFixed()
          };
        },
        hex() {
          const { hex } = this.colors;
          return hex && hex.replace("#", "");
        }
      },
      created() {
        this.currentColor = this.colors.hex;
      },
      methods: {
        childChange(data) {
          this.colorChange(data);
        },
        inputChange(data) {
          if (!data)
            return;
          if (data["#"]) {
            this.isValidHex(data["#"]) && this.colorChange({
              hex: data["#"],
              source: "hex"
            });
          } else if (data.r || data.g || data.b || data.a) {
            this.colorChange({
              r: data.r || this.colors.rgba.r,
              g: data.g || this.colors.rgba.g,
              b: data.b || this.colors.rgba.b,
              a: data.a || this.colors.rgba.a,
              source: "rgba"
            });
          } else if (data.h || data.s || data.v) {
            this.colorChange({
              h: data.h || this.colors.hsv.h,
              s: data.s / 100 || this.colors.hsv.s,
              v: data.v / 100 || this.colors.hsv.v,
              source: "hsv"
            });
          }
        },
        clickCurrentColor() {
          this.colorChange({
            hex: this.currentColor,
            source: "hex"
          });
        },
        handleAccept() {
          this.$emit("ok");
        },
        handleCancel() {
          this.$emit("cancel");
        },
        handleReset() {
          this.$emit("reset");
        }
      }
    };
    const _hoisted_1$r = {
      role: "heading",
      class: "vc-ps-head"
    };
    const _hoisted_2$j = { class: "vc-ps-body" };
    const _hoisted_3$g = { class: "vc-ps-saturation-wrap" };
    const _hoisted_4$g = { class: "vc-ps-hue-wrap" };
    const _hoisted_5$f = /* @__PURE__ */ createBaseVNode(
      "div",
      { class: "vc-ps-hue-pointer" },
      [
        /* @__PURE__ */ createBaseVNode("i", { class: "vc-ps-hue-pointer--left" }),
        /* @__PURE__ */ createBaseVNode("i", { class: "vc-ps-hue-pointer--right" })
      ],
      -1
      /* HOISTED */
    );
    const _hoisted_6$f = { class: "vc-ps-previews" };
    const _hoisted_7$d = { class: "vc-ps-previews__label" };
    const _hoisted_8$a = { class: "vc-ps-previews__swatches" };
    const _hoisted_9$a = ["aria-label"];
    const _hoisted_10$9 = ["aria-label"];
    const _hoisted_11$9 = { class: "vc-ps-previews__label" };
    const _hoisted_12$9 = {
      key: 0,
      class: "vc-ps-actions"
    };
    const _hoisted_13$9 = ["aria-label"];
    const _hoisted_14$9 = ["aria-label"];
    const _hoisted_15$9 = { class: "vc-ps-fields" };
    const _hoisted_16$9 = /* @__PURE__ */ createBaseVNode(
      "div",
      { class: "vc-ps-fields__divider" },
      null,
      -1
      /* HOISTED */
    );
    const _hoisted_17$7 = /* @__PURE__ */ createBaseVNode(
      "div",
      { class: "vc-ps-fields__divider" },
      null,
      -1
      /* HOISTED */
    );
    function render$4(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Saturation = resolveComponent("Saturation");
      const _component_Hue = resolveComponent("Hue");
      const _component_EdIn = resolveComponent("EdIn");
      return openBlock(), createElementBlock(
        "div",
        {
          role: "application",
          "aria-label": "PhotoShop color picker",
          class: normalizeClass(["vc-photoshop", [$props.disableFields ? "vc-photoshop__disable-fields" : ""]])
        },
        [
          createBaseVNode(
            "div",
            _hoisted_1$r,
            toDisplayString$2($props.head),
            1
            /* TEXT */
          ),
          createBaseVNode("div", _hoisted_2$j, [
            createBaseVNode("div", _hoisted_3$g, [
              createVNode(_component_Saturation, {
                value: _ctx.colors,
                onChange: $options.childChange
              }, null, 8, ["value", "onChange"])
            ]),
            createBaseVNode("div", _hoisted_4$g, [
              createVNode(_component_Hue, {
                value: _ctx.colors,
                direction: "vertical",
                onChange: $options.childChange
              }, {
                default: withCtx(() => [
                  _hoisted_5$f
                ]),
                _: 1
                /* STABLE */
              }, 8, ["value", "onChange"])
            ]),
            createBaseVNode(
              "div",
              {
                class: normalizeClass(["vc-ps-controls", [$props.disableFields ? "vc-ps-controls__disable-fields" : ""]])
              },
              [
                createBaseVNode("div", _hoisted_6$f, [
                  createBaseVNode(
                    "div",
                    _hoisted_7$d,
                    toDisplayString$2($props.newLabel),
                    1
                    /* TEXT */
                  ),
                  createBaseVNode("div", _hoisted_8$a, [
                    createBaseVNode("div", {
                      class: "vc-ps-previews__pr-color",
                      "aria-label": `New color is ${_ctx.colors.hex}`,
                      style: normalizeStyle({ background: _ctx.colors.hex })
                    }, null, 12, _hoisted_9$a),
                    createBaseVNode("div", {
                      class: "vc-ps-previews__pr-color",
                      "aria-label": `Current color is ${$data.currentColor}`,
                      style: normalizeStyle({ background: $data.currentColor }),
                      onClick: _cache[0] || (_cache[0] = (...args) => $options.clickCurrentColor && $options.clickCurrentColor(...args))
                    }, null, 12, _hoisted_10$9)
                  ]),
                  createBaseVNode(
                    "div",
                    _hoisted_11$9,
                    toDisplayString$2($props.currentLabel),
                    1
                    /* TEXT */
                  )
                ]),
                !$props.disableFields ? (openBlock(), createElementBlock("div", _hoisted_12$9, [
                  createBaseVNode("div", {
                    class: "vc-ps-ac-btn",
                    role: "button",
                    "aria-label": $props.acceptLabel,
                    onClick: _cache[1] || (_cache[1] = (...args) => $options.handleAccept && $options.handleAccept(...args))
                  }, toDisplayString$2($props.acceptLabel), 9, _hoisted_13$9),
                  createBaseVNode("div", {
                    class: "vc-ps-ac-btn",
                    role: "button",
                    "aria-label": $props.cancelLabel,
                    onClick: _cache[2] || (_cache[2] = (...args) => $options.handleCancel && $options.handleCancel(...args))
                  }, toDisplayString$2($props.cancelLabel), 9, _hoisted_14$9),
                  createBaseVNode("div", _hoisted_15$9, [
                    createCommentVNode(" hsla "),
                    createVNode(_component_EdIn, {
                      label: "h",
                      desc: "°",
                      value: $options.hsv.h,
                      onChange: $options.inputChange
                    }, null, 8, ["value", "onChange"]),
                    createVNode(_component_EdIn, {
                      label: "s",
                      desc: "%",
                      value: $options.hsv.s,
                      max: 100,
                      onChange: $options.inputChange
                    }, null, 8, ["value", "onChange"]),
                    createVNode(_component_EdIn, {
                      label: "v",
                      desc: "%",
                      value: $options.hsv.v,
                      max: 100,
                      onChange: $options.inputChange
                    }, null, 8, ["value", "onChange"]),
                    _hoisted_16$9,
                    createCommentVNode(" rgba "),
                    createVNode(_component_EdIn, {
                      label: "r",
                      value: _ctx.colors.rgba.r,
                      onChange: $options.inputChange
                    }, null, 8, ["value", "onChange"]),
                    createVNode(_component_EdIn, {
                      label: "g",
                      value: _ctx.colors.rgba.g,
                      onChange: $options.inputChange
                    }, null, 8, ["value", "onChange"]),
                    createVNode(_component_EdIn, {
                      label: "b",
                      value: _ctx.colors.rgba.b,
                      onChange: $options.inputChange
                    }, null, 8, ["value", "onChange"]),
                    _hoisted_17$7,
                    createCommentVNode(" hex "),
                    createVNode(_component_EdIn, {
                      label: "#",
                      class: "vc-ps-fields__hex",
                      value: $options.hex,
                      onChange: $options.inputChange
                    }, null, 8, ["value", "onChange"])
                  ]),
                  $props.hasResetButton ? (openBlock(), createElementBlock(
                    "div",
                    {
                      key: 0,
                      class: "vc-ps-ac-btn",
                      "aria-label": "reset",
                      onClick: _cache[3] || (_cache[3] = (...args) => $options.handleReset && $options.handleReset(...args))
                    },
                    toDisplayString$2($props.resetLabel),
                    1
                    /* TEXT */
                  )) : createCommentVNode("v-if", true)
                ])) : createCommentVNode("v-if", true)
              ],
              2
              /* CLASS */
            )
          ])
        ],
        2
        /* CLASS */
      );
    }
    var css_248z$4 = '.vc-photoshop{background:#dcdcdc;border-radius:4px;box-shadow:0 0 0 1px rgba(0,0,0,.25),0 8px 16px rgba(0,0,0,.15);box-sizing:initial;font-family:Roboto;width:513px}.vc-photoshop__disable-fields{width:390px}.vc-ps-head{background-image:linear-gradient(-180deg,#f0f0f0,#d4d4d4);border-bottom:1px solid #b1b1b1;border-radius:4px 4px 0 0;box-shadow:inset 0 1px 0 0 hsla(0,0%,100%,.2),inset 0 -1px 0 0 rgba(0,0,0,.02);color:#4d4d4d;font-size:13px;height:23px;line-height:24px;text-align:center}.vc-ps-body{display:flex;padding:15px}.vc-ps-saturation-wrap{border:2px solid #b3b3b3;border-bottom-color:#f0f0f0;height:256px;overflow:hidden;position:relative;width:256px}.vc-ps-saturation-wrap .vc-saturation-circle{height:12px;width:12px}.vc-ps-hue-wrap{border:2px solid #b3b3b3;border-bottom-color:#f0f0f0;height:256px;margin-left:10px;width:19px}.vc-ps-hue-pointer,.vc-ps-hue-wrap{position:relative}.vc-ps-hue-pointer--left,.vc-ps-hue-pointer--right{border-color:transparent transparent transparent #555;border-style:solid;border-width:5px 0 5px 8px;height:0;position:absolute;width:0}.vc-ps-hue-pointer--left:after,.vc-ps-hue-pointer--right:after{border-color:transparent transparent transparent #fff;border-style:solid;border-width:4px 0 4px 6px;content:"";height:0;left:1px;position:absolute;top:1px;transform:translate(-8px,-5px);width:0}.vc-ps-hue-pointer--left{transform:translate(-13px,-4px)}.vc-ps-hue-pointer--right{transform:translate(20px,-4px) rotate(180deg)}.vc-ps-controls{display:flex;margin-left:10px;width:180px}.vc-ps-controls__disable-fields{width:auto}.vc-ps-actions{flex:1;margin-left:20px}.vc-ps-ac-btn{background-image:linear-gradient(-180deg,#fff,#e6e6e6);border:1px solid #878787;border-radius:2px;box-shadow:0 1px 0 0 #eaeaea;color:#000;cursor:pointer;font-size:14px;height:20px;line-height:20px;margin-bottom:10px;text-align:center}.vc-ps-previews{width:60px}.vc-ps-previews__swatches{border:1px solid #b3b3b3;border-bottom-color:#f0f0f0;margin-bottom:2px;margin-top:1px}.vc-ps-previews__pr-color{box-shadow:inset 1px 0 0 #000,inset -1px 0 0 #000,inset 0 1px 0 #000;height:34px}.vc-ps-previews__label{color:#000;font-size:14px;text-align:center}.vc-ps-fields{padding-bottom:9px;padding-top:5px;position:relative;width:80px}.vc-ps-fields .vc-input__input{border:1px solid #888;box-shadow:inset 0 1px 1px rgba(0,0,0,.1),0 1px 0 0 #ececec;font-size:13px;height:18px;margin-bottom:5px;margin-left:40%;margin-right:10px;padding-left:3px;width:40%}.vc-ps-fields .vc-input__desc,.vc-ps-fields .vc-input__label{font-size:13px;height:18px;line-height:22px;position:absolute;text-transform:uppercase;top:0}.vc-ps-fields .vc-input__label{left:0;width:34px}.vc-ps-fields .vc-input__desc{right:0;width:0}.vc-ps-fields__divider{height:5px}.vc-ps-fields__hex .vc-input__input{border:1px solid #888;box-shadow:inset 0 1px 1px rgba(0,0,0,.1),0 1px 0 0 #ececec;font-size:13px;height:18px;margin-bottom:6px;margin-left:20%;padding-left:3px;width:80%}.vc-ps-fields__hex .vc-input__label{font-size:13px;height:18px;left:0;line-height:22px;position:absolute;text-transform:uppercase;top:0;width:14px}';
    styleInject(css_248z$4);
    script$4.render = render$4;
    script$4.__file = "src/components/photoshop/photoshop.vue";
    script$4.install = install;
    const presetColors = [
      "#D0021B",
      "#F5A623",
      "#F8E71C",
      "#8B572A",
      "#7ED321",
      "#417505",
      "#BD10E0",
      "#9013FE",
      "#4A90E2",
      "#50E3C2",
      "#B8E986",
      "#000000",
      "#4A4A4A",
      "#9B9B9B",
      "#FFFFFF",
      "rgba(0,0,0,0)"
    ];
    var script$3 = {
      name: "Sketch",
      components: {
        Saturation: script$a,
        Hue: script$9,
        Alpha: script$c,
        EdIn: script$b,
        Checkboard: script$d
      },
      mixins: [colorMixin],
      props: {
        presetColors: {
          type: Array,
          default() {
            return presetColors;
          }
        },
        disableAlpha: {
          type: Boolean,
          default: false
        },
        disableFields: {
          type: Boolean,
          default: false
        }
      },
      computed: {
        hex() {
          let hex;
          if (this.colors.a < 1)
            hex = this.colors.hex8;
          else
            hex = this.colors.hex;
          return hex.replace("#", "");
        },
        activeColor() {
          const { rgba } = this.colors;
          return `rgba(${[rgba.r, rgba.g, rgba.b, rgba.a].join(",")})`;
        }
      },
      methods: {
        handlePreset(c2) {
          this.colorChange(c2);
        },
        childChange(data) {
          this.colorChange(data);
        },
        inputChange(data) {
          if (!data)
            return;
          if (data.hex) {
            this.isValidHex(data.hex) && this.colorChange({
              hex: data.hex,
              source: "hex"
            });
          } else if (data.r || data.g || data.b || data.a) {
            this.colorChange({
              r: data.r || this.colors.rgba.r,
              g: data.g || this.colors.rgba.g,
              b: data.b || this.colors.rgba.b,
              a: data.a || this.colors.rgba.a,
              source: "rgba"
            });
          }
        }
      }
    };
    const _hoisted_1$q = { class: "vc-sketch-saturation-wrap" };
    const _hoisted_2$i = { class: "vc-sketch-controls" };
    const _hoisted_3$f = { class: "vc-sketch-sliders" };
    const _hoisted_4$f = { class: "vc-sketch-hue-wrap" };
    const _hoisted_5$e = {
      key: 0,
      class: "vc-sketch-alpha-wrap"
    };
    const _hoisted_6$e = { class: "vc-sketch-color-wrap" };
    const _hoisted_7$c = ["aria-label"];
    const _hoisted_8$9 = {
      key: 0,
      class: "vc-sketch-field"
    };
    const _hoisted_9$9 = { class: "vc-sketch-field--double" };
    const _hoisted_10$8 = { class: "vc-sketch-field--single" };
    const _hoisted_11$8 = { class: "vc-sketch-field--single" };
    const _hoisted_12$8 = { class: "vc-sketch-field--single" };
    const _hoisted_13$8 = {
      key: 0,
      class: "vc-sketch-field--single"
    };
    const _hoisted_14$8 = {
      class: "vc-sketch-presets",
      role: "group",
      "aria-label": "A color preset, pick one to set as current color"
    };
    const _hoisted_15$8 = ["aria-label", "onClick"];
    const _hoisted_16$8 = ["aria-label", "onClick"];
    function render$3(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Saturation = resolveComponent("Saturation");
      const _component_Hue = resolveComponent("Hue");
      const _component_Alpha = resolveComponent("Alpha");
      const _component_Checkboard = resolveComponent("Checkboard");
      const _component_EdIn = resolveComponent("EdIn");
      return openBlock(), createElementBlock(
        "div",
        {
          role: "application",
          "aria-label": "Sketch color picker",
          class: normalizeClass(["vc-sketch", [$props.disableAlpha ? "vc-sketch__disable-alpha" : ""]])
        },
        [
          createBaseVNode("div", _hoisted_1$q, [
            createVNode(_component_Saturation, {
              value: _ctx.colors,
              onChange: $options.childChange
            }, null, 8, ["value", "onChange"])
          ]),
          createBaseVNode("div", _hoisted_2$i, [
            createBaseVNode("div", _hoisted_3$f, [
              createBaseVNode("div", _hoisted_4$f, [
                createVNode(_component_Hue, {
                  value: _ctx.colors,
                  onChange: $options.childChange
                }, null, 8, ["value", "onChange"])
              ]),
              !$props.disableAlpha ? (openBlock(), createElementBlock("div", _hoisted_5$e, [
                createVNode(_component_Alpha, {
                  value: _ctx.colors,
                  onChange: $options.childChange
                }, null, 8, ["value", "onChange"])
              ])) : createCommentVNode("v-if", true)
            ]),
            createBaseVNode("div", _hoisted_6$e, [
              createBaseVNode("div", {
                "aria-label": `Current color is ${$options.activeColor}`,
                class: "vc-sketch-active-color",
                style: normalizeStyle({ background: $options.activeColor })
              }, null, 12, _hoisted_7$c),
              createVNode(_component_Checkboard)
            ])
          ]),
          !$props.disableFields ? (openBlock(), createElementBlock("div", _hoisted_8$9, [
            createCommentVNode(" rgba "),
            createBaseVNode("div", _hoisted_9$9, [
              createVNode(_component_EdIn, {
                label: "hex",
                value: $options.hex,
                onChange: $options.inputChange
              }, null, 8, ["value", "onChange"])
            ]),
            createBaseVNode("div", _hoisted_10$8, [
              createVNode(_component_EdIn, {
                label: "r",
                value: _ctx.colors.rgba.r,
                onChange: $options.inputChange
              }, null, 8, ["value", "onChange"])
            ]),
            createBaseVNode("div", _hoisted_11$8, [
              createVNode(_component_EdIn, {
                label: "g",
                value: _ctx.colors.rgba.g,
                onChange: $options.inputChange
              }, null, 8, ["value", "onChange"])
            ]),
            createBaseVNode("div", _hoisted_12$8, [
              createVNode(_component_EdIn, {
                label: "b",
                value: _ctx.colors.rgba.b,
                onChange: $options.inputChange
              }, null, 8, ["value", "onChange"])
            ]),
            !$props.disableAlpha ? (openBlock(), createElementBlock("div", _hoisted_13$8, [
              createVNode(_component_EdIn, {
                label: "a",
                value: _ctx.colors.a,
                "arrow-offset": 0.01,
                max: 1,
                onChange: $options.inputChange
              }, null, 8, ["value", "arrow-offset", "onChange"])
            ])) : createCommentVNode("v-if", true)
          ])) : createCommentVNode("v-if", true),
          createBaseVNode("div", _hoisted_14$8, [
            (openBlock(true), createElementBlock(
              Fragment,
              null,
              renderList($props.presetColors, (c2) => {
                return openBlock(), createElementBlock(
                  Fragment,
                  null,
                  [
                    !_ctx.isTransparent(c2) ? (openBlock(), createElementBlock("div", {
                      key: `!${c2}`,
                      class: "vc-sketch-presets-color",
                      "aria-label": `Color:${c2}`,
                      style: normalizeStyle({ background: c2 }),
                      onClick: ($event) => $options.handlePreset(c2)
                    }, null, 12, _hoisted_15$8)) : (openBlock(), createElementBlock("div", {
                      key: c2,
                      "aria-label": `Color:${c2}`,
                      class: "vc-sketch-presets-color",
                      onClick: ($event) => $options.handlePreset(c2)
                    }, [
                      createVNode(_component_Checkboard)
                    ], 8, _hoisted_16$8))
                  ],
                  64
                  /* STABLE_FRAGMENT */
                );
              }),
              256
              /* UNKEYED_FRAGMENT */
            ))
          ])
        ],
        2
        /* CLASS */
      );
    }
    var css_248z$3 = ".vc-sketch{background:#fff;border-radius:4px;box-shadow:0 0 0 1px rgba(0,0,0,.15),0 8px 16px rgba(0,0,0,.15);box-sizing:initial;padding:10px 10px 0;position:relative;width:200px}.vc-sketch-saturation-wrap{overflow:hidden;padding-bottom:75%;position:relative;width:100%}.vc-sketch-controls{display:flex}.vc-sketch-sliders{flex:1;padding:4px 0}.vc-sketch-sliders .vc-alpha-gradient,.vc-sketch-sliders .vc-hue{border-radius:2px}.vc-sketch-alpha-wrap,.vc-sketch-hue-wrap{height:10px;position:relative}.vc-sketch-alpha-wrap{margin-top:4px;overflow:hidden}.vc-sketch-color-wrap{border-radius:3px;height:24px;margin-left:4px;margin-top:4px;position:relative;width:24px}.vc-sketch-active-color{border-radius:2px;bottom:0;box-shadow:inset 0 0 0 1px rgba(0,0,0,.15),inset 0 0 4px rgba(0,0,0,.25);left:0;position:absolute;right:0;top:0;z-index:2}.vc-sketch-color-wrap .vc-checkerboard{background-size:auto}.vc-sketch-field{display:flex;padding-top:4px}.vc-sketch-field .vc-input__input{border:none;box-shadow:inset 0 0 0 1px #ccc;font-size:10px;padding:4px 0 3px 10%;width:90%}.vc-sketch-field .vc-input__label{color:#222;display:block;font-size:11px;padding-bottom:4px;padding-top:3px;text-align:center;text-transform:capitalize}.vc-sketch-field--single{flex:1;padding-left:6px}.vc-sketch-field--double{flex:2}.vc-sketch-presets{border-top:1px solid #eee;margin-left:-10px;margin-right:-10px;padding-left:10px;padding-top:10px}.vc-sketch-presets-color{cursor:pointer;display:inline-block;height:16px;margin:0 10px 10px 0;overflow:hidden;position:relative;vertical-align:top;width:16px}.vc-sketch-presets-color,.vc-sketch-presets-color .vc-checkerboard{border-radius:3px;box-shadow:inset 0 0 0 1px rgba(0,0,0,.15)}.vc-sketch__disable-alpha .vc-sketch-color-wrap{height:10px}";
    styleInject(css_248z$3);
    script$3.render = render$3;
    script$3.__file = "src/components/sketch/sketch.vue";
    script$3.install = install;
    const DEFAULT_SATURATION = 0.5;
    var script$2 = {
      name: "Slider",
      components: {
        Hue: script$9
      },
      mixins: [colorMixin],
      props: {
        swatches: {
          type: Array,
          default() {
            return [
              { s: DEFAULT_SATURATION, l: 0.8 },
              { s: DEFAULT_SATURATION, l: 0.65 },
              { s: DEFAULT_SATURATION, l: 0.5 },
              { s: DEFAULT_SATURATION, l: 0.35 },
              { s: DEFAULT_SATURATION, l: 0.2 }
            ];
          }
        }
      },
      computed: {
        normalizedSwatches() {
          const { swatches } = this;
          return swatches.map((swatch) => {
            if (typeof swatch !== "object") {
              return {
                s: DEFAULT_SATURATION,
                l: swatch
              };
            }
            return swatch;
          });
        }
      },
      methods: {
        isActive(swatch, index2) {
          const { hsl } = this.colors;
          if (hsl.l === 1 && swatch.l === 1)
            return true;
          if (hsl.l === 0 && swatch.l === 0)
            return true;
          return Math.abs(hsl.l - swatch.l) < 0.01 && Math.abs(hsl.s - swatch.s) < 0.01;
        },
        hueChange(data) {
          this.colorChange(data);
        },
        handleSwClick(index2, swatch) {
          this.colorChange({
            h: this.colors.hsl.h,
            s: swatch.s,
            l: swatch.l,
            source: "hsl"
          });
        }
      }
    };
    const _hoisted_1$p = {
      role: "application",
      "aria-label": "Slider color picker",
      class: "vc-slider"
    };
    const _hoisted_2$h = { class: "vc-slider-hue-warp" };
    const _hoisted_3$e = {
      class: "vc-slider-swatches",
      role: "group"
    };
    const _hoisted_4$e = ["data-index", "aria-label", "onClick"];
    function render$2(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Hue = resolveComponent("Hue");
      return openBlock(), createElementBlock("div", _hoisted_1$p, [
        createBaseVNode("div", _hoisted_2$h, [
          createVNode(_component_Hue, {
            value: _ctx.colors,
            onChange: $options.hueChange
          }, null, 8, ["value", "onChange"])
        ]),
        createBaseVNode("div", _hoisted_3$e, [
          (openBlock(true), createElementBlock(
            Fragment,
            null,
            renderList($options.normalizedSwatches, (swatch, index2) => {
              return openBlock(), createElementBlock("div", {
                key: index2,
                class: "vc-slider-swatch",
                "data-index": index2,
                "aria-label": `color:${_ctx.colors.hex}`,
                role: "button",
                onClick: ($event) => $options.handleSwClick(index2, swatch)
              }, [
                createBaseVNode(
                  "div",
                  {
                    class: normalizeClass(["vc-slider-swatch-picker", { "vc-slider-swatch-picker--active": $options.isActive(swatch, index2), "vc-slider-swatch-picker--white": swatch.l === 1 }]),
                    style: normalizeStyle({ background: `hsl(${_ctx.colors.hsl.h}, ${swatch.s * 100}%, ${swatch.l * 100}%)` })
                  },
                  null,
                  6
                  /* CLASS, STYLE */
                )
              ], 8, _hoisted_4$e);
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ])
      ]);
    }
    var css_248z$2 = ".vc-slider{position:relative;width:410px}.vc-slider-hue-warp{height:12px;position:relative}.vc-slider-hue-warp .vc-hue-picker{background-color:#f8f8f8;border-radius:6px;box-shadow:0 1px 4px 0 rgba(0,0,0,.37);height:14px;transform:translate(-7px,-2px);width:14px}.vc-slider-swatches{display:flex;margin-top:20px}.vc-slider-swatch{flex:1;margin-right:1px;width:20%}.vc-slider-swatch:first-child{margin-right:1px}.vc-slider-swatch:first-child .vc-slider-swatch-picker{border-radius:2px 0 0 2px}.vc-slider-swatch:last-child{margin-right:0}.vc-slider-swatch:last-child .vc-slider-swatch-picker{border-radius:0 2px 2px 0}.vc-slider-swatch-picker{cursor:pointer;height:12px}.vc-slider-swatch:nth-child(n) .vc-slider-swatch-picker.vc-slider-swatch-picker--active{border-radius:3.6px/2px;transform:scaleY(1.8)}.vc-slider-swatch-picker--white{box-shadow:inset 0 0 0 1px #ddd}.vc-slider-swatch-picker--active.vc-slider-swatch-picker--white{box-shadow:inset 0 0 0 .6px #ddd}";
    styleInject(css_248z$2);
    script$2.render = render$2;
    script$2.__file = "src/components/slider/slider.vue";
    script$2.install = install;
    var red = { "50": "#ffebee", "100": "#ffcdd2", "200": "#ef9a9a", "300": "#e57373", "400": "#ef5350", "500": "#f44336", "600": "#e53935", "700": "#d32f2f", "800": "#c62828", "900": "#b71c1c", "a100": "#ff8a80", "a200": "#ff5252", "a400": "#ff1744", "a700": "#d50000" };
    var pink = { "50": "#fce4ec", "100": "#f8bbd0", "200": "#f48fb1", "300": "#f06292", "400": "#ec407a", "500": "#e91e63", "600": "#d81b60", "700": "#c2185b", "800": "#ad1457", "900": "#880e4f", "a100": "#ff80ab", "a200": "#ff4081", "a400": "#f50057", "a700": "#c51162" };
    var purple = { "50": "#f3e5f5", "100": "#e1bee7", "200": "#ce93d8", "300": "#ba68c8", "400": "#ab47bc", "500": "#9c27b0", "600": "#8e24aa", "700": "#7b1fa2", "800": "#6a1b9a", "900": "#4a148c", "a100": "#ea80fc", "a200": "#e040fb", "a400": "#d500f9", "a700": "#aa00ff" };
    var deepPurple = { "50": "#ede7f6", "100": "#d1c4e9", "200": "#b39ddb", "300": "#9575cd", "400": "#7e57c2", "500": "#673ab7", "600": "#5e35b1", "700": "#512da8", "800": "#4527a0", "900": "#311b92", "a100": "#b388ff", "a200": "#7c4dff", "a400": "#651fff", "a700": "#6200ea" };
    var indigo = { "50": "#e8eaf6", "100": "#c5cae9", "200": "#9fa8da", "300": "#7986cb", "400": "#5c6bc0", "500": "#3f51b5", "600": "#3949ab", "700": "#303f9f", "800": "#283593", "900": "#1a237e", "a100": "#8c9eff", "a200": "#536dfe", "a400": "#3d5afe", "a700": "#304ffe" };
    var blue = { "50": "#e3f2fd", "100": "#bbdefb", "200": "#90caf9", "300": "#64b5f6", "400": "#42a5f5", "500": "#2196f3", "600": "#1e88e5", "700": "#1976d2", "800": "#1565c0", "900": "#0d47a1", "a100": "#82b1ff", "a200": "#448aff", "a400": "#2979ff", "a700": "#2962ff" };
    var lightBlue = { "50": "#e1f5fe", "100": "#b3e5fc", "200": "#81d4fa", "300": "#4fc3f7", "400": "#29b6f6", "500": "#03a9f4", "600": "#039be5", "700": "#0288d1", "800": "#0277bd", "900": "#01579b", "a100": "#80d8ff", "a200": "#40c4ff", "a400": "#00b0ff", "a700": "#0091ea" };
    var cyan = { "50": "#e0f7fa", "100": "#b2ebf2", "200": "#80deea", "300": "#4dd0e1", "400": "#26c6da", "500": "#00bcd4", "600": "#00acc1", "700": "#0097a7", "800": "#00838f", "900": "#006064", "a100": "#84ffff", "a200": "#18ffff", "a400": "#00e5ff", "a700": "#00b8d4" };
    var teal = { "50": "#e0f2f1", "100": "#b2dfdb", "200": "#80cbc4", "300": "#4db6ac", "400": "#26a69a", "500": "#009688", "600": "#00897b", "700": "#00796b", "800": "#00695c", "900": "#004d40", "a100": "#a7ffeb", "a200": "#64ffda", "a400": "#1de9b6", "a700": "#00bfa5" };
    var green = { "50": "#e8f5e9", "100": "#c8e6c9", "200": "#a5d6a7", "300": "#81c784", "400": "#66bb6a", "500": "#4caf50", "600": "#43a047", "700": "#388e3c", "800": "#2e7d32", "900": "#1b5e20", "a100": "#b9f6ca", "a200": "#69f0ae", "a400": "#00e676", "a700": "#00c853" };
    var lightGreen = { "50": "#f1f8e9", "100": "#dcedc8", "200": "#c5e1a5", "300": "#aed581", "400": "#9ccc65", "500": "#8bc34a", "600": "#7cb342", "700": "#689f38", "800": "#558b2f", "900": "#33691e", "a100": "#ccff90", "a200": "#b2ff59", "a400": "#76ff03", "a700": "#64dd17" };
    var lime = { "50": "#f9fbe7", "100": "#f0f4c3", "200": "#e6ee9c", "300": "#dce775", "400": "#d4e157", "500": "#cddc39", "600": "#c0ca33", "700": "#afb42b", "800": "#9e9d24", "900": "#827717", "a100": "#f4ff81", "a200": "#eeff41", "a400": "#c6ff00", "a700": "#aeea00" };
    var yellow = { "50": "#fffde7", "100": "#fff9c4", "200": "#fff59d", "300": "#fff176", "400": "#ffee58", "500": "#ffeb3b", "600": "#fdd835", "700": "#fbc02d", "800": "#f9a825", "900": "#f57f17", "a100": "#ffff8d", "a200": "#ffff00", "a400": "#ffea00", "a700": "#ffd600" };
    var amber = { "50": "#fff8e1", "100": "#ffecb3", "200": "#ffe082", "300": "#ffd54f", "400": "#ffca28", "500": "#ffc107", "600": "#ffb300", "700": "#ffa000", "800": "#ff8f00", "900": "#ff6f00", "a100": "#ffe57f", "a200": "#ffd740", "a400": "#ffc400", "a700": "#ffab00" };
    var orange = { "50": "#fff3e0", "100": "#ffe0b2", "200": "#ffcc80", "300": "#ffb74d", "400": "#ffa726", "500": "#ff9800", "600": "#fb8c00", "700": "#f57c00", "800": "#ef6c00", "900": "#e65100", "a100": "#ffd180", "a200": "#ffab40", "a400": "#ff9100", "a700": "#ff6d00" };
    var deepOrange = { "50": "#fbe9e7", "100": "#ffccbc", "200": "#ffab91", "300": "#ff8a65", "400": "#ff7043", "500": "#ff5722", "600": "#f4511e", "700": "#e64a19", "800": "#d84315", "900": "#bf360c", "a100": "#ff9e80", "a200": "#ff6e40", "a400": "#ff3d00", "a700": "#dd2c00" };
    var brown = { "50": "#efebe9", "100": "#d7ccc8", "200": "#bcaaa4", "300": "#a1887f", "400": "#8d6e63", "500": "#795548", "600": "#6d4c41", "700": "#5d4037", "800": "#4e342e", "900": "#3e2723" };
    var grey = { "50": "#fafafa", "100": "#f5f5f5", "200": "#eeeeee", "300": "#e0e0e0", "400": "#bdbdbd", "500": "#9e9e9e", "600": "#757575", "700": "#616161", "800": "#424242", "900": "#212121" };
    var blueGrey = { "50": "#eceff1", "100": "#cfd8dc", "200": "#b0bec5", "300": "#90a4ae", "400": "#78909c", "500": "#607d8b", "600": "#546e7a", "700": "#455a64", "800": "#37474f", "900": "#263238" };
    var darkText = { "primary": "rgba(0, 0, 0, 0.87)", "secondary": "rgba(0, 0, 0, 0.54)", "disabled": "rgba(0, 0, 0, 0.38)", "dividers": "rgba(0, 0, 0, 0.12)" };
    var lightText = { "primary": "rgba(255, 255, 255, 1)", "secondary": "rgba(255, 255, 255, 0.7)", "disabled": "rgba(255, 255, 255, 0.5)", "dividers": "rgba(255, 255, 255, 0.12)" };
    var darkIcons = { "active": "rgba(0, 0, 0, 0.54)", "inactive": "rgba(0, 0, 0, 0.38)" };
    var lightIcons = { "active": "rgba(255, 255, 255, 1)", "inactive": "rgba(255, 255, 255, 0.5)" };
    var white = "#ffffff";
    var black = "#000000";
    const material = {
      red,
      pink,
      purple,
      deepPurple,
      indigo,
      blue,
      lightBlue,
      cyan,
      teal,
      green,
      lightGreen,
      lime,
      yellow,
      amber,
      orange,
      deepOrange,
      brown,
      grey,
      blueGrey,
      darkText,
      lightText,
      darkIcons,
      lightIcons,
      white,
      black
    };
    const colorMap = [
      "red",
      "pink",
      "purple",
      "deepPurple",
      "indigo",
      "blue",
      "lightBlue",
      "cyan",
      "teal",
      "green",
      "lightGreen",
      "lime",
      "yellow",
      "amber",
      "orange",
      "deepOrange",
      "brown",
      "blueGrey",
      "black"
    ];
    const colorLevel = ["900", "700", "500", "300", "100"];
    const defaultColors$1 = (() => {
      const colors = [];
      colorMap.forEach((type) => {
        let typeColor = [];
        if (type.toLowerCase() === "black" || type.toLowerCase() === "white") {
          typeColor = typeColor.concat(["#000000", "#FFFFFF"]);
        } else {
          colorLevel.forEach((level) => {
            const color = material[type][level];
            typeColor.push(color.toUpperCase());
          });
        }
        colors.push(typeColor);
      });
      return colors;
    })();
    var script$1 = {
      name: "Swatches",
      mixins: [colorMixin],
      props: {
        palette: {
          type: Array,
          default() {
            return defaultColors$1;
          }
        }
      },
      computed: {
        pick() {
          return this.colors.hex;
        }
      },
      methods: {
        equal(color) {
          return color.toLowerCase() === this.colors.hex.toLowerCase();
        },
        handlerClick(c2) {
          this.colorChange({
            hex: c2,
            source: "hex"
          });
        }
      }
    };
    const _hoisted_1$o = ["data-pick"];
    const _hoisted_2$g = {
      class: "vc-swatches-box",
      role: "listbox"
    };
    const _hoisted_3$d = ["aria-label", "aria-selected", "data-color", "onKeyup", "onClick"];
    const _hoisted_4$d = { class: "vc-swatches-pick" };
    const _hoisted_5$d = {
      style: { "width": "24px", "height": "24px" },
      viewBox: "0 0 24 24"
    };
    const _hoisted_6$d = /* @__PURE__ */ createBaseVNode(
      "path",
      { d: "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z" },
      null,
      -1
      /* HOISTED */
    );
    const _hoisted_7$b = [
      _hoisted_6$d
    ];
    function render$1(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        role: "application",
        "aria-label": "Swatches color picker",
        class: "vc-swatches",
        "data-pick": $options.pick
      }, [
        createBaseVNode("div", _hoisted_2$g, [
          (openBlock(true), createElementBlock(
            Fragment,
            null,
            renderList($props.palette, (group, $idx) => {
              return openBlock(), createElementBlock("div", {
                key: $idx,
                class: "vc-swatches-color-group"
              }, [
                (openBlock(true), createElementBlock(
                  Fragment,
                  null,
                  renderList(group, (c2) => {
                    return openBlock(), createElementBlock("div", {
                      key: c2,
                      class: normalizeClass(["vc-swatches-color-it", [{ "vc-swatches-color--white": c2 === "#FFFFFF" }]]),
                      role: "option",
                      "aria-label": `Color:${c2}`,
                      "aria-selected": $options.equal(c2),
                      "data-color": c2,
                      style: normalizeStyle({ background: c2 }),
                      tabindex: "0",
                      onKeyup: withKeys(($event) => $options.handlerClick(c2), ["enter"]),
                      onClick: ($event) => $options.handlerClick(c2)
                    }, [
                      withDirectives(createBaseVNode(
                        "div",
                        _hoisted_4$d,
                        [
                          (openBlock(), createElementBlock("svg", _hoisted_5$d, _hoisted_7$b))
                        ],
                        512
                        /* NEED_PATCH */
                      ), [
                        [vShow, $options.equal(c2)]
                      ])
                    ], 46, _hoisted_3$d);
                  }),
                  128
                  /* KEYED_FRAGMENT */
                ))
              ]);
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ])
      ], 8, _hoisted_1$o);
    }
    var css_248z$1 = ".vc-swatches{background-color:#fff;box-shadow:0 2px 10px rgba(0,0,0,.12),0 2px 5px rgba(0,0,0,.16);height:240px;overflow-y:scroll;width:320px}.vc-swatches-box{overflow:hidden;padding:16px 0 6px 16px}.vc-swatches-color-group{float:left;margin-right:10px;padding-bottom:10px;width:40px}.vc-swatches-color-it{background:#880e4f;-ms-border-radius:2px 2px 0 0;-moz-border-radius:2px 2px 0 0;-o-border-radius:2px 2px 0 0;-webkit-border-radius:2px 2px 0 0;border-radius:2px 2px 0 0;box-sizing:border-box;cursor:pointer;height:24px;margin-bottom:1px;overflow:hidden;width:40px}.vc-swatches-color--white{border:1px solid #ddd}.vc-swatches-pick{fill:#fff;display:block;margin-left:8px}.vc-swatches-color--white .vc-swatches-pick{fill:#333}";
    styleInject(css_248z$1);
    script$1.render = render$1;
    script$1.__file = "src/components/swatches/swatches.vue";
    script$1.install = install;
    const defaultColors = [
      "#FF6900",
      "#FCB900",
      "#7BDCB5",
      "#00D084",
      "#8ED1FC",
      "#0693E3",
      "#ABB8C3",
      "#EB144C",
      "#F78DA7",
      "#9900EF"
    ];
    var script = {
      name: "Twitter",
      components: {
        EditableInput: script$b
      },
      mixins: [colorMixin],
      props: {
        width: {
          type: [String, Number],
          default: 276
        },
        defaultColors: {
          type: Array,
          default() {
            return defaultColors;
          }
        },
        triangle: {
          default: "top-left",
          validator(value) {
            return ["hide", "top-left", "top-right"].includes(value);
          }
        }
      },
      computed: {
        hsv() {
          const { hsv } = this.colors;
          return {
            h: hsv.h.toFixed(),
            s: (hsv.s * 100).toFixed(),
            v: (hsv.v * 100).toFixed()
          };
        },
        hex() {
          const { hex } = this.colors;
          return hex && hex.replace("#", "");
        }
      },
      methods: {
        equal(color) {
          return color.toLowerCase() === this.colors.hex.toLowerCase();
        },
        handlerClick(color) {
          this.colorChange({
            hex: color,
            source: "hex"
          });
        },
        inputChange(data) {
          if (!data)
            return;
          if (data["#"]) {
            this.isValidHex(data["#"]) && this.colorChange({
              hex: data["#"],
              source: "hex"
            });
          } else if (data.r || data.g || data.b || data.a) {
            this.colorChange({
              r: data.r || this.colors.rgba.r,
              g: data.g || this.colors.rgba.g,
              b: data.b || this.colors.rgba.b,
              a: data.a || this.colors.rgba.a,
              source: "rgba"
            });
          } else if (data.h || data.s || data.v) {
            this.colorChange({
              h: data.h || this.colors.hsv.h,
              s: data.s / 100 || this.colors.hsv.s,
              v: data.v / 100 || this.colors.hsv.v,
              source: "hsv"
            });
          }
        }
      }
    };
    const _hoisted_1$n = /* @__PURE__ */ createBaseVNode(
      "div",
      { class: "vc-twitter-triangle-shadow" },
      null,
      -1
      /* HOISTED */
    );
    const _hoisted_2$f = /* @__PURE__ */ createBaseVNode(
      "div",
      { class: "vc-twitter-triangle" },
      null,
      -1
      /* HOISTED */
    );
    const _hoisted_3$c = { class: "vc-twitter-body" };
    const _hoisted_4$c = ["onKeyup", "onClick"];
    const _hoisted_5$c = /* @__PURE__ */ createBaseVNode(
      "div",
      { class: "vc-twitter-hash" },
      " # ",
      -1
      /* HOISTED */
    );
    const _hoisted_6$c = /* @__PURE__ */ createBaseVNode(
      "div",
      { class: "vc-twitter-clear" },
      null,
      -1
      /* HOISTED */
    );
    function render(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_EditableInput = resolveComponent("EditableInput");
      return openBlock(), createElementBlock(
        "div",
        {
          class: normalizeClass(["vc-twitter", {
            "vc-twitter-hide-triangle ": $props.triangle === "hide",
            "vc-twitter-top-left-triangle ": $props.triangle === "top-left",
            "vc-twitter-top-right-triangle ": $props.triangle === "top-right"
          }]),
          style: normalizeStyle({
            width: typeof $props.width === "number" ? `${$props.width}px` : $props.width
          })
        },
        [
          _hoisted_1$n,
          _hoisted_2$f,
          createBaseVNode("div", _hoisted_3$c, [
            (openBlock(true), createElementBlock(
              Fragment,
              null,
              renderList($props.defaultColors, (color, index2) => {
                return openBlock(), createElementBlock("span", {
                  key: index2,
                  class: "vc-twitter-swatch",
                  style: normalizeStyle({
                    background: color,
                    boxShadow: `0 0 4px ${$options.equal(color) ? color : "transparent"}`
                  }),
                  role: "button",
                  tabindex: "0",
                  onKeyup: withKeys(($event) => $options.handlerClick(color), ["enter"]),
                  onClick: ($event) => $options.handlerClick(color)
                }, null, 44, _hoisted_4$c);
              }),
              128
              /* KEYED_FRAGMENT */
            )),
            _hoisted_5$c,
            createVNode(_component_EditableInput, {
              label: "#",
              value: $options.hex,
              onChange: $options.inputChange
            }, null, 8, ["value", "onChange"]),
            _hoisted_6$c
          ])
        ],
        6
        /* CLASS, STYLE */
      );
    }
    var css_248z = ".vc-twitter{background:#fff;border:0 solid rgba(0,0,0,.25);border-radius:4px;box-shadow:0 1px 4px rgba(0,0,0,.25);position:relative}.vc-twitter-triangle{border-color:transparent transparent #fff}.vc-twitter-triangle,.vc-twitter-triangle-shadow{border-style:solid;border-width:0 9px 10px;height:0;position:absolute;width:0}.vc-twitter-triangle-shadow{border-color:transparent transparent rgba(0,0,0,.1)}.vc-twitter-body{padding:15px 9px 9px 15px}.vc-twitter .vc-editable-input{position:relative}.vc-twitter .vc-editable-input input{border:0;border-radius:0 4px 4px 0;box-shadow:inset 0 0 0 1px #f0f0f0;box-sizing:content-box;color:#666;float:left;font-size:14px;height:28px;outline:none;padding:1px 1px 1px 8px;width:100px}.vc-twitter .vc-editable-input span{display:none}.vc-twitter-hash{align-items:center;background:#f0f0f0;border-radius:4px 0 0 4px;color:#98a1a4;display:flex;float:left;height:30px;justify-content:center;width:30px}.vc-twitter-swatch{border-radius:4px;cursor:pointer;float:left;height:30px;margin:0 6px 6px 0;position:relative;width:30px}.vc-twitter-clear{clear:both}.vc-twitter-hide-triangle .vc-twitter-triangle,.vc-twitter-hide-triangle .vc-twitter-triangle-shadow{display:none}.vc-twitter-top-left-triangle .vc-twitter-triangle{left:12px;top:-10px}.vc-twitter-top-left-triangle .vc-twitter-triangle-shadow{left:12px;top:-11px}.vc-twitter-top-right-triangle .vc-twitter-triangle{right:12px;top:-10px}.vc-twitter-top-right-triangle .vc-twitter-triangle-shadow{right:12px;top:-11px}";
    styleInject(css_248z);
    script.render = render;
    script.__file = "src/components/twitter/twitter.vue";
    script.install = install;
    const components = [
      script$c,
      script$d,
      script$8,
      script$7,
      script$b,
      script$6,
      script$9,
      script$5,
      script$4,
      script$a,
      script$3,
      script$2,
      script$1,
      script
    ];
    const _sfc_main$p = {
      mixins: [BarButtonGeneric],
      components: components.reduce((acc, cur) => {
        acc[cur.name] = cur;
        return acc;
      }, {}),
      data() {
        return {
          color: this.item.color
        };
      },
      computed: {
        is_menu() {
          return true;
        },
        css_color() {
          return this.color.hex8 || this.color || "#000";
        }
      },
      methods: {
        mousedown_handler(e2) {
          if (e2.target.tagName.toLowerCase() != "input")
            e2.preventDefault();
        }
      },
      watch: {
        "item.color"(item_color) {
          if (this.color != item_color) {
            this._prevent_next_color_update = true;
            this.color = item_color;
          }
        },
        color(new_color) {
          if (this.item.update_color && !this._prevent_next_color_update) {
            this.item.update_color(new_color);
          }
          this._prevent_next_color_update = false;
        }
      }
    };
    const _hoisted_1$m = ["title"];
    const _hoisted_2$e = ["id"];
    function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["bar-button", _ctx.button_class]),
        title: _ctx.title,
        onMousedown: _cache[2] || (_cache[2] = (...args) => $options.mousedown_handler && $options.mousedown_handler(...args))
      }, [
        createBaseVNode("div", {
          class: "color-square",
          style: normalizeStyle({ "background-color": $options.css_color })
        }, null, 4),
        createBaseVNode("div", {
          class: normalizeClass(["menu", _ctx.item.menu_class]),
          id: _ctx.item.menu_id,
          onClick: _cache[1] || (_cache[1] = (e2) => _ctx.item.stay_open ? e2.stopPropagation() : true)
        }, [
          (openBlock(), createBlock(resolveDynamicComponent(_ctx.item.type || "compact"), {
            modelValue: $data.color,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.color = $event)
          }, null, 8, ["modelValue"]))
        ], 10, _hoisted_2$e)
      ], 42, _hoisted_1$m);
    }
    const BarButtonColor = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["render", _sfc_render$n], ["__scopeId", "data-v-064d1d20"]]);
    const _sfc_main$o = {};
    const _hoisted_1$l = { class: "bar-separator" };
    function _sfc_render$m(_ctx, _cache) {
      return openBlock(), createElementBlock("div", _hoisted_1$l);
    }
    const BarSeparator = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["render", _sfc_render$m]]);
    const _sfc_main$n = {};
    const _hoisted_1$k = { class: "bar-spacer" };
    function _sfc_render$l(_ctx, _cache) {
      return openBlock(), createElementBlock("div", _hoisted_1$k);
    }
    const BarSpacer = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", _sfc_render$l]]);
    const _sfc_main$m = {
      components: {
        BarButtonGeneric,
        BarButtonColor,
        BarSeparator,
        BarSpacer
      },
      props: {
        content: {
          type: Array,
          required: true
        }
      },
      data() {
        return {
          menu_open: false
        };
      },
      methods: {
        clickaway(e2) {
          if (!this.$el.contains(e2.target))
            this.menu_open = false;
        },
        toggle_menu(item, event2) {
          event2.stopPropagation();
          const touch = event2.sourceCapabilities && event2.sourceCapabilities.firesTouchEvents;
          this.menu_open = item._el.is_menu && !item.disabled ? touch ? true : !this.menu_open : false;
        },
        get_component(is) {
          if (is && !Array.isArray(is) && typeof is == "object")
            return is;
          else if (typeof is == "string")
            return "bar-" + is;
          else
            return "bar-button-generic";
        }
      },
      mounted() {
        document.addEventListener("click", this.clickaway);
      },
      beforeUnmount() {
        document.removeEventListener("click", this.clickaway);
      }
    };
    const _hoisted_1$j = { class: "bar" };
    function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$j, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($props.content, (item, item_idx) => {
          return openBlock(), createBlock(resolveDynamicComponent($options.get_component(item.is)), {
            key: "bar-item-" + item_idx,
            item,
            class: normalizeClass(item.class),
            id: item.id,
            is_open: $data.menu_open,
            ref_for: true,
            ref: (el) => Object.defineProperty(item, "_el", { value: el, writable: true }),
            onClick: ($event) => $options.toggle_menu(item, $event)
          }, null, 8, ["item", "class", "id", "is_open", "onClick"]);
        }), 128))
      ]);
    }
    const VueFileToolbarMenu = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["render", _sfc_render$k], ["__scopeId", "data-v-871be110"]]);
    const _sfc_main$l = {
      components: {
        VueFinalModal: Ro$2,
        VueDragResize
      },
      data() {
        return {
          width: 0,
          height: 0,
          top: 100,
          left: 0,
          postResults: {},
          posting: false,
          initalHeight: 400,
          initalLeft: window.innerWidth / 2 - 450
        };
      },
      computed: {
        // other computed properties
        // ...
        // gives access to this.counterStore and this.userStore
        ...mapStores(useProfileStore),
        // ...mapState(usePreferenceStore, ['debugModalData']),
        ...mapWritableState(useProfileStore, ["showPostModal"])
      },
      methods: {
        done: function() {
          this.showPostModal = false;
        },
        dragResize: function(newRect) {
          this.width = newRect.width;
          this.height = newRect.height;
          this.top = newRect.top;
          this.left = newRect.left;
          this.$refs.errorHolder.style.height = newRect.height + "px";
        },
        post: async function() {
          this.$refs.errorHolder.style.height = this.initalHeight + "px";
          this.posting = true;
          this.postResults = {};
          this.postResults = await this.profileStore.publishRecord();
          this.posting = false;
          console.log(this.postResults);
        },
        onSelectElement(event2) {
          const tagName = event2.target.tagName;
          if (tagName === "INPUT" || tagName === "TEXTAREA" || tagName === "SELECT") {
            event2.stopPropagation();
          }
        },
        copyErrorToClipboard: function() {
          var text = this.cleanUpErrorResponse(this.postResults.msg);
          navigator.clipboard.writeText(text).then(function() {
            console.log("Async: Copying to clipboard was successful!");
          }, function(err) {
            console.error("Async: Could not copy text: ", err);
          });
        },
        /** 
        * Helper to make the XML preview display nicer
        * @return {string} - the cleaned up string
        */
        cleanUpErrorResponse: function(msg) {
          msg = JSON.stringify(msg, null, 2);
          msg = msg.replace(/\\n|\\t/g, "").replace(/\\"/g, '"').replace(/&lt;/g, "<").replace(/&gt;/g, ">");
          return msg;
        }
      },
      mounted() {
      }
    };
    const _withScopeId$a = (n2) => (pushScopeId("data-v-2e38c14e"), n2 = n2(), popScopeId(), n2);
    const _hoisted_1$i = { key: 0 };
    const _hoisted_2$d = { key: 1 };
    const _hoisted_3$b = /* @__PURE__ */ _withScopeId$a(() => /* @__PURE__ */ createBaseVNode("h2", null, "There was an error posting. Please report error. ", -1));
    const _hoisted_4$b = { key: 0 };
    const _hoisted_5$b = { key: 2 };
    const _hoisted_6$b = {
      key: 0,
      style: { "margin": "0.5em 0 0.5em 0", "background-color": "#90ee9052", "padding": "0.5em", "border-radius": "0.25em" }
    };
    const _hoisted_7$a = ["href"];
    function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_VueDragResize = resolveComponent("VueDragResize");
      const _component_VueFinalModal = resolveComponent("VueFinalModal");
      return openBlock(), createBlock(_component_VueFinalModal, {
        "display-directive": "show",
        "hide-overlay": false,
        "overlay-transition": "vfm-fade",
        "click-to-close": false,
        "esc-to-close": false
      }, {
        default: withCtx(() => [
          createVNode(_component_VueDragResize, {
            "is-active": true,
            w: 900,
            h: $data.initalHeight,
            x: $data.initalLeft,
            class: "login-modal",
            onResizing: $options.dragResize,
            onDragging: $options.dragResize,
            sticks: ["br"],
            stickSize: 22
          }, {
            default: withCtx(() => [
              createBaseVNode("div", {
                id: "error-holder",
                ref: "errorHolder",
                onMousedown: _cache[3] || (_cache[3] = ($event) => $options.onSelectElement($event)),
                onTouchstart: _cache[4] || (_cache[4] = ($event) => $options.onSelectElement($event))
              }, [
                $data.posting ? (openBlock(), createElementBlock("h1", _hoisted_1$i, "Posting please wait...")) : createCommentVNode("", true),
                $data.posting == false && Object.keys($data.postResults).length != 0 ? (openBlock(), createElementBlock("div", _hoisted_2$d, [
                  _hoisted_3$b,
                  createBaseVNode("button", {
                    onClick: _cache[0] || (_cache[0] = (...args) => $options.copyErrorToClipboard && $options.copyErrorToClipboard(...args))
                  }, "Copy error to clipboard"),
                  createTextVNode(),
                  createBaseVNode("button", {
                    onClick: _cache[1] || (_cache[1] = (...args) => $options.done && $options.done(...args))
                  }, "Close"),
                  createBaseVNode("div", null, [
                    $data.postResults.status === false ? (openBlock(), createElementBlock("code", _hoisted_4$b, toDisplayString$2($options.cleanUpErrorResponse($data.postResults.msg)), 1)) : createCommentVNode("", true)
                  ])
                ])) : createCommentVNode("", true),
                $data.posting == true && Object.keys($data.postResults).length != 0 ? (openBlock(), createElementBlock("div", _hoisted_5$b, [
                  $data.postResults.resourceLinks.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_6$b, [
                    createTextVNode(" The record was accepted by the system. To view the record follow these links: "),
                    (openBlock(true), createElementBlock(Fragment, null, renderList($data.postResults.resourceLinks, (rl) => {
                      return openBlock(), createElementBlock("div", {
                        key: rl.url
                      }, [
                        createBaseVNode("a", {
                          href: rl.url + "?blastdacache=" + Date.now(),
                          target: "_blank"
                        }, "View " + toDisplayString$2(rl.type) + " on " + toDisplayString$2(rl.env), 9, _hoisted_7$a)
                      ]);
                    }), 128))
                  ])) : createCommentVNode("", true)
                ])) : createCommentVNode("", true),
                createBaseVNode("button", {
                  onClick: _cache[2] || (_cache[2] = (...args) => $options.done && $options.done(...args))
                }, "Close")
              ], 544)
            ]),
            _: 1
          }, 8, ["h", "x", "onResizing", "onDragging"])
        ]),
        _: 1
      });
    }
    const PostModal = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["render", _sfc_render$j], ["__scopeId", "data-v-2e38c14e"]]);
    const _sfc_main$k = {
      components: { VueFileToolbarMenu, PostModal },
      data() {
        return {
          happy: false,
          test: "testsss"
        };
      },
      props: {
        disable: {
          default: [],
          type: Array
        }
      },
      computed: {
        ...mapStores(useProfileStore, usePreferenceStore),
        ...mapState(useProfileStore, ["profilesLoaded", "activeProfile", "rtLookup", "activeProfileSaved"]),
        ...mapState(usePreferenceStore, ["styleDefault", "showPrefModal", "panelDisplay"]),
        ...mapWritableState(usePreferenceStore, ["showLoginModal", "showScriptshifterConfigModal"]),
        ...mapWritableState(useProfileStore, ["showPostModal"]),
        panelTitleProperties() {
          return this.panelDisplay.properties ? "done" : "";
        },
        panelTitleDualEdit() {
          return this.panelDisplay.dualEdit ? "done" : "";
        },
        panelTitleOpacEdit() {
          return this.panelDisplay.opac ? "done" : "";
        },
        panelTitleXMLEdit() {
          return this.panelDisplay.xml ? "done" : "";
        },
        panelTitleMARCEdit() {
          return this.panelDisplay.marc ? "done" : "";
        },
        userName() {
          if (this.preferenceStore.catInitals && this.preferenceStore.catCode) {
            return `${this.preferenceStore.catInitals} (${this.preferenceStore.catCode})`;
          } else if (this.preferenceStore.catInitals) {
            return this.preferenceStore.catInitals;
          } else
            ;
        },
        my_menu() {
          let menu = [];
          if (!this.disable.includes("logo")) {
            menu.push({
              // html: `
              //     <svg width="25px" height="25px" version="1.1" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
              //      <g class="nav-icon-color" >
              //       <path d="m55.5 34.398-20.199 63.102 11.898-1.1992 31.199-63.801z"/>
              //       <path d="m59.898 4.5-3.1992 23.898 21.199-1.6992z"/>
              //       <path d="m54.301 2.5-26.699 11.699 23.398 12.801z"/>
              //       <path d="m24.102 18.898-2.5 69.301 8.0977 7.8008 20.102-63z"/>
              //      </g>
              //     </svg>
              //     `,         
              // html: `
              //     <span style="font-size:2em; font-weight:bold; position: absolute; width: 100px; left:0;">M</span>
              //     `,                
            });
          }
          if (!this.disable.includes("Menu")) {
            menu.push(
              { text: "Menu", menu: [
                { text: "Load Resource", click: () => this.$router.push("/load"), icon: "💾" }
              ] }
            );
          }
          if (!this.disable.includes("View")) {
            menu.push(
              { text: "View", menu: [
                { text: "Properties", click: () => this.preferenceStore.togglePanel("properties"), icon: this.panelTitleProperties },
                { text: "Dual Edit", click: () => this.preferenceStore.togglePanel("dualEdit"), icon: this.panelTitleDualEdit },
                { text: "Preview OPAC", click: () => this.preferenceStore.togglePanel("opac"), icon: this.panelTitleOpacEdit },
                { text: "Preview XML", click: () => this.preferenceStore.togglePanel("xml"), icon: this.panelTitleXMLEdit },
                { text: "Preview MARC", click: () => this.preferenceStore.togglePanel("marc"), icon: this.panelTitleMARCEdit },
                { is: "separator" }
              ] }
            );
          }
          if (!this.disable.includes("Preferences")) {
            menu.push(
              { text: "Preferences", menu: [
                { text: "Scriptshifter", click: () => this.showScriptshifterConfigModal = true, icon: "translate" },
                { is: "separator" },
                { text: "General", click: () => this.preferenceStore.togglePrefModal("General") },
                { text: "Edit Panel", click: () => this.preferenceStore.togglePrefModal("Edit Panel") },
                { text: "Literal Field", click: () => this.preferenceStore.togglePrefModal("Literal Field") },
                { text: "Complex Lookup", click: () => this.preferenceStore.togglePrefModal("Complex Lookup") },
                { text: "Action Button", click: () => this.preferenceStore.togglePrefModal("Action Button") },
                { text: "Nav Bar", click: () => this.preferenceStore.togglePrefModal("Nav Bar") },
                { text: "Sidebars - OPAC", click: () => this.preferenceStore.togglePrefModal("General") },
                { text: "Sidebars - Property", click: () => this.preferenceStore.togglePrefModal("General") }
              ] }
            );
          }
          if (this.$route.path.startsWith("/edit/")) {
            menu.push({ is: "separator" });
          }
          if (this.$route.path.startsWith("/edit/")) {
            menu.push(
              {
                text: this.activeProfileSaved ? "Saved" : "Save",
                disabled: this.activeProfileSaved ? true : false,
                // active: this.happy,
                icon: this.activeProfileSaved ? "turned_in" : "turned_in_not",
                class: this.activeProfileSaved ? "save-saved" : "save-not-saved",
                click: () => {
                  this.profileStore.saveRecord();
                }
              }
            );
            menu.push(
              {
                text: "Post",
                icon: "sailing",
                click: () => {
                  this.showPostModal = true;
                  this.$nextTick(() => {
                    this.$refs.postmodal.post();
                  });
                }
              }
            );
          }
          menu.push(
            {
              text: this.userName,
              // active: this.happy,
              icon: "account_circle",
              class: "login-menu",
              click: () => {
                this.showLoginModal = true;
              }
            }
          );
          return menu;
        }
      },
      // watch: {
      //   // whenever question changes, this function will run
      //   question(newVal, oldVal) {
      //     if(newVal===true){
      //     }
      //   }
      // },
      methods: {
        returnPixleAsPercent: function(pixles) {
          return pixles / window.innerHeight * 100;
        }
      },
      created() {
      }
    };
    const __injectCSSVars__$a = () => {
      useCssVars((_ctx) => ({
        "64e4d156": _ctx.preferenceStore.returnValue("--n-edit-main-splitpane-nav-font-size"),
        "29f94bab": _ctx.preferenceStore.returnValue("--n-edit-main-splitpane-nav-height", true) - 1 + "px",
        "777b4b46": _ctx.preferenceStore.returnValue("--c-edit-main-splitpane-nav-font-color"),
        "5e9dbbbc": _ctx.preferenceStore.returnValue("--c-edit-main-splitpane-nav-background-color")
      }));
    };
    const __setup__$a = _sfc_main$k.setup;
    _sfc_main$k.setup = __setup__$a ? (props, ctx) => {
      __injectCSSVars__$a();
      return __setup__$a(props, ctx);
    } : __injectCSSVars__$a;
    const _hoisted_1$h = { id: "nav-holder" };
    function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_vue_file_toolbar_menu = resolveComponent("vue-file-toolbar-menu");
      const _component_PostModal = resolveComponent("PostModal");
      return openBlock(), createElementBlock("div", null, [
        (openBlock(), createBlock(Teleport, { to: "body" }, [
          createBaseVNode("div", _hoisted_1$h, [
            createVNode(_component_vue_file_toolbar_menu, { content: $options.my_menu }, null, 8, ["content"])
          ]),
          _ctx.showPostModal == true ? (openBlock(), createBlock(_component_PostModal, {
            key: 0,
            ref: "postmodal",
            modelValue: _ctx.showPostModal,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.showPostModal = $event)
          }, null, 8, ["modelValue"])) : createCommentVNode("", true)
        ]))
      ]);
    }
    const Nav = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$i], ["__scopeId", "data-v-1ba5c538"]]);
    ({
      components: { Splitpanes: M$1, Pane: g$3, Nav },
      data() {
        return {};
      },
      computed: {
        // other computed properties
        // ...
        // gives access to this.counterStore and this.userStore
        ...mapStores(usePreferenceStore)
      },
      methods: {
        returnPixleAsPercent: function(pixles) {
          return pixles / window.innerHeight * 100;
        }
      },
      props: {}
    });
    const PROVIDE_INJECT_KEY_ACCORDION_LIST = "PROVIDE_INJECT_KEY_ACCORDION_LIST";
    const _sfc_main$1$1 = /* @__PURE__ */ defineComponent({
      __name: "AccordionList",
      props: {
        openMultipleItems: { type: Boolean },
        state: null,
        setClosePropertyTime: null
      },
      emits: ["update:state"],
      setup(__props, { emit: emit2 }) {
        const props = __props;
        const localState = ref({});
        const state = computed({
          set(newState) {
            const usePropsState = !!props.state;
            if (usePropsState)
              emit2("update:state", newState);
            else
              localState.value = newState;
          },
          get() {
            return props.state ? props.state : localState.value;
          }
        });
        const hasOpenedItem = computed(() => {
          return Object.values(state.value).some((status) => status);
        });
        let counter = 0;
        let resizeObserver = null;
        const rootElementRef = ref();
        function observeElements() {
          var _a;
          resizeObserver == null ? void 0 : resizeObserver.disconnect();
          resizeObserver = new ResizeObserver((entries) => {
            entries.forEach(({ target, contentRect }) => {
              var _a2, _b, _c, _d;
              if (target.classList.contains("accordion-item__content"))
                (_b = (_a2 = target.parentElement) == null ? void 0 : _a2.style) == null ? void 0 : _b.setProperty("--content-height", `${contentRect.height}px`);
              if (target.tagName.toLowerCase() === "summary")
                (_d = (_c = target.parentElement) == null ? void 0 : _c.style) == null ? void 0 : _d.setProperty("--summary-height", `${contentRect.height}px`);
            });
          });
          const elements = ((_a = rootElementRef.value) == null ? void 0 : _a.querySelectorAll(".accordion-item__content, summary")) || [];
          elements.forEach((element) => resizeObserver == null ? void 0 : resizeObserver.observe(element));
        }
        function onItemInit(payload) {
          const isObserverCreated = !!resizeObserver;
          if (isObserverCreated)
            observeElements();
          const canAddOpenedItem = !hasOpenedItem.value || !!props.openMultipleItems;
          const id2 = payload.id || (counter++).toString();
          const shouldBeOpenedByDefault = !!payload.defaultOpened && canAddOpenedItem;
          const isItemOpened = shouldBeOpenedByDefault || !!payload.isOnServerOpened || state.value[id2];
          state.value[id2] = isItemOpened;
          return { id: id2, isItemOpened };
        }
        function onItemTrigger(id2) {
          const newState = { ...state.value };
          const newItemValue = !newState[id2];
          if (!props.openMultipleItems)
            Object.keys(newState).forEach((key2) => newState[key2] = false);
          newState[id2] = newItemValue;
          state.value = newState;
        }
        onMounted(observeElements);
        onBeforeUnmount(() => {
          if (!resizeObserver)
            return;
          resizeObserver.disconnect();
          resizeObserver = null;
        });
        provide(PROVIDE_INJECT_KEY_ACCORDION_LIST, {
          init: onItemInit,
          trigger: onItemTrigger,
          setClosePropertyTime: props.setClosePropertyTime || 100,
          accordionListState: state
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("div", {
            ref_key: "rootElementRef",
            ref: rootElementRef,
            class: "accordion-list"
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 512);
        };
      }
    });
    const _hoisted_1$g = ["open", "data-id", "data-is-on-server-opened"];
    const _hoisted_2$c = ["onClick"];
    const _hoisted_3$a = { class: "accordion-item__summary-title" };
    const _hoisted_4$a = {
      key: 0,
      class: "accordion-item__summary-icon"
    };
    const _hoisted_5$a = {
      key: 1,
      class: "accordion-item__summary-icon accordion-item__summary-icon--default"
    };
    const _hoisted_6$a = { class: "accordion-item__content" };
    const _sfc_main$j = /* @__PURE__ */ defineComponent({
      __name: "AccordionItem",
      props: {
        id: null,
        defaultOpened: { type: Boolean },
        disabled: { type: Boolean }
      },
      setup(__props) {
        const props = __props;
        const { trigger: trigger2, init, accordionListState, setClosePropertyTime } = inject(PROVIDE_INJECT_KEY_ACCORDION_LIST) || {};
        const currentItemState = computed(() => (accordionListState == null ? void 0 : accordionListState.value[id2.value]) || false);
        const detailsRef = ref();
        const id2 = ref("");
        const isTransitionPending = ref(false);
        const detailsElementState = ref(currentItemState.value);
        const isOnServerOpened = ref(false);
        const onServerId = ref("");
        onServerPrefetch(async () => {
          if (!init) {
            console.error("no initItem function provided, please use AccordionItem only inside AccordionList");
            return;
          }
          const { id: id22, isItemOpened } = init({ ...props });
          isOnServerOpened.value = isItemOpened;
          onServerId.value = id22;
        });
        onMounted(() => {
          var _a, _b, _c;
          if (!init) {
            console.error("no initItem function provided, please use AccordionItem only inside AccordionList");
            return;
          }
          if ((_a = detailsRef.value) == null ? void 0 : _a.dataset.id)
            id2.value = detailsRef.value.dataset.id;
          const isOnServerOpened2 = ((_c = (_b = detailsRef.value) == null ? void 0 : _b.dataset) == null ? void 0 : _c.isOnServerOpened) == "true";
          const { id: onServerId2 } = init({ ...props, isOnServerOpened: isOnServerOpened2 });
          id2.value = onServerId2;
        });
        function onSummaryClick() {
          if (!trigger2 || props.disabled)
            return;
          trigger2(id2.value);
        }
        const detailsClasses = computed(() => {
          return {
            "accordion-item--open": currentItemState.value || isOnServerOpened.value,
            "accordion-item--disabled": props.disabled
          };
        });
        function onTransitionRun() {
          isTransitionPending.value = true;
        }
        function onTransitionEnd() {
          isTransitionPending.value = false;
          detailsElementState.value = currentItemState.value;
        }
        watch$1(currentItemState, (newValue) => {
          if (newValue) {
            detailsElementState.value = true;
            return;
          }
          setTimeout(() => {
            if (!isTransitionPending.value)
              detailsElementState.value = false;
          }, setClosePropertyTime);
        });
        return (_ctx, _cache) => {
          return openBlock(), createElementBlock("details", {
            ref_key: "detailsRef",
            ref: detailsRef,
            class: normalizeClass(["accordion-item", unref(detailsClasses)]),
            open: detailsElementState.value || isOnServerOpened.value,
            "data-id": onServerId.value,
            "data-is-on-server-opened": isOnServerOpened.value,
            onTransitionrun: onTransitionRun,
            onTransitionend: onTransitionEnd
          }, [
            createBaseVNode("summary", {
              class: "accordion-item__summary",
              onClick: withModifiers(onSummaryClick, ["prevent"])
            }, [
              createBaseVNode("span", _hoisted_3$a, [
                renderSlot(_ctx.$slots, "summary")
              ]),
              _ctx.$slots.icon ? (openBlock(), createElementBlock("span", _hoisted_4$a, [
                renderSlot(_ctx.$slots, "icon")
              ])) : (openBlock(), createElementBlock("span", _hoisted_5$a))
            ], 8, _hoisted_2$c),
            createBaseVNode("div", _hoisted_6$a, [
              renderSlot(_ctx.$slots, "default")
            ])
          ], 42, _hoisted_1$g);
        };
      }
    });
    var vuedraggable_umd = { exports: {} };
    /**!
     * Sortable 1.14.0
     * @author	RubaXa   <trash@rubaxa.org>
     * @author	owenm    <owen23355@gmail.com>
     * @license MIT
     */
    function ownKeys$a(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols2 = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
          symbols2 = symbols2.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        }
        keys.push.apply(keys, symbols2);
      }
      return keys;
    }
    function _objectSpread2(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2] != null ? arguments[i2] : {};
        if (i2 % 2) {
          ownKeys$a(Object(source), true).forEach(function(key2) {
            _defineProperty$a(target, key2, source[key2]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys$a(Object(source)).forEach(function(key2) {
            Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
          });
        }
      }
      return target;
    }
    function _typeof$6(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof$6 = function(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof$6 = function(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof$6(obj);
    }
    function _defineProperty$a(obj, key2, value) {
      if (key2 in obj) {
        Object.defineProperty(obj, key2, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key2] = value;
      }
      return obj;
    }
    function _extends() {
      _extends = Object.assign || function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key2 in source) {
            if (Object.prototype.hasOwnProperty.call(source, key2)) {
              target[key2] = source[key2];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key2, i2;
      for (i2 = 0; i2 < sourceKeys.length; i2++) {
        key2 = sourceKeys[i2];
        if (excluded.indexOf(key2) >= 0)
          continue;
        target[key2] = source[key2];
      }
      return target;
    }
    function _objectWithoutProperties(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose(source, excluded);
      var key2, i2;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
          key2 = sourceSymbolKeys[i2];
          if (excluded.indexOf(key2) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key2))
            continue;
          target[key2] = source[key2];
        }
      }
      return target;
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$3(arr) || _nonIterableSpread();
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray$3(arr);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _unsupportedIterableToArray$3(o3, minLen) {
      if (!o3)
        return;
      if (typeof o3 === "string")
        return _arrayLikeToArray$3(o3, minLen);
      var n2 = Object.prototype.toString.call(o3).slice(8, -1);
      if (n2 === "Object" && o3.constructor)
        n2 = o3.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o3);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray$3(o3, minLen);
    }
    function _arrayLikeToArray$3(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
        arr2[i2] = arr[i2];
      return arr2;
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var version = "1.14.0";
    function userAgent(pattern) {
      if (typeof window !== "undefined" && window.navigator) {
        return !!/* @__PURE__ */ navigator.userAgent.match(pattern);
      }
    }
    var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
    var Edge = userAgent(/Edge/i);
    var FireFox = userAgent(/firefox/i);
    var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
    var IOS = userAgent(/iP(ad|od|hone)/i);
    var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
    var captureMode = {
      capture: false,
      passive: false
    };
    function on(el, event2, fn2) {
      el.addEventListener(event2, fn2, !IE11OrLess && captureMode);
    }
    function off(el, event2, fn2) {
      el.removeEventListener(event2, fn2, !IE11OrLess && captureMode);
    }
    function matches(el, selector) {
      if (!selector)
        return;
      selector[0] === ">" && (selector = selector.substring(1));
      if (el) {
        try {
          if (el.matches) {
            return el.matches(selector);
          } else if (el.msMatchesSelector) {
            return el.msMatchesSelector(selector);
          } else if (el.webkitMatchesSelector) {
            return el.webkitMatchesSelector(selector);
          }
        } catch (_2) {
          return false;
        }
      }
      return false;
    }
    function getParentOrHost(el) {
      return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
    }
    function closest(el, selector, ctx, includeCTX) {
      if (el) {
        ctx = ctx || document;
        do {
          if (selector != null && (selector[0] === ">" ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
            return el;
          }
          if (el === ctx)
            break;
        } while (el = getParentOrHost(el));
      }
      return null;
    }
    var R_SPACE = /\s+/g;
    function toggleClass(el, name, state) {
      if (el && name) {
        if (el.classList) {
          el.classList[state ? "add" : "remove"](name);
        } else {
          var className = (" " + el.className + " ").replace(R_SPACE, " ").replace(" " + name + " ", " ");
          el.className = (className + (state ? " " + name : "")).replace(R_SPACE, " ");
        }
      }
    }
    function css(el, prop, val) {
      var style = el && el.style;
      if (style) {
        if (val === void 0) {
          if (document.defaultView && document.defaultView.getComputedStyle) {
            val = document.defaultView.getComputedStyle(el, "");
          } else if (el.currentStyle) {
            val = el.currentStyle;
          }
          return prop === void 0 ? val : val[prop];
        } else {
          if (!(prop in style) && prop.indexOf("webkit") === -1) {
            prop = "-webkit-" + prop;
          }
          style[prop] = val + (typeof val === "string" ? "" : "px");
        }
      }
    }
    function matrix(el, selfOnly) {
      var appliedTransforms = "";
      if (typeof el === "string") {
        appliedTransforms = el;
      } else {
        do {
          var transform2 = css(el, "transform");
          if (transform2 && transform2 !== "none") {
            appliedTransforms = transform2 + " " + appliedTransforms;
          }
        } while (!selfOnly && (el = el.parentNode));
      }
      var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
      return matrixFn && new matrixFn(appliedTransforms);
    }
    function find(ctx, tagName, iterator2) {
      if (ctx) {
        var list = ctx.getElementsByTagName(tagName), i2 = 0, n2 = list.length;
        if (iterator2) {
          for (; i2 < n2; i2++) {
            iterator2(list[i2], i2);
          }
        }
        return list;
      }
      return [];
    }
    function getWindowScrollingElement() {
      var scrollingElement = document.scrollingElement;
      if (scrollingElement) {
        return scrollingElement;
      } else {
        return document.documentElement;
      }
    }
    function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
      if (!el.getBoundingClientRect && el !== window)
        return;
      var elRect, top2, left2, bottom2, right2, height, width;
      if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
        elRect = el.getBoundingClientRect();
        top2 = elRect.top;
        left2 = elRect.left;
        bottom2 = elRect.bottom;
        right2 = elRect.right;
        height = elRect.height;
        width = elRect.width;
      } else {
        top2 = 0;
        left2 = 0;
        bottom2 = window.innerHeight;
        right2 = window.innerWidth;
        height = window.innerHeight;
        width = window.innerWidth;
      }
      if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
        container = container || el.parentNode;
        if (!IE11OrLess) {
          do {
            if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
              var containerRect = container.getBoundingClientRect();
              top2 -= containerRect.top + parseInt(css(container, "border-top-width"));
              left2 -= containerRect.left + parseInt(css(container, "border-left-width"));
              bottom2 = top2 + elRect.height;
              right2 = left2 + elRect.width;
              break;
            }
          } while (container = container.parentNode);
        }
      }
      if (undoScale && el !== window) {
        var elMatrix = matrix(container || el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
        if (elMatrix) {
          top2 /= scaleY;
          left2 /= scaleX;
          width /= scaleX;
          height /= scaleY;
          bottom2 = top2 + height;
          right2 = left2 + width;
        }
      }
      return {
        top: top2,
        left: left2,
        bottom: bottom2,
        right: right2,
        width,
        height
      };
    }
    function isScrolledPast(el, elSide, parentSide) {
      var parent = getParentAutoScrollElement(el, true), elSideVal = getRect(el)[elSide];
      while (parent) {
        var parentSideVal = getRect(parent)[parentSide], visible = void 0;
        {
          visible = elSideVal >= parentSideVal;
        }
        if (!visible)
          return parent;
        if (parent === getWindowScrollingElement())
          break;
        parent = getParentAutoScrollElement(parent, false);
      }
      return false;
    }
    function getChild(el, childNum, options, includeDragEl) {
      var currentChild = 0, i2 = 0, children = el.children;
      while (i2 < children.length) {
        if (children[i2].style.display !== "none" && children[i2] !== Sortable.ghost && (includeDragEl || children[i2] !== Sortable.dragged) && closest(children[i2], options.draggable, el, false)) {
          if (currentChild === childNum) {
            return children[i2];
          }
          currentChild++;
        }
        i2++;
      }
      return null;
    }
    function lastChild(el, selector) {
      var last = el.lastElementChild;
      while (last && (last === Sortable.ghost || css(last, "display") === "none" || selector && !matches(last, selector))) {
        last = last.previousElementSibling;
      }
      return last || null;
    }
    function index(el, selector) {
      var index2 = 0;
      if (!el || !el.parentNode) {
        return -1;
      }
      while (el = el.previousElementSibling) {
        if (el.nodeName.toUpperCase() !== "TEMPLATE" && el !== Sortable.clone && (!selector || matches(el, selector))) {
          index2++;
        }
      }
      return index2;
    }
    function getRelativeScrollOffset(el) {
      var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
      if (el) {
        do {
          var elMatrix = matrix(el), scaleX = elMatrix.a, scaleY = elMatrix.d;
          offsetLeft += el.scrollLeft * scaleX;
          offsetTop += el.scrollTop * scaleY;
        } while (el !== winScroller && (el = el.parentNode));
      }
      return [offsetLeft, offsetTop];
    }
    function indexOfObject(arr, obj) {
      for (var i2 in arr) {
        if (!arr.hasOwnProperty(i2))
          continue;
        for (var key2 in obj) {
          if (obj.hasOwnProperty(key2) && obj[key2] === arr[i2][key2])
            return Number(i2);
        }
      }
      return -1;
    }
    function getParentAutoScrollElement(el, includeSelf) {
      if (!el || !el.getBoundingClientRect)
        return getWindowScrollingElement();
      var elem = el;
      var gotSelf = false;
      do {
        if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
          var elemCSS = css(elem);
          if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
            if (!elem.getBoundingClientRect || elem === document.body)
              return getWindowScrollingElement();
            if (gotSelf || includeSelf)
              return elem;
            gotSelf = true;
          }
        }
      } while (elem = elem.parentNode);
      return getWindowScrollingElement();
    }
    function extend(dst, src) {
      if (dst && src) {
        for (var key2 in src) {
          if (src.hasOwnProperty(key2)) {
            dst[key2] = src[key2];
          }
        }
      }
      return dst;
    }
    function isRectEqual(rect1, rect2) {
      return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
    }
    var _throttleTimeout;
    function throttle(callback, ms) {
      return function() {
        if (!_throttleTimeout) {
          var args = arguments, _this = this;
          if (args.length === 1) {
            callback.call(_this, args[0]);
          } else {
            callback.apply(_this, args);
          }
          _throttleTimeout = setTimeout(function() {
            _throttleTimeout = void 0;
          }, ms);
        }
      };
    }
    function cancelThrottle() {
      clearTimeout(_throttleTimeout);
      _throttleTimeout = void 0;
    }
    function scrollBy(el, x2, y2) {
      el.scrollLeft += x2;
      el.scrollTop += y2;
    }
    function clone(el) {
      var Polymer = window.Polymer;
      var $2 = window.jQuery || window.Zepto;
      if (Polymer && Polymer.dom) {
        return Polymer.dom(el).cloneNode(true);
      } else if ($2) {
        return $2(el).clone(true)[0];
      } else {
        return el.cloneNode(true);
      }
    }
    function setRect(el, rect) {
      css(el, "position", "absolute");
      css(el, "top", rect.top);
      css(el, "left", rect.left);
      css(el, "width", rect.width);
      css(el, "height", rect.height);
    }
    function unsetRect(el) {
      css(el, "position", "");
      css(el, "top", "");
      css(el, "left", "");
      css(el, "width", "");
      css(el, "height", "");
    }
    var expando = "Sortable" + (/* @__PURE__ */ new Date()).getTime();
    function AnimationStateManager() {
      var animationStates = [], animationCallbackId;
      return {
        captureAnimationState: function captureAnimationState() {
          animationStates = [];
          if (!this.options.animation)
            return;
          var children = [].slice.call(this.el.children);
          children.forEach(function(child2) {
            if (css(child2, "display") === "none" || child2 === Sortable.ghost)
              return;
            animationStates.push({
              target: child2,
              rect: getRect(child2)
            });
            var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
            if (child2.thisAnimationDuration) {
              var childMatrix = matrix(child2, true);
              if (childMatrix) {
                fromRect.top -= childMatrix.f;
                fromRect.left -= childMatrix.e;
              }
            }
            child2.fromRect = fromRect;
          });
        },
        addAnimationState: function addAnimationState(state) {
          animationStates.push(state);
        },
        removeAnimationState: function removeAnimationState(target) {
          animationStates.splice(indexOfObject(animationStates, {
            target
          }), 1);
        },
        animateAll: function animateAll(callback) {
          var _this = this;
          if (!this.options.animation) {
            clearTimeout(animationCallbackId);
            if (typeof callback === "function")
              callback();
            return;
          }
          var animating = false, animationTime = 0;
          animationStates.forEach(function(state) {
            var time = 0, target = state.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state.rect, targetMatrix = matrix(target, true);
            if (targetMatrix) {
              toRect.top -= targetMatrix.f;
              toRect.left -= targetMatrix.e;
            }
            target.toRect = toRect;
            if (target.thisAnimationDuration) {
              if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
              (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
                time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
              }
            }
            if (!isRectEqual(toRect, fromRect)) {
              target.prevFromRect = fromRect;
              target.prevToRect = toRect;
              if (!time) {
                time = _this.options.animation;
              }
              _this.animate(target, animatingRect, toRect, time);
            }
            if (time) {
              animating = true;
              animationTime = Math.max(animationTime, time);
              clearTimeout(target.animationResetTimer);
              target.animationResetTimer = setTimeout(function() {
                target.animationTime = 0;
                target.prevFromRect = null;
                target.fromRect = null;
                target.prevToRect = null;
                target.thisAnimationDuration = null;
              }, time);
              target.thisAnimationDuration = time;
            }
          });
          clearTimeout(animationCallbackId);
          if (!animating) {
            if (typeof callback === "function")
              callback();
          } else {
            animationCallbackId = setTimeout(function() {
              if (typeof callback === "function")
                callback();
            }, animationTime);
          }
          animationStates = [];
        },
        animate: function animate(target, currentRect, toRect, duration) {
          if (duration) {
            css(target, "transition", "");
            css(target, "transform", "");
            var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
            target.animatingX = !!translateX;
            target.animatingY = !!translateY;
            css(target, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
            this.forRepaintDummy = repaint(target);
            css(target, "transition", "transform " + duration + "ms" + (this.options.easing ? " " + this.options.easing : ""));
            css(target, "transform", "translate3d(0,0,0)");
            typeof target.animated === "number" && clearTimeout(target.animated);
            target.animated = setTimeout(function() {
              css(target, "transition", "");
              css(target, "transform", "");
              target.animated = false;
              target.animatingX = false;
              target.animatingY = false;
            }, duration);
          }
        }
      };
    }
    function repaint(target) {
      return target.offsetWidth;
    }
    function calculateRealTime(animatingRect, fromRect, toRect, options) {
      return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
    }
    var plugins = [];
    var defaults = {
      initializeByDefault: true
    };
    var PluginManager = {
      mount: function mount(plugin) {
        for (var option in defaults) {
          if (defaults.hasOwnProperty(option) && !(option in plugin)) {
            plugin[option] = defaults[option];
          }
        }
        plugins.forEach(function(p2) {
          if (p2.pluginName === plugin.pluginName) {
            throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
          }
        });
        plugins.push(plugin);
      },
      pluginEvent: function pluginEvent2(eventName, sortable, evt) {
        var _this = this;
        this.eventCanceled = false;
        evt.cancel = function() {
          _this.eventCanceled = true;
        };
        var eventNameGlobal = eventName + "Global";
        plugins.forEach(function(plugin) {
          if (!sortable[plugin.pluginName])
            return;
          if (sortable[plugin.pluginName][eventNameGlobal]) {
            sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
              sortable
            }, evt));
          }
          if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
            sortable[plugin.pluginName][eventName](_objectSpread2({
              sortable
            }, evt));
          }
        });
      },
      initializePlugins: function initializePlugins(sortable, el, defaults2, options) {
        plugins.forEach(function(plugin) {
          var pluginName = plugin.pluginName;
          if (!sortable.options[pluginName] && !plugin.initializeByDefault)
            return;
          var initialized = new plugin(sortable, el, sortable.options);
          initialized.sortable = sortable;
          initialized.options = sortable.options;
          sortable[pluginName] = initialized;
          _extends(defaults2, initialized.defaults);
        });
        for (var option in sortable.options) {
          if (!sortable.options.hasOwnProperty(option))
            continue;
          var modified = this.modifyOption(sortable, option, sortable.options[option]);
          if (typeof modified !== "undefined") {
            sortable.options[option] = modified;
          }
        }
      },
      getEventProperties: function getEventProperties(name, sortable) {
        var eventProperties = {};
        plugins.forEach(function(plugin) {
          if (typeof plugin.eventProperties !== "function")
            return;
          _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
        });
        return eventProperties;
      },
      modifyOption: function modifyOption(sortable, name, value) {
        var modifiedValue;
        plugins.forEach(function(plugin) {
          if (!sortable[plugin.pluginName])
            return;
          if (plugin.optionListeners && typeof plugin.optionListeners[name] === "function") {
            modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
          }
        });
        return modifiedValue;
      }
    };
    function dispatchEvent(_ref) {
      var sortable = _ref.sortable, rootEl2 = _ref.rootEl, name = _ref.name, targetEl = _ref.targetEl, cloneEl2 = _ref.cloneEl, toEl = _ref.toEl, fromEl = _ref.fromEl, oldIndex2 = _ref.oldIndex, newIndex2 = _ref.newIndex, oldDraggableIndex2 = _ref.oldDraggableIndex, newDraggableIndex2 = _ref.newDraggableIndex, originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, extraEventProperties = _ref.extraEventProperties;
      sortable = sortable || rootEl2 && rootEl2[expando];
      if (!sortable)
        return;
      var evt, options = sortable.options, onName = "on" + name.charAt(0).toUpperCase() + name.substr(1);
      if (window.CustomEvent && !IE11OrLess && !Edge) {
        evt = new CustomEvent(name, {
          bubbles: true,
          cancelable: true
        });
      } else {
        evt = document.createEvent("Event");
        evt.initEvent(name, true, true);
      }
      evt.to = toEl || rootEl2;
      evt.from = fromEl || rootEl2;
      evt.item = targetEl || rootEl2;
      evt.clone = cloneEl2;
      evt.oldIndex = oldIndex2;
      evt.newIndex = newIndex2;
      evt.oldDraggableIndex = oldDraggableIndex2;
      evt.newDraggableIndex = newDraggableIndex2;
      evt.originalEvent = originalEvent;
      evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
      var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
      for (var option in allEventProperties) {
        evt[option] = allEventProperties[option];
      }
      if (rootEl2) {
        rootEl2.dispatchEvent(evt);
      }
      if (options[onName]) {
        options[onName].call(sortable, evt);
      }
    }
    var _excluded = ["evt"];
    var pluginEvent = function pluginEvent2(eventName, sortable) {
      var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref.evt, data = _objectWithoutProperties(_ref, _excluded);
      PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
        dragEl,
        parentEl,
        ghostEl,
        rootEl,
        nextEl,
        lastDownEl,
        cloneEl,
        cloneHidden,
        dragStarted: moved,
        putSortable,
        activeSortable: Sortable.active,
        originalEvent,
        oldIndex,
        oldDraggableIndex,
        newIndex,
        newDraggableIndex,
        hideGhostForTarget: _hideGhostForTarget,
        unhideGhostForTarget: _unhideGhostForTarget,
        cloneNowHidden: function cloneNowHidden() {
          cloneHidden = true;
        },
        cloneNowShown: function cloneNowShown() {
          cloneHidden = false;
        },
        dispatchSortableEvent: function dispatchSortableEvent(name) {
          _dispatchEvent({
            sortable,
            name,
            originalEvent
          });
        }
      }, data));
    };
    function _dispatchEvent(info) {
      dispatchEvent(_objectSpread2({
        putSortable,
        cloneEl,
        targetEl: dragEl,
        rootEl,
        oldIndex,
        oldDraggableIndex,
        newIndex,
        newDraggableIndex
      }, info));
    }
    var dragEl, parentEl, ghostEl, rootEl, nextEl, lastDownEl, cloneEl, cloneHidden, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, activeGroup, putSortable, awaitingDragStarted = false, ignoreNextClick = false, sortables = [], tapEvt, touchEvt, lastDx, lastDy, tapDistanceLeft, tapDistanceTop, moved, lastTarget, lastDirection, pastFirstInvertThresh = false, isCircumstantialInvert = false, targetMoveDistance, ghostRelativeParent, ghostRelativeParentInitialScroll = [], _silent = false, savedInputChecked = [];
    var documentExists = typeof document !== "undefined", PositionGhostAbsolutely = IOS, CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float", supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div"), supportCssPointerEvents = function() {
      if (!documentExists)
        return;
      if (IE11OrLess) {
        return false;
      }
      var el = document.createElement("x");
      el.style.cssText = "pointer-events:auto";
      return el.style.pointerEvents === "auto";
    }(), _detectDirection = function _detectDirection2(el, options) {
      var elCSS = css(el), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el, 0, options), child2 = getChild(el, 1, options), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
      if (elCSS.display === "flex") {
        return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
      }
      if (elCSS.display === "grid") {
        return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
      }
      if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
        var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
        return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
      }
      return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
    }, _dragElInRowColumn = function _dragElInRowColumn2(dragRect, targetRect, vertical) {
      var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
      return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
    }, _detectNearestEmptySortable = function _detectNearestEmptySortable2(x2, y2) {
      var ret;
      sortables.some(function(sortable) {
        var threshold = sortable[expando].options.emptyInsertThreshold;
        if (!threshold || lastChild(sortable))
          return;
        var rect = getRect(sortable), insideHorizontally = x2 >= rect.left - threshold && x2 <= rect.right + threshold, insideVertically = y2 >= rect.top - threshold && y2 <= rect.bottom + threshold;
        if (insideHorizontally && insideVertically) {
          return ret = sortable;
        }
      });
      return ret;
    }, _prepareGroup = function _prepareGroup2(options) {
      function toFn(value, pull) {
        return function(to2, from, dragEl2, evt) {
          var sameGroup = to2.options.group.name && from.options.group.name && to2.options.group.name === from.options.group.name;
          if (value == null && (pull || sameGroup)) {
            return true;
          } else if (value == null || value === false) {
            return false;
          } else if (pull && value === "clone") {
            return value;
          } else if (typeof value === "function") {
            return toFn(value(to2, from, dragEl2, evt), pull)(to2, from, dragEl2, evt);
          } else {
            var otherGroup = (pull ? to2 : from).options.group.name;
            return value === true || typeof value === "string" && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
          }
        };
      }
      var group = {};
      var originalGroup = options.group;
      if (!originalGroup || _typeof$6(originalGroup) != "object") {
        originalGroup = {
          name: originalGroup
        };
      }
      group.name = originalGroup.name;
      group.checkPull = toFn(originalGroup.pull, true);
      group.checkPut = toFn(originalGroup.put);
      group.revertClone = originalGroup.revertClone;
      options.group = group;
    }, _hideGhostForTarget = function _hideGhostForTarget2() {
      if (!supportCssPointerEvents && ghostEl) {
        css(ghostEl, "display", "none");
      }
    }, _unhideGhostForTarget = function _unhideGhostForTarget2() {
      if (!supportCssPointerEvents && ghostEl) {
        css(ghostEl, "display", "");
      }
    };
    if (documentExists) {
      document.addEventListener("click", function(evt) {
        if (ignoreNextClick) {
          evt.preventDefault();
          evt.stopPropagation && evt.stopPropagation();
          evt.stopImmediatePropagation && evt.stopImmediatePropagation();
          ignoreNextClick = false;
          return false;
        }
      }, true);
    }
    var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent2(evt) {
      if (dragEl) {
        evt = evt.touches ? evt.touches[0] : evt;
        var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
        if (nearest) {
          var event2 = {};
          for (var i2 in evt) {
            if (evt.hasOwnProperty(i2)) {
              event2[i2] = evt[i2];
            }
          }
          event2.target = event2.rootEl = nearest;
          event2.preventDefault = void 0;
          event2.stopPropagation = void 0;
          nearest[expando]._onDragOver(event2);
        }
      }
    };
    var _checkOutsideTargetEl = function _checkOutsideTargetEl2(evt) {
      if (dragEl) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
      }
    };
    function Sortable(el, options) {
      if (!(el && el.nodeType && el.nodeType === 1)) {
        throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
      }
      this.el = el;
      this.options = options = _extends({}, options);
      el[expando] = this;
      var defaults2 = {
        group: null,
        sort: true,
        disabled: false,
        store: null,
        handle: null,
        draggable: /^[uo]l$/i.test(el.nodeName) ? ">li" : ">*",
        swapThreshold: 1,
        // percentage; 0 <= x <= 1
        invertSwap: false,
        // invert always
        invertedSwapThreshold: null,
        // will be set to same as swapThreshold if default
        removeCloneOnHide: true,
        direction: function direction() {
          return _detectDirection(el, this.options);
        },
        ghostClass: "sortable-ghost",
        chosenClass: "sortable-chosen",
        dragClass: "sortable-drag",
        ignore: "a, img",
        filter: null,
        preventOnFilter: true,
        animation: 0,
        easing: null,
        setData: function setData(dataTransfer, dragEl2) {
          dataTransfer.setData("Text", dragEl2.textContent);
        },
        dropBubble: false,
        dragoverBubble: false,
        dataIdAttr: "data-id",
        delay: 0,
        delayOnTouchOnly: false,
        touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
        forceFallback: false,
        fallbackClass: "sortable-fallback",
        fallbackOnBody: false,
        fallbackTolerance: 0,
        fallbackOffset: {
          x: 0,
          y: 0
        },
        supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && !Safari,
        emptyInsertThreshold: 5
      };
      PluginManager.initializePlugins(this, el, defaults2);
      for (var name in defaults2) {
        !(name in options) && (options[name] = defaults2[name]);
      }
      _prepareGroup(options);
      for (var fn2 in this) {
        if (fn2.charAt(0) === "_" && typeof this[fn2] === "function") {
          this[fn2] = this[fn2].bind(this);
        }
      }
      this.nativeDraggable = options.forceFallback ? false : supportDraggable;
      if (this.nativeDraggable) {
        this.options.touchStartThreshold = 1;
      }
      if (options.supportPointer) {
        on(el, "pointerdown", this._onTapStart);
      } else {
        on(el, "mousedown", this._onTapStart);
        on(el, "touchstart", this._onTapStart);
      }
      if (this.nativeDraggable) {
        on(el, "dragover", this);
        on(el, "dragenter", this);
      }
      sortables.push(this.el);
      options.store && options.store.get && this.sort(options.store.get(this) || []);
      _extends(this, AnimationStateManager());
    }
    Sortable.prototype = /** @lends Sortable.prototype */
    {
      constructor: Sortable,
      _isOutsideThisEl: function _isOutsideThisEl(target) {
        if (!this.el.contains(target) && target !== this.el) {
          lastTarget = null;
        }
      },
      _getDirection: function _getDirection(evt, target) {
        return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
      },
      _onTapStart: function _onTapStart(evt) {
        if (!evt.cancelable)
          return;
        var _this = this, el = this.el, options = this.options, preventOnFilter = options.preventOnFilter, type = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter2 = options.filter;
        _saveInputCheckedState(el);
        if (dragEl) {
          return;
        }
        if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
          return;
        }
        if (originalTarget.isContentEditable) {
          return;
        }
        if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") {
          return;
        }
        target = closest(target, options.draggable, el, false);
        if (target && target.animated) {
          return;
        }
        if (lastDownEl === target) {
          return;
        }
        oldIndex = index(target);
        oldDraggableIndex = index(target, options.draggable);
        if (typeof filter2 === "function") {
          if (filter2.call(this, evt, target, this)) {
            _dispatchEvent({
              sortable: _this,
              rootEl: originalTarget,
              name: "filter",
              targetEl: target,
              toEl: el,
              fromEl: el
            });
            pluginEvent("filter", _this, {
              evt
            });
            preventOnFilter && evt.cancelable && evt.preventDefault();
            return;
          }
        } else if (filter2) {
          filter2 = filter2.split(",").some(function(criteria) {
            criteria = closest(originalTarget, criteria.trim(), el, false);
            if (criteria) {
              _dispatchEvent({
                sortable: _this,
                rootEl: criteria,
                name: "filter",
                targetEl: target,
                fromEl: el,
                toEl: el
              });
              pluginEvent("filter", _this, {
                evt
              });
              return true;
            }
          });
          if (filter2) {
            preventOnFilter && evt.cancelable && evt.preventDefault();
            return;
          }
        }
        if (options.handle && !closest(originalTarget, options.handle, el, false)) {
          return;
        }
        this._prepareDragStart(evt, touch, target);
      },
      _prepareDragStart: function _prepareDragStart(evt, touch, target) {
        var _this = this, el = _this.el, options = _this.options, ownerDocument = el.ownerDocument, dragStartFn;
        if (target && !dragEl && target.parentNode === el) {
          var dragRect = getRect(target);
          rootEl = el;
          dragEl = target;
          parentEl = dragEl.parentNode;
          nextEl = dragEl.nextSibling;
          lastDownEl = target;
          activeGroup = options.group;
          Sortable.dragged = dragEl;
          tapEvt = {
            target: dragEl,
            clientX: (touch || evt).clientX,
            clientY: (touch || evt).clientY
          };
          tapDistanceLeft = tapEvt.clientX - dragRect.left;
          tapDistanceTop = tapEvt.clientY - dragRect.top;
          this._lastX = (touch || evt).clientX;
          this._lastY = (touch || evt).clientY;
          dragEl.style["will-change"] = "all";
          dragStartFn = function dragStartFn2() {
            pluginEvent("delayEnded", _this, {
              evt
            });
            if (Sortable.eventCanceled) {
              _this._onDrop();
              return;
            }
            _this._disableDelayedDragEvents();
            if (!FireFox && _this.nativeDraggable) {
              dragEl.draggable = true;
            }
            _this._triggerDragStart(evt, touch);
            _dispatchEvent({
              sortable: _this,
              name: "choose",
              originalEvent: evt
            });
            toggleClass(dragEl, options.chosenClass, true);
          };
          options.ignore.split(",").forEach(function(criteria) {
            find(dragEl, criteria.trim(), _disableDraggable);
          });
          on(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
          on(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
          on(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
          on(ownerDocument, "mouseup", _this._onDrop);
          on(ownerDocument, "touchend", _this._onDrop);
          on(ownerDocument, "touchcancel", _this._onDrop);
          if (FireFox && this.nativeDraggable) {
            this.options.touchStartThreshold = 4;
            dragEl.draggable = true;
          }
          pluginEvent("delayStart", this, {
            evt
          });
          if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
            if (Sortable.eventCanceled) {
              this._onDrop();
              return;
            }
            on(ownerDocument, "mouseup", _this._disableDelayedDrag);
            on(ownerDocument, "touchend", _this._disableDelayedDrag);
            on(ownerDocument, "touchcancel", _this._disableDelayedDrag);
            on(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
            on(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
            options.supportPointer && on(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
            _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
          } else {
            dragStartFn();
          }
        }
      },
      _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e2) {
        var touch = e2.touches ? e2.touches[0] : e2;
        if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
          this._disableDelayedDrag();
        }
      },
      _disableDelayedDrag: function _disableDelayedDrag() {
        dragEl && _disableDraggable(dragEl);
        clearTimeout(this._dragStartTimer);
        this._disableDelayedDragEvents();
      },
      _disableDelayedDragEvents: function _disableDelayedDragEvents() {
        var ownerDocument = this.el.ownerDocument;
        off(ownerDocument, "mouseup", this._disableDelayedDrag);
        off(ownerDocument, "touchend", this._disableDelayedDrag);
        off(ownerDocument, "touchcancel", this._disableDelayedDrag);
        off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
        off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
        off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
      },
      _triggerDragStart: function _triggerDragStart(evt, touch) {
        touch = touch || evt.pointerType == "touch" && evt;
        if (!this.nativeDraggable || touch) {
          if (this.options.supportPointer) {
            on(document, "pointermove", this._onTouchMove);
          } else if (touch) {
            on(document, "touchmove", this._onTouchMove);
          } else {
            on(document, "mousemove", this._onTouchMove);
          }
        } else {
          on(dragEl, "dragend", this);
          on(rootEl, "dragstart", this._onDragStart);
        }
        try {
          if (document.selection) {
            _nextTick(function() {
              document.selection.empty();
            });
          } else {
            window.getSelection().removeAllRanges();
          }
        } catch (err) {
        }
      },
      _dragStarted: function _dragStarted(fallback, evt) {
        awaitingDragStarted = false;
        if (rootEl && dragEl) {
          pluginEvent("dragStarted", this, {
            evt
          });
          if (this.nativeDraggable) {
            on(document, "dragover", _checkOutsideTargetEl);
          }
          var options = this.options;
          !fallback && toggleClass(dragEl, options.dragClass, false);
          toggleClass(dragEl, options.ghostClass, true);
          Sortable.active = this;
          fallback && this._appendGhost();
          _dispatchEvent({
            sortable: this,
            name: "start",
            originalEvent: evt
          });
        } else {
          this._nulling();
        }
      },
      _emulateDragOver: function _emulateDragOver() {
        if (touchEvt) {
          this._lastX = touchEvt.clientX;
          this._lastY = touchEvt.clientY;
          _hideGhostForTarget();
          var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
          var parent = target;
          while (target && target.shadowRoot) {
            target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
            if (target === parent)
              break;
            parent = target;
          }
          dragEl.parentNode[expando]._isOutsideThisEl(target);
          if (parent) {
            do {
              if (parent[expando]) {
                var inserted = void 0;
                inserted = parent[expando]._onDragOver({
                  clientX: touchEvt.clientX,
                  clientY: touchEvt.clientY,
                  target,
                  rootEl: parent
                });
                if (inserted && !this.options.dragoverBubble) {
                  break;
                }
              }
              target = parent;
            } while (parent = parent.parentNode);
          }
          _unhideGhostForTarget();
        }
      },
      _onTouchMove: function _onTouchMove(evt) {
        if (tapEvt) {
          var options = this.options, fallbackTolerance = options.fallbackTolerance, fallbackOffset = options.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
          if (!Sortable.active && !awaitingDragStarted) {
            if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
              return;
            }
            this._onDragStart(evt, true);
          }
          if (ghostEl) {
            if (ghostMatrix) {
              ghostMatrix.e += dx - (lastDx || 0);
              ghostMatrix.f += dy - (lastDy || 0);
            } else {
              ghostMatrix = {
                a: 1,
                b: 0,
                c: 0,
                d: 1,
                e: dx,
                f: dy
              };
            }
            var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
            css(ghostEl, "webkitTransform", cssMatrix);
            css(ghostEl, "mozTransform", cssMatrix);
            css(ghostEl, "msTransform", cssMatrix);
            css(ghostEl, "transform", cssMatrix);
            lastDx = dx;
            lastDy = dy;
            touchEvt = touch;
          }
          evt.cancelable && evt.preventDefault();
        }
      },
      _appendGhost: function _appendGhost() {
        if (!ghostEl) {
          var container = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options = this.options;
          if (PositionGhostAbsolutely) {
            ghostRelativeParent = container;
            while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
              ghostRelativeParent = ghostRelativeParent.parentNode;
            }
            if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
              if (ghostRelativeParent === document)
                ghostRelativeParent = getWindowScrollingElement();
              rect.top += ghostRelativeParent.scrollTop;
              rect.left += ghostRelativeParent.scrollLeft;
            } else {
              ghostRelativeParent = getWindowScrollingElement();
            }
            ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
          }
          ghostEl = dragEl.cloneNode(true);
          toggleClass(ghostEl, options.ghostClass, false);
          toggleClass(ghostEl, options.fallbackClass, true);
          toggleClass(ghostEl, options.dragClass, true);
          css(ghostEl, "transition", "");
          css(ghostEl, "transform", "");
          css(ghostEl, "box-sizing", "border-box");
          css(ghostEl, "margin", 0);
          css(ghostEl, "top", rect.top);
          css(ghostEl, "left", rect.left);
          css(ghostEl, "width", rect.width);
          css(ghostEl, "height", rect.height);
          css(ghostEl, "opacity", "0.8");
          css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
          css(ghostEl, "zIndex", "100000");
          css(ghostEl, "pointerEvents", "none");
          Sortable.ghost = ghostEl;
          container.appendChild(ghostEl);
          css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
        }
      },
      _onDragStart: function _onDragStart(evt, fallback) {
        var _this = this;
        var dataTransfer = evt.dataTransfer;
        var options = _this.options;
        pluginEvent("dragStart", this, {
          evt
        });
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        pluginEvent("setupClone", this);
        if (!Sortable.eventCanceled) {
          cloneEl = clone(dragEl);
          cloneEl.draggable = false;
          cloneEl.style["will-change"] = "";
          this._hideClone();
          toggleClass(cloneEl, this.options.chosenClass, false);
          Sortable.clone = cloneEl;
        }
        _this.cloneId = _nextTick(function() {
          pluginEvent("clone", _this);
          if (Sortable.eventCanceled)
            return;
          if (!_this.options.removeCloneOnHide) {
            rootEl.insertBefore(cloneEl, dragEl);
          }
          _this._hideClone();
          _dispatchEvent({
            sortable: _this,
            name: "clone"
          });
        });
        !fallback && toggleClass(dragEl, options.dragClass, true);
        if (fallback) {
          ignoreNextClick = true;
          _this._loopId = setInterval(_this._emulateDragOver, 50);
        } else {
          off(document, "mouseup", _this._onDrop);
          off(document, "touchend", _this._onDrop);
          off(document, "touchcancel", _this._onDrop);
          if (dataTransfer) {
            dataTransfer.effectAllowed = "move";
            options.setData && options.setData.call(_this, dataTransfer, dragEl);
          }
          on(document, "drop", _this);
          css(dragEl, "transform", "translateZ(0)");
        }
        awaitingDragStarted = true;
        _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
        on(document, "selectstart", _this);
        moved = true;
        if (Safari) {
          css(document.body, "user-select", "none");
        }
      },
      // Returns true - if no further action is needed (either inserted or another condition)
      _onDragOver: function _onDragOver(evt) {
        var el = this.el, target = evt.target, dragRect, targetRect, revert, options = this.options, group = options.group, activeSortable = Sortable.active, isOwner = activeGroup === group, canSort = options.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
        if (_silent)
          return;
        function dragOverEvent(name, extra) {
          pluginEvent(name, _this, _objectSpread2({
            evt,
            isOwner,
            axis: vertical ? "vertical" : "horizontal",
            revert,
            dragRect,
            targetRect,
            canSort,
            fromSortable,
            target,
            completed,
            onMove: function onMove(target2, after2) {
              return _onMove(rootEl, el, dragEl, dragRect, target2, getRect(target2), evt, after2);
            },
            changed
          }, extra));
        }
        function capture() {
          dragOverEvent("dragOverAnimationCapture");
          _this.captureAnimationState();
          if (_this !== fromSortable) {
            fromSortable.captureAnimationState();
          }
        }
        function completed(insertion) {
          dragOverEvent("dragOverCompleted", {
            insertion
          });
          if (insertion) {
            if (isOwner) {
              activeSortable._hideClone();
            } else {
              activeSortable._showClone(_this);
            }
            if (_this !== fromSortable) {
              toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
              toggleClass(dragEl, options.ghostClass, true);
            }
            if (putSortable !== _this && _this !== Sortable.active) {
              putSortable = _this;
            } else if (_this === Sortable.active && putSortable) {
              putSortable = null;
            }
            if (fromSortable === _this) {
              _this._ignoreWhileAnimating = target;
            }
            _this.animateAll(function() {
              dragOverEvent("dragOverAnimationComplete");
              _this._ignoreWhileAnimating = null;
            });
            if (_this !== fromSortable) {
              fromSortable.animateAll();
              fromSortable._ignoreWhileAnimating = null;
            }
          }
          if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
            lastTarget = null;
          }
          if (!options.dragoverBubble && !evt.rootEl && target !== document) {
            dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
            !insertion && nearestEmptyInsertDetectEvent(evt);
          }
          !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
          return completedFired = true;
        }
        function changed() {
          newIndex = index(dragEl);
          newDraggableIndex = index(dragEl, options.draggable);
          _dispatchEvent({
            sortable: _this,
            name: "change",
            toEl: el,
            newIndex,
            newDraggableIndex,
            originalEvent: evt
          });
        }
        if (evt.preventDefault !== void 0) {
          evt.cancelable && evt.preventDefault();
        }
        target = closest(target, options.draggable, el, true);
        dragOverEvent("dragOver");
        if (Sortable.eventCanceled)
          return completedFired;
        if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
          return completed(false);
        }
        ignoreNextClick = false;
        if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
          vertical = this._getDirection(evt, target) === "vertical";
          dragRect = getRect(dragEl);
          dragOverEvent("dragOverValid");
          if (Sortable.eventCanceled)
            return completedFired;
          if (revert) {
            parentEl = rootEl;
            capture();
            this._hideClone();
            dragOverEvent("revert");
            if (!Sortable.eventCanceled) {
              if (nextEl) {
                rootEl.insertBefore(dragEl, nextEl);
              } else {
                rootEl.appendChild(dragEl);
              }
            }
            return completed(true);
          }
          var elLastChild = lastChild(el, options.draggable);
          if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
            if (elLastChild === dragEl) {
              return completed(false);
            }
            if (elLastChild && el === evt.target) {
              target = elLastChild;
            }
            if (target) {
              targetRect = getRect(target);
            }
            if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
              capture();
              el.appendChild(dragEl);
              parentEl = el;
              changed();
              return completed(true);
            }
          } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
            var firstChild = getChild(el, 0, options, true);
            if (firstChild === dragEl) {
              return completed(false);
            }
            target = firstChild;
            targetRect = getRect(target);
            if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
              capture();
              el.insertBefore(dragEl, firstChild);
              parentEl = el;
              changed();
              return completed(true);
            }
          } else if (target.parentNode === el) {
            targetRect = getRect(target);
            var direction = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
            if (lastTarget !== target) {
              targetBeforeFirstSwap = targetRect[side1];
              pastFirstInvertThresh = false;
              isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
            }
            direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
            var sibling;
            if (direction !== 0) {
              var dragIndex = index(dragEl);
              do {
                dragIndex -= direction;
                sibling = parentEl.children[dragIndex];
              } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
            }
            if (direction === 0 || sibling === target) {
              return completed(false);
            }
            lastTarget = target;
            lastDirection = direction;
            var nextSibling = target.nextElementSibling, after = false;
            after = direction === 1;
            var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
            if (moveVector !== false) {
              if (moveVector === 1 || moveVector === -1) {
                after = moveVector === 1;
              }
              _silent = true;
              setTimeout(_unsilent, 30);
              capture();
              if (after && !nextSibling) {
                el.appendChild(dragEl);
              } else {
                target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
              }
              if (scrolledPastTop) {
                scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
              }
              parentEl = dragEl.parentNode;
              if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
                targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
              }
              changed();
              return completed(true);
            }
          }
          if (el.contains(dragEl)) {
            return completed(false);
          }
        }
        return false;
      },
      _ignoreWhileAnimating: null,
      _offMoveEvents: function _offMoveEvents() {
        off(document, "mousemove", this._onTouchMove);
        off(document, "touchmove", this._onTouchMove);
        off(document, "pointermove", this._onTouchMove);
        off(document, "dragover", nearestEmptyInsertDetectEvent);
        off(document, "mousemove", nearestEmptyInsertDetectEvent);
        off(document, "touchmove", nearestEmptyInsertDetectEvent);
      },
      _offUpEvents: function _offUpEvents() {
        var ownerDocument = this.el.ownerDocument;
        off(ownerDocument, "mouseup", this._onDrop);
        off(ownerDocument, "touchend", this._onDrop);
        off(ownerDocument, "pointerup", this._onDrop);
        off(ownerDocument, "touchcancel", this._onDrop);
        off(document, "selectstart", this);
      },
      _onDrop: function _onDrop(evt) {
        var el = this.el, options = this.options;
        newIndex = index(dragEl);
        newDraggableIndex = index(dragEl, options.draggable);
        pluginEvent("drop", this, {
          evt
        });
        parentEl = dragEl && dragEl.parentNode;
        newIndex = index(dragEl);
        newDraggableIndex = index(dragEl, options.draggable);
        if (Sortable.eventCanceled) {
          this._nulling();
          return;
        }
        awaitingDragStarted = false;
        isCircumstantialInvert = false;
        pastFirstInvertThresh = false;
        clearInterval(this._loopId);
        clearTimeout(this._dragStartTimer);
        _cancelNextTick(this.cloneId);
        _cancelNextTick(this._dragStartId);
        if (this.nativeDraggable) {
          off(document, "drop", this);
          off(el, "dragstart", this._onDragStart);
        }
        this._offMoveEvents();
        this._offUpEvents();
        if (Safari) {
          css(document.body, "user-select", "");
        }
        css(dragEl, "transform", "");
        if (evt) {
          if (moved) {
            evt.cancelable && evt.preventDefault();
            !options.dropBubble && evt.stopPropagation();
          }
          ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
          if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
            cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
          }
          if (dragEl) {
            if (this.nativeDraggable) {
              off(dragEl, "dragend", this);
            }
            _disableDraggable(dragEl);
            dragEl.style["will-change"] = "";
            if (moved && !awaitingDragStarted) {
              toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
            }
            toggleClass(dragEl, this.options.chosenClass, false);
            _dispatchEvent({
              sortable: this,
              name: "unchoose",
              toEl: parentEl,
              newIndex: null,
              newDraggableIndex: null,
              originalEvent: evt
            });
            if (rootEl !== parentEl) {
              if (newIndex >= 0) {
                _dispatchEvent({
                  rootEl: parentEl,
                  name: "add",
                  toEl: parentEl,
                  fromEl: rootEl,
                  originalEvent: evt
                });
                _dispatchEvent({
                  sortable: this,
                  name: "remove",
                  toEl: parentEl,
                  originalEvent: evt
                });
                _dispatchEvent({
                  rootEl: parentEl,
                  name: "sort",
                  toEl: parentEl,
                  fromEl: rootEl,
                  originalEvent: evt
                });
                _dispatchEvent({
                  sortable: this,
                  name: "sort",
                  toEl: parentEl,
                  originalEvent: evt
                });
              }
              putSortable && putSortable.save();
            } else {
              if (newIndex !== oldIndex) {
                if (newIndex >= 0) {
                  _dispatchEvent({
                    sortable: this,
                    name: "update",
                    toEl: parentEl,
                    originalEvent: evt
                  });
                  _dispatchEvent({
                    sortable: this,
                    name: "sort",
                    toEl: parentEl,
                    originalEvent: evt
                  });
                }
              }
            }
            if (Sortable.active) {
              if (newIndex == null || newIndex === -1) {
                newIndex = oldIndex;
                newDraggableIndex = oldDraggableIndex;
              }
              _dispatchEvent({
                sortable: this,
                name: "end",
                toEl: parentEl,
                originalEvent: evt
              });
              this.save();
            }
          }
        }
        this._nulling();
      },
      _nulling: function _nulling() {
        pluginEvent("nulling", this);
        rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
        savedInputChecked.forEach(function(el) {
          el.checked = true;
        });
        savedInputChecked.length = lastDx = lastDy = 0;
      },
      handleEvent: function handleEvent(evt) {
        switch (evt.type) {
          case "drop":
          case "dragend":
            this._onDrop(evt);
            break;
          case "dragenter":
          case "dragover":
            if (dragEl) {
              this._onDragOver(evt);
              _globalDragOver(evt);
            }
            break;
          case "selectstart":
            evt.preventDefault();
            break;
        }
      },
      /**
       * Serializes the item into an array of string.
       * @returns {String[]}
       */
      toArray: function toArray() {
        var order2 = [], el, children = this.el.children, i2 = 0, n2 = children.length, options = this.options;
        for (; i2 < n2; i2++) {
          el = children[i2];
          if (closest(el, options.draggable, this.el, false)) {
            order2.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
          }
        }
        return order2;
      },
      /**
       * Sorts the elements according to the array.
       * @param  {String[]}  order  order of the items
       */
      sort: function sort(order2, useAnimation) {
        var items = {}, rootEl2 = this.el;
        this.toArray().forEach(function(id2, i2) {
          var el = rootEl2.children[i2];
          if (closest(el, this.options.draggable, rootEl2, false)) {
            items[id2] = el;
          }
        }, this);
        useAnimation && this.captureAnimationState();
        order2.forEach(function(id2) {
          if (items[id2]) {
            rootEl2.removeChild(items[id2]);
            rootEl2.appendChild(items[id2]);
          }
        });
        useAnimation && this.animateAll();
      },
      /**
       * Save the current sorting
       */
      save: function save() {
        var store = this.options.store;
        store && store.set && store.set(this);
      },
      /**
       * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
       * @param   {HTMLElement}  el
       * @param   {String}       [selector]  default: `options.draggable`
       * @returns {HTMLElement|null}
       */
      closest: function closest$1(el, selector) {
        return closest(el, selector || this.options.draggable, this.el, false);
      },
      /**
       * Set/get option
       * @param   {string} name
       * @param   {*}      [value]
       * @returns {*}
       */
      option: function option(name, value) {
        var options = this.options;
        if (value === void 0) {
          return options[name];
        } else {
          var modifiedValue = PluginManager.modifyOption(this, name, value);
          if (typeof modifiedValue !== "undefined") {
            options[name] = modifiedValue;
          } else {
            options[name] = value;
          }
          if (name === "group") {
            _prepareGroup(options);
          }
        }
      },
      /**
       * Destroy
       */
      destroy: function destroy() {
        pluginEvent("destroy", this);
        var el = this.el;
        el[expando] = null;
        off(el, "mousedown", this._onTapStart);
        off(el, "touchstart", this._onTapStart);
        off(el, "pointerdown", this._onTapStart);
        if (this.nativeDraggable) {
          off(el, "dragover", this);
          off(el, "dragenter", this);
        }
        Array.prototype.forEach.call(el.querySelectorAll("[draggable]"), function(el2) {
          el2.removeAttribute("draggable");
        });
        this._onDrop();
        this._disableDelayedDragEvents();
        sortables.splice(sortables.indexOf(this.el), 1);
        this.el = el = null;
      },
      _hideClone: function _hideClone() {
        if (!cloneHidden) {
          pluginEvent("hideClone", this);
          if (Sortable.eventCanceled)
            return;
          css(cloneEl, "display", "none");
          if (this.options.removeCloneOnHide && cloneEl.parentNode) {
            cloneEl.parentNode.removeChild(cloneEl);
          }
          cloneHidden = true;
        }
      },
      _showClone: function _showClone(putSortable2) {
        if (putSortable2.lastPutMode !== "clone") {
          this._hideClone();
          return;
        }
        if (cloneHidden) {
          pluginEvent("showClone", this);
          if (Sortable.eventCanceled)
            return;
          if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
            rootEl.insertBefore(cloneEl, dragEl);
          } else if (nextEl) {
            rootEl.insertBefore(cloneEl, nextEl);
          } else {
            rootEl.appendChild(cloneEl);
          }
          if (this.options.group.revertClone) {
            this.animate(dragEl, cloneEl);
          }
          css(cloneEl, "display", "");
          cloneHidden = false;
        }
      }
    };
    function _globalDragOver(evt) {
      if (evt.dataTransfer) {
        evt.dataTransfer.dropEffect = "move";
      }
      evt.cancelable && evt.preventDefault();
    }
    function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
      var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
      if (window.CustomEvent && !IE11OrLess && !Edge) {
        evt = new CustomEvent("move", {
          bubbles: true,
          cancelable: true
        });
      } else {
        evt = document.createEvent("Event");
        evt.initEvent("move", true, true);
      }
      evt.to = toEl;
      evt.from = fromEl;
      evt.dragged = dragEl2;
      evt.draggedRect = dragRect;
      evt.related = targetEl || toEl;
      evt.relatedRect = targetRect || getRect(toEl);
      evt.willInsertAfter = willInsertAfter;
      evt.originalEvent = originalEvent;
      fromEl.dispatchEvent(evt);
      if (onMoveFn) {
        retVal = onMoveFn.call(sortable, evt, originalEvent);
      }
      return retVal;
    }
    function _disableDraggable(el) {
      el.draggable = false;
    }
    function _unsilent() {
      _silent = false;
    }
    function _ghostIsFirst(evt, vertical, sortable) {
      var rect = getRect(getChild(sortable.el, 0, sortable.options, true));
      var spacer = 10;
      return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;
    }
    function _ghostIsLast(evt, vertical, sortable) {
      var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
      var spacer = 10;
      return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
    }
    function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
      var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
      if (!invertSwap) {
        if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
          if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
            pastFirstInvertThresh = true;
          }
          if (!pastFirstInvertThresh) {
            if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
              return -lastDirection;
            }
          } else {
            invert = true;
          }
        } else {
          if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
            return _getInsertDirection(target);
          }
        }
      }
      invert = invert || invertSwap;
      if (invert) {
        if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
          return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
        }
      }
      return 0;
    }
    function _getInsertDirection(target) {
      if (index(dragEl) < index(target)) {
        return 1;
      } else {
        return -1;
      }
    }
    function _generateId(el) {
      var str = el.tagName + el.className + el.src + el.href + el.textContent, i2 = str.length, sum = 0;
      while (i2--) {
        sum += str.charCodeAt(i2);
      }
      return sum.toString(36);
    }
    function _saveInputCheckedState(root2) {
      savedInputChecked.length = 0;
      var inputs = root2.getElementsByTagName("input");
      var idx = inputs.length;
      while (idx--) {
        var el = inputs[idx];
        el.checked && savedInputChecked.push(el);
      }
    }
    function _nextTick(fn2) {
      return setTimeout(fn2, 0);
    }
    function _cancelNextTick(id2) {
      return clearTimeout(id2);
    }
    if (documentExists) {
      on(document, "touchmove", function(evt) {
        if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
          evt.preventDefault();
        }
      });
    }
    Sortable.utils = {
      on,
      off,
      css,
      find,
      is: function is(el, selector) {
        return !!closest(el, selector, el, false);
      },
      extend,
      throttle,
      closest,
      toggleClass,
      clone,
      index,
      nextTick: _nextTick,
      cancelNextTick: _cancelNextTick,
      detectDirection: _detectDirection,
      getChild
    };
    Sortable.get = function(element) {
      return element[expando];
    };
    Sortable.mount = function() {
      for (var _len = arguments.length, plugins2 = new Array(_len), _key = 0; _key < _len; _key++) {
        plugins2[_key] = arguments[_key];
      }
      if (plugins2[0].constructor === Array)
        plugins2 = plugins2[0];
      plugins2.forEach(function(plugin) {
        if (!plugin.prototype || !plugin.prototype.constructor) {
          throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
        }
        if (plugin.utils)
          Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
        PluginManager.mount(plugin);
      });
    };
    Sortable.create = function(el, options) {
      return new Sortable(el, options);
    };
    Sortable.version = version;
    var autoScrolls = [], scrollEl, scrollRootEl, scrolling = false, lastAutoScrollX, lastAutoScrollY, touchEvt$1, pointerElemChangedInterval;
    function AutoScrollPlugin() {
      function AutoScroll() {
        this.defaults = {
          scroll: true,
          forceAutoScrollFallback: false,
          scrollSensitivity: 30,
          scrollSpeed: 10,
          bubbleScroll: true
        };
        for (var fn2 in this) {
          if (fn2.charAt(0) === "_" && typeof this[fn2] === "function") {
            this[fn2] = this[fn2].bind(this);
          }
        }
      }
      AutoScroll.prototype = {
        dragStarted: function dragStarted2(_ref) {
          var originalEvent = _ref.originalEvent;
          if (this.sortable.nativeDraggable) {
            on(document, "dragover", this._handleAutoScroll);
          } else {
            if (this.options.supportPointer) {
              on(document, "pointermove", this._handleFallbackAutoScroll);
            } else if (originalEvent.touches) {
              on(document, "touchmove", this._handleFallbackAutoScroll);
            } else {
              on(document, "mousemove", this._handleFallbackAutoScroll);
            }
          }
        },
        dragOverCompleted: function dragOverCompleted(_ref2) {
          var originalEvent = _ref2.originalEvent;
          if (!this.options.dragOverBubble && !originalEvent.rootEl) {
            this._handleAutoScroll(originalEvent);
          }
        },
        drop: function drop2() {
          if (this.sortable.nativeDraggable) {
            off(document, "dragover", this._handleAutoScroll);
          } else {
            off(document, "pointermove", this._handleFallbackAutoScroll);
            off(document, "touchmove", this._handleFallbackAutoScroll);
            off(document, "mousemove", this._handleFallbackAutoScroll);
          }
          clearPointerElemChangedInterval();
          clearAutoScrolls();
          cancelThrottle();
        },
        nulling: function nulling() {
          touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
          autoScrolls.length = 0;
        },
        _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
          this._handleAutoScroll(evt, true);
        },
        _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
          var _this = this;
          var x2 = (evt.touches ? evt.touches[0] : evt).clientX, y2 = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x2, y2);
          touchEvt$1 = evt;
          if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
            autoScroll(evt, this.options, elem, fallback);
            var ogElemScroller = getParentAutoScrollElement(elem, true);
            if (scrolling && (!pointerElemChangedInterval || x2 !== lastAutoScrollX || y2 !== lastAutoScrollY)) {
              pointerElemChangedInterval && clearPointerElemChangedInterval();
              pointerElemChangedInterval = setInterval(function() {
                var newElem = getParentAutoScrollElement(document.elementFromPoint(x2, y2), true);
                if (newElem !== ogElemScroller) {
                  ogElemScroller = newElem;
                  clearAutoScrolls();
                }
                autoScroll(evt, _this.options, newElem, fallback);
              }, 10);
              lastAutoScrollX = x2;
              lastAutoScrollY = y2;
            }
          } else {
            if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
              clearAutoScrolls();
              return;
            }
            autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
          }
        }
      };
      return _extends(AutoScroll, {
        pluginName: "scroll",
        initializeByDefault: true
      });
    }
    function clearAutoScrolls() {
      autoScrolls.forEach(function(autoScroll2) {
        clearInterval(autoScroll2.pid);
      });
      autoScrolls = [];
    }
    function clearPointerElemChangedInterval() {
      clearInterval(pointerElemChangedInterval);
    }
    var autoScroll = throttle(function(evt, options, rootEl2, isFallback) {
      if (!options.scroll)
        return;
      var x2 = (evt.touches ? evt.touches[0] : evt).clientX, y2 = (evt.touches ? evt.touches[0] : evt).clientY, sens = options.scrollSensitivity, speed = options.scrollSpeed, winScroller = getWindowScrollingElement();
      var scrollThisInstance = false, scrollCustomFn;
      if (scrollRootEl !== rootEl2) {
        scrollRootEl = rootEl2;
        clearAutoScrolls();
        scrollEl = options.scroll;
        scrollCustomFn = options.scrollFn;
        if (scrollEl === true) {
          scrollEl = getParentAutoScrollElement(rootEl2, true);
        }
      }
      var layersOut = 0;
      var currentParent = scrollEl;
      do {
        var el = currentParent, rect = getRect(el), top2 = rect.top, bottom2 = rect.bottom, left2 = rect.left, right2 = rect.right, width = rect.width, height = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el.scrollWidth, scrollHeight = el.scrollHeight, elCSS = css(el), scrollPosX = el.scrollLeft, scrollPosY = el.scrollTop;
        if (el === winScroller) {
          canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
          canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
        } else {
          canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
          canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
        }
        var vx = canScrollX && (Math.abs(right2 - x2) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left2 - x2) <= sens && !!scrollPosX);
        var vy = canScrollY && (Math.abs(bottom2 - y2) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top2 - y2) <= sens && !!scrollPosY);
        if (!autoScrolls[layersOut]) {
          for (var i2 = 0; i2 <= layersOut; i2++) {
            if (!autoScrolls[i2]) {
              autoScrolls[i2] = {};
            }
          }
        }
        if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
          autoScrolls[layersOut].el = el;
          autoScrolls[layersOut].vx = vx;
          autoScrolls[layersOut].vy = vy;
          clearInterval(autoScrolls[layersOut].pid);
          if (vx != 0 || vy != 0) {
            scrollThisInstance = true;
            autoScrolls[layersOut].pid = setInterval((function() {
              if (isFallback && this.layer === 0) {
                Sortable.active._onTouchMove(touchEvt$1);
              }
              var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
              var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
              if (typeof scrollCustomFn === "function") {
                if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
                  return;
                }
              }
              scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
            }).bind({
              layer: layersOut
            }), 24);
          }
        }
        layersOut++;
      } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
      scrolling = scrollThisInstance;
    }, 30);
    var drop = function drop2(_ref) {
      var originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, dragEl2 = _ref.dragEl, activeSortable = _ref.activeSortable, dispatchSortableEvent = _ref.dispatchSortableEvent, hideGhostForTarget = _ref.hideGhostForTarget, unhideGhostForTarget = _ref.unhideGhostForTarget;
      if (!originalEvent)
        return;
      var toSortable = putSortable2 || activeSortable;
      hideGhostForTarget();
      var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
      var target = document.elementFromPoint(touch.clientX, touch.clientY);
      unhideGhostForTarget();
      if (toSortable && !toSortable.el.contains(target)) {
        dispatchSortableEvent("spill");
        this.onSpill({
          dragEl: dragEl2,
          putSortable: putSortable2
        });
      }
    };
    function Revert() {
    }
    Revert.prototype = {
      startIndex: null,
      dragStart: function dragStart(_ref2) {
        var oldDraggableIndex2 = _ref2.oldDraggableIndex;
        this.startIndex = oldDraggableIndex2;
      },
      onSpill: function onSpill(_ref3) {
        var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
        this.sortable.captureAnimationState();
        if (putSortable2) {
          putSortable2.captureAnimationState();
        }
        var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
        if (nextSibling) {
          this.sortable.el.insertBefore(dragEl2, nextSibling);
        } else {
          this.sortable.el.appendChild(dragEl2);
        }
        this.sortable.animateAll();
        if (putSortable2) {
          putSortable2.animateAll();
        }
      },
      drop
    };
    _extends(Revert, {
      pluginName: "revertOnSpill"
    });
    function Remove() {
    }
    Remove.prototype = {
      onSpill: function onSpill(_ref4) {
        var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
        var parentSortable = putSortable2 || this.sortable;
        parentSortable.captureAnimationState();
        dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
        parentSortable.animateAll();
      },
      drop
    };
    _extends(Remove, {
      pluginName: "removeOnSpill"
    });
    var lastSwapEl;
    function SwapPlugin() {
      function Swap() {
        this.defaults = {
          swapClass: "sortable-swap-highlight"
        };
      }
      Swap.prototype = {
        dragStart: function dragStart(_ref) {
          var dragEl2 = _ref.dragEl;
          lastSwapEl = dragEl2;
        },
        dragOverValid: function dragOverValid(_ref2) {
          var completed = _ref2.completed, target = _ref2.target, onMove = _ref2.onMove, activeSortable = _ref2.activeSortable, changed = _ref2.changed, cancel = _ref2.cancel;
          if (!activeSortable.options.swap)
            return;
          var el = this.sortable.el, options = this.options;
          if (target && target !== el) {
            var prevSwapEl = lastSwapEl;
            if (onMove(target) !== false) {
              toggleClass(target, options.swapClass, true);
              lastSwapEl = target;
            } else {
              lastSwapEl = null;
            }
            if (prevSwapEl && prevSwapEl !== lastSwapEl) {
              toggleClass(prevSwapEl, options.swapClass, false);
            }
          }
          changed();
          completed(true);
          cancel();
        },
        drop: function drop2(_ref3) {
          var activeSortable = _ref3.activeSortable, putSortable2 = _ref3.putSortable, dragEl2 = _ref3.dragEl;
          var toSortable = putSortable2 || this.sortable;
          var options = this.options;
          lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);
          if (lastSwapEl && (options.swap || putSortable2 && putSortable2.options.swap)) {
            if (dragEl2 !== lastSwapEl) {
              toSortable.captureAnimationState();
              if (toSortable !== activeSortable)
                activeSortable.captureAnimationState();
              swapNodes(dragEl2, lastSwapEl);
              toSortable.animateAll();
              if (toSortable !== activeSortable)
                activeSortable.animateAll();
            }
          }
        },
        nulling: function nulling() {
          lastSwapEl = null;
        }
      };
      return _extends(Swap, {
        pluginName: "swap",
        eventProperties: function eventProperties() {
          return {
            swapItem: lastSwapEl
          };
        }
      });
    }
    function swapNodes(n1, n2) {
      var p1 = n1.parentNode, p2 = n2.parentNode, i1, i2;
      if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1))
        return;
      i1 = index(n1);
      i2 = index(n2);
      if (p1.isEqualNode(p2) && i1 < i2) {
        i2++;
      }
      p1.insertBefore(n2, p1.children[i1]);
      p2.insertBefore(n1, p2.children[i2]);
    }
    var multiDragElements = [], multiDragClones = [], lastMultiDragSelect, multiDragSortable, initialFolding = false, folding = false, dragStarted = false, dragEl$1, clonesFromRect, clonesHidden;
    function MultiDragPlugin() {
      function MultiDrag(sortable) {
        for (var fn2 in this) {
          if (fn2.charAt(0) === "_" && typeof this[fn2] === "function") {
            this[fn2] = this[fn2].bind(this);
          }
        }
        if (sortable.options.supportPointer) {
          on(document, "pointerup", this._deselectMultiDrag);
        } else {
          on(document, "mouseup", this._deselectMultiDrag);
          on(document, "touchend", this._deselectMultiDrag);
        }
        on(document, "keydown", this._checkKeyDown);
        on(document, "keyup", this._checkKeyUp);
        this.defaults = {
          selectedClass: "sortable-selected",
          multiDragKey: null,
          setData: function setData(dataTransfer, dragEl2) {
            var data = "";
            if (multiDragElements.length && multiDragSortable === sortable) {
              multiDragElements.forEach(function(multiDragElement, i2) {
                data += (!i2 ? "" : ", ") + multiDragElement.textContent;
              });
            } else {
              data = dragEl2.textContent;
            }
            dataTransfer.setData("Text", data);
          }
        };
      }
      MultiDrag.prototype = {
        multiDragKeyDown: false,
        isMultiDrag: false,
        delayStartGlobal: function delayStartGlobal(_ref) {
          var dragged = _ref.dragEl;
          dragEl$1 = dragged;
        },
        delayEnded: function delayEnded() {
          this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);
        },
        setupClone: function setupClone(_ref2) {
          var sortable = _ref2.sortable, cancel = _ref2.cancel;
          if (!this.isMultiDrag)
            return;
          for (var i2 = 0; i2 < multiDragElements.length; i2++) {
            multiDragClones.push(clone(multiDragElements[i2]));
            multiDragClones[i2].sortableIndex = multiDragElements[i2].sortableIndex;
            multiDragClones[i2].draggable = false;
            multiDragClones[i2].style["will-change"] = "";
            toggleClass(multiDragClones[i2], this.options.selectedClass, false);
            multiDragElements[i2] === dragEl$1 && toggleClass(multiDragClones[i2], this.options.chosenClass, false);
          }
          sortable._hideClone();
          cancel();
        },
        clone: function clone2(_ref3) {
          var sortable = _ref3.sortable, rootEl2 = _ref3.rootEl, dispatchSortableEvent = _ref3.dispatchSortableEvent, cancel = _ref3.cancel;
          if (!this.isMultiDrag)
            return;
          if (!this.options.removeCloneOnHide) {
            if (multiDragElements.length && multiDragSortable === sortable) {
              insertMultiDragClones(true, rootEl2);
              dispatchSortableEvent("clone");
              cancel();
            }
          }
        },
        showClone: function showClone(_ref4) {
          var cloneNowShown = _ref4.cloneNowShown, rootEl2 = _ref4.rootEl, cancel = _ref4.cancel;
          if (!this.isMultiDrag)
            return;
          insertMultiDragClones(false, rootEl2);
          multiDragClones.forEach(function(clone2) {
            css(clone2, "display", "");
          });
          cloneNowShown();
          clonesHidden = false;
          cancel();
        },
        hideClone: function hideClone(_ref5) {
          var _this = this;
          _ref5.sortable;
          var cloneNowHidden = _ref5.cloneNowHidden, cancel = _ref5.cancel;
          if (!this.isMultiDrag)
            return;
          multiDragClones.forEach(function(clone2) {
            css(clone2, "display", "none");
            if (_this.options.removeCloneOnHide && clone2.parentNode) {
              clone2.parentNode.removeChild(clone2);
            }
          });
          cloneNowHidden();
          clonesHidden = true;
          cancel();
        },
        dragStartGlobal: function dragStartGlobal(_ref6) {
          _ref6.sortable;
          if (!this.isMultiDrag && multiDragSortable) {
            multiDragSortable.multiDrag._deselectMultiDrag();
          }
          multiDragElements.forEach(function(multiDragElement) {
            multiDragElement.sortableIndex = index(multiDragElement);
          });
          multiDragElements = multiDragElements.sort(function(a2, b2) {
            return a2.sortableIndex - b2.sortableIndex;
          });
          dragStarted = true;
        },
        dragStarted: function dragStarted2(_ref7) {
          var _this2 = this;
          var sortable = _ref7.sortable;
          if (!this.isMultiDrag)
            return;
          if (this.options.sort) {
            sortable.captureAnimationState();
            if (this.options.animation) {
              multiDragElements.forEach(function(multiDragElement) {
                if (multiDragElement === dragEl$1)
                  return;
                css(multiDragElement, "position", "absolute");
              });
              var dragRect = getRect(dragEl$1, false, true, true);
              multiDragElements.forEach(function(multiDragElement) {
                if (multiDragElement === dragEl$1)
                  return;
                setRect(multiDragElement, dragRect);
              });
              folding = true;
              initialFolding = true;
            }
          }
          sortable.animateAll(function() {
            folding = false;
            initialFolding = false;
            if (_this2.options.animation) {
              multiDragElements.forEach(function(multiDragElement) {
                unsetRect(multiDragElement);
              });
            }
            if (_this2.options.sort) {
              removeMultiDragElements();
            }
          });
        },
        dragOver: function dragOver(_ref8) {
          var target = _ref8.target, completed = _ref8.completed, cancel = _ref8.cancel;
          if (folding && ~multiDragElements.indexOf(target)) {
            completed(false);
            cancel();
          }
        },
        revert: function revert(_ref9) {
          var fromSortable = _ref9.fromSortable, rootEl2 = _ref9.rootEl, sortable = _ref9.sortable, dragRect = _ref9.dragRect;
          if (multiDragElements.length > 1) {
            multiDragElements.forEach(function(multiDragElement) {
              sortable.addAnimationState({
                target: multiDragElement,
                rect: folding ? getRect(multiDragElement) : dragRect
              });
              unsetRect(multiDragElement);
              multiDragElement.fromRect = dragRect;
              fromSortable.removeAnimationState(multiDragElement);
            });
            folding = false;
            insertMultiDragElements(!this.options.removeCloneOnHide, rootEl2);
          }
        },
        dragOverCompleted: function dragOverCompleted(_ref10) {
          var sortable = _ref10.sortable, isOwner = _ref10.isOwner, insertion = _ref10.insertion, activeSortable = _ref10.activeSortable, parentEl2 = _ref10.parentEl, putSortable2 = _ref10.putSortable;
          var options = this.options;
          if (insertion) {
            if (isOwner) {
              activeSortable._hideClone();
            }
            initialFolding = false;
            if (options.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable2)) {
              var dragRectAbsolute = getRect(dragEl$1, false, true, true);
              multiDragElements.forEach(function(multiDragElement) {
                if (multiDragElement === dragEl$1)
                  return;
                setRect(multiDragElement, dragRectAbsolute);
                parentEl2.appendChild(multiDragElement);
              });
              folding = true;
            }
            if (!isOwner) {
              if (!folding) {
                removeMultiDragElements();
              }
              if (multiDragElements.length > 1) {
                var clonesHiddenBefore = clonesHidden;
                activeSortable._showClone(sortable);
                if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) {
                  multiDragClones.forEach(function(clone2) {
                    activeSortable.addAnimationState({
                      target: clone2,
                      rect: clonesFromRect
                    });
                    clone2.fromRect = clonesFromRect;
                    clone2.thisAnimationDuration = null;
                  });
                }
              } else {
                activeSortable._showClone(sortable);
              }
            }
          }
        },
        dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {
          var dragRect = _ref11.dragRect, isOwner = _ref11.isOwner, activeSortable = _ref11.activeSortable;
          multiDragElements.forEach(function(multiDragElement) {
            multiDragElement.thisAnimationDuration = null;
          });
          if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {
            clonesFromRect = _extends({}, dragRect);
            var dragMatrix = matrix(dragEl$1, true);
            clonesFromRect.top -= dragMatrix.f;
            clonesFromRect.left -= dragMatrix.e;
          }
        },
        dragOverAnimationComplete: function dragOverAnimationComplete() {
          if (folding) {
            folding = false;
            removeMultiDragElements();
          }
        },
        drop: function drop2(_ref12) {
          var evt = _ref12.originalEvent, rootEl2 = _ref12.rootEl, parentEl2 = _ref12.parentEl, sortable = _ref12.sortable, dispatchSortableEvent = _ref12.dispatchSortableEvent, oldIndex2 = _ref12.oldIndex, putSortable2 = _ref12.putSortable;
          var toSortable = putSortable2 || this.sortable;
          if (!evt)
            return;
          var options = this.options, children = parentEl2.children;
          if (!dragStarted) {
            if (options.multiDragKey && !this.multiDragKeyDown) {
              this._deselectMultiDrag();
            }
            toggleClass(dragEl$1, options.selectedClass, !~multiDragElements.indexOf(dragEl$1));
            if (!~multiDragElements.indexOf(dragEl$1)) {
              multiDragElements.push(dragEl$1);
              dispatchEvent({
                sortable,
                rootEl: rootEl2,
                name: "select",
                targetEl: dragEl$1,
                originalEvt: evt
              });
              if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {
                var lastIndex = index(lastMultiDragSelect), currentIndex = index(dragEl$1);
                if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {
                  var n2, i2;
                  if (currentIndex > lastIndex) {
                    i2 = lastIndex;
                    n2 = currentIndex;
                  } else {
                    i2 = currentIndex;
                    n2 = lastIndex + 1;
                  }
                  for (; i2 < n2; i2++) {
                    if (~multiDragElements.indexOf(children[i2]))
                      continue;
                    toggleClass(children[i2], options.selectedClass, true);
                    multiDragElements.push(children[i2]);
                    dispatchEvent({
                      sortable,
                      rootEl: rootEl2,
                      name: "select",
                      targetEl: children[i2],
                      originalEvt: evt
                    });
                  }
                }
              } else {
                lastMultiDragSelect = dragEl$1;
              }
              multiDragSortable = toSortable;
            } else {
              multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);
              lastMultiDragSelect = null;
              dispatchEvent({
                sortable,
                rootEl: rootEl2,
                name: "deselect",
                targetEl: dragEl$1,
                originalEvt: evt
              });
            }
          }
          if (dragStarted && this.isMultiDrag) {
            folding = false;
            if ((parentEl2[expando].options.sort || parentEl2 !== rootEl2) && multiDragElements.length > 1) {
              var dragRect = getRect(dragEl$1), multiDragIndex = index(dragEl$1, ":not(." + this.options.selectedClass + ")");
              if (!initialFolding && options.animation)
                dragEl$1.thisAnimationDuration = null;
              toSortable.captureAnimationState();
              if (!initialFolding) {
                if (options.animation) {
                  dragEl$1.fromRect = dragRect;
                  multiDragElements.forEach(function(multiDragElement) {
                    multiDragElement.thisAnimationDuration = null;
                    if (multiDragElement !== dragEl$1) {
                      var rect = folding ? getRect(multiDragElement) : dragRect;
                      multiDragElement.fromRect = rect;
                      toSortable.addAnimationState({
                        target: multiDragElement,
                        rect
                      });
                    }
                  });
                }
                removeMultiDragElements();
                multiDragElements.forEach(function(multiDragElement) {
                  if (children[multiDragIndex]) {
                    parentEl2.insertBefore(multiDragElement, children[multiDragIndex]);
                  } else {
                    parentEl2.appendChild(multiDragElement);
                  }
                  multiDragIndex++;
                });
                if (oldIndex2 === index(dragEl$1)) {
                  var update = false;
                  multiDragElements.forEach(function(multiDragElement) {
                    if (multiDragElement.sortableIndex !== index(multiDragElement)) {
                      update = true;
                      return;
                    }
                  });
                  if (update) {
                    dispatchSortableEvent("update");
                  }
                }
              }
              multiDragElements.forEach(function(multiDragElement) {
                unsetRect(multiDragElement);
              });
              toSortable.animateAll();
            }
            multiDragSortable = toSortable;
          }
          if (rootEl2 === parentEl2 || putSortable2 && putSortable2.lastPutMode !== "clone") {
            multiDragClones.forEach(function(clone2) {
              clone2.parentNode && clone2.parentNode.removeChild(clone2);
            });
          }
        },
        nullingGlobal: function nullingGlobal() {
          this.isMultiDrag = dragStarted = false;
          multiDragClones.length = 0;
        },
        destroyGlobal: function destroyGlobal() {
          this._deselectMultiDrag();
          off(document, "pointerup", this._deselectMultiDrag);
          off(document, "mouseup", this._deselectMultiDrag);
          off(document, "touchend", this._deselectMultiDrag);
          off(document, "keydown", this._checkKeyDown);
          off(document, "keyup", this._checkKeyUp);
        },
        _deselectMultiDrag: function _deselectMultiDrag(evt) {
          if (typeof dragStarted !== "undefined" && dragStarted)
            return;
          if (multiDragSortable !== this.sortable)
            return;
          if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false))
            return;
          if (evt && evt.button !== 0)
            return;
          while (multiDragElements.length) {
            var el = multiDragElements[0];
            toggleClass(el, this.options.selectedClass, false);
            multiDragElements.shift();
            dispatchEvent({
              sortable: this.sortable,
              rootEl: this.sortable.el,
              name: "deselect",
              targetEl: el,
              originalEvt: evt
            });
          }
        },
        _checkKeyDown: function _checkKeyDown(evt) {
          if (evt.key === this.options.multiDragKey) {
            this.multiDragKeyDown = true;
          }
        },
        _checkKeyUp: function _checkKeyUp(evt) {
          if (evt.key === this.options.multiDragKey) {
            this.multiDragKeyDown = false;
          }
        }
      };
      return _extends(MultiDrag, {
        // Static methods & properties
        pluginName: "multiDrag",
        utils: {
          /**
           * Selects the provided multi-drag item
           * @param  {HTMLElement} el    The element to be selected
           */
          select: function select(el) {
            var sortable = el.parentNode[expando];
            if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el))
              return;
            if (multiDragSortable && multiDragSortable !== sortable) {
              multiDragSortable.multiDrag._deselectMultiDrag();
              multiDragSortable = sortable;
            }
            toggleClass(el, sortable.options.selectedClass, true);
            multiDragElements.push(el);
          },
          /**
           * Deselects the provided multi-drag item
           * @param  {HTMLElement} el    The element to be deselected
           */
          deselect: function deselect(el) {
            var sortable = el.parentNode[expando], index2 = multiDragElements.indexOf(el);
            if (!sortable || !sortable.options.multiDrag || !~index2)
              return;
            toggleClass(el, sortable.options.selectedClass, false);
            multiDragElements.splice(index2, 1);
          }
        },
        eventProperties: function eventProperties() {
          var _this3 = this;
          var oldIndicies = [], newIndicies = [];
          multiDragElements.forEach(function(multiDragElement) {
            oldIndicies.push({
              multiDragElement,
              index: multiDragElement.sortableIndex
            });
            var newIndex2;
            if (folding && multiDragElement !== dragEl$1) {
              newIndex2 = -1;
            } else if (folding) {
              newIndex2 = index(multiDragElement, ":not(." + _this3.options.selectedClass + ")");
            } else {
              newIndex2 = index(multiDragElement);
            }
            newIndicies.push({
              multiDragElement,
              index: newIndex2
            });
          });
          return {
            items: _toConsumableArray(multiDragElements),
            clones: [].concat(multiDragClones),
            oldIndicies,
            newIndicies
          };
        },
        optionListeners: {
          multiDragKey: function multiDragKey(key2) {
            key2 = key2.toLowerCase();
            if (key2 === "ctrl") {
              key2 = "Control";
            } else if (key2.length > 1) {
              key2 = key2.charAt(0).toUpperCase() + key2.substr(1);
            }
            return key2;
          }
        }
      });
    }
    function insertMultiDragElements(clonesInserted, rootEl2) {
      multiDragElements.forEach(function(multiDragElement, i2) {
        var target = rootEl2.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i2) : 0)];
        if (target) {
          rootEl2.insertBefore(multiDragElement, target);
        } else {
          rootEl2.appendChild(multiDragElement);
        }
      });
    }
    function insertMultiDragClones(elementsInserted, rootEl2) {
      multiDragClones.forEach(function(clone2, i2) {
        var target = rootEl2.children[clone2.sortableIndex + (elementsInserted ? Number(i2) : 0)];
        if (target) {
          rootEl2.insertBefore(clone2, target);
        } else {
          rootEl2.appendChild(clone2);
        }
      });
    }
    function removeMultiDragElements() {
      multiDragElements.forEach(function(multiDragElement) {
        if (multiDragElement === dragEl$1)
          return;
        multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);
      });
    }
    Sortable.mount(new AutoScrollPlugin());
    Sortable.mount(Remove, Revert);
    const sortable_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      MultiDrag: MultiDragPlugin,
      Sortable,
      Swap: SwapPlugin,
      default: Sortable
    }, Symbol.toStringTag, { value: "Module" }));
    const require$$1 = /* @__PURE__ */ getAugmentedNamespace(sortable_esm);
    (function(module2, exports2) {
      (function webpackUniversalModuleDefinition(root2, factory2) {
        module2.exports = factory2(require$$0$1, require$$1);
      })(typeof self !== "undefined" ? self : commonjsGlobal, function(__WEBPACK_EXTERNAL_MODULE__8bbf__, __WEBPACK_EXTERNAL_MODULE_a352__) {
        return (
          /******/
          function(modules) {
            var installedModules = {};
            function __webpack_require__(moduleId) {
              if (installedModules[moduleId]) {
                return installedModules[moduleId].exports;
              }
              var module3 = installedModules[moduleId] = {
                /******/
                i: moduleId,
                /******/
                l: false,
                /******/
                exports: {}
                /******/
              };
              modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
              module3.l = true;
              return module3.exports;
            }
            __webpack_require__.m = modules;
            __webpack_require__.c = installedModules;
            __webpack_require__.d = function(exports3, name, getter) {
              if (!__webpack_require__.o(exports3, name)) {
                Object.defineProperty(exports3, name, { enumerable: true, get: getter });
              }
            };
            __webpack_require__.r = function(exports3) {
              if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                Object.defineProperty(exports3, Symbol.toStringTag, { value: "Module" });
              }
              Object.defineProperty(exports3, "__esModule", { value: true });
            };
            __webpack_require__.t = function(value, mode) {
              if (mode & 1)
                value = __webpack_require__(value);
              if (mode & 8)
                return value;
              if (mode & 4 && typeof value === "object" && value && value.__esModule)
                return value;
              var ns = /* @__PURE__ */ Object.create(null);
              __webpack_require__.r(ns);
              Object.defineProperty(ns, "default", { enumerable: true, value });
              if (mode & 2 && typeof value != "string")
                for (var key2 in value)
                  __webpack_require__.d(ns, key2, (function(key3) {
                    return value[key3];
                  }).bind(null, key2));
              return ns;
            };
            __webpack_require__.n = function(module3) {
              var getter = module3 && module3.__esModule ? (
                /******/
                function getDefault() {
                  return module3["default"];
                }
              ) : (
                /******/
                function getModuleExports() {
                  return module3;
                }
              );
              __webpack_require__.d(getter, "a", getter);
              return getter;
            };
            __webpack_require__.o = function(object, property) {
              return Object.prototype.hasOwnProperty.call(object, property);
            };
            __webpack_require__.p = "";
            return __webpack_require__(__webpack_require__.s = "fb15");
          }({
            /***/
            "00ee": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var wellKnownSymbol = __webpack_require__("b622");
                var TO_STRING_TAG = wellKnownSymbol("toStringTag");
                var test = {};
                test[TO_STRING_TAG] = "z";
                module3.exports = String(test) === "[object z]";
              }
            ),
            /***/
            "0366": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var aFunction = __webpack_require__("1c0b");
                module3.exports = function(fn2, that, length) {
                  aFunction(fn2);
                  if (that === void 0)
                    return fn2;
                  switch (length) {
                    case 0:
                      return function() {
                        return fn2.call(that);
                      };
                    case 1:
                      return function(a2) {
                        return fn2.call(that, a2);
                      };
                    case 2:
                      return function(a2, b2) {
                        return fn2.call(that, a2, b2);
                      };
                    case 3:
                      return function(a2, b2, c2) {
                        return fn2.call(that, a2, b2, c2);
                      };
                  }
                  return function() {
                    return fn2.apply(that, arguments);
                  };
                };
              }
            ),
            /***/
            "057f": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var toIndexedObject = __webpack_require__("fc6a");
                var nativeGetOwnPropertyNames = __webpack_require__("241c").f;
                var toString2 = {}.toString;
                var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
                var getWindowNames = function(it2) {
                  try {
                    return nativeGetOwnPropertyNames(it2);
                  } catch (error) {
                    return windowNames.slice();
                  }
                };
                module3.exports.f = function getOwnPropertyNames(it2) {
                  return windowNames && toString2.call(it2) == "[object Window]" ? getWindowNames(it2) : nativeGetOwnPropertyNames(toIndexedObject(it2));
                };
              }
            ),
            /***/
            "06cf": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var DESCRIPTORS = __webpack_require__("83ab");
                var propertyIsEnumerableModule = __webpack_require__("d1e7");
                var createPropertyDescriptor = __webpack_require__("5c6c");
                var toIndexedObject = __webpack_require__("fc6a");
                var toPrimitive = __webpack_require__("c04e");
                var has2 = __webpack_require__("5135");
                var IE8_DOM_DEFINE = __webpack_require__("0cfb");
                var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
                exports3.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O2, P2) {
                  O2 = toIndexedObject(O2);
                  P2 = toPrimitive(P2, true);
                  if (IE8_DOM_DEFINE)
                    try {
                      return nativeGetOwnPropertyDescriptor(O2, P2);
                    } catch (error) {
                    }
                  if (has2(O2, P2))
                    return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O2, P2), O2[P2]);
                };
              }
            ),
            /***/
            "0cfb": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var DESCRIPTORS = __webpack_require__("83ab");
                var fails = __webpack_require__("d039");
                var createElement = __webpack_require__("cc12");
                module3.exports = !DESCRIPTORS && !fails(function() {
                  return Object.defineProperty(createElement("div"), "a", {
                    get: function() {
                      return 7;
                    }
                  }).a != 7;
                });
              }
            ),
            /***/
            "13d5": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var $2 = __webpack_require__("23e7");
                var $reduce = __webpack_require__("d58f").left;
                var arrayMethodIsStrict = __webpack_require__("a640");
                var arrayMethodUsesToLength = __webpack_require__("ae40");
                var STRICT_METHOD = arrayMethodIsStrict("reduce");
                var USES_TO_LENGTH = arrayMethodUsesToLength("reduce", { 1: 0 });
                $2({ target: "Array", proto: true, forced: !STRICT_METHOD || !USES_TO_LENGTH }, {
                  reduce: function reduce(callbackfn) {
                    return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
                  }
                });
              }
            ),
            /***/
            "14c3": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var classof = __webpack_require__("c6b6");
                var regexpExec = __webpack_require__("9263");
                module3.exports = function(R2, S2) {
                  var exec = R2.exec;
                  if (typeof exec === "function") {
                    var result = exec.call(R2, S2);
                    if (typeof result !== "object") {
                      throw TypeError("RegExp exec method returned something other than an Object or null");
                    }
                    return result;
                  }
                  if (classof(R2) !== "RegExp") {
                    throw TypeError("RegExp#exec called on incompatible receiver");
                  }
                  return regexpExec.call(R2, S2);
                };
              }
            ),
            /***/
            "159b": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var global2 = __webpack_require__("da84");
                var DOMIterables = __webpack_require__("fdbc");
                var forEach = __webpack_require__("17c2");
                var createNonEnumerableProperty = __webpack_require__("9112");
                for (var COLLECTION_NAME in DOMIterables) {
                  var Collection = global2[COLLECTION_NAME];
                  var CollectionPrototype = Collection && Collection.prototype;
                  if (CollectionPrototype && CollectionPrototype.forEach !== forEach)
                    try {
                      createNonEnumerableProperty(CollectionPrototype, "forEach", forEach);
                    } catch (error) {
                      CollectionPrototype.forEach = forEach;
                    }
                }
              }
            ),
            /***/
            "17c2": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var $forEach = __webpack_require__("b727").forEach;
                var arrayMethodIsStrict = __webpack_require__("a640");
                var arrayMethodUsesToLength = __webpack_require__("ae40");
                var STRICT_METHOD = arrayMethodIsStrict("forEach");
                var USES_TO_LENGTH = arrayMethodUsesToLength("forEach");
                module3.exports = !STRICT_METHOD || !USES_TO_LENGTH ? function forEach(callbackfn) {
                  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
                } : [].forEach;
              }
            ),
            /***/
            "1be4": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var getBuiltIn = __webpack_require__("d066");
                module3.exports = getBuiltIn("document", "documentElement");
              }
            ),
            /***/
            "1c0b": (
              /***/
              function(module3, exports3) {
                module3.exports = function(it2) {
                  if (typeof it2 != "function") {
                    throw TypeError(String(it2) + " is not a function");
                  }
                  return it2;
                };
              }
            ),
            /***/
            "1c7e": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var wellKnownSymbol = __webpack_require__("b622");
                var ITERATOR = wellKnownSymbol("iterator");
                var SAFE_CLOSING = false;
                try {
                  var called = 0;
                  var iteratorWithReturn = {
                    next: function() {
                      return { done: !!called++ };
                    },
                    "return": function() {
                      SAFE_CLOSING = true;
                    }
                  };
                  iteratorWithReturn[ITERATOR] = function() {
                    return this;
                  };
                  Array.from(iteratorWithReturn, function() {
                    throw 2;
                  });
                } catch (error) {
                }
                module3.exports = function(exec, SKIP_CLOSING) {
                  if (!SKIP_CLOSING && !SAFE_CLOSING)
                    return false;
                  var ITERATION_SUPPORT = false;
                  try {
                    var object = {};
                    object[ITERATOR] = function() {
                      return {
                        next: function() {
                          return { done: ITERATION_SUPPORT = true };
                        }
                      };
                    };
                    exec(object);
                  } catch (error) {
                  }
                  return ITERATION_SUPPORT;
                };
              }
            ),
            /***/
            "1d80": (
              /***/
              function(module3, exports3) {
                module3.exports = function(it2) {
                  if (it2 == void 0)
                    throw TypeError("Can't call method on " + it2);
                  return it2;
                };
              }
            ),
            /***/
            "1dde": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var fails = __webpack_require__("d039");
                var wellKnownSymbol = __webpack_require__("b622");
                var V8_VERSION = __webpack_require__("2d00");
                var SPECIES = wellKnownSymbol("species");
                module3.exports = function(METHOD_NAME) {
                  return V8_VERSION >= 51 || !fails(function() {
                    var array = [];
                    var constructor = array.constructor = {};
                    constructor[SPECIES] = function() {
                      return { foo: 1 };
                    };
                    return array[METHOD_NAME](Boolean).foo !== 1;
                  });
                };
              }
            ),
            /***/
            "23cb": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var toInteger = __webpack_require__("a691");
                var max2 = Math.max;
                var min2 = Math.min;
                module3.exports = function(index2, length) {
                  var integer = toInteger(index2);
                  return integer < 0 ? max2(integer + length, 0) : min2(integer, length);
                };
              }
            ),
            /***/
            "23e7": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var global2 = __webpack_require__("da84");
                var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
                var createNonEnumerableProperty = __webpack_require__("9112");
                var redefine = __webpack_require__("6eeb");
                var setGlobal = __webpack_require__("ce4e");
                var copyConstructorProperties = __webpack_require__("e893");
                var isForced = __webpack_require__("94ca");
                module3.exports = function(options, source) {
                  var TARGET = options.target;
                  var GLOBAL = options.global;
                  var STATIC = options.stat;
                  var FORCED, target, key2, targetProperty, sourceProperty, descriptor;
                  if (GLOBAL) {
                    target = global2;
                  } else if (STATIC) {
                    target = global2[TARGET] || setGlobal(TARGET, {});
                  } else {
                    target = (global2[TARGET] || {}).prototype;
                  }
                  if (target)
                    for (key2 in source) {
                      sourceProperty = source[key2];
                      if (options.noTargetGet) {
                        descriptor = getOwnPropertyDescriptor(target, key2);
                        targetProperty = descriptor && descriptor.value;
                      } else
                        targetProperty = target[key2];
                      FORCED = isForced(GLOBAL ? key2 : TARGET + (STATIC ? "." : "#") + key2, options.forced);
                      if (!FORCED && targetProperty !== void 0) {
                        if (typeof sourceProperty === typeof targetProperty)
                          continue;
                        copyConstructorProperties(sourceProperty, targetProperty);
                      }
                      if (options.sham || targetProperty && targetProperty.sham) {
                        createNonEnumerableProperty(sourceProperty, "sham", true);
                      }
                      redefine(target, key2, sourceProperty, options);
                    }
                };
              }
            ),
            /***/
            "241c": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var internalObjectKeys = __webpack_require__("ca84");
                var enumBugKeys = __webpack_require__("7839");
                var hiddenKeys = enumBugKeys.concat("length", "prototype");
                exports3.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O2) {
                  return internalObjectKeys(O2, hiddenKeys);
                };
              }
            ),
            /***/
            "25f0": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var redefine = __webpack_require__("6eeb");
                var anObject = __webpack_require__("825a");
                var fails = __webpack_require__("d039");
                var flags2 = __webpack_require__("ad6d");
                var TO_STRING = "toString";
                var RegExpPrototype = RegExp.prototype;
                var nativeToString = RegExpPrototype[TO_STRING];
                var NOT_GENERIC = fails(function() {
                  return nativeToString.call({ source: "a", flags: "b" }) != "/a/b";
                });
                var INCORRECT_NAME = nativeToString.name != TO_STRING;
                if (NOT_GENERIC || INCORRECT_NAME) {
                  redefine(RegExp.prototype, TO_STRING, function toString2() {
                    var R2 = anObject(this);
                    var p2 = String(R2.source);
                    var rf = R2.flags;
                    var f2 = String(rf === void 0 && R2 instanceof RegExp && !("flags" in RegExpPrototype) ? flags2.call(R2) : rf);
                    return "/" + p2 + "/" + f2;
                  }, { unsafe: true });
                }
              }
            ),
            /***/
            "2ca0": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var $2 = __webpack_require__("23e7");
                var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
                var toLength = __webpack_require__("50c4");
                var notARegExp = __webpack_require__("5a34");
                var requireObjectCoercible = __webpack_require__("1d80");
                var correctIsRegExpLogic = __webpack_require__("ab13");
                var IS_PURE = __webpack_require__("c430");
                var nativeStartsWith = "".startsWith;
                var min2 = Math.min;
                var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic("startsWith");
                var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function() {
                  var descriptor = getOwnPropertyDescriptor(String.prototype, "startsWith");
                  return descriptor && !descriptor.writable;
                }();
                $2({ target: "String", proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
                  startsWith: function startsWith(searchString) {
                    var that = String(requireObjectCoercible(this));
                    notARegExp(searchString);
                    var index2 = toLength(min2(arguments.length > 1 ? arguments[1] : void 0, that.length));
                    var search = String(searchString);
                    return nativeStartsWith ? nativeStartsWith.call(that, search, index2) : that.slice(index2, index2 + search.length) === search;
                  }
                });
              }
            ),
            /***/
            "2d00": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var global2 = __webpack_require__("da84");
                var userAgent2 = __webpack_require__("342f");
                var process = global2.process;
                var versions = process && process.versions;
                var v8 = versions && versions.v8;
                var match, version2;
                if (v8) {
                  match = v8.split(".");
                  version2 = match[0] + match[1];
                } else if (userAgent2) {
                  match = userAgent2.match(/Edge\/(\d+)/);
                  if (!match || match[1] >= 74) {
                    match = userAgent2.match(/Chrome\/(\d+)/);
                    if (match)
                      version2 = match[1];
                  }
                }
                module3.exports = version2 && +version2;
              }
            ),
            /***/
            "342f": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var getBuiltIn = __webpack_require__("d066");
                module3.exports = getBuiltIn("navigator", "userAgent") || "";
              }
            ),
            /***/
            "35a1": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var classof = __webpack_require__("f5df");
                var Iterators = __webpack_require__("3f8c");
                var wellKnownSymbol = __webpack_require__("b622");
                var ITERATOR = wellKnownSymbol("iterator");
                module3.exports = function(it2) {
                  if (it2 != void 0)
                    return it2[ITERATOR] || it2["@@iterator"] || Iterators[classof(it2)];
                };
              }
            ),
            /***/
            "37e8": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var DESCRIPTORS = __webpack_require__("83ab");
                var definePropertyModule = __webpack_require__("9bf2");
                var anObject = __webpack_require__("825a");
                var objectKeys = __webpack_require__("df75");
                module3.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O2, Properties2) {
                  anObject(O2);
                  var keys = objectKeys(Properties2);
                  var length = keys.length;
                  var index2 = 0;
                  var key2;
                  while (length > index2)
                    definePropertyModule.f(O2, key2 = keys[index2++], Properties2[key2]);
                  return O2;
                };
              }
            ),
            /***/
            "3bbe": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var isObject2 = __webpack_require__("861d");
                module3.exports = function(it2) {
                  if (!isObject2(it2) && it2 !== null) {
                    throw TypeError("Can't set " + String(it2) + " as a prototype");
                  }
                  return it2;
                };
              }
            ),
            /***/
            "3ca3": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var charAt = __webpack_require__("6547").charAt;
                var InternalStateModule = __webpack_require__("69f3");
                var defineIterator = __webpack_require__("7dd0");
                var STRING_ITERATOR = "String Iterator";
                var setInternalState = InternalStateModule.set;
                var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
                defineIterator(String, "String", function(iterated) {
                  setInternalState(this, {
                    type: STRING_ITERATOR,
                    string: String(iterated),
                    index: 0
                  });
                }, function next() {
                  var state = getInternalState(this);
                  var string = state.string;
                  var index2 = state.index;
                  var point;
                  if (index2 >= string.length)
                    return { value: void 0, done: true };
                  point = charAt(string, index2);
                  state.index += point.length;
                  return { value: point, done: false };
                });
              }
            ),
            /***/
            "3f8c": (
              /***/
              function(module3, exports3) {
                module3.exports = {};
              }
            ),
            /***/
            "4160": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var $2 = __webpack_require__("23e7");
                var forEach = __webpack_require__("17c2");
                $2({ target: "Array", proto: true, forced: [].forEach != forEach }, {
                  forEach
                });
              }
            ),
            /***/
            "428f": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var global2 = __webpack_require__("da84");
                module3.exports = global2;
              }
            ),
            /***/
            "44ad": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var fails = __webpack_require__("d039");
                var classof = __webpack_require__("c6b6");
                var split = "".split;
                module3.exports = fails(function() {
                  return !Object("z").propertyIsEnumerable(0);
                }) ? function(it2) {
                  return classof(it2) == "String" ? split.call(it2, "") : Object(it2);
                } : Object;
              }
            ),
            /***/
            "44d2": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var wellKnownSymbol = __webpack_require__("b622");
                var create = __webpack_require__("7c73");
                var definePropertyModule = __webpack_require__("9bf2");
                var UNSCOPABLES = wellKnownSymbol("unscopables");
                var ArrayPrototype = Array.prototype;
                if (ArrayPrototype[UNSCOPABLES] == void 0) {
                  definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
                    configurable: true,
                    value: create(null)
                  });
                }
                module3.exports = function(key2) {
                  ArrayPrototype[UNSCOPABLES][key2] = true;
                };
              }
            ),
            /***/
            "44e7": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var isObject2 = __webpack_require__("861d");
                var classof = __webpack_require__("c6b6");
                var wellKnownSymbol = __webpack_require__("b622");
                var MATCH = wellKnownSymbol("match");
                module3.exports = function(it2) {
                  var isRegExp2;
                  return isObject2(it2) && ((isRegExp2 = it2[MATCH]) !== void 0 ? !!isRegExp2 : classof(it2) == "RegExp");
                };
              }
            ),
            /***/
            "4930": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var fails = __webpack_require__("d039");
                module3.exports = !!Object.getOwnPropertySymbols && !fails(function() {
                  return !String(Symbol());
                });
              }
            ),
            /***/
            "4d64": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var toIndexedObject = __webpack_require__("fc6a");
                var toLength = __webpack_require__("50c4");
                var toAbsoluteIndex = __webpack_require__("23cb");
                var createMethod = function(IS_INCLUDES) {
                  return function($this, el, fromIndex) {
                    var O2 = toIndexedObject($this);
                    var length = toLength(O2.length);
                    var index2 = toAbsoluteIndex(fromIndex, length);
                    var value;
                    if (IS_INCLUDES && el != el)
                      while (length > index2) {
                        value = O2[index2++];
                        if (value != value)
                          return true;
                      }
                    else
                      for (; length > index2; index2++) {
                        if ((IS_INCLUDES || index2 in O2) && O2[index2] === el)
                          return IS_INCLUDES || index2 || 0;
                      }
                    return !IS_INCLUDES && -1;
                  };
                };
                module3.exports = {
                  // `Array.prototype.includes` method
                  // https://tc39.github.io/ecma262/#sec-array.prototype.includes
                  includes: createMethod(true),
                  // `Array.prototype.indexOf` method
                  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
                  indexOf: createMethod(false)
                };
              }
            ),
            /***/
            "4de4": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var $2 = __webpack_require__("23e7");
                var $filter = __webpack_require__("b727").filter;
                var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
                var arrayMethodUsesToLength = __webpack_require__("ae40");
                var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("filter");
                var USES_TO_LENGTH = arrayMethodUsesToLength("filter");
                $2({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
                  filter: function filter2(callbackfn) {
                    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
                  }
                });
              }
            ),
            /***/
            "4df4": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var bind = __webpack_require__("0366");
                var toObject = __webpack_require__("7b0b");
                var callWithSafeIterationClosing = __webpack_require__("9bdd");
                var isArrayIteratorMethod = __webpack_require__("e95a");
                var toLength = __webpack_require__("50c4");
                var createProperty = __webpack_require__("8418");
                var getIteratorMethod = __webpack_require__("35a1");
                module3.exports = function from(arrayLike) {
                  var O2 = toObject(arrayLike);
                  var C2 = typeof this == "function" ? this : Array;
                  var argumentsLength = arguments.length;
                  var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
                  var mapping = mapfn !== void 0;
                  var iteratorMethod = getIteratorMethod(O2);
                  var index2 = 0;
                  var length, result, step, iterator2, next, value;
                  if (mapping)
                    mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : void 0, 2);
                  if (iteratorMethod != void 0 && !(C2 == Array && isArrayIteratorMethod(iteratorMethod))) {
                    iterator2 = iteratorMethod.call(O2);
                    next = iterator2.next;
                    result = new C2();
                    for (; !(step = next.call(iterator2)).done; index2++) {
                      value = mapping ? callWithSafeIterationClosing(iterator2, mapfn, [step.value, index2], true) : step.value;
                      createProperty(result, index2, value);
                    }
                  } else {
                    length = toLength(O2.length);
                    result = new C2(length);
                    for (; length > index2; index2++) {
                      value = mapping ? mapfn(O2[index2], index2) : O2[index2];
                      createProperty(result, index2, value);
                    }
                  }
                  result.length = index2;
                  return result;
                };
              }
            ),
            /***/
            "4fad": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var $2 = __webpack_require__("23e7");
                var $entries = __webpack_require__("6f53").entries;
                $2({ target: "Object", stat: true }, {
                  entries: function entries(O2) {
                    return $entries(O2);
                  }
                });
              }
            ),
            /***/
            "50c4": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var toInteger = __webpack_require__("a691");
                var min2 = Math.min;
                module3.exports = function(argument) {
                  return argument > 0 ? min2(toInteger(argument), 9007199254740991) : 0;
                };
              }
            ),
            /***/
            "5135": (
              /***/
              function(module3, exports3) {
                var hasOwnProperty2 = {}.hasOwnProperty;
                module3.exports = function(it2, key2) {
                  return hasOwnProperty2.call(it2, key2);
                };
              }
            ),
            /***/
            "5319": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var fixRegExpWellKnownSymbolLogic = __webpack_require__("d784");
                var anObject = __webpack_require__("825a");
                var toObject = __webpack_require__("7b0b");
                var toLength = __webpack_require__("50c4");
                var toInteger = __webpack_require__("a691");
                var requireObjectCoercible = __webpack_require__("1d80");
                var advanceStringIndex = __webpack_require__("8aa5");
                var regExpExec = __webpack_require__("14c3");
                var max2 = Math.max;
                var min2 = Math.min;
                var floor = Math.floor;
                var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
                var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;
                var maybeToString = function(it2) {
                  return it2 === void 0 ? it2 : String(it2);
                };
                fixRegExpWellKnownSymbolLogic("replace", 2, function(REPLACE, nativeReplace, maybeCallNative, reason) {
                  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
                  var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;
                  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
                  return [
                    // `String.prototype.replace` method
                    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
                    function replace(searchValue, replaceValue) {
                      var O2 = requireObjectCoercible(this);
                      var replacer2 = searchValue == void 0 ? void 0 : searchValue[REPLACE];
                      return replacer2 !== void 0 ? replacer2.call(searchValue, O2, replaceValue) : nativeReplace.call(String(O2), searchValue, replaceValue);
                    },
                    // `RegExp.prototype[@@replace]` method
                    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
                    function(regexp, replaceValue) {
                      if (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0 || typeof replaceValue === "string" && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1) {
                        var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
                        if (res.done)
                          return res.value;
                      }
                      var rx = anObject(regexp);
                      var S2 = String(this);
                      var functionalReplace = typeof replaceValue === "function";
                      if (!functionalReplace)
                        replaceValue = String(replaceValue);
                      var global2 = rx.global;
                      if (global2) {
                        var fullUnicode = rx.unicode;
                        rx.lastIndex = 0;
                      }
                      var results = [];
                      while (true) {
                        var result = regExpExec(rx, S2);
                        if (result === null)
                          break;
                        results.push(result);
                        if (!global2)
                          break;
                        var matchStr = String(result[0]);
                        if (matchStr === "")
                          rx.lastIndex = advanceStringIndex(S2, toLength(rx.lastIndex), fullUnicode);
                      }
                      var accumulatedResult = "";
                      var nextSourcePosition = 0;
                      for (var i2 = 0; i2 < results.length; i2++) {
                        result = results[i2];
                        var matched = String(result[0]);
                        var position = max2(min2(toInteger(result.index), S2.length), 0);
                        var captures = [];
                        for (var j2 = 1; j2 < result.length; j2++)
                          captures.push(maybeToString(result[j2]));
                        var namedCaptures = result.groups;
                        if (functionalReplace) {
                          var replacerArgs = [matched].concat(captures, position, S2);
                          if (namedCaptures !== void 0)
                            replacerArgs.push(namedCaptures);
                          var replacement = String(replaceValue.apply(void 0, replacerArgs));
                        } else {
                          replacement = getSubstitution(matched, S2, position, captures, namedCaptures, replaceValue);
                        }
                        if (position >= nextSourcePosition) {
                          accumulatedResult += S2.slice(nextSourcePosition, position) + replacement;
                          nextSourcePosition = position + matched.length;
                        }
                      }
                      return accumulatedResult + S2.slice(nextSourcePosition);
                    }
                  ];
                  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
                    var tailPos = position + matched.length;
                    var m2 = captures.length;
                    var symbols2 = SUBSTITUTION_SYMBOLS_NO_NAMED;
                    if (namedCaptures !== void 0) {
                      namedCaptures = toObject(namedCaptures);
                      symbols2 = SUBSTITUTION_SYMBOLS;
                    }
                    return nativeReplace.call(replacement, symbols2, function(match, ch) {
                      var capture;
                      switch (ch.charAt(0)) {
                        case "$":
                          return "$";
                        case "&":
                          return matched;
                        case "`":
                          return str.slice(0, position);
                        case "'":
                          return str.slice(tailPos);
                        case "<":
                          capture = namedCaptures[ch.slice(1, -1)];
                          break;
                        default:
                          var n2 = +ch;
                          if (n2 === 0)
                            return match;
                          if (n2 > m2) {
                            var f2 = floor(n2 / 10);
                            if (f2 === 0)
                              return match;
                            if (f2 <= m2)
                              return captures[f2 - 1] === void 0 ? ch.charAt(1) : captures[f2 - 1] + ch.charAt(1);
                            return match;
                          }
                          capture = captures[n2 - 1];
                      }
                      return capture === void 0 ? "" : capture;
                    });
                  }
                });
              }
            ),
            /***/
            "5692": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var IS_PURE = __webpack_require__("c430");
                var store = __webpack_require__("c6cd");
                (module3.exports = function(key2, value) {
                  return store[key2] || (store[key2] = value !== void 0 ? value : {});
                })("versions", []).push({
                  version: "3.6.5",
                  mode: IS_PURE ? "pure" : "global",
                  copyright: "© 2020 Denis Pushkarev (zloirock.ru)"
                });
              }
            ),
            /***/
            "56ef": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var getBuiltIn = __webpack_require__("d066");
                var getOwnPropertyNamesModule = __webpack_require__("241c");
                var getOwnPropertySymbolsModule = __webpack_require__("7418");
                var anObject = __webpack_require__("825a");
                module3.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys2(it2) {
                  var keys = getOwnPropertyNamesModule.f(anObject(it2));
                  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
                  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it2)) : keys;
                };
              }
            ),
            /***/
            "5a34": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var isRegExp2 = __webpack_require__("44e7");
                module3.exports = function(it2) {
                  if (isRegExp2(it2)) {
                    throw TypeError("The method doesn't accept regular expressions");
                  }
                  return it2;
                };
              }
            ),
            /***/
            "5c6c": (
              /***/
              function(module3, exports3) {
                module3.exports = function(bitmap, value) {
                  return {
                    enumerable: !(bitmap & 1),
                    configurable: !(bitmap & 2),
                    writable: !(bitmap & 4),
                    value
                  };
                };
              }
            ),
            /***/
            "5db7": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var $2 = __webpack_require__("23e7");
                var flattenIntoArray = __webpack_require__("a2bf");
                var toObject = __webpack_require__("7b0b");
                var toLength = __webpack_require__("50c4");
                var aFunction = __webpack_require__("1c0b");
                var arraySpeciesCreate = __webpack_require__("65f0");
                $2({ target: "Array", proto: true }, {
                  flatMap: function flatMap(callbackfn) {
                    var O2 = toObject(this);
                    var sourceLen = toLength(O2.length);
                    var A2;
                    aFunction(callbackfn);
                    A2 = arraySpeciesCreate(O2, 0);
                    A2.length = flattenIntoArray(A2, O2, O2, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
                    return A2;
                  }
                });
              }
            ),
            /***/
            "6547": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var toInteger = __webpack_require__("a691");
                var requireObjectCoercible = __webpack_require__("1d80");
                var createMethod = function(CONVERT_TO_STRING) {
                  return function($this, pos) {
                    var S2 = String(requireObjectCoercible($this));
                    var position = toInteger(pos);
                    var size2 = S2.length;
                    var first, second;
                    if (position < 0 || position >= size2)
                      return CONVERT_TO_STRING ? "" : void 0;
                    first = S2.charCodeAt(position);
                    return first < 55296 || first > 56319 || position + 1 === size2 || (second = S2.charCodeAt(position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? S2.charAt(position) : first : CONVERT_TO_STRING ? S2.slice(position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
                  };
                };
                module3.exports = {
                  // `String.prototype.codePointAt` method
                  // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
                  codeAt: createMethod(false),
                  // `String.prototype.at` method
                  // https://github.com/mathiasbynens/String.prototype.at
                  charAt: createMethod(true)
                };
              }
            ),
            /***/
            "65f0": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var isObject2 = __webpack_require__("861d");
                var isArray2 = __webpack_require__("e8b5");
                var wellKnownSymbol = __webpack_require__("b622");
                var SPECIES = wellKnownSymbol("species");
                module3.exports = function(originalArray, length) {
                  var C2;
                  if (isArray2(originalArray)) {
                    C2 = originalArray.constructor;
                    if (typeof C2 == "function" && (C2 === Array || isArray2(C2.prototype)))
                      C2 = void 0;
                    else if (isObject2(C2)) {
                      C2 = C2[SPECIES];
                      if (C2 === null)
                        C2 = void 0;
                    }
                  }
                  return new (C2 === void 0 ? Array : C2)(length === 0 ? 0 : length);
                };
              }
            ),
            /***/
            "69f3": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var NATIVE_WEAK_MAP = __webpack_require__("7f9a");
                var global2 = __webpack_require__("da84");
                var isObject2 = __webpack_require__("861d");
                var createNonEnumerableProperty = __webpack_require__("9112");
                var objectHas = __webpack_require__("5135");
                var sharedKey = __webpack_require__("f772");
                var hiddenKeys = __webpack_require__("d012");
                var WeakMap2 = global2.WeakMap;
                var set2, get2, has2;
                var enforce = function(it2) {
                  return has2(it2) ? get2(it2) : set2(it2, {});
                };
                var getterFor = function(TYPE) {
                  return function(it2) {
                    var state;
                    if (!isObject2(it2) || (state = get2(it2)).type !== TYPE) {
                      throw TypeError("Incompatible receiver, " + TYPE + " required");
                    }
                    return state;
                  };
                };
                if (NATIVE_WEAK_MAP) {
                  var store = new WeakMap2();
                  var wmget = store.get;
                  var wmhas = store.has;
                  var wmset = store.set;
                  set2 = function(it2, metadata) {
                    wmset.call(store, it2, metadata);
                    return metadata;
                  };
                  get2 = function(it2) {
                    return wmget.call(store, it2) || {};
                  };
                  has2 = function(it2) {
                    return wmhas.call(store, it2);
                  };
                } else {
                  var STATE = sharedKey("state");
                  hiddenKeys[STATE] = true;
                  set2 = function(it2, metadata) {
                    createNonEnumerableProperty(it2, STATE, metadata);
                    return metadata;
                  };
                  get2 = function(it2) {
                    return objectHas(it2, STATE) ? it2[STATE] : {};
                  };
                  has2 = function(it2) {
                    return objectHas(it2, STATE);
                  };
                }
                module3.exports = {
                  set: set2,
                  get: get2,
                  has: has2,
                  enforce,
                  getterFor
                };
              }
            ),
            /***/
            "6eeb": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var global2 = __webpack_require__("da84");
                var createNonEnumerableProperty = __webpack_require__("9112");
                var has2 = __webpack_require__("5135");
                var setGlobal = __webpack_require__("ce4e");
                var inspectSource = __webpack_require__("8925");
                var InternalStateModule = __webpack_require__("69f3");
                var getInternalState = InternalStateModule.get;
                var enforceInternalState = InternalStateModule.enforce;
                var TEMPLATE = String(String).split("String");
                (module3.exports = function(O2, key2, value, options) {
                  var unsafe = options ? !!options.unsafe : false;
                  var simple = options ? !!options.enumerable : false;
                  var noTargetGet = options ? !!options.noTargetGet : false;
                  if (typeof value == "function") {
                    if (typeof key2 == "string" && !has2(value, "name"))
                      createNonEnumerableProperty(value, "name", key2);
                    enforceInternalState(value).source = TEMPLATE.join(typeof key2 == "string" ? key2 : "");
                  }
                  if (O2 === global2) {
                    if (simple)
                      O2[key2] = value;
                    else
                      setGlobal(key2, value);
                    return;
                  } else if (!unsafe) {
                    delete O2[key2];
                  } else if (!noTargetGet && O2[key2]) {
                    simple = true;
                  }
                  if (simple)
                    O2[key2] = value;
                  else
                    createNonEnumerableProperty(O2, key2, value);
                })(Function.prototype, "toString", function toString2() {
                  return typeof this == "function" && getInternalState(this).source || inspectSource(this);
                });
              }
            ),
            /***/
            "6f53": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var DESCRIPTORS = __webpack_require__("83ab");
                var objectKeys = __webpack_require__("df75");
                var toIndexedObject = __webpack_require__("fc6a");
                var propertyIsEnumerable2 = __webpack_require__("d1e7").f;
                var createMethod = function(TO_ENTRIES) {
                  return function(it2) {
                    var O2 = toIndexedObject(it2);
                    var keys = objectKeys(O2);
                    var length = keys.length;
                    var i2 = 0;
                    var result = [];
                    var key2;
                    while (length > i2) {
                      key2 = keys[i2++];
                      if (!DESCRIPTORS || propertyIsEnumerable2.call(O2, key2)) {
                        result.push(TO_ENTRIES ? [key2, O2[key2]] : O2[key2]);
                      }
                    }
                    return result;
                  };
                };
                module3.exports = {
                  // `Object.entries` method
                  // https://tc39.github.io/ecma262/#sec-object.entries
                  entries: createMethod(true),
                  // `Object.values` method
                  // https://tc39.github.io/ecma262/#sec-object.values
                  values: createMethod(false)
                };
              }
            ),
            /***/
            "73d9": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var addToUnscopables = __webpack_require__("44d2");
                addToUnscopables("flatMap");
              }
            ),
            /***/
            "7418": (
              /***/
              function(module3, exports3) {
                exports3.f = Object.getOwnPropertySymbols;
              }
            ),
            /***/
            "746f": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var path = __webpack_require__("428f");
                var has2 = __webpack_require__("5135");
                var wrappedWellKnownSymbolModule = __webpack_require__("e538");
                var defineProperty2 = __webpack_require__("9bf2").f;
                module3.exports = function(NAME) {
                  var Symbol2 = path.Symbol || (path.Symbol = {});
                  if (!has2(Symbol2, NAME))
                    defineProperty2(Symbol2, NAME, {
                      value: wrappedWellKnownSymbolModule.f(NAME)
                    });
                };
              }
            ),
            /***/
            "7839": (
              /***/
              function(module3, exports3) {
                module3.exports = [
                  "constructor",
                  "hasOwnProperty",
                  "isPrototypeOf",
                  "propertyIsEnumerable",
                  "toLocaleString",
                  "toString",
                  "valueOf"
                ];
              }
            ),
            /***/
            "7b0b": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var requireObjectCoercible = __webpack_require__("1d80");
                module3.exports = function(argument) {
                  return Object(requireObjectCoercible(argument));
                };
              }
            ),
            /***/
            "7c73": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var anObject = __webpack_require__("825a");
                var defineProperties = __webpack_require__("37e8");
                var enumBugKeys = __webpack_require__("7839");
                var hiddenKeys = __webpack_require__("d012");
                var html = __webpack_require__("1be4");
                var documentCreateElement = __webpack_require__("cc12");
                var sharedKey = __webpack_require__("f772");
                var GT = ">";
                var LT = "<";
                var PROTOTYPE = "prototype";
                var SCRIPT = "script";
                var IE_PROTO = sharedKey("IE_PROTO");
                var EmptyConstructor = function() {
                };
                var scriptTag = function(content) {
                  return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
                };
                var NullProtoObjectViaActiveX = function(activeXDocument2) {
                  activeXDocument2.write(scriptTag(""));
                  activeXDocument2.close();
                  var temp = activeXDocument2.parentWindow.Object;
                  activeXDocument2 = null;
                  return temp;
                };
                var NullProtoObjectViaIFrame = function() {
                  var iframe = documentCreateElement("iframe");
                  var JS = "java" + SCRIPT + ":";
                  var iframeDocument;
                  iframe.style.display = "none";
                  html.appendChild(iframe);
                  iframe.src = String(JS);
                  iframeDocument = iframe.contentWindow.document;
                  iframeDocument.open();
                  iframeDocument.write(scriptTag("document.F=Object"));
                  iframeDocument.close();
                  return iframeDocument.F;
                };
                var activeXDocument;
                var NullProtoObject = function() {
                  try {
                    activeXDocument = document.domain && new ActiveXObject("htmlfile");
                  } catch (error) {
                  }
                  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
                  var length = enumBugKeys.length;
                  while (length--)
                    delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
                  return NullProtoObject();
                };
                hiddenKeys[IE_PROTO] = true;
                module3.exports = Object.create || function create(O2, Properties2) {
                  var result;
                  if (O2 !== null) {
                    EmptyConstructor[PROTOTYPE] = anObject(O2);
                    result = new EmptyConstructor();
                    EmptyConstructor[PROTOTYPE] = null;
                    result[IE_PROTO] = O2;
                  } else
                    result = NullProtoObject();
                  return Properties2 === void 0 ? result : defineProperties(result, Properties2);
                };
              }
            ),
            /***/
            "7dd0": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var $2 = __webpack_require__("23e7");
                var createIteratorConstructor = __webpack_require__("9ed3");
                var getPrototypeOf = __webpack_require__("e163");
                var setPrototypeOf = __webpack_require__("d2bb");
                var setToStringTag = __webpack_require__("d44e");
                var createNonEnumerableProperty = __webpack_require__("9112");
                var redefine = __webpack_require__("6eeb");
                var wellKnownSymbol = __webpack_require__("b622");
                var IS_PURE = __webpack_require__("c430");
                var Iterators = __webpack_require__("3f8c");
                var IteratorsCore = __webpack_require__("ae93");
                var IteratorPrototype = IteratorsCore.IteratorPrototype;
                var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
                var ITERATOR = wellKnownSymbol("iterator");
                var KEYS = "keys";
                var VALUES = "values";
                var ENTRIES = "entries";
                var returnThis = function() {
                  return this;
                };
                module3.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
                  createIteratorConstructor(IteratorConstructor, NAME, next);
                  var getIterationMethod = function(KIND) {
                    if (KIND === DEFAULT && defaultIterator)
                      return defaultIterator;
                    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
                      return IterablePrototype[KIND];
                    switch (KIND) {
                      case KEYS:
                        return function keys() {
                          return new IteratorConstructor(this, KIND);
                        };
                      case VALUES:
                        return function values() {
                          return new IteratorConstructor(this, KIND);
                        };
                      case ENTRIES:
                        return function entries() {
                          return new IteratorConstructor(this, KIND);
                        };
                    }
                    return function() {
                      return new IteratorConstructor(this);
                    };
                  };
                  var TO_STRING_TAG = NAME + " Iterator";
                  var INCORRECT_VALUES_NAME = false;
                  var IterablePrototype = Iterable.prototype;
                  var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
                  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
                  var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
                  var CurrentIteratorPrototype, methods, KEY;
                  if (anyNativeIterator) {
                    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
                    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
                      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
                        if (setPrototypeOf) {
                          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
                        } else if (typeof CurrentIteratorPrototype[ITERATOR] != "function") {
                          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
                        }
                      }
                      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
                      if (IS_PURE)
                        Iterators[TO_STRING_TAG] = returnThis;
                    }
                  }
                  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
                    INCORRECT_VALUES_NAME = true;
                    defaultIterator = function values() {
                      return nativeIterator.call(this);
                    };
                  }
                  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
                    createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
                  }
                  Iterators[NAME] = defaultIterator;
                  if (DEFAULT) {
                    methods = {
                      values: getIterationMethod(VALUES),
                      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
                      entries: getIterationMethod(ENTRIES)
                    };
                    if (FORCED)
                      for (KEY in methods) {
                        if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
                          redefine(IterablePrototype, KEY, methods[KEY]);
                        }
                      }
                    else
                      $2({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
                  }
                  return methods;
                };
              }
            ),
            /***/
            "7f9a": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var global2 = __webpack_require__("da84");
                var inspectSource = __webpack_require__("8925");
                var WeakMap2 = global2.WeakMap;
                module3.exports = typeof WeakMap2 === "function" && /native code/.test(inspectSource(WeakMap2));
              }
            ),
            /***/
            "825a": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var isObject2 = __webpack_require__("861d");
                module3.exports = function(it2) {
                  if (!isObject2(it2)) {
                    throw TypeError(String(it2) + " is not an object");
                  }
                  return it2;
                };
              }
            ),
            /***/
            "83ab": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var fails = __webpack_require__("d039");
                module3.exports = !fails(function() {
                  return Object.defineProperty({}, 1, { get: function() {
                    return 7;
                  } })[1] != 7;
                });
              }
            ),
            /***/
            "8418": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var toPrimitive = __webpack_require__("c04e");
                var definePropertyModule = __webpack_require__("9bf2");
                var createPropertyDescriptor = __webpack_require__("5c6c");
                module3.exports = function(object, key2, value) {
                  var propertyKey = toPrimitive(key2);
                  if (propertyKey in object)
                    definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
                  else
                    object[propertyKey] = value;
                };
              }
            ),
            /***/
            "861d": (
              /***/
              function(module3, exports3) {
                module3.exports = function(it2) {
                  return typeof it2 === "object" ? it2 !== null : typeof it2 === "function";
                };
              }
            ),
            /***/
            "8875": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
                (function(root2, factory2) {
                  {
                    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = factory2, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports3, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module3.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                  }
                })(typeof self !== "undefined" ? self : this, function() {
                  function getCurrentScript() {
                    var descriptor = Object.getOwnPropertyDescriptor(document, "currentScript");
                    if (!descriptor && "currentScript" in document && document.currentScript) {
                      return document.currentScript;
                    }
                    if (descriptor && descriptor.get !== getCurrentScript && document.currentScript) {
                      return document.currentScript;
                    }
                    try {
                      throw new Error();
                    } catch (err) {
                      var ieStackRegExp = /.*at [^(]*\((.*):(.+):(.+)\)$/ig, ffStackRegExp = /@([^@]*):(\d+):(\d+)\s*$/ig, stackDetails = ieStackRegExp.exec(err.stack) || ffStackRegExp.exec(err.stack), scriptLocation = stackDetails && stackDetails[1] || false, line = stackDetails && stackDetails[2] || false, currentLocation = document.location.href.replace(document.location.hash, ""), pageSource, inlineScriptSourceRegExp, inlineScriptSource, scripts = document.getElementsByTagName("script");
                      if (scriptLocation === currentLocation) {
                        pageSource = document.documentElement.outerHTML;
                        inlineScriptSourceRegExp = new RegExp("(?:[^\\n]+?\\n){0," + (line - 2) + "}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*", "i");
                        inlineScriptSource = pageSource.replace(inlineScriptSourceRegExp, "$1").trim();
                      }
                      for (var i2 = 0; i2 < scripts.length; i2++) {
                        if (scripts[i2].readyState === "interactive") {
                          return scripts[i2];
                        }
                        if (scripts[i2].src === scriptLocation) {
                          return scripts[i2];
                        }
                        if (scriptLocation === currentLocation && scripts[i2].innerHTML && scripts[i2].innerHTML.trim() === inlineScriptSource) {
                          return scripts[i2];
                        }
                      }
                      return null;
                    }
                  }
                  return getCurrentScript;
                });
              }
            ),
            /***/
            "8925": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var store = __webpack_require__("c6cd");
                var functionToString = Function.toString;
                if (typeof store.inspectSource != "function") {
                  store.inspectSource = function(it2) {
                    return functionToString.call(it2);
                  };
                }
                module3.exports = store.inspectSource;
              }
            ),
            /***/
            "8aa5": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var charAt = __webpack_require__("6547").charAt;
                module3.exports = function(S2, index2, unicode) {
                  return index2 + (unicode ? charAt(S2, index2).length : 1);
                };
              }
            ),
            /***/
            "8bbf": (
              /***/
              function(module3, exports3) {
                module3.exports = __WEBPACK_EXTERNAL_MODULE__8bbf__;
              }
            ),
            /***/
            "90e3": (
              /***/
              function(module3, exports3) {
                var id2 = 0;
                var postfix = Math.random();
                module3.exports = function(key2) {
                  return "Symbol(" + String(key2 === void 0 ? "" : key2) + ")_" + (++id2 + postfix).toString(36);
                };
              }
            ),
            /***/
            "9112": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var DESCRIPTORS = __webpack_require__("83ab");
                var definePropertyModule = __webpack_require__("9bf2");
                var createPropertyDescriptor = __webpack_require__("5c6c");
                module3.exports = DESCRIPTORS ? function(object, key2, value) {
                  return definePropertyModule.f(object, key2, createPropertyDescriptor(1, value));
                } : function(object, key2, value) {
                  object[key2] = value;
                  return object;
                };
              }
            ),
            /***/
            "9263": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var regexpFlags = __webpack_require__("ad6d");
                var stickyHelpers = __webpack_require__("9f7f");
                var nativeExec = RegExp.prototype.exec;
                var nativeReplace = String.prototype.replace;
                var patchedExec = nativeExec;
                var UPDATES_LAST_INDEX_WRONG = function() {
                  var re1 = /a/;
                  var re2 = /b*/g;
                  nativeExec.call(re1, "a");
                  nativeExec.call(re2, "a");
                  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
                }();
                var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET;
                var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
                var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y;
                if (PATCH) {
                  patchedExec = function exec(str) {
                    var re2 = this;
                    var lastIndex, reCopy, match, i2;
                    var sticky = UNSUPPORTED_Y && re2.sticky;
                    var flags2 = regexpFlags.call(re2);
                    var source = re2.source;
                    var charsAdded = 0;
                    var strCopy = str;
                    if (sticky) {
                      flags2 = flags2.replace("y", "");
                      if (flags2.indexOf("g") === -1) {
                        flags2 += "g";
                      }
                      strCopy = String(str).slice(re2.lastIndex);
                      if (re2.lastIndex > 0 && (!re2.multiline || re2.multiline && str[re2.lastIndex - 1] !== "\n")) {
                        source = "(?: " + source + ")";
                        strCopy = " " + strCopy;
                        charsAdded++;
                      }
                      reCopy = new RegExp("^(?:" + source + ")", flags2);
                    }
                    if (NPCG_INCLUDED) {
                      reCopy = new RegExp("^" + source + "$(?!\\s)", flags2);
                    }
                    if (UPDATES_LAST_INDEX_WRONG)
                      lastIndex = re2.lastIndex;
                    match = nativeExec.call(sticky ? reCopy : re2, strCopy);
                    if (sticky) {
                      if (match) {
                        match.input = match.input.slice(charsAdded);
                        match[0] = match[0].slice(charsAdded);
                        match.index = re2.lastIndex;
                        re2.lastIndex += match[0].length;
                      } else
                        re2.lastIndex = 0;
                    } else if (UPDATES_LAST_INDEX_WRONG && match) {
                      re2.lastIndex = re2.global ? match.index + match[0].length : lastIndex;
                    }
                    if (NPCG_INCLUDED && match && match.length > 1) {
                      nativeReplace.call(match[0], reCopy, function() {
                        for (i2 = 1; i2 < arguments.length - 2; i2++) {
                          if (arguments[i2] === void 0)
                            match[i2] = void 0;
                        }
                      });
                    }
                    return match;
                  };
                }
                module3.exports = patchedExec;
              }
            ),
            /***/
            "94ca": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var fails = __webpack_require__("d039");
                var replacement = /#|\.prototype\./;
                var isForced = function(feature, detection) {
                  var value = data[normalize(feature)];
                  return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == "function" ? fails(detection) : !!detection;
                };
                var normalize = isForced.normalize = function(string) {
                  return String(string).replace(replacement, ".").toLowerCase();
                };
                var data = isForced.data = {};
                var NATIVE = isForced.NATIVE = "N";
                var POLYFILL = isForced.POLYFILL = "P";
                module3.exports = isForced;
              }
            ),
            /***/
            "99af": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var $2 = __webpack_require__("23e7");
                var fails = __webpack_require__("d039");
                var isArray2 = __webpack_require__("e8b5");
                var isObject2 = __webpack_require__("861d");
                var toObject = __webpack_require__("7b0b");
                var toLength = __webpack_require__("50c4");
                var createProperty = __webpack_require__("8418");
                var arraySpeciesCreate = __webpack_require__("65f0");
                var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
                var wellKnownSymbol = __webpack_require__("b622");
                var V8_VERSION = __webpack_require__("2d00");
                var IS_CONCAT_SPREADABLE = wellKnownSymbol("isConcatSpreadable");
                var MAX_SAFE_INTEGER2 = 9007199254740991;
                var MAXIMUM_ALLOWED_INDEX_EXCEEDED = "Maximum allowed index exceeded";
                var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function() {
                  var array = [];
                  array[IS_CONCAT_SPREADABLE] = false;
                  return array.concat()[0] !== array;
                });
                var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("concat");
                var isConcatSpreadable = function(O2) {
                  if (!isObject2(O2))
                    return false;
                  var spreadable = O2[IS_CONCAT_SPREADABLE];
                  return spreadable !== void 0 ? !!spreadable : isArray2(O2);
                };
                var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;
                $2({ target: "Array", proto: true, forced: FORCED }, {
                  concat: function concat(arg) {
                    var O2 = toObject(this);
                    var A2 = arraySpeciesCreate(O2, 0);
                    var n2 = 0;
                    var i2, k2, length, len, E2;
                    for (i2 = -1, length = arguments.length; i2 < length; i2++) {
                      E2 = i2 === -1 ? O2 : arguments[i2];
                      if (isConcatSpreadable(E2)) {
                        len = toLength(E2.length);
                        if (n2 + len > MAX_SAFE_INTEGER2)
                          throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                        for (k2 = 0; k2 < len; k2++, n2++)
                          if (k2 in E2)
                            createProperty(A2, n2, E2[k2]);
                      } else {
                        if (n2 >= MAX_SAFE_INTEGER2)
                          throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                        createProperty(A2, n2++, E2);
                      }
                    }
                    A2.length = n2;
                    return A2;
                  }
                });
              }
            ),
            /***/
            "9bdd": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var anObject = __webpack_require__("825a");
                module3.exports = function(iterator2, fn2, value, ENTRIES) {
                  try {
                    return ENTRIES ? fn2(anObject(value)[0], value[1]) : fn2(value);
                  } catch (error) {
                    var returnMethod = iterator2["return"];
                    if (returnMethod !== void 0)
                      anObject(returnMethod.call(iterator2));
                    throw error;
                  }
                };
              }
            ),
            /***/
            "9bf2": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var DESCRIPTORS = __webpack_require__("83ab");
                var IE8_DOM_DEFINE = __webpack_require__("0cfb");
                var anObject = __webpack_require__("825a");
                var toPrimitive = __webpack_require__("c04e");
                var nativeDefineProperty = Object.defineProperty;
                exports3.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty2(O2, P2, Attributes) {
                  anObject(O2);
                  P2 = toPrimitive(P2, true);
                  anObject(Attributes);
                  if (IE8_DOM_DEFINE)
                    try {
                      return nativeDefineProperty(O2, P2, Attributes);
                    } catch (error) {
                    }
                  if ("get" in Attributes || "set" in Attributes)
                    throw TypeError("Accessors not supported");
                  if ("value" in Attributes)
                    O2[P2] = Attributes.value;
                  return O2;
                };
              }
            ),
            /***/
            "9ed3": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var IteratorPrototype = __webpack_require__("ae93").IteratorPrototype;
                var create = __webpack_require__("7c73");
                var createPropertyDescriptor = __webpack_require__("5c6c");
                var setToStringTag = __webpack_require__("d44e");
                var Iterators = __webpack_require__("3f8c");
                var returnThis = function() {
                  return this;
                };
                module3.exports = function(IteratorConstructor, NAME, next) {
                  var TO_STRING_TAG = NAME + " Iterator";
                  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
                  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
                  Iterators[TO_STRING_TAG] = returnThis;
                  return IteratorConstructor;
                };
              }
            ),
            /***/
            "9f7f": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var fails = __webpack_require__("d039");
                function RE(s2, f2) {
                  return RegExp(s2, f2);
                }
                exports3.UNSUPPORTED_Y = fails(function() {
                  var re2 = RE("a", "y");
                  re2.lastIndex = 2;
                  return re2.exec("abcd") != null;
                });
                exports3.BROKEN_CARET = fails(function() {
                  var re2 = RE("^r", "gy");
                  re2.lastIndex = 2;
                  return re2.exec("str") != null;
                });
              }
            ),
            /***/
            "a2bf": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var isArray2 = __webpack_require__("e8b5");
                var toLength = __webpack_require__("50c4");
                var bind = __webpack_require__("0366");
                var flattenIntoArray = function(target, original, source, sourceLen, start2, depth, mapper, thisArg) {
                  var targetIndex = start2;
                  var sourceIndex = 0;
                  var mapFn = mapper ? bind(mapper, thisArg, 3) : false;
                  var element;
                  while (sourceIndex < sourceLen) {
                    if (sourceIndex in source) {
                      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
                      if (depth > 0 && isArray2(element)) {
                        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
                      } else {
                        if (targetIndex >= 9007199254740991)
                          throw TypeError("Exceed the acceptable array length");
                        target[targetIndex] = element;
                      }
                      targetIndex++;
                    }
                    sourceIndex++;
                  }
                  return targetIndex;
                };
                module3.exports = flattenIntoArray;
              }
            ),
            /***/
            "a352": (
              /***/
              function(module3, exports3) {
                module3.exports = __WEBPACK_EXTERNAL_MODULE_a352__;
              }
            ),
            /***/
            "a434": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var $2 = __webpack_require__("23e7");
                var toAbsoluteIndex = __webpack_require__("23cb");
                var toInteger = __webpack_require__("a691");
                var toLength = __webpack_require__("50c4");
                var toObject = __webpack_require__("7b0b");
                var arraySpeciesCreate = __webpack_require__("65f0");
                var createProperty = __webpack_require__("8418");
                var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
                var arrayMethodUsesToLength = __webpack_require__("ae40");
                var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("splice");
                var USES_TO_LENGTH = arrayMethodUsesToLength("splice", { ACCESSORS: true, 0: 0, 1: 2 });
                var max2 = Math.max;
                var min2 = Math.min;
                var MAX_SAFE_INTEGER2 = 9007199254740991;
                var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = "Maximum allowed length exceeded";
                $2({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
                  splice: function splice2(start2, deleteCount) {
                    var O2 = toObject(this);
                    var len = toLength(O2.length);
                    var actualStart = toAbsoluteIndex(start2, len);
                    var argumentsLength = arguments.length;
                    var insertCount, actualDeleteCount, A2, k2, from, to2;
                    if (argumentsLength === 0) {
                      insertCount = actualDeleteCount = 0;
                    } else if (argumentsLength === 1) {
                      insertCount = 0;
                      actualDeleteCount = len - actualStart;
                    } else {
                      insertCount = argumentsLength - 2;
                      actualDeleteCount = min2(max2(toInteger(deleteCount), 0), len - actualStart);
                    }
                    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER2) {
                      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
                    }
                    A2 = arraySpeciesCreate(O2, actualDeleteCount);
                    for (k2 = 0; k2 < actualDeleteCount; k2++) {
                      from = actualStart + k2;
                      if (from in O2)
                        createProperty(A2, k2, O2[from]);
                    }
                    A2.length = actualDeleteCount;
                    if (insertCount < actualDeleteCount) {
                      for (k2 = actualStart; k2 < len - actualDeleteCount; k2++) {
                        from = k2 + actualDeleteCount;
                        to2 = k2 + insertCount;
                        if (from in O2)
                          O2[to2] = O2[from];
                        else
                          delete O2[to2];
                      }
                      for (k2 = len; k2 > len - actualDeleteCount + insertCount; k2--)
                        delete O2[k2 - 1];
                    } else if (insertCount > actualDeleteCount) {
                      for (k2 = len - actualDeleteCount; k2 > actualStart; k2--) {
                        from = k2 + actualDeleteCount - 1;
                        to2 = k2 + insertCount - 1;
                        if (from in O2)
                          O2[to2] = O2[from];
                        else
                          delete O2[to2];
                      }
                    }
                    for (k2 = 0; k2 < insertCount; k2++) {
                      O2[k2 + actualStart] = arguments[k2 + 2];
                    }
                    O2.length = len - actualDeleteCount + insertCount;
                    return A2;
                  }
                });
              }
            ),
            /***/
            "a4d3": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var $2 = __webpack_require__("23e7");
                var global2 = __webpack_require__("da84");
                var getBuiltIn = __webpack_require__("d066");
                var IS_PURE = __webpack_require__("c430");
                var DESCRIPTORS = __webpack_require__("83ab");
                var NATIVE_SYMBOL = __webpack_require__("4930");
                var USE_SYMBOL_AS_UID = __webpack_require__("fdbf");
                var fails = __webpack_require__("d039");
                var has2 = __webpack_require__("5135");
                var isArray2 = __webpack_require__("e8b5");
                var isObject2 = __webpack_require__("861d");
                var anObject = __webpack_require__("825a");
                var toObject = __webpack_require__("7b0b");
                var toIndexedObject = __webpack_require__("fc6a");
                var toPrimitive = __webpack_require__("c04e");
                var createPropertyDescriptor = __webpack_require__("5c6c");
                var nativeObjectCreate = __webpack_require__("7c73");
                var objectKeys = __webpack_require__("df75");
                var getOwnPropertyNamesModule = __webpack_require__("241c");
                var getOwnPropertyNamesExternal = __webpack_require__("057f");
                var getOwnPropertySymbolsModule = __webpack_require__("7418");
                var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
                var definePropertyModule = __webpack_require__("9bf2");
                var propertyIsEnumerableModule = __webpack_require__("d1e7");
                var createNonEnumerableProperty = __webpack_require__("9112");
                var redefine = __webpack_require__("6eeb");
                var shared2 = __webpack_require__("5692");
                var sharedKey = __webpack_require__("f772");
                var hiddenKeys = __webpack_require__("d012");
                var uid2 = __webpack_require__("90e3");
                var wellKnownSymbol = __webpack_require__("b622");
                var wrappedWellKnownSymbolModule = __webpack_require__("e538");
                var defineWellKnownSymbol = __webpack_require__("746f");
                var setToStringTag = __webpack_require__("d44e");
                var InternalStateModule = __webpack_require__("69f3");
                var $forEach = __webpack_require__("b727").forEach;
                var HIDDEN = sharedKey("hidden");
                var SYMBOL = "Symbol";
                var PROTOTYPE = "prototype";
                var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
                var setInternalState = InternalStateModule.set;
                var getInternalState = InternalStateModule.getterFor(SYMBOL);
                var ObjectPrototype = Object[PROTOTYPE];
                var $Symbol = global2.Symbol;
                var $stringify = getBuiltIn("JSON", "stringify");
                var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
                var nativeDefineProperty = definePropertyModule.f;
                var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
                var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
                var AllSymbols = shared2("symbols");
                var ObjectPrototypeSymbols = shared2("op-symbols");
                var StringToSymbolRegistry = shared2("string-to-symbol-registry");
                var SymbolToStringRegistry = shared2("symbol-to-string-registry");
                var WellKnownSymbolsStore = shared2("wks");
                var QObject = global2.QObject;
                var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
                var setSymbolDescriptor = DESCRIPTORS && fails(function() {
                  return nativeObjectCreate(nativeDefineProperty({}, "a", {
                    get: function() {
                      return nativeDefineProperty(this, "a", { value: 7 }).a;
                    }
                  })).a != 7;
                }) ? function(O2, P2, Attributes) {
                  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P2);
                  if (ObjectPrototypeDescriptor)
                    delete ObjectPrototype[P2];
                  nativeDefineProperty(O2, P2, Attributes);
                  if (ObjectPrototypeDescriptor && O2 !== ObjectPrototype) {
                    nativeDefineProperty(ObjectPrototype, P2, ObjectPrototypeDescriptor);
                  }
                } : nativeDefineProperty;
                var wrap = function(tag, description) {
                  var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);
                  setInternalState(symbol, {
                    type: SYMBOL,
                    tag,
                    description
                  });
                  if (!DESCRIPTORS)
                    symbol.description = description;
                  return symbol;
                };
                var isSymbol2 = USE_SYMBOL_AS_UID ? function(it2) {
                  return typeof it2 == "symbol";
                } : function(it2) {
                  return Object(it2) instanceof $Symbol;
                };
                var $defineProperty = function defineProperty2(O2, P2, Attributes) {
                  if (O2 === ObjectPrototype)
                    $defineProperty(ObjectPrototypeSymbols, P2, Attributes);
                  anObject(O2);
                  var key2 = toPrimitive(P2, true);
                  anObject(Attributes);
                  if (has2(AllSymbols, key2)) {
                    if (!Attributes.enumerable) {
                      if (!has2(O2, HIDDEN))
                        nativeDefineProperty(O2, HIDDEN, createPropertyDescriptor(1, {}));
                      O2[HIDDEN][key2] = true;
                    } else {
                      if (has2(O2, HIDDEN) && O2[HIDDEN][key2])
                        O2[HIDDEN][key2] = false;
                      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
                    }
                    return setSymbolDescriptor(O2, key2, Attributes);
                  }
                  return nativeDefineProperty(O2, key2, Attributes);
                };
                var $defineProperties = function defineProperties(O2, Properties2) {
                  anObject(O2);
                  var properties = toIndexedObject(Properties2);
                  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
                  $forEach(keys, function(key2) {
                    if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key2))
                      $defineProperty(O2, key2, properties[key2]);
                  });
                  return O2;
                };
                var $create = function create(O2, Properties2) {
                  return Properties2 === void 0 ? nativeObjectCreate(O2) : $defineProperties(nativeObjectCreate(O2), Properties2);
                };
                var $propertyIsEnumerable = function propertyIsEnumerable2(V2) {
                  var P2 = toPrimitive(V2, true);
                  var enumerable = nativePropertyIsEnumerable.call(this, P2);
                  if (this === ObjectPrototype && has2(AllSymbols, P2) && !has2(ObjectPrototypeSymbols, P2))
                    return false;
                  return enumerable || !has2(this, P2) || !has2(AllSymbols, P2) || has2(this, HIDDEN) && this[HIDDEN][P2] ? enumerable : true;
                };
                var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O2, P2) {
                  var it2 = toIndexedObject(O2);
                  var key2 = toPrimitive(P2, true);
                  if (it2 === ObjectPrototype && has2(AllSymbols, key2) && !has2(ObjectPrototypeSymbols, key2))
                    return;
                  var descriptor = nativeGetOwnPropertyDescriptor(it2, key2);
                  if (descriptor && has2(AllSymbols, key2) && !(has2(it2, HIDDEN) && it2[HIDDEN][key2])) {
                    descriptor.enumerable = true;
                  }
                  return descriptor;
                };
                var $getOwnPropertyNames = function getOwnPropertyNames(O2) {
                  var names2 = nativeGetOwnPropertyNames(toIndexedObject(O2));
                  var result = [];
                  $forEach(names2, function(key2) {
                    if (!has2(AllSymbols, key2) && !has2(hiddenKeys, key2))
                      result.push(key2);
                  });
                  return result;
                };
                var $getOwnPropertySymbols = function getOwnPropertySymbols(O2) {
                  var IS_OBJECT_PROTOTYPE = O2 === ObjectPrototype;
                  var names2 = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O2));
                  var result = [];
                  $forEach(names2, function(key2) {
                    if (has2(AllSymbols, key2) && (!IS_OBJECT_PROTOTYPE || has2(ObjectPrototype, key2))) {
                      result.push(AllSymbols[key2]);
                    }
                  });
                  return result;
                };
                if (!NATIVE_SYMBOL) {
                  $Symbol = function Symbol2() {
                    if (this instanceof $Symbol)
                      throw TypeError("Symbol is not a constructor");
                    var description = !arguments.length || arguments[0] === void 0 ? void 0 : String(arguments[0]);
                    var tag = uid2(description);
                    var setter = function(value) {
                      if (this === ObjectPrototype)
                        setter.call(ObjectPrototypeSymbols, value);
                      if (has2(this, HIDDEN) && has2(this[HIDDEN], tag))
                        this[HIDDEN][tag] = false;
                      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
                    };
                    if (DESCRIPTORS && USE_SETTER)
                      setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
                    return wrap(tag, description);
                  };
                  redefine($Symbol[PROTOTYPE], "toString", function toString2() {
                    return getInternalState(this).tag;
                  });
                  redefine($Symbol, "withoutSetter", function(description) {
                    return wrap(uid2(description), description);
                  });
                  propertyIsEnumerableModule.f = $propertyIsEnumerable;
                  definePropertyModule.f = $defineProperty;
                  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
                  getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
                  getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;
                  wrappedWellKnownSymbolModule.f = function(name) {
                    return wrap(wellKnownSymbol(name), name);
                  };
                  if (DESCRIPTORS) {
                    nativeDefineProperty($Symbol[PROTOTYPE], "description", {
                      configurable: true,
                      get: function description() {
                        return getInternalState(this).description;
                      }
                    });
                    if (!IS_PURE) {
                      redefine(ObjectPrototype, "propertyIsEnumerable", $propertyIsEnumerable, { unsafe: true });
                    }
                  }
                }
                $2({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
                  Symbol: $Symbol
                });
                $forEach(objectKeys(WellKnownSymbolsStore), function(name) {
                  defineWellKnownSymbol(name);
                });
                $2({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
                  // `Symbol.for` method
                  // https://tc39.github.io/ecma262/#sec-symbol.for
                  "for": function(key2) {
                    var string = String(key2);
                    if (has2(StringToSymbolRegistry, string))
                      return StringToSymbolRegistry[string];
                    var symbol = $Symbol(string);
                    StringToSymbolRegistry[string] = symbol;
                    SymbolToStringRegistry[symbol] = string;
                    return symbol;
                  },
                  // `Symbol.keyFor` method
                  // https://tc39.github.io/ecma262/#sec-symbol.keyfor
                  keyFor: function keyFor(sym) {
                    if (!isSymbol2(sym))
                      throw TypeError(sym + " is not a symbol");
                    if (has2(SymbolToStringRegistry, sym))
                      return SymbolToStringRegistry[sym];
                  },
                  useSetter: function() {
                    USE_SETTER = true;
                  },
                  useSimple: function() {
                    USE_SETTER = false;
                  }
                });
                $2({ target: "Object", stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
                  // `Object.create` method
                  // https://tc39.github.io/ecma262/#sec-object.create
                  create: $create,
                  // `Object.defineProperty` method
                  // https://tc39.github.io/ecma262/#sec-object.defineproperty
                  defineProperty: $defineProperty,
                  // `Object.defineProperties` method
                  // https://tc39.github.io/ecma262/#sec-object.defineproperties
                  defineProperties: $defineProperties,
                  // `Object.getOwnPropertyDescriptor` method
                  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
                  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
                });
                $2({ target: "Object", stat: true, forced: !NATIVE_SYMBOL }, {
                  // `Object.getOwnPropertyNames` method
                  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
                  getOwnPropertyNames: $getOwnPropertyNames,
                  // `Object.getOwnPropertySymbols` method
                  // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
                  getOwnPropertySymbols: $getOwnPropertySymbols
                });
                $2({ target: "Object", stat: true, forced: fails(function() {
                  getOwnPropertySymbolsModule.f(1);
                }) }, {
                  getOwnPropertySymbols: function getOwnPropertySymbols(it2) {
                    return getOwnPropertySymbolsModule.f(toObject(it2));
                  }
                });
                if ($stringify) {
                  var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function() {
                    var symbol = $Symbol();
                    return $stringify([symbol]) != "[null]" || $stringify({ a: symbol }) != "{}" || $stringify(Object(symbol)) != "{}";
                  });
                  $2({ target: "JSON", stat: true, forced: FORCED_JSON_STRINGIFY }, {
                    // eslint-disable-next-line no-unused-vars
                    stringify: function stringify2(it2, replacer2, space) {
                      var args = [it2];
                      var index2 = 1;
                      var $replacer;
                      while (arguments.length > index2)
                        args.push(arguments[index2++]);
                      $replacer = replacer2;
                      if (!isObject2(replacer2) && it2 === void 0 || isSymbol2(it2))
                        return;
                      if (!isArray2(replacer2))
                        replacer2 = function(key2, value) {
                          if (typeof $replacer == "function")
                            value = $replacer.call(this, key2, value);
                          if (!isSymbol2(value))
                            return value;
                        };
                      args[1] = replacer2;
                      return $stringify.apply(null, args);
                    }
                  });
                }
                if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) {
                  createNonEnumerableProperty($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
                }
                setToStringTag($Symbol, SYMBOL);
                hiddenKeys[HIDDEN] = true;
              }
            ),
            /***/
            "a630": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var $2 = __webpack_require__("23e7");
                var from = __webpack_require__("4df4");
                var checkCorrectnessOfIteration = __webpack_require__("1c7e");
                var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {
                  Array.from(iterable);
                });
                $2({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, {
                  from
                });
              }
            ),
            /***/
            "a640": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var fails = __webpack_require__("d039");
                module3.exports = function(METHOD_NAME, argument) {
                  var method = [][METHOD_NAME];
                  return !!method && fails(function() {
                    method.call(null, argument || function() {
                      throw 1;
                    }, 1);
                  });
                };
              }
            ),
            /***/
            "a691": (
              /***/
              function(module3, exports3) {
                var ceil = Math.ceil;
                var floor = Math.floor;
                module3.exports = function(argument) {
                  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
                };
              }
            ),
            /***/
            "ab13": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var wellKnownSymbol = __webpack_require__("b622");
                var MATCH = wellKnownSymbol("match");
                module3.exports = function(METHOD_NAME) {
                  var regexp = /./;
                  try {
                    "/./"[METHOD_NAME](regexp);
                  } catch (e2) {
                    try {
                      regexp[MATCH] = false;
                      return "/./"[METHOD_NAME](regexp);
                    } catch (f2) {
                    }
                  }
                  return false;
                };
              }
            ),
            /***/
            "ac1f": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var $2 = __webpack_require__("23e7");
                var exec = __webpack_require__("9263");
                $2({ target: "RegExp", proto: true, forced: /./.exec !== exec }, {
                  exec
                });
              }
            ),
            /***/
            "ad6d": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var anObject = __webpack_require__("825a");
                module3.exports = function() {
                  var that = anObject(this);
                  var result = "";
                  if (that.global)
                    result += "g";
                  if (that.ignoreCase)
                    result += "i";
                  if (that.multiline)
                    result += "m";
                  if (that.dotAll)
                    result += "s";
                  if (that.unicode)
                    result += "u";
                  if (that.sticky)
                    result += "y";
                  return result;
                };
              }
            ),
            /***/
            "ae40": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var DESCRIPTORS = __webpack_require__("83ab");
                var fails = __webpack_require__("d039");
                var has2 = __webpack_require__("5135");
                var defineProperty2 = Object.defineProperty;
                var cache2 = {};
                var thrower = function(it2) {
                  throw it2;
                };
                module3.exports = function(METHOD_NAME, options) {
                  if (has2(cache2, METHOD_NAME))
                    return cache2[METHOD_NAME];
                  if (!options)
                    options = {};
                  var method = [][METHOD_NAME];
                  var ACCESSORS = has2(options, "ACCESSORS") ? options.ACCESSORS : false;
                  var argument0 = has2(options, 0) ? options[0] : thrower;
                  var argument1 = has2(options, 1) ? options[1] : void 0;
                  return cache2[METHOD_NAME] = !!method && !fails(function() {
                    if (ACCESSORS && !DESCRIPTORS)
                      return true;
                    var O2 = { length: -1 };
                    if (ACCESSORS)
                      defineProperty2(O2, 1, { enumerable: true, get: thrower });
                    else
                      O2[1] = 1;
                    method.call(O2, argument0, argument1);
                  });
                };
              }
            ),
            /***/
            "ae93": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var getPrototypeOf = __webpack_require__("e163");
                var createNonEnumerableProperty = __webpack_require__("9112");
                var has2 = __webpack_require__("5135");
                var wellKnownSymbol = __webpack_require__("b622");
                var IS_PURE = __webpack_require__("c430");
                var ITERATOR = wellKnownSymbol("iterator");
                var BUGGY_SAFARI_ITERATORS = false;
                var returnThis = function() {
                  return this;
                };
                var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
                if ([].keys) {
                  arrayIterator = [].keys();
                  if (!("next" in arrayIterator))
                    BUGGY_SAFARI_ITERATORS = true;
                  else {
                    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
                    if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
                      IteratorPrototype = PrototypeOfArrayIteratorPrototype;
                  }
                }
                if (IteratorPrototype == void 0)
                  IteratorPrototype = {};
                if (!IS_PURE && !has2(IteratorPrototype, ITERATOR)) {
                  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
                }
                module3.exports = {
                  IteratorPrototype,
                  BUGGY_SAFARI_ITERATORS
                };
              }
            ),
            /***/
            "b041": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
                var classof = __webpack_require__("f5df");
                module3.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString2() {
                  return "[object " + classof(this) + "]";
                };
              }
            ),
            /***/
            "b0c0": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var DESCRIPTORS = __webpack_require__("83ab");
                var defineProperty2 = __webpack_require__("9bf2").f;
                var FunctionPrototype = Function.prototype;
                var FunctionPrototypeToString = FunctionPrototype.toString;
                var nameRE = /^\s*function ([^ (]*)/;
                var NAME = "name";
                if (DESCRIPTORS && !(NAME in FunctionPrototype)) {
                  defineProperty2(FunctionPrototype, NAME, {
                    configurable: true,
                    get: function() {
                      try {
                        return FunctionPrototypeToString.call(this).match(nameRE)[1];
                      } catch (error) {
                        return "";
                      }
                    }
                  });
                }
              }
            ),
            /***/
            "b622": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var global2 = __webpack_require__("da84");
                var shared2 = __webpack_require__("5692");
                var has2 = __webpack_require__("5135");
                var uid2 = __webpack_require__("90e3");
                var NATIVE_SYMBOL = __webpack_require__("4930");
                var USE_SYMBOL_AS_UID = __webpack_require__("fdbf");
                var WellKnownSymbolsStore = shared2("wks");
                var Symbol2 = global2.Symbol;
                var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2 : Symbol2 && Symbol2.withoutSetter || uid2;
                module3.exports = function(name) {
                  if (!has2(WellKnownSymbolsStore, name)) {
                    if (NATIVE_SYMBOL && has2(Symbol2, name))
                      WellKnownSymbolsStore[name] = Symbol2[name];
                    else
                      WellKnownSymbolsStore[name] = createWellKnownSymbol("Symbol." + name);
                  }
                  return WellKnownSymbolsStore[name];
                };
              }
            ),
            /***/
            "b64b": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var $2 = __webpack_require__("23e7");
                var toObject = __webpack_require__("7b0b");
                var nativeKeys = __webpack_require__("df75");
                var fails = __webpack_require__("d039");
                var FAILS_ON_PRIMITIVES = fails(function() {
                  nativeKeys(1);
                });
                $2({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES }, {
                  keys: function keys(it2) {
                    return nativeKeys(toObject(it2));
                  }
                });
              }
            ),
            /***/
            "b727": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var bind = __webpack_require__("0366");
                var IndexedObject = __webpack_require__("44ad");
                var toObject = __webpack_require__("7b0b");
                var toLength = __webpack_require__("50c4");
                var arraySpeciesCreate = __webpack_require__("65f0");
                var push = [].push;
                var createMethod = function(TYPE) {
                  var IS_MAP = TYPE == 1;
                  var IS_FILTER = TYPE == 2;
                  var IS_SOME = TYPE == 3;
                  var IS_EVERY = TYPE == 4;
                  var IS_FIND_INDEX = TYPE == 6;
                  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
                  return function($this, callbackfn, that, specificCreate) {
                    var O2 = toObject($this);
                    var self2 = IndexedObject(O2);
                    var boundFunction = bind(callbackfn, that, 3);
                    var length = toLength(self2.length);
                    var index2 = 0;
                    var create = specificCreate || arraySpeciesCreate;
                    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : void 0;
                    var value, result;
                    for (; length > index2; index2++)
                      if (NO_HOLES || index2 in self2) {
                        value = self2[index2];
                        result = boundFunction(value, index2, O2);
                        if (TYPE) {
                          if (IS_MAP)
                            target[index2] = result;
                          else if (result)
                            switch (TYPE) {
                              case 3:
                                return true;
                              case 5:
                                return value;
                              case 6:
                                return index2;
                              case 2:
                                push.call(target, value);
                            }
                          else if (IS_EVERY)
                            return false;
                        }
                      }
                    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
                  };
                };
                module3.exports = {
                  // `Array.prototype.forEach` method
                  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
                  forEach: createMethod(0),
                  // `Array.prototype.map` method
                  // https://tc39.github.io/ecma262/#sec-array.prototype.map
                  map: createMethod(1),
                  // `Array.prototype.filter` method
                  // https://tc39.github.io/ecma262/#sec-array.prototype.filter
                  filter: createMethod(2),
                  // `Array.prototype.some` method
                  // https://tc39.github.io/ecma262/#sec-array.prototype.some
                  some: createMethod(3),
                  // `Array.prototype.every` method
                  // https://tc39.github.io/ecma262/#sec-array.prototype.every
                  every: createMethod(4),
                  // `Array.prototype.find` method
                  // https://tc39.github.io/ecma262/#sec-array.prototype.find
                  find: createMethod(5),
                  // `Array.prototype.findIndex` method
                  // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
                  findIndex: createMethod(6)
                };
              }
            ),
            /***/
            "c04e": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var isObject2 = __webpack_require__("861d");
                module3.exports = function(input, PREFERRED_STRING) {
                  if (!isObject2(input))
                    return input;
                  var fn2, val;
                  if (PREFERRED_STRING && typeof (fn2 = input.toString) == "function" && !isObject2(val = fn2.call(input)))
                    return val;
                  if (typeof (fn2 = input.valueOf) == "function" && !isObject2(val = fn2.call(input)))
                    return val;
                  if (!PREFERRED_STRING && typeof (fn2 = input.toString) == "function" && !isObject2(val = fn2.call(input)))
                    return val;
                  throw TypeError("Can't convert object to primitive value");
                };
              }
            ),
            /***/
            "c430": (
              /***/
              function(module3, exports3) {
                module3.exports = false;
              }
            ),
            /***/
            "c6b6": (
              /***/
              function(module3, exports3) {
                var toString2 = {}.toString;
                module3.exports = function(it2) {
                  return toString2.call(it2).slice(8, -1);
                };
              }
            ),
            /***/
            "c6cd": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var global2 = __webpack_require__("da84");
                var setGlobal = __webpack_require__("ce4e");
                var SHARED = "__core-js_shared__";
                var store = global2[SHARED] || setGlobal(SHARED, {});
                module3.exports = store;
              }
            ),
            /***/
            "c740": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var $2 = __webpack_require__("23e7");
                var $findIndex = __webpack_require__("b727").findIndex;
                var addToUnscopables = __webpack_require__("44d2");
                var arrayMethodUsesToLength = __webpack_require__("ae40");
                var FIND_INDEX = "findIndex";
                var SKIPS_HOLES = true;
                var USES_TO_LENGTH = arrayMethodUsesToLength(FIND_INDEX);
                if (FIND_INDEX in [])
                  Array(1)[FIND_INDEX](function() {
                    SKIPS_HOLES = false;
                  });
                $2({ target: "Array", proto: true, forced: SKIPS_HOLES || !USES_TO_LENGTH }, {
                  findIndex: function findIndex2(callbackfn) {
                    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
                  }
                });
                addToUnscopables(FIND_INDEX);
              }
            ),
            /***/
            "c8ba": (
              /***/
              function(module3, exports3) {
                var g2;
                g2 = /* @__PURE__ */ function() {
                  return this;
                }();
                try {
                  g2 = g2 || new Function("return this")();
                } catch (e2) {
                  if (typeof window === "object")
                    g2 = window;
                }
                module3.exports = g2;
              }
            ),
            /***/
            "c975": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var $2 = __webpack_require__("23e7");
                var $indexOf = __webpack_require__("4d64").indexOf;
                var arrayMethodIsStrict = __webpack_require__("a640");
                var arrayMethodUsesToLength = __webpack_require__("ae40");
                var nativeIndexOf = [].indexOf;
                var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
                var STRICT_METHOD = arrayMethodIsStrict("indexOf");
                var USES_TO_LENGTH = arrayMethodUsesToLength("indexOf", { ACCESSORS: true, 1: 0 });
                $2({ target: "Array", proto: true, forced: NEGATIVE_ZERO || !STRICT_METHOD || !USES_TO_LENGTH }, {
                  indexOf: function indexOf(searchElement) {
                    return NEGATIVE_ZERO ? nativeIndexOf.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : void 0);
                  }
                });
              }
            ),
            /***/
            "ca84": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var has2 = __webpack_require__("5135");
                var toIndexedObject = __webpack_require__("fc6a");
                var indexOf = __webpack_require__("4d64").indexOf;
                var hiddenKeys = __webpack_require__("d012");
                module3.exports = function(object, names2) {
                  var O2 = toIndexedObject(object);
                  var i2 = 0;
                  var result = [];
                  var key2;
                  for (key2 in O2)
                    !has2(hiddenKeys, key2) && has2(O2, key2) && result.push(key2);
                  while (names2.length > i2)
                    if (has2(O2, key2 = names2[i2++])) {
                      ~indexOf(result, key2) || result.push(key2);
                    }
                  return result;
                };
              }
            ),
            /***/
            "caad": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var $2 = __webpack_require__("23e7");
                var $includes = __webpack_require__("4d64").includes;
                var addToUnscopables = __webpack_require__("44d2");
                var arrayMethodUsesToLength = __webpack_require__("ae40");
                var USES_TO_LENGTH = arrayMethodUsesToLength("indexOf", { ACCESSORS: true, 1: 0 });
                $2({ target: "Array", proto: true, forced: !USES_TO_LENGTH }, {
                  includes: function includes(el) {
                    return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
                  }
                });
                addToUnscopables("includes");
              }
            ),
            /***/
            "cc12": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var global2 = __webpack_require__("da84");
                var isObject2 = __webpack_require__("861d");
                var document2 = global2.document;
                var EXISTS = isObject2(document2) && isObject2(document2.createElement);
                module3.exports = function(it2) {
                  return EXISTS ? document2.createElement(it2) : {};
                };
              }
            ),
            /***/
            "ce4e": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var global2 = __webpack_require__("da84");
                var createNonEnumerableProperty = __webpack_require__("9112");
                module3.exports = function(key2, value) {
                  try {
                    createNonEnumerableProperty(global2, key2, value);
                  } catch (error) {
                    global2[key2] = value;
                  }
                  return value;
                };
              }
            ),
            /***/
            "d012": (
              /***/
              function(module3, exports3) {
                module3.exports = {};
              }
            ),
            /***/
            "d039": (
              /***/
              function(module3, exports3) {
                module3.exports = function(exec) {
                  try {
                    return !!exec();
                  } catch (error) {
                    return true;
                  }
                };
              }
            ),
            /***/
            "d066": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var path = __webpack_require__("428f");
                var global2 = __webpack_require__("da84");
                var aFunction = function(variable) {
                  return typeof variable == "function" ? variable : void 0;
                };
                module3.exports = function(namespace, method) {
                  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global2[namespace]) : path[namespace] && path[namespace][method] || global2[namespace] && global2[namespace][method];
                };
              }
            ),
            /***/
            "d1e7": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
                var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
                var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);
                exports3.f = NASHORN_BUG ? function propertyIsEnumerable2(V2) {
                  var descriptor = getOwnPropertyDescriptor(this, V2);
                  return !!descriptor && descriptor.enumerable;
                } : nativePropertyIsEnumerable;
              }
            ),
            /***/
            "d28b": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var defineWellKnownSymbol = __webpack_require__("746f");
                defineWellKnownSymbol("iterator");
              }
            ),
            /***/
            "d2bb": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var anObject = __webpack_require__("825a");
                var aPossiblePrototype = __webpack_require__("3bbe");
                module3.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
                  var CORRECT_SETTER = false;
                  var test = {};
                  var setter;
                  try {
                    setter = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set;
                    setter.call(test, []);
                    CORRECT_SETTER = test instanceof Array;
                  } catch (error) {
                  }
                  return function setPrototypeOf(O2, proto) {
                    anObject(O2);
                    aPossiblePrototype(proto);
                    if (CORRECT_SETTER)
                      setter.call(O2, proto);
                    else
                      O2.__proto__ = proto;
                    return O2;
                  };
                }() : void 0);
              }
            ),
            /***/
            "d3b7": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
                var redefine = __webpack_require__("6eeb");
                var toString2 = __webpack_require__("b041");
                if (!TO_STRING_TAG_SUPPORT) {
                  redefine(Object.prototype, "toString", toString2, { unsafe: true });
                }
              }
            ),
            /***/
            "d44e": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var defineProperty2 = __webpack_require__("9bf2").f;
                var has2 = __webpack_require__("5135");
                var wellKnownSymbol = __webpack_require__("b622");
                var TO_STRING_TAG = wellKnownSymbol("toStringTag");
                module3.exports = function(it2, TAG, STATIC) {
                  if (it2 && !has2(it2 = STATIC ? it2 : it2.prototype, TO_STRING_TAG)) {
                    defineProperty2(it2, TO_STRING_TAG, { configurable: true, value: TAG });
                  }
                };
              }
            ),
            /***/
            "d58f": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var aFunction = __webpack_require__("1c0b");
                var toObject = __webpack_require__("7b0b");
                var IndexedObject = __webpack_require__("44ad");
                var toLength = __webpack_require__("50c4");
                var createMethod = function(IS_RIGHT) {
                  return function(that, callbackfn, argumentsLength, memo2) {
                    aFunction(callbackfn);
                    var O2 = toObject(that);
                    var self2 = IndexedObject(O2);
                    var length = toLength(O2.length);
                    var index2 = IS_RIGHT ? length - 1 : 0;
                    var i2 = IS_RIGHT ? -1 : 1;
                    if (argumentsLength < 2)
                      while (true) {
                        if (index2 in self2) {
                          memo2 = self2[index2];
                          index2 += i2;
                          break;
                        }
                        index2 += i2;
                        if (IS_RIGHT ? index2 < 0 : length <= index2) {
                          throw TypeError("Reduce of empty array with no initial value");
                        }
                      }
                    for (; IS_RIGHT ? index2 >= 0 : length > index2; index2 += i2)
                      if (index2 in self2) {
                        memo2 = callbackfn(memo2, self2[index2], index2, O2);
                      }
                    return memo2;
                  };
                };
                module3.exports = {
                  // `Array.prototype.reduce` method
                  // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
                  left: createMethod(false),
                  // `Array.prototype.reduceRight` method
                  // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
                  right: createMethod(true)
                };
              }
            ),
            /***/
            "d784": (
              /***/
              function(module3, exports3, __webpack_require__) {
                __webpack_require__("ac1f");
                var redefine = __webpack_require__("6eeb");
                var fails = __webpack_require__("d039");
                var wellKnownSymbol = __webpack_require__("b622");
                var regexpExec = __webpack_require__("9263");
                var createNonEnumerableProperty = __webpack_require__("9112");
                var SPECIES = wellKnownSymbol("species");
                var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
                  var re2 = /./;
                  re2.exec = function() {
                    var result = [];
                    result.groups = { a: "7" };
                    return result;
                  };
                  return "".replace(re2, "$<a>") !== "7";
                });
                var REPLACE_KEEPS_$0 = function() {
                  return "a".replace(/./, "$0") === "$0";
                }();
                var REPLACE = wellKnownSymbol("replace");
                var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
                  if (/./[REPLACE]) {
                    return /./[REPLACE]("a", "$0") === "";
                  }
                  return false;
                }();
                var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function() {
                  var re2 = /(?:)/;
                  var originalExec = re2.exec;
                  re2.exec = function() {
                    return originalExec.apply(this, arguments);
                  };
                  var result = "ab".split(re2);
                  return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
                });
                module3.exports = function(KEY, length, exec, sham) {
                  var SYMBOL = wellKnownSymbol(KEY);
                  var DELEGATES_TO_SYMBOL = !fails(function() {
                    var O2 = {};
                    O2[SYMBOL] = function() {
                      return 7;
                    };
                    return ""[KEY](O2) != 7;
                  });
                  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function() {
                    var execCalled = false;
                    var re2 = /a/;
                    if (KEY === "split") {
                      re2 = {};
                      re2.constructor = {};
                      re2.constructor[SPECIES] = function() {
                        return re2;
                      };
                      re2.flags = "";
                      re2[SYMBOL] = /./[SYMBOL];
                    }
                    re2.exec = function() {
                      execCalled = true;
                      return null;
                    };
                    re2[SYMBOL]("");
                    return !execCalled;
                  });
                  if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === "replace" && !(REPLACE_SUPPORTS_NAMED_GROUPS && REPLACE_KEEPS_$0 && !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE) || KEY === "split" && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
                    var nativeRegExpMethod = /./[SYMBOL];
                    var methods = exec(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
                      if (regexp.exec === regexpExec) {
                        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
                          return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
                        }
                        return { done: true, value: nativeMethod.call(str, regexp, arg2) };
                      }
                      return { done: false };
                    }, {
                      REPLACE_KEEPS_$0,
                      REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
                    });
                    var stringMethod = methods[0];
                    var regexMethod = methods[1];
                    redefine(String.prototype, KEY, stringMethod);
                    redefine(
                      RegExp.prototype,
                      SYMBOL,
                      length == 2 ? function(string, arg) {
                        return regexMethod.call(string, this, arg);
                      } : function(string) {
                        return regexMethod.call(string, this);
                      }
                    );
                  }
                  if (sham)
                    createNonEnumerableProperty(RegExp.prototype[SYMBOL], "sham", true);
                };
              }
            ),
            /***/
            "d81d": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var $2 = __webpack_require__("23e7");
                var $map = __webpack_require__("b727").map;
                var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
                var arrayMethodUsesToLength = __webpack_require__("ae40");
                var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("map");
                var USES_TO_LENGTH = arrayMethodUsesToLength("map");
                $2({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
                  map: function map(callbackfn) {
                    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
                  }
                });
              }
            ),
            /***/
            "da84": (
              /***/
              function(module3, exports3, __webpack_require__) {
                (function(global2) {
                  var check = function(it2) {
                    return it2 && it2.Math == Math && it2;
                  };
                  module3.exports = // eslint-disable-next-line no-undef
                  check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof global2 == "object" && global2) || // eslint-disable-next-line no-new-func
                  Function("return this")();
                }).call(this, __webpack_require__("c8ba"));
              }
            ),
            /***/
            "dbb4": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var $2 = __webpack_require__("23e7");
                var DESCRIPTORS = __webpack_require__("83ab");
                var ownKeys2 = __webpack_require__("56ef");
                var toIndexedObject = __webpack_require__("fc6a");
                var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
                var createProperty = __webpack_require__("8418");
                $2({ target: "Object", stat: true, sham: !DESCRIPTORS }, {
                  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
                    var O2 = toIndexedObject(object);
                    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
                    var keys = ownKeys2(O2);
                    var result = {};
                    var index2 = 0;
                    var key2, descriptor;
                    while (keys.length > index2) {
                      descriptor = getOwnPropertyDescriptor(O2, key2 = keys[index2++]);
                      if (descriptor !== void 0)
                        createProperty(result, key2, descriptor);
                    }
                    return result;
                  }
                });
              }
            ),
            /***/
            "dbf1": (
              /***/
              function(module3, __webpack_exports__, __webpack_require__) {
                (function(global2) {
                  __webpack_require__.d(__webpack_exports__, "a", function() {
                    return console2;
                  });
                  function getConsole() {
                    if (typeof window !== "undefined") {
                      return window.console;
                    }
                    return global2.console;
                  }
                  var console2 = getConsole();
                }).call(this, __webpack_require__("c8ba"));
              }
            ),
            /***/
            "ddb0": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var global2 = __webpack_require__("da84");
                var DOMIterables = __webpack_require__("fdbc");
                var ArrayIteratorMethods = __webpack_require__("e260");
                var createNonEnumerableProperty = __webpack_require__("9112");
                var wellKnownSymbol = __webpack_require__("b622");
                var ITERATOR = wellKnownSymbol("iterator");
                var TO_STRING_TAG = wellKnownSymbol("toStringTag");
                var ArrayValues = ArrayIteratorMethods.values;
                for (var COLLECTION_NAME in DOMIterables) {
                  var Collection = global2[COLLECTION_NAME];
                  var CollectionPrototype = Collection && Collection.prototype;
                  if (CollectionPrototype) {
                    if (CollectionPrototype[ITERATOR] !== ArrayValues)
                      try {
                        createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
                      } catch (error) {
                        CollectionPrototype[ITERATOR] = ArrayValues;
                      }
                    if (!CollectionPrototype[TO_STRING_TAG]) {
                      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
                    }
                    if (DOMIterables[COLLECTION_NAME])
                      for (var METHOD_NAME in ArrayIteratorMethods) {
                        if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME])
                          try {
                            createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
                          } catch (error) {
                            CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
                          }
                      }
                  }
                }
              }
            ),
            /***/
            "df75": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var internalObjectKeys = __webpack_require__("ca84");
                var enumBugKeys = __webpack_require__("7839");
                module3.exports = Object.keys || function keys(O2) {
                  return internalObjectKeys(O2, enumBugKeys);
                };
              }
            ),
            /***/
            "e01a": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var $2 = __webpack_require__("23e7");
                var DESCRIPTORS = __webpack_require__("83ab");
                var global2 = __webpack_require__("da84");
                var has2 = __webpack_require__("5135");
                var isObject2 = __webpack_require__("861d");
                var defineProperty2 = __webpack_require__("9bf2").f;
                var copyConstructorProperties = __webpack_require__("e893");
                var NativeSymbol = global2.Symbol;
                if (DESCRIPTORS && typeof NativeSymbol == "function" && (!("description" in NativeSymbol.prototype) || // Safari 12 bug
                NativeSymbol().description !== void 0)) {
                  var EmptyStringDescriptionStore = {};
                  var SymbolWrapper = function Symbol2() {
                    var description = arguments.length < 1 || arguments[0] === void 0 ? void 0 : String(arguments[0]);
                    var result = this instanceof SymbolWrapper ? new NativeSymbol(description) : description === void 0 ? NativeSymbol() : NativeSymbol(description);
                    if (description === "")
                      EmptyStringDescriptionStore[result] = true;
                    return result;
                  };
                  copyConstructorProperties(SymbolWrapper, NativeSymbol);
                  var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
                  symbolPrototype.constructor = SymbolWrapper;
                  var symbolToString = symbolPrototype.toString;
                  var native = String(NativeSymbol("test")) == "Symbol(test)";
                  var regexp = /^Symbol\((.*)\)[^)]+$/;
                  defineProperty2(symbolPrototype, "description", {
                    configurable: true,
                    get: function description() {
                      var symbol = isObject2(this) ? this.valueOf() : this;
                      var string = symbolToString.call(symbol);
                      if (has2(EmptyStringDescriptionStore, symbol))
                        return "";
                      var desc = native ? string.slice(7, -1) : string.replace(regexp, "$1");
                      return desc === "" ? void 0 : desc;
                    }
                  });
                  $2({ global: true, forced: true }, {
                    Symbol: SymbolWrapper
                  });
                }
              }
            ),
            /***/
            "e163": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var has2 = __webpack_require__("5135");
                var toObject = __webpack_require__("7b0b");
                var sharedKey = __webpack_require__("f772");
                var CORRECT_PROTOTYPE_GETTER = __webpack_require__("e177");
                var IE_PROTO = sharedKey("IE_PROTO");
                var ObjectPrototype = Object.prototype;
                module3.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function(O2) {
                  O2 = toObject(O2);
                  if (has2(O2, IE_PROTO))
                    return O2[IE_PROTO];
                  if (typeof O2.constructor == "function" && O2 instanceof O2.constructor) {
                    return O2.constructor.prototype;
                  }
                  return O2 instanceof Object ? ObjectPrototype : null;
                };
              }
            ),
            /***/
            "e177": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var fails = __webpack_require__("d039");
                module3.exports = !fails(function() {
                  function F2() {
                  }
                  F2.prototype.constructor = null;
                  return Object.getPrototypeOf(new F2()) !== F2.prototype;
                });
              }
            ),
            /***/
            "e260": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var toIndexedObject = __webpack_require__("fc6a");
                var addToUnscopables = __webpack_require__("44d2");
                var Iterators = __webpack_require__("3f8c");
                var InternalStateModule = __webpack_require__("69f3");
                var defineIterator = __webpack_require__("7dd0");
                var ARRAY_ITERATOR = "Array Iterator";
                var setInternalState = InternalStateModule.set;
                var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
                module3.exports = defineIterator(Array, "Array", function(iterated, kind) {
                  setInternalState(this, {
                    type: ARRAY_ITERATOR,
                    target: toIndexedObject(iterated),
                    // target
                    index: 0,
                    // next index
                    kind
                    // kind
                  });
                }, function() {
                  var state = getInternalState(this);
                  var target = state.target;
                  var kind = state.kind;
                  var index2 = state.index++;
                  if (!target || index2 >= target.length) {
                    state.target = void 0;
                    return { value: void 0, done: true };
                  }
                  if (kind == "keys")
                    return { value: index2, done: false };
                  if (kind == "values")
                    return { value: target[index2], done: false };
                  return { value: [index2, target[index2]], done: false };
                }, "values");
                Iterators.Arguments = Iterators.Array;
                addToUnscopables("keys");
                addToUnscopables("values");
                addToUnscopables("entries");
              }
            ),
            /***/
            "e439": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var $2 = __webpack_require__("23e7");
                var fails = __webpack_require__("d039");
                var toIndexedObject = __webpack_require__("fc6a");
                var nativeGetOwnPropertyDescriptor = __webpack_require__("06cf").f;
                var DESCRIPTORS = __webpack_require__("83ab");
                var FAILS_ON_PRIMITIVES = fails(function() {
                  nativeGetOwnPropertyDescriptor(1);
                });
                var FORCED = !DESCRIPTORS || FAILS_ON_PRIMITIVES;
                $2({ target: "Object", stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
                  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it2, key2) {
                    return nativeGetOwnPropertyDescriptor(toIndexedObject(it2), key2);
                  }
                });
              }
            ),
            /***/
            "e538": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var wellKnownSymbol = __webpack_require__("b622");
                exports3.f = wellKnownSymbol;
              }
            ),
            /***/
            "e893": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var has2 = __webpack_require__("5135");
                var ownKeys2 = __webpack_require__("56ef");
                var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
                var definePropertyModule = __webpack_require__("9bf2");
                module3.exports = function(target, source) {
                  var keys = ownKeys2(source);
                  var defineProperty2 = definePropertyModule.f;
                  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
                  for (var i2 = 0; i2 < keys.length; i2++) {
                    var key2 = keys[i2];
                    if (!has2(target, key2))
                      defineProperty2(target, key2, getOwnPropertyDescriptor(source, key2));
                  }
                };
              }
            ),
            /***/
            "e8b5": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var classof = __webpack_require__("c6b6");
                module3.exports = Array.isArray || function isArray2(arg) {
                  return classof(arg) == "Array";
                };
              }
            ),
            /***/
            "e95a": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var wellKnownSymbol = __webpack_require__("b622");
                var Iterators = __webpack_require__("3f8c");
                var ITERATOR = wellKnownSymbol("iterator");
                var ArrayPrototype = Array.prototype;
                module3.exports = function(it2) {
                  return it2 !== void 0 && (Iterators.Array === it2 || ArrayPrototype[ITERATOR] === it2);
                };
              }
            ),
            /***/
            "f5df": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
                var classofRaw = __webpack_require__("c6b6");
                var wellKnownSymbol = __webpack_require__("b622");
                var TO_STRING_TAG = wellKnownSymbol("toStringTag");
                var CORRECT_ARGUMENTS = classofRaw(/* @__PURE__ */ function() {
                  return arguments;
                }()) == "Arguments";
                var tryGet = function(it2, key2) {
                  try {
                    return it2[key2];
                  } catch (error) {
                  }
                };
                module3.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it2) {
                  var O2, tag, result;
                  return it2 === void 0 ? "Undefined" : it2 === null ? "Null" : typeof (tag = tryGet(O2 = Object(it2), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O2) : (result = classofRaw(O2)) == "Object" && typeof O2.callee == "function" ? "Arguments" : result;
                };
              }
            ),
            /***/
            "f772": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var shared2 = __webpack_require__("5692");
                var uid2 = __webpack_require__("90e3");
                var keys = shared2("keys");
                module3.exports = function(key2) {
                  return keys[key2] || (keys[key2] = uid2(key2));
                };
              }
            ),
            /***/
            "fb15": (
              /***/
              function(module3, __webpack_exports__, __webpack_require__) {
                __webpack_require__.r(__webpack_exports__);
                if (typeof window !== "undefined") {
                  var currentScript = window.document.currentScript;
                  {
                    var getCurrentScript = __webpack_require__("8875");
                    currentScript = getCurrentScript();
                    if (!("currentScript" in document)) {
                      Object.defineProperty(document, "currentScript", { get: getCurrentScript });
                    }
                  }
                  var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/);
                  if (src) {
                    __webpack_require__.p = src[1];
                  }
                }
                __webpack_require__("99af");
                __webpack_require__("4de4");
                __webpack_require__("4160");
                __webpack_require__("c975");
                __webpack_require__("d81d");
                __webpack_require__("a434");
                __webpack_require__("159b");
                __webpack_require__("a4d3");
                __webpack_require__("e439");
                __webpack_require__("dbb4");
                __webpack_require__("b64b");
                function _defineProperty2(obj, key2, value) {
                  if (key2 in obj) {
                    Object.defineProperty(obj, key2, {
                      value,
                      enumerable: true,
                      configurable: true,
                      writable: true
                    });
                  } else {
                    obj[key2] = value;
                  }
                  return obj;
                }
                function ownKeys2(object, enumerableOnly) {
                  var keys = Object.keys(object);
                  if (Object.getOwnPropertySymbols) {
                    var symbols2 = Object.getOwnPropertySymbols(object);
                    if (enumerableOnly)
                      symbols2 = symbols2.filter(function(sym) {
                        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                      });
                    keys.push.apply(keys, symbols2);
                  }
                  return keys;
                }
                function _objectSpread22(target) {
                  for (var i2 = 1; i2 < arguments.length; i2++) {
                    var source = arguments[i2] != null ? arguments[i2] : {};
                    if (i2 % 2) {
                      ownKeys2(Object(source), true).forEach(function(key2) {
                        _defineProperty2(target, key2, source[key2]);
                      });
                    } else if (Object.getOwnPropertyDescriptors) {
                      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                    } else {
                      ownKeys2(Object(source)).forEach(function(key2) {
                        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
                      });
                    }
                  }
                  return target;
                }
                function _arrayWithHoles2(arr) {
                  if (Array.isArray(arr))
                    return arr;
                }
                __webpack_require__("e01a");
                __webpack_require__("d28b");
                __webpack_require__("e260");
                __webpack_require__("d3b7");
                __webpack_require__("3ca3");
                __webpack_require__("ddb0");
                function _iterableToArrayLimit2(arr, i2) {
                  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
                    return;
                  var _arr = [];
                  var _n = true;
                  var _d = false;
                  var _e2 = void 0;
                  try {
                    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
                      _arr.push(_s.value);
                      if (i2 && _arr.length === i2)
                        break;
                    }
                  } catch (err) {
                    _d = true;
                    _e2 = err;
                  } finally {
                    try {
                      if (!_n && _i["return"] != null)
                        _i["return"]();
                    } finally {
                      if (_d)
                        throw _e2;
                    }
                  }
                  return _arr;
                }
                __webpack_require__("a630");
                __webpack_require__("fb6a");
                __webpack_require__("b0c0");
                __webpack_require__("25f0");
                function _arrayLikeToArray2(arr, len) {
                  if (len == null || len > arr.length)
                    len = arr.length;
                  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
                    arr2[i2] = arr[i2];
                  }
                  return arr2;
                }
                function _unsupportedIterableToArray2(o3, minLen) {
                  if (!o3)
                    return;
                  if (typeof o3 === "string")
                    return _arrayLikeToArray2(o3, minLen);
                  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
                  if (n2 === "Object" && o3.constructor)
                    n2 = o3.constructor.name;
                  if (n2 === "Map" || n2 === "Set")
                    return Array.from(o3);
                  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
                    return _arrayLikeToArray2(o3, minLen);
                }
                function _nonIterableRest2() {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                function _slicedToArray2(arr, i2) {
                  return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i2) || _unsupportedIterableToArray2(arr, i2) || _nonIterableRest2();
                }
                function _arrayWithoutHoles2(arr) {
                  if (Array.isArray(arr))
                    return _arrayLikeToArray2(arr);
                }
                function _iterableToArray2(iter) {
                  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
                    return Array.from(iter);
                }
                function _nonIterableSpread2() {
                  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                function _toConsumableArray2(arr) {
                  return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread2();
                }
                var external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_ = __webpack_require__("a352");
                var external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_default = /* @__PURE__ */ __webpack_require__.n(external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_);
                function removeNode(node) {
                  if (node.parentElement !== null) {
                    node.parentElement.removeChild(node);
                  }
                }
                function insertNodeAt(fatherNode, node, position) {
                  var refNode = position === 0 ? fatherNode.children[0] : fatherNode.children[position - 1].nextSibling;
                  fatherNode.insertBefore(node, refNode);
                }
                var console2 = __webpack_require__("dbf1");
                __webpack_require__("13d5");
                __webpack_require__("4fad");
                __webpack_require__("ac1f");
                __webpack_require__("5319");
                function cached(fn2) {
                  var cache2 = /* @__PURE__ */ Object.create(null);
                  return function cachedFn(str) {
                    var hit = cache2[str];
                    return hit || (cache2[str] = fn2(str));
                  };
                }
                var regex2 = /-(\w)/g;
                var camelize2 = cached(function(str) {
                  return str.replace(regex2, function(_2, c2) {
                    return c2.toUpperCase();
                  });
                });
                __webpack_require__("5db7");
                __webpack_require__("73d9");
                var manageAndEmit = ["Start", "Add", "Remove", "Update", "End"];
                var emit2 = ["Choose", "Unchoose", "Sort", "Filter", "Clone"];
                var manage = ["Move"];
                var eventHandlerNames = [manage, manageAndEmit, emit2].flatMap(function(events2) {
                  return events2;
                }).map(function(evt) {
                  return "on".concat(evt);
                });
                var events = {
                  manage,
                  manageAndEmit,
                  emit: emit2
                };
                function isReadOnly(eventName) {
                  return eventHandlerNames.indexOf(eventName) !== -1;
                }
                __webpack_require__("caad");
                __webpack_require__("2ca0");
                var tags = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "label", "legend", "li", "link", "main", "map", "mark", "math", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rb", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "slot", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr"];
                function isHtmlTag(name) {
                  return tags.includes(name);
                }
                function isTransition(name) {
                  return ["transition-group", "TransitionGroup"].includes(name);
                }
                function isHtmlAttribute(value) {
                  return ["id", "class", "role", "style"].includes(value) || value.startsWith("data-") || value.startsWith("aria-") || value.startsWith("on");
                }
                function project(entries) {
                  return entries.reduce(function(res, _ref) {
                    var _ref2 = _slicedToArray2(_ref, 2), key2 = _ref2[0], value = _ref2[1];
                    res[key2] = value;
                    return res;
                  }, {});
                }
                function getComponentAttributes(_ref3) {
                  var $attrs = _ref3.$attrs, _ref3$componentData = _ref3.componentData, componentData = _ref3$componentData === void 0 ? {} : _ref3$componentData;
                  var attributes = project(Object.entries($attrs).filter(function(_ref4) {
                    var _ref5 = _slicedToArray2(_ref4, 2), key2 = _ref5[0];
                    _ref5[1];
                    return isHtmlAttribute(key2);
                  }));
                  return _objectSpread22(_objectSpread22({}, attributes), componentData);
                }
                function createSortableOption(_ref6) {
                  var $attrs = _ref6.$attrs, callBackBuilder = _ref6.callBackBuilder;
                  var options = project(getValidSortableEntries($attrs));
                  Object.entries(callBackBuilder).forEach(function(_ref7) {
                    var _ref8 = _slicedToArray2(_ref7, 2), eventType = _ref8[0], eventBuilder = _ref8[1];
                    events[eventType].forEach(function(event2) {
                      options["on".concat(event2)] = eventBuilder(event2);
                    });
                  });
                  var draggable2 = "[data-draggable]".concat(options.draggable || "");
                  return _objectSpread22(_objectSpread22({}, options), {}, {
                    draggable: draggable2
                  });
                }
                function getValidSortableEntries(value) {
                  return Object.entries(value).filter(function(_ref9) {
                    var _ref10 = _slicedToArray2(_ref9, 2), key2 = _ref10[0];
                    _ref10[1];
                    return !isHtmlAttribute(key2);
                  }).map(function(_ref11) {
                    var _ref12 = _slicedToArray2(_ref11, 2), key2 = _ref12[0], value2 = _ref12[1];
                    return [camelize2(key2), value2];
                  }).filter(function(_ref13) {
                    var _ref14 = _slicedToArray2(_ref13, 2), key2 = _ref14[0];
                    _ref14[1];
                    return !isReadOnly(key2);
                  });
                }
                __webpack_require__("c740");
                function _classCallCheck2(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _defineProperties2(target, props2) {
                  for (var i2 = 0; i2 < props2.length; i2++) {
                    var descriptor = props2[i2];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                function _createClass2(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties2(Constructor.prototype, protoProps);
                  return Constructor;
                }
                var getHtmlElementFromNode = function getHtmlElementFromNode2(_ref) {
                  var el = _ref.el;
                  return el;
                };
                var addContext = function addContext2(domElement, context) {
                  return domElement.__draggable_context = context;
                };
                var getContext2 = function getContext3(domElement) {
                  return domElement.__draggable_context;
                };
                var componentStructure_ComponentStructure = /* @__PURE__ */ function() {
                  function ComponentStructure(_ref2) {
                    var _ref2$nodes = _ref2.nodes, header = _ref2$nodes.header, defaultNodes = _ref2$nodes.default, footer = _ref2$nodes.footer, root2 = _ref2.root, realList = _ref2.realList;
                    _classCallCheck2(this, ComponentStructure);
                    this.defaultNodes = defaultNodes;
                    this.children = [].concat(_toConsumableArray2(header), _toConsumableArray2(defaultNodes), _toConsumableArray2(footer));
                    this.externalComponent = root2.externalComponent;
                    this.rootTransition = root2.transition;
                    this.tag = root2.tag;
                    this.realList = realList;
                  }
                  _createClass2(ComponentStructure, [{
                    key: "render",
                    value: function render2(h2, attributes) {
                      var tag = this.tag, children = this.children, _isRootComponent = this._isRootComponent;
                      var option = !_isRootComponent ? children : {
                        default: function _default() {
                          return children;
                        }
                      };
                      return h2(tag, attributes, option);
                    }
                  }, {
                    key: "updated",
                    value: function updated() {
                      var defaultNodes = this.defaultNodes, realList = this.realList;
                      defaultNodes.forEach(function(node, index2) {
                        addContext(getHtmlElementFromNode(node), {
                          element: realList[index2],
                          index: index2
                        });
                      });
                    }
                  }, {
                    key: "getUnderlyingVm",
                    value: function getUnderlyingVm(domElement) {
                      return getContext2(domElement);
                    }
                  }, {
                    key: "getVmIndexFromDomIndex",
                    value: function getVmIndexFromDomIndex(domIndex, element) {
                      var defaultNodes = this.defaultNodes;
                      var length = defaultNodes.length;
                      var domChildren = element.children;
                      var domElement = domChildren.item(domIndex);
                      if (domElement === null) {
                        return length;
                      }
                      var context = getContext2(domElement);
                      if (context) {
                        return context.index;
                      }
                      if (length === 0) {
                        return 0;
                      }
                      var firstDomListElement = getHtmlElementFromNode(defaultNodes[0]);
                      var indexFirstDomListElement = _toConsumableArray2(domChildren).findIndex(function(element2) {
                        return element2 === firstDomListElement;
                      });
                      return domIndex < indexFirstDomListElement ? 0 : length;
                    }
                  }, {
                    key: "_isRootComponent",
                    get: function get2() {
                      return this.externalComponent || this.rootTransition;
                    }
                  }]);
                  return ComponentStructure;
                }();
                var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__("8bbf");
                function getSlot(slots, key2) {
                  var slotValue = slots[key2];
                  return slotValue ? slotValue() : [];
                }
                function computeNodes(_ref) {
                  var $slots = _ref.$slots, realList = _ref.realList, getKey2 = _ref.getKey;
                  var normalizedList = realList || [];
                  var _map = ["header", "footer"].map(function(name) {
                    return getSlot($slots, name);
                  }), _map2 = _slicedToArray2(_map, 2), header = _map2[0], footer = _map2[1];
                  var item = $slots.item;
                  if (!item) {
                    throw new Error("draggable element must have an item slot");
                  }
                  var defaultNodes = normalizedList.flatMap(function(element, index2) {
                    return item({
                      element,
                      index: index2
                    }).map(function(node) {
                      node.key = getKey2(element);
                      node.props = _objectSpread22(_objectSpread22({}, node.props || {}), {}, {
                        "data-draggable": true
                      });
                      return node;
                    });
                  });
                  if (defaultNodes.length !== normalizedList.length) {
                    throw new Error("Item slot must have only one child");
                  }
                  return {
                    header,
                    footer,
                    default: defaultNodes
                  };
                }
                function getRootInformation(tag) {
                  var transition = isTransition(tag);
                  var externalComponent = !isHtmlTag(tag) && !transition;
                  return {
                    transition,
                    externalComponent,
                    tag: externalComponent ? Object(external_commonjs_vue_commonjs2_vue_root_Vue_["resolveComponent"])(tag) : transition ? external_commonjs_vue_commonjs2_vue_root_Vue_["TransitionGroup"] : tag
                  };
                }
                function computeComponentStructure(_ref2) {
                  var $slots = _ref2.$slots, tag = _ref2.tag, realList = _ref2.realList, getKey2 = _ref2.getKey;
                  var nodes = computeNodes({
                    $slots,
                    realList,
                    getKey: getKey2
                  });
                  var root2 = getRootInformation(tag);
                  return new componentStructure_ComponentStructure({
                    nodes,
                    root: root2,
                    realList
                  });
                }
                function _emit(evtName, evtData) {
                  var _this = this;
                  Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function() {
                    return _this.$emit(evtName.toLowerCase(), evtData);
                  });
                }
                function _manage(evtName) {
                  var _this2 = this;
                  return function(evtData, originalElement) {
                    if (_this2.realList !== null) {
                      return _this2["onDrag".concat(evtName)](evtData, originalElement);
                    }
                  };
                }
                function _manageAndEmit(evtName) {
                  var _this3 = this;
                  var delegateCallBack = _manage.call(this, evtName);
                  return function(evtData, originalElement) {
                    delegateCallBack.call(_this3, evtData, originalElement);
                    _emit.call(_this3, evtName, evtData);
                  };
                }
                var draggingElement = null;
                var props = {
                  list: {
                    type: Array,
                    required: false,
                    default: null
                  },
                  modelValue: {
                    type: Array,
                    required: false,
                    default: null
                  },
                  itemKey: {
                    type: [String, Function],
                    required: true
                  },
                  clone: {
                    type: Function,
                    default: function _default(original) {
                      return original;
                    }
                  },
                  tag: {
                    type: String,
                    default: "div"
                  },
                  move: {
                    type: Function,
                    default: null
                  },
                  componentData: {
                    type: Object,
                    required: false,
                    default: null
                  }
                };
                var emits = ["update:modelValue", "change"].concat(_toConsumableArray2([].concat(_toConsumableArray2(events.manageAndEmit), _toConsumableArray2(events.emit)).map(function(evt) {
                  return evt.toLowerCase();
                })));
                var draggableComponent = Object(external_commonjs_vue_commonjs2_vue_root_Vue_["defineComponent"])({
                  name: "draggable",
                  inheritAttrs: false,
                  props,
                  emits,
                  data: function data() {
                    return {
                      error: false
                    };
                  },
                  render: function render2() {
                    try {
                      this.error = false;
                      var $slots = this.$slots, $attrs = this.$attrs, tag = this.tag, componentData = this.componentData, realList = this.realList, getKey2 = this.getKey;
                      var componentStructure = computeComponentStructure({
                        $slots,
                        tag,
                        realList,
                        getKey: getKey2
                      });
                      this.componentStructure = componentStructure;
                      var attributes = getComponentAttributes({
                        $attrs,
                        componentData
                      });
                      return componentStructure.render(external_commonjs_vue_commonjs2_vue_root_Vue_["h"], attributes);
                    } catch (err) {
                      this.error = true;
                      return Object(external_commonjs_vue_commonjs2_vue_root_Vue_["h"])("pre", {
                        style: {
                          color: "red"
                        }
                      }, err.stack);
                    }
                  },
                  created: function created() {
                    if (this.list !== null && this.modelValue !== null) {
                      console2[
                        "a"
                        /* console */
                      ].error("modelValue and list props are mutually exclusive! Please set one or another.");
                    }
                  },
                  mounted: function mounted() {
                    var _this4 = this;
                    if (this.error) {
                      return;
                    }
                    var $attrs = this.$attrs, $el = this.$el, componentStructure = this.componentStructure;
                    componentStructure.updated();
                    var sortableOptions = createSortableOption({
                      $attrs,
                      callBackBuilder: {
                        manageAndEmit: function manageAndEmit2(event2) {
                          return _manageAndEmit.call(_this4, event2);
                        },
                        emit: function emit3(event2) {
                          return _emit.bind(_this4, event2);
                        },
                        manage: function manage2(event2) {
                          return _manage.call(_this4, event2);
                        }
                      }
                    });
                    var targetDomElement = $el.nodeType === 1 ? $el : $el.parentElement;
                    this._sortable = new external_commonjs_sortablejs_commonjs2_sortablejs_amd_sortablejs_root_Sortable_default.a(targetDomElement, sortableOptions);
                    this.targetDomElement = targetDomElement;
                    targetDomElement.__draggable_component__ = this;
                  },
                  updated: function updated() {
                    this.componentStructure.updated();
                  },
                  beforeUnmount: function beforeUnmount() {
                    if (this._sortable !== void 0)
                      this._sortable.destroy();
                  },
                  computed: {
                    realList: function realList() {
                      var list = this.list;
                      return list ? list : this.modelValue;
                    },
                    getKey: function getKey2() {
                      var itemKey = this.itemKey;
                      if (typeof itemKey === "function") {
                        return itemKey;
                      }
                      return function(element) {
                        return element[itemKey];
                      };
                    }
                  },
                  watch: {
                    $attrs: {
                      handler: function handler(newOptionValue) {
                        var _sortable = this._sortable;
                        if (!_sortable)
                          return;
                        getValidSortableEntries(newOptionValue).forEach(function(_ref) {
                          var _ref2 = _slicedToArray2(_ref, 2), key2 = _ref2[0], value = _ref2[1];
                          _sortable.option(key2, value);
                        });
                      },
                      deep: true
                    }
                  },
                  methods: {
                    getUnderlyingVm: function getUnderlyingVm(domElement) {
                      return this.componentStructure.getUnderlyingVm(domElement) || null;
                    },
                    getUnderlyingPotencialDraggableComponent: function getUnderlyingPotencialDraggableComponent(htmElement) {
                      return htmElement.__draggable_component__;
                    },
                    emitChanges: function emitChanges(evt) {
                      var _this5 = this;
                      Object(external_commonjs_vue_commonjs2_vue_root_Vue_["nextTick"])(function() {
                        return _this5.$emit("change", evt);
                      });
                    },
                    alterList: function alterList(onList) {
                      if (this.list) {
                        onList(this.list);
                        return;
                      }
                      var newList = _toConsumableArray2(this.modelValue);
                      onList(newList);
                      this.$emit("update:modelValue", newList);
                    },
                    spliceList: function spliceList() {
                      var _arguments = arguments;
                      var spliceList2 = function spliceList3(list) {
                        return list.splice.apply(list, _toConsumableArray2(_arguments));
                      };
                      this.alterList(spliceList2);
                    },
                    updatePosition: function updatePosition(oldIndex2, newIndex2) {
                      var updatePosition2 = function updatePosition3(list) {
                        return list.splice(newIndex2, 0, list.splice(oldIndex2, 1)[0]);
                      };
                      this.alterList(updatePosition2);
                    },
                    getRelatedContextFromMoveEvent: function getRelatedContextFromMoveEvent(_ref3) {
                      var to2 = _ref3.to, related = _ref3.related;
                      var component = this.getUnderlyingPotencialDraggableComponent(to2);
                      if (!component) {
                        return {
                          component
                        };
                      }
                      var list = component.realList;
                      var context = {
                        list,
                        component
                      };
                      if (to2 !== related && list) {
                        var destination = component.getUnderlyingVm(related) || {};
                        return _objectSpread22(_objectSpread22({}, destination), context);
                      }
                      return context;
                    },
                    getVmIndexFromDomIndex: function getVmIndexFromDomIndex(domIndex) {
                      return this.componentStructure.getVmIndexFromDomIndex(domIndex, this.targetDomElement);
                    },
                    onDragStart: function onDragStart(evt) {
                      this.context = this.getUnderlyingVm(evt.item);
                      evt.item._underlying_vm_ = this.clone(this.context.element);
                      draggingElement = evt.item;
                    },
                    onDragAdd: function onDragAdd(evt) {
                      var element = evt.item._underlying_vm_;
                      if (element === void 0) {
                        return;
                      }
                      removeNode(evt.item);
                      var newIndex2 = this.getVmIndexFromDomIndex(evt.newIndex);
                      this.spliceList(newIndex2, 0, element);
                      var added = {
                        element,
                        newIndex: newIndex2
                      };
                      this.emitChanges({
                        added
                      });
                    },
                    onDragRemove: function onDragRemove(evt) {
                      insertNodeAt(this.$el, evt.item, evt.oldIndex);
                      if (evt.pullMode === "clone") {
                        removeNode(evt.clone);
                        return;
                      }
                      var _this$context = this.context, oldIndex2 = _this$context.index, element = _this$context.element;
                      this.spliceList(oldIndex2, 1);
                      var removed = {
                        element,
                        oldIndex: oldIndex2
                      };
                      this.emitChanges({
                        removed
                      });
                    },
                    onDragUpdate: function onDragUpdate(evt) {
                      removeNode(evt.item);
                      insertNodeAt(evt.from, evt.item, evt.oldIndex);
                      var oldIndex2 = this.context.index;
                      var newIndex2 = this.getVmIndexFromDomIndex(evt.newIndex);
                      this.updatePosition(oldIndex2, newIndex2);
                      var moved2 = {
                        element: this.context.element,
                        oldIndex: oldIndex2,
                        newIndex: newIndex2
                      };
                      this.emitChanges({
                        moved: moved2
                      });
                    },
                    computeFutureIndex: function computeFutureIndex(relatedContext, evt) {
                      if (!relatedContext.element) {
                        return 0;
                      }
                      var domChildren = _toConsumableArray2(evt.to.children).filter(function(el) {
                        return el.style["display"] !== "none";
                      });
                      var currentDomIndex = domChildren.indexOf(evt.related);
                      var currentIndex = relatedContext.component.getVmIndexFromDomIndex(currentDomIndex);
                      var draggedInList = domChildren.indexOf(draggingElement) !== -1;
                      return draggedInList || !evt.willInsertAfter ? currentIndex : currentIndex + 1;
                    },
                    onDragMove: function onDragMove(evt, originalEvent) {
                      var move = this.move, realList = this.realList;
                      if (!move || !realList) {
                        return true;
                      }
                      var relatedContext = this.getRelatedContextFromMoveEvent(evt);
                      var futureIndex = this.computeFutureIndex(relatedContext, evt);
                      var draggedContext = _objectSpread22(_objectSpread22({}, this.context), {}, {
                        futureIndex
                      });
                      var sendEvent = _objectSpread22(_objectSpread22({}, evt), {}, {
                        relatedContext,
                        draggedContext
                      });
                      return move(sendEvent, originalEvent);
                    },
                    onDragEnd: function onDragEnd() {
                      draggingElement = null;
                    }
                  }
                });
                var vuedraggable = draggableComponent;
                __webpack_exports__["default"] = vuedraggable;
              }
            ),
            /***/
            "fb6a": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var $2 = __webpack_require__("23e7");
                var isObject2 = __webpack_require__("861d");
                var isArray2 = __webpack_require__("e8b5");
                var toAbsoluteIndex = __webpack_require__("23cb");
                var toLength = __webpack_require__("50c4");
                var toIndexedObject = __webpack_require__("fc6a");
                var createProperty = __webpack_require__("8418");
                var wellKnownSymbol = __webpack_require__("b622");
                var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
                var arrayMethodUsesToLength = __webpack_require__("ae40");
                var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("slice");
                var USES_TO_LENGTH = arrayMethodUsesToLength("slice", { ACCESSORS: true, 0: 0, 1: 2 });
                var SPECIES = wellKnownSymbol("species");
                var nativeSlice = [].slice;
                var max2 = Math.max;
                $2({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
                  slice: function slice(start2, end2) {
                    var O2 = toIndexedObject(this);
                    var length = toLength(O2.length);
                    var k2 = toAbsoluteIndex(start2, length);
                    var fin = toAbsoluteIndex(end2 === void 0 ? length : end2, length);
                    var Constructor, result, n2;
                    if (isArray2(O2)) {
                      Constructor = O2.constructor;
                      if (typeof Constructor == "function" && (Constructor === Array || isArray2(Constructor.prototype))) {
                        Constructor = void 0;
                      } else if (isObject2(Constructor)) {
                        Constructor = Constructor[SPECIES];
                        if (Constructor === null)
                          Constructor = void 0;
                      }
                      if (Constructor === Array || Constructor === void 0) {
                        return nativeSlice.call(O2, k2, fin);
                      }
                    }
                    result = new (Constructor === void 0 ? Array : Constructor)(max2(fin - k2, 0));
                    for (n2 = 0; k2 < fin; k2++, n2++)
                      if (k2 in O2)
                        createProperty(result, n2, O2[k2]);
                    result.length = n2;
                    return result;
                  }
                });
              }
            ),
            /***/
            "fc6a": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var IndexedObject = __webpack_require__("44ad");
                var requireObjectCoercible = __webpack_require__("1d80");
                module3.exports = function(it2) {
                  return IndexedObject(requireObjectCoercible(it2));
                };
              }
            ),
            /***/
            "fdbc": (
              /***/
              function(module3, exports3) {
                module3.exports = {
                  CSSRuleList: 0,
                  CSSStyleDeclaration: 0,
                  CSSValueList: 0,
                  ClientRectList: 0,
                  DOMRectList: 0,
                  DOMStringList: 0,
                  DOMTokenList: 1,
                  DataTransferItemList: 0,
                  FileList: 0,
                  HTMLAllCollection: 0,
                  HTMLCollection: 0,
                  HTMLFormElement: 0,
                  HTMLSelectElement: 0,
                  MediaList: 0,
                  MimeTypeArray: 0,
                  NamedNodeMap: 0,
                  NodeList: 1,
                  PaintRequestList: 0,
                  Plugin: 0,
                  PluginArray: 0,
                  SVGLengthList: 0,
                  SVGNumberList: 0,
                  SVGPathSegList: 0,
                  SVGPointList: 0,
                  SVGStringList: 0,
                  SVGTransformList: 0,
                  SourceBufferList: 0,
                  StyleSheetList: 0,
                  TextTrackCueList: 0,
                  TextTrackList: 0,
                  TouchList: 0
                };
              }
            ),
            /***/
            "fdbf": (
              /***/
              function(module3, exports3, __webpack_require__) {
                var NATIVE_SYMBOL = __webpack_require__("4930");
                module3.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
              }
            )
            /******/
          })["default"]
        );
      });
    })(vuedraggable_umd);
    var vuedraggable_umdExports = vuedraggable_umd.exports;
    const draggable = /* @__PURE__ */ getDefaultExportFromCjs(vuedraggable_umdExports);
    const _sfc_main$i = {
      data() {
        return {};
      },
      components: {
        AccordionList: _sfc_main$1$1,
        AccordionItem: _sfc_main$j,
        draggable
      },
      computed: {
        // other computed properties
        // ...
        // gives access to this.counterStore and this.userStore
        ...mapStores(useProfileStore, usePreferenceStore),
        // // gives read access to this.count and this.double
        ...mapState(useProfileStore, ["profilesLoaded", "activeProfile", "rtLookup", "activeComponent"]),
        ...mapState(usePreferenceStore, ["styleDefault"]),
        ...mapWritableState(useProfileStore, ["activeComponent"])
      },
      methods: {
        returnTemplateTypes: function(templates) {
          let titles = [];
          for (let t2 of templates) {
            if (this.rtLookup[t2] && this.rtLookup[t2].resourceLabel) {
              titles.push(this.rtLookup[t2].resourceLabel);
            }
          }
          return titles;
        }
      },
      mounted() {
      }
    };
    const __injectCSSVars__$9 = () => {
      useCssVars((_ctx) => ({
        "30b8593d": _ctx.preferenceStore.returnValue("--n-edit-main-splitpane-properties-font-size"),
        "06f7a2c0": _ctx.preferenceStore.returnValue("--c-edit-main-splitpane-properties-font-color"),
        "751584a8": _ctx.preferenceStore.returnValue("--n-edit-main-splitpane-properties-font-size", true) + 0.25 + "em",
        "2f2698ea": _ctx.preferenceStore.returnValue("--c-edit-main-splitpane-properties-font-family"),
        "89c97bae": _ctx.preferenceStore.returnValue("--n-edit-main-splitpane-properties-font-size", true) / 2 + "em",
        "96609790": _ctx.preferenceStore.returnValue("--c-edit-main-splitpane-properties-highlight-background-color"),
        "6a1f750e": _ctx.preferenceStore.returnValue("--c-edit-main-splitpane-properties-empty-indicator-color"),
        "26d6d328": _ctx.preferenceStore.returnValue("--n-edit-main-splitpane-properties-font-size", true) / 1 + "em",
        "4487a6c7": _ctx.preferenceStore.returnValue("--n-edit-main-splitpane-properties-font-size", true) - 0.15 + "em",
        "4c1eaf96": _ctx.preferenceStore.returnValue("--c-general-icon-item-color")
      }));
    };
    const __setup__$9 = _sfc_main$i.setup;
    _sfc_main$i.setup = __setup__$9 ? (props, ctx) => {
      __injectCSSVars__$9();
      return __setup__$9(props, ctx);
    } : __injectCSSVars__$9;
    const _withScopeId$9 = (n2) => (pushScopeId("data-v-6259947c"), n2 = n2(), popScopeId(), n2);
    const _hoisted_1$f = {
      class: /* @__PURE__ */ normalizeClass({ "container-type-icon": true })
    };
    const _hoisted_2$b = {
      key: 0,
      width: "1.5em",
      height: "1.1em",
      version: "1.1",
      xmlns: "http://www.w3.org/2000/svg"
    };
    const _hoisted_3$9 = ["fill"];
    const _hoisted_4$9 = ["fill"];
    const _hoisted_5$9 = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createBaseVNode("path", { d: "m5 50l45-45 45 45-45 45z" }, null, -1));
    const _hoisted_6$9 = [
      _hoisted_5$9
    ];
    const _hoisted_7$9 = {
      key: 2,
      viewBox: "0 -32 50 72",
      version: "1.1",
      xmlns: "http://www.w3.org/2000/svg"
    };
    const _hoisted_8$8 = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createBaseVNode("rect", {
      width: "40px",
      height: "40px",
      class: "item-icon"
    }, null, -1));
    const _hoisted_9$8 = [
      _hoisted_8$8
    ];
    const _hoisted_10$7 = {
      key: 3,
      version: "1.1",
      viewBox: "0 -20 100 100",
      xmlns: "http://www.w3.org/2000/svg"
    };
    const _hoisted_11$7 = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createBaseVNode("path", {
      fill: "royalblue",
      d: "m62.113 24.66 1.9023-15.238 18.875 32.691-7.5469 20.004 15.238 1.9023-32.691 18.875-20.004-7.5469-1.9023 15.238-18.875-32.691 7.5469-20.004-15.238-1.9023 32.691-18.875zm-17.684 15.695-4.0781 15.215 15.215 4.0781 4.0781-15.215z",
      "fill-rule": "evenodd"
    }, null, -1));
    const _hoisted_12$7 = [
      _hoisted_11$7
    ];
    const _hoisted_13$7 = {
      key: 4,
      class: "sidebar-header-text"
    };
    const _hoisted_14$7 = {
      key: 5,
      class: "sidebar-header-text"
    };
    const _hoisted_15$7 = {
      key: 6,
      class: "sidebar-header-text"
    };
    const _hoisted_16$7 = {
      key: 7,
      class: "sidebar-header-text"
    };
    const _hoisted_17$6 = {
      class: "sidebar-property-ul",
      role: "list"
    };
    const _hoisted_18$6 = ["onClick"];
    const _hoisted_19$6 = ["onClick"];
    const _hoisted_20$6 = {
      key: 0,
      class: "sidebar-property-ul sidebar-property-ul-sub-ul"
    };
    const _hoisted_21$6 = {
      tabindex: "-1",
      href: "#",
      class: "sidebar-property-ul-alink sidebar-property-ul-alink-sublink"
    };
    const _hoisted_22$6 = { key: 0 };
    const _hoisted_23$5 = {
      key: 0,
      width: "1.5em",
      height: "1.1em",
      version: "1.1",
      xmlns: "http://www.w3.org/2000/svg"
    };
    const _hoisted_24$4 = ["fill"];
    const _hoisted_25$4 = ["fill"];
    const _hoisted_26$4 = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createBaseVNode("path", { d: "m5 50l45-45 45 45-45 45z" }, null, -1));
    const _hoisted_27$4 = [
      _hoisted_26$4
    ];
    const _hoisted_28$4 = {
      key: 2,
      viewBox: "0 -32 50 72",
      version: "1.1",
      xmlns: "http://www.w3.org/2000/svg"
    };
    const _hoisted_29$3 = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createBaseVNode("rect", {
      width: "40px",
      height: "40px",
      class: "item-icon"
    }, null, -1));
    const _hoisted_30$3 = [
      _hoisted_29$3
    ];
    const _hoisted_31$3 = {
      key: 3,
      version: "1.1",
      viewBox: "0 -20 100 100",
      xmlns: "http://www.w3.org/2000/svg"
    };
    const _hoisted_32$3 = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createBaseVNode("path", {
      fill: "royalblue",
      d: "m62.113 24.66 1.9023-15.238 18.875 32.691-7.5469 20.004 15.238 1.9023-32.691 18.875-20.004-7.5469-1.9023 15.238-18.875-32.691 7.5469-20.004-15.238-1.9023 32.691-18.875zm-17.684 15.695-4.0781 15.215 15.215 4.0781 4.0781-15.215z",
      "fill-rule": "evenodd"
    }, null, -1));
    const _hoisted_33$3 = [
      _hoisted_32$3
    ];
    const _hoisted_34$3 = {
      key: 4,
      class: "sidebar-header-text"
    };
    const _hoisted_35$3 = {
      key: 5,
      class: "sidebar-header-text"
    };
    const _hoisted_36$3 = {
      key: 6,
      class: "sidebar-header-text"
    };
    const _hoisted_37$3 = {
      key: 7,
      class: "sidebar-header-text"
    };
    const _hoisted_38$3 = {
      class: "sidebar-property-ul",
      role: "list"
    };
    const _hoisted_39$3 = ["onClick"];
    const _hoisted_40$3 = ["onClick"];
    const _hoisted_41$3 = {
      key: 0,
      class: "sidebar-property-ul sidebar-property-ul-sub-ul"
    };
    const _hoisted_42$3 = {
      tabindex: "-1",
      href: "#",
      class: "sidebar-property-ul-alink sidebar-property-ul-alink-sublink"
    };
    function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_draggable = resolveComponent("draggable");
      const _component_AccordionItem = resolveComponent("AccordionItem");
      const _component_AccordionList = resolveComponent("AccordionList");
      return openBlock(), createElementBlock(Fragment, null, [
        _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-properties-accordion") == true ? (openBlock(), createBlock(_component_AccordionList, {
          key: 0,
          "open-multiple-items": false
        }, {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.activeProfile.rtOrder, (profileName) => {
              return openBlock(), createElementBlock(Fragment, { key: profileName }, [
                _ctx.activeProfile.rt[profileName].noData != true ? (openBlock(), createBlock(_component_AccordionItem, {
                  key: 0,
                  style: { "color": "white" },
                  id: "accordion_" + profileName,
                  "default-closed": ""
                }, {
                  summary: withCtx(() => [
                    createBaseVNode("div", _hoisted_1$f, [
                      profileName.split(":").slice(-1)[0] == "Work" ? (openBlock(), createElementBlock("svg", _hoisted_2$b, [
                        createBaseVNode("circle", {
                          fill: _ctx.preferenceStore.returnValue("--c-general-icon-work-color"),
                          cx: "0.55em",
                          cy: "0.6em",
                          r: "0.45em"
                        }, null, 8, _hoisted_3$9)
                      ])) : createCommentVNode("", true),
                      profileName.includes("Instance") ? (openBlock(), createElementBlock("svg", {
                        key: 1,
                        fill: _ctx.preferenceStore.returnValue("--c-general-icon-instance-color"),
                        style: { "margin-right": "7px" },
                        width: "18px",
                        height: "18px",
                        version: "1.1",
                        viewBox: "0 0 100 100",
                        xmlns: "http://www.w3.org/2000/svg"
                      }, _hoisted_6$9, 8, _hoisted_4$9)) : createCommentVNode("", true),
                      profileName.includes(":Item") ? (openBlock(), createElementBlock("svg", _hoisted_7$9, _hoisted_9$8)) : createCommentVNode("", true),
                      profileName.endsWith(":Hub") ? (openBlock(), createElementBlock("svg", _hoisted_10$7, _hoisted_12$7)) : createCommentVNode("", true),
                      profileName.split(":").slice(-1)[0] == "Work" ? (openBlock(), createElementBlock("span", _hoisted_13$7, toDisplayString$2(_ctx.$t("message.wordWork")), 1)) : createCommentVNode("", true),
                      profileName.split(":").slice(-1)[0] == "Instance" ? (openBlock(), createElementBlock("span", _hoisted_14$7, toDisplayString$2(_ctx.$t("message.wordInstance")), 1)) : createCommentVNode("", true),
                      profileName.split(":").slice(-1)[0] == "Item" ? (openBlock(), createElementBlock("span", _hoisted_15$7, toDisplayString$2(_ctx.$t("message.wordItem")), 1)) : createCommentVNode("", true),
                      profileName.split(":").slice(-1)[0] == "Hub" ? (openBlock(), createElementBlock("span", _hoisted_16$7, toDisplayString$2(_ctx.$t("message.wordHub")), 1)) : createCommentVNode("", true)
                    ])
                  ]),
                  default: withCtx(() => [
                    createBaseVNode("ul", _hoisted_17$6, [
                      createVNode(_component_draggable, {
                        modelValue: _ctx.activeProfile.rt[profileName].ptOrder,
                        "onUpdate:modelValue": ($event) => _ctx.activeProfile.rt[profileName].ptOrder = $event,
                        group: "people",
                        onStart: _cache[0] || (_cache[0] = ($event) => _ctx.drag = true),
                        onEnd: _cache[1] || (_cache[1] = ($event) => _ctx.drag = false),
                        "item-key": "id"
                      }, {
                        item: withCtx(({ element }) => [
                          createBaseVNode("li", {
                            onClick: withModifiers(($event) => _ctx.activeComponent = _ctx.activeProfile.rt[profileName].pt[element], ["stop"]),
                            class: "sidebar-property-li sidebar-property-li-empty"
                          }, [
                            createBaseVNode("a", {
                              href: "#",
                              onClick: withModifiers(($event) => _ctx.activeComponent = _ctx.activeProfile.rt[profileName].pt[element], ["stop"]),
                              class: "sidebar-property-ul-alink"
                            }, [
                              _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-properties-number-labels") ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                                createTextVNode(toDisplayString$2(_ctx.activeProfile.rt[profileName].ptOrder.indexOf(element)), 1)
                              ], 64)) : createCommentVNode("", true),
                              createTextVNode(" " + toDisplayString$2(_ctx.activeProfile.rt[profileName].pt[element].propertyLabel), 1)
                            ], 8, _hoisted_19$6),
                            _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-properties-show-types") ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                              _ctx.activeProfile.rt[profileName].pt[element].valueConstraint.valueTemplateRefs.length > 1 ? (openBlock(), createElementBlock("ul", _hoisted_20$6, [
                                (openBlock(true), createElementBlock(Fragment, null, renderList($options.returnTemplateTypes(_ctx.activeProfile.rt[profileName].pt[element].valueConstraint.valueTemplateRefs), (t2) => {
                                  return openBlock(), createElementBlock("li", {
                                    class: "sidebar-property-li sidebar-property-li-sub-li",
                                    key: t2
                                  }, [
                                    createBaseVNode("a", _hoisted_21$6, toDisplayString$2(t2), 1)
                                  ]);
                                }), 128))
                              ])) : createCommentVNode("", true)
                            ], 64)) : createCommentVNode("", true)
                          ], 8, _hoisted_18$6)
                        ]),
                        _: 2
                      }, 1032, ["modelValue", "onUpdate:modelValue"])
                    ])
                  ]),
                  _: 2
                }, 1032, ["id"])) : createCommentVNode("", true)
              ], 64);
            }), 128))
          ]),
          _: 1
        })) : createCommentVNode("", true),
        _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-properties-accordion") == false ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(_ctx.activeProfile.rtOrder, (profileName) => {
          return openBlock(), createElementBlock("div", {
            class: "sidebar",
            key: profileName
          }, [
            _ctx.activeProfile.rt[profileName].noData != true ? (openBlock(), createElementBlock("div", _hoisted_22$6, [
              createBaseVNode("div", {
                class: normalizeClass({ "container-type-icon": true, "sidebar-spacer": profileName.split(":").slice(-1)[0] == "Instance" || profileName.split(":").slice(-1)[0] == "Item" })
              }, [
                profileName.split(":").slice(-1)[0] == "Work" ? (openBlock(), createElementBlock("svg", _hoisted_23$5, [
                  createBaseVNode("circle", {
                    fill: _ctx.preferenceStore.returnValue("--c-general-icon-work-color"),
                    cx: "0.55em",
                    cy: "0.6em",
                    r: "0.45em"
                  }, null, 8, _hoisted_24$4)
                ])) : createCommentVNode("", true),
                profileName.includes("Instance") ? (openBlock(), createElementBlock("svg", {
                  key: 1,
                  fill: _ctx.preferenceStore.returnValue("--c-general-icon-instance-color"),
                  width: "20px",
                  height: "20px",
                  version: "1.1",
                  viewBox: "0 0 100 100",
                  xmlns: "http://www.w3.org/2000/svg"
                }, _hoisted_27$4, 8, _hoisted_25$4)) : createCommentVNode("", true),
                profileName.includes(":Item") ? (openBlock(), createElementBlock("svg", _hoisted_28$4, _hoisted_30$3)) : createCommentVNode("", true),
                profileName.endsWith(":Hub") ? (openBlock(), createElementBlock("svg", _hoisted_31$3, _hoisted_33$3)) : createCommentVNode("", true),
                profileName.split(":").slice(-1)[0] == "Work" ? (openBlock(), createElementBlock("span", _hoisted_34$3, toDisplayString$2(_ctx.$t("message.wordWork")), 1)) : createCommentVNode("", true),
                profileName.split(":").slice(-1)[0] == "Instance" ? (openBlock(), createElementBlock("span", _hoisted_35$3, toDisplayString$2(_ctx.$t("message.wordInstance")), 1)) : createCommentVNode("", true),
                profileName.split(":").slice(-1)[0] == "Item" ? (openBlock(), createElementBlock("span", _hoisted_36$3, toDisplayString$2(_ctx.$t("message.wordItem")), 1)) : createCommentVNode("", true),
                profileName.split(":").slice(-1)[0] == "Hub" ? (openBlock(), createElementBlock("span", _hoisted_37$3, toDisplayString$2(_ctx.$t("message.wordHub")), 1)) : createCommentVNode("", true)
              ], 2),
              createBaseVNode("ul", _hoisted_38$3, [
                createVNode(_component_draggable, {
                  modelValue: _ctx.activeProfile.rt[profileName].ptOrder,
                  "onUpdate:modelValue": ($event) => _ctx.activeProfile.rt[profileName].ptOrder = $event,
                  group: "people",
                  onStart: _cache[2] || (_cache[2] = ($event) => _ctx.drag = true),
                  onEnd: _cache[3] || (_cache[3] = ($event) => _ctx.drag = false),
                  "item-key": "id"
                }, {
                  item: withCtx(({ element }) => [
                    createBaseVNode("li", {
                      onClick: withModifiers(($event) => _ctx.activeComponent = _ctx.activeProfile.rt[profileName].pt[element], ["stop"]),
                      class: "sidebar-property-li sidebar-property-li-empty"
                    }, [
                      createBaseVNode("a", {
                        href: "#",
                        onClick: withModifiers(($event) => _ctx.activeComponent = _ctx.activeProfile.rt[profileName].pt[element], ["stop"]),
                        class: "sidebar-property-ul-alink"
                      }, [
                        _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-properties-number-labels") ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                          createTextVNode(toDisplayString$2(_ctx.activeProfile.rt[profileName].ptOrder.indexOf(element)), 1)
                        ], 64)) : createCommentVNode("", true),
                        createTextVNode(" " + toDisplayString$2(_ctx.activeProfile.rt[profileName].pt[element].propertyLabel), 1)
                      ], 8, _hoisted_40$3),
                      _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-properties-show-types") ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                        _ctx.activeProfile.rt[profileName].pt[element].valueConstraint.valueTemplateRefs.length > 1 ? (openBlock(), createElementBlock("ul", _hoisted_41$3, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList($options.returnTemplateTypes(_ctx.activeProfile.rt[profileName].pt[element].valueConstraint.valueTemplateRefs), (t2) => {
                            return openBlock(), createElementBlock("li", {
                              class: "sidebar-property-li sidebar-property-li-sub-li",
                              key: t2
                            }, [
                              createBaseVNode("a", _hoisted_42$3, toDisplayString$2(t2), 1)
                            ]);
                          }), 128))
                        ])) : createCommentVNode("", true)
                      ], 64)) : createCommentVNode("", true)
                    ], 8, _hoisted_39$3)
                  ]),
                  _: 2
                }, 1032, ["modelValue", "onUpdate:modelValue"])
              ])
            ])) : createCommentVNode("", true)
          ]);
        }), 128)) : createCommentVNode("", true)
      ], 64);
    }
    const Properties = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["render", _sfc_render$h], ["__scopeId", "data-v-6259947c"]]);
    const _sfc_main$h = {
      name: "InlineModeAddField",
      components: {},
      props: {
        guid: String
      },
      data: function() {
        return {
          aaaaa: "",
          filter: ""
        };
      },
      created: function() {
      },
      computed: {
        ...mapStores(useProfileStore),
        possibleFields() {
          return this.profileStore.returnPossibleFieldsInComponent(this.guid);
        }
      },
      methods: {
        codeInput() {
          console.log(this.$refs.dropdown.style.left);
          console.log(this.$refs.input.getBoundingClientRect());
          const rect = this.$refs.input.getBoundingClientRect();
          this.$refs.dropdown.style.left = rect.left + "px";
          this.$refs.dropdown.style.display = "block";
        },
        blur() {
          window.setTimeout(() => {
            this.$refs.dropdown.style.display = "none";
          }, 250);
        },
        addToDisplay(p2) {
          this.profileStore.setInlineDisplay(this.guid, p2.label);
        }
      }
    };
    const _hoisted_1$e = {
      ref: "dropdown",
      class: "dropdown"
    };
    const _hoisted_2$a = ["onClick"];
    function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
      return $options.possibleFields.length > 1 ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        withDirectives(createBaseVNode("input", {
          ref: "input",
          onInput: _cache[0] || (_cache[0] = (...args) => $options.codeInput && $options.codeInput(...args)),
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.filter = $event),
          onFocus: _cache[2] || (_cache[2] = (...args) => $options.codeInput && $options.codeInput(...args)),
          onBlur: _cache[3] || (_cache[3] = (...args) => $options.blur && $options.blur(...args))
        }, null, 544), [
          [vModelText, _ctx.filter]
        ]),
        createBaseVNode("div", _hoisted_1$e, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($options.possibleFields, (pf) => {
            return openBlock(), createElementBlock(Fragment, null, [
              _ctx.filter != "" && pf.code.toLowerCase().startsWith(_ctx.filter.toLowerCase()) || _ctx.filter.trim() == "" ? (openBlock(), createElementBlock("div", {
                key: 0,
                onClick: ($event) => $options.addToDisplay(pf),
                class: "dropdown-item"
              }, toDisplayString$2(pf.code) + " - " + toDisplayString$2(pf.label), 9, _hoisted_2$a)) : createCommentVNode("", true)
            ], 64);
          }), 256))
        ], 512)
      ], 64)) : createCommentVNode("", true);
    }
    const InlineModeAddField = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$g], ["__scopeId", "data-v-df540489"]]);
    const _sfc_main$g = {
      components: { InlineModeAddField },
      props: {
        instanceMode: Boolean
      },
      data() {
        return {
          userActiveResourceName: null,
          hideProps: [
            "http://id.loc.gov/ontologies/bibframe/hasInstance",
            "http://id.loc.gov/ontologies/bibframe/instanceOf",
            "http://id.loc.gov/ontologies/bibframe/hasItem"
          ]
        };
      },
      computed: {
        // other computed properties
        // ...
        ...mapStores(usePreferenceStore),
        ...mapStores(useProfileStore),
        ...mapState(usePreferenceStore, ["styleDefault"]),
        // gives read access to this.count and this.double
        // ...mapState(usePreferenceStore, ['profilesLoaded']),
        ...mapState(useProfileStore, ["profilesLoaded", "activeProfile", "activeComponent"]),
        activeResourceName() {
          if (this.userActiveResourceName === null) {
            if (this.activeProfile && this.activeProfile.rtOrder) {
              return this.activeProfile.rtOrder[0];
            }
          } else {
            return this.userActiveResourceName;
          }
        }
      },
      methods: {
        inlineRowButtonMouseEnter: function(event2) {
          console.log(event2);
        },
        addProperty: function(event2, profile) {
          console.log(profile, event2.target.value);
          this.profileStore.setPropertyVisible(profile, event2.target.value);
          event2.target.value = "home";
        }
      },
      watch: {
        activeComponent(newVal) {
          console.log(newVal);
          console.log(document.getElementById("edit_" + newVal.id));
          this.$nextTick(() => {
            window.setTimeout(() => {
              document.getElementById(`edit_${newVal.parentId}_${newVal.id}`).scrollIntoView({ behavior: "smooth", block: "start" });
              console.log(document.getElementById(`edit_${newVal.parentId}_${newVal.id}`));
              document.getElementById(`edit_${newVal.parentId}_${newVal.id}`).querySelector("input,textarea").focus();
              for (let el of document.getElementById(`edit_${newVal.parentId}_${newVal.id}`).querySelectorAll("input,textarea")) {
                el.style.transition = "background 500ms";
                el.style.background = "yellow";
              }
              window.setTimeout(() => {
                for (let el of document.getElementById(`edit_${newVal.parentId}_${newVal.id}`).querySelectorAll("input,textarea")) {
                  el.style.background = "transparent";
                }
              }, 500);
            }, 10);
          });
        }
      },
      mounted: function() {
      }
    };
    const __injectCSSVars__$8 = () => {
      useCssVars((_ctx) => ({
        "e3964738": _ctx.preferenceStore.returnValue("--c-edit-main-splitpane-edit-background-color-work"),
        "308c9868": _ctx.preferenceStore.returnValue("--c-edit-main-splitpane-edit-background-color-instance")
      }));
    };
    const __setup__$8 = _sfc_main$g.setup;
    _sfc_main$g.setup = __setup__$8 ? (props, ctx) => {
      __injectCSSVars__$8();
      return __setup__$8(props, ctx);
    } : __injectCSSVars__$8;
    const _withScopeId$8 = (n2) => (pushScopeId("data-v-6041af01"), n2 = n2(), popScopeId(), n2);
    const _hoisted_1$d = {
      key: 0,
      style: { "text-align": "right" }
    };
    const _hoisted_2$9 = ["onClick"];
    const _hoisted_3$8 = { class: "component-label" };
    const _hoisted_4$8 = {
      key: 0,
      class: "component-label"
    };
    const _hoisted_5$8 = {
      key: 0,
      class: "inline-mode-resource-color-work"
    };
    const _hoisted_6$8 = {
      key: 1,
      class: "inline-mode-resource-color-instance"
    };
    const _hoisted_7$8 = ["onChange"];
    const _hoisted_8$7 = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createBaseVNode("option", {
      value: "home",
      selected: ""
    }, "Add Property", -1));
    const _hoisted_9$7 = ["value"];
    function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Main = resolveComponent("Main");
      const _component_InlineModeAddField = resolveComponent("InlineModeAddField");
      return openBlock(), createElementBlock(Fragment, null, [
        _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-switch-between-resource-button") === true ? (openBlock(), createElementBlock("div", _hoisted_1$d, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(this.activeProfile.rtOrder, (profileName) => {
            return openBlock(), createElementBlock("button", {
              onClick: ($event) => $data.userActiveResourceName = profileName,
              class: normalizeClass({ "activeResourceButton": $options.activeResourceName === profileName })
            }, toDisplayString$2(profileName.split(":").slice(-1)[0]), 11, _hoisted_2$9);
          }), 256))
        ])) : createCommentVNode("", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList(this.activeProfile.rtOrder, (profileName) => {
          return openBlock(), createElementBlock("div", {
            key: profileName,
            class: normalizeClass({ "edit-panel-work": profileName.split(":").slice(-1)[0] == "Work", "edit-panel-scroll-x-parent": _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-scroll-x") })
          }, [
            $props.instanceMode == true && profileName.indexOf(":Instance") > -1 ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-switch-between-resource-button") === false || _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-switch-between-resource-button") === true && profileName == $options.activeResourceName ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.activeProfile.rt[profileName].ptOrder, (profileCompoent, idx) => {
                return openBlock(), createElementBlock("div", { key: profileCompoent }, [
                  _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-adhoc-mode") === true && _ctx.activeProfile.rt[profileName].pt[profileCompoent].canBeHidden === false || _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-adhoc-mode") === false ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    createBaseVNode("div", _hoisted_3$8, toDisplayString$2(_ctx.activeProfile.rt[profileName].pt[profileCompoent].propertyLabel), 1),
                    createVNode(_component_Main, {
                      guid: _ctx.activeProfile.rt[profileName].pt[profileCompoent]["@guid"],
                      level: 0,
                      id: _ctx.activeProfile.rt[profileName].pt[profileCompoent].id,
                      parentId: _ctx.activeProfile.rt[profileName].pt[profileCompoent].parentId
                    }, null, 8, ["guid", "id", "parentId"])
                  ], 64)) : createCommentVNode("", true)
                ]);
              }), 128)) : createCommentVNode("", true)
            ], 64)) : createCommentVNode("", true),
            $props.instanceMode == false ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(_ctx.activeProfile.rt[profileName].ptOrder, (profileCompoent, idx) => {
              return openBlock(), createElementBlock(Fragment, { key: profileCompoent }, [
                !$data.hideProps.includes(_ctx.activeProfile.rt[profileName].pt[profileCompoent].propertyURI) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-adhoc-mode") === true && _ctx.activeProfile.rt[profileName].pt[profileCompoent].canBeHidden === false || _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-adhoc-mode") === false ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-switch-between-resource-button") === false || _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-switch-between-resource-button") === true && profileName == $options.activeResourceName ? (openBlock(), createElementBlock("div", {
                      key: 0,
                      class: normalizeClass({ "inline-mode": _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-inline-mode"), "edit-panel-scroll-x-child": _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-scroll-x") })
                    }, [
                      _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-shortcode-display-mode") == false && _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-inline-mode") == false ? (openBlock(), createElementBlock("div", _hoisted_4$8, toDisplayString$2(_ctx.activeProfile.rt[profileName].pt[profileCompoent].propertyLabel), 1)) : createCommentVNode("", true),
                      _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-inline-mode") ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                        profileName.split(":").slice(-1)[0] == "Work" ? (openBlock(), createElementBlock("div", _hoisted_5$8, " ")) : createCommentVNode("", true),
                        profileName.indexOf(":Instance") > -1 ? (openBlock(), createElementBlock("div", _hoisted_6$8, " ")) : createCommentVNode("", true),
                        createBaseVNode("button", {
                          onMouseenter: _cache[0] || (_cache[0] = (...args) => $options.inlineRowButtonMouseEnter && $options.inlineRowButtonMouseEnter(...args)),
                          class: normalizeClass({ "inline-mode-mian-button": true, "inline-mode-mian-button-has-ref": _ctx.profileStore.ptHasRefComponent(_ctx.activeProfile.rt[profileName].pt[profileCompoent]) })
                        }, null, 34)
                      ], 64)) : createCommentVNode("", true),
                      createVNode(_component_Main, {
                        guid: _ctx.activeProfile.rt[profileName].pt[profileCompoent]["@guid"],
                        level: 0,
                        id: _ctx.activeProfile.rt[profileName].pt[profileCompoent].id,
                        parentId: _ctx.activeProfile.rt[profileName].pt[profileCompoent].parentId
                      }, null, 8, ["guid", "id", "parentId"]),
                      _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-inline-mode") ? (openBlock(), createBlock(_component_InlineModeAddField, {
                        key: 2,
                        guid: _ctx.activeProfile.rt[profileName].pt[profileCompoent]["@guid"]
                      }, null, 8, ["guid"])) : createCommentVNode("", true)
                    ], 2)) : createCommentVNode("", true)
                  ], 64)) : createCommentVNode("", true)
                ], 64)) : createCommentVNode("", true)
              ], 64);
            }), 128)) : createCommentVNode("", true),
            _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-adhoc-mode") === true ? (openBlock(), createElementBlock("select", {
              key: 2,
              style: { "margin-left": "40px", "margin-bottom": "0px" },
              onChange: ($event) => $options.addProperty($event, profileName)
            }, [
              _hoisted_8$7,
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.activeProfile.rt[profileName].ptOrder, (profileCompoent, idx) => {
                return openBlock(), createElementBlock(Fragment, null, [
                  _ctx.activeProfile.rt[profileName].pt[profileCompoent].canBeHidden == true ? (openBlock(), createElementBlock("option", {
                    key: 0,
                    value: profileCompoent
                  }, toDisplayString$2(_ctx.activeProfile.rt[profileName].pt[profileCompoent].propertyLabel), 9, _hoisted_9$7)) : createCommentVNode("", true)
                ], 64);
              }), 256))
            ], 40, _hoisted_7$8)) : createCommentVNode("", true)
          ], 2);
        }), 128))
      ], 64);
    }
    const EditPanel = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$f], ["__scopeId", "data-v-6041af01"]]);
    const _sfc_main$f = {
      data() {
        return {};
      },
      computed: {
        // other computed properties
        // ...
        // gives access to this.counterStore and this.userStore
        ...mapStores(useProfileStore, usePreferenceStore),
        // // gives read access to this.count and this.double
        ...mapState(useProfileStore, ["profilesLoaded", "activeProfile", "rtLookup", "activeComponent"]),
        ...mapState(usePreferenceStore, ["styleDefault"]),
        ...mapWritableState(useProfileStore, ["activeComponent"])
      },
      methods: {
        returnTemplateTypes: function(templates) {
          let titles = [];
          for (let t2 of templates) {
            if (this.rtLookup[t2] && this.rtLookup[t2].resourceLabel) {
              titles.push(this.rtLookup[t2].resourceLabel);
            }
          }
          return titles;
        },
        buildDisplayObjects: function(userValue) {
          let ignore = [
            "http://id.loc.gov/ontologies/bflc/aap-normalized",
            "http://www.loc.gov/mads/rdf/v1#isMemberOfMADSScheme"
          ];
          let results = [];
          for (let k1 in userValue) {
            if (!k1.startsWith("@")) {
              for (let value of userValue[k1]) {
                let textAdded = [];
                let toAdd = {
                  uri: null,
                  label: [],
                  children: []
                };
                for (let k2 in value) {
                  if (k2 == "@id") {
                    toAdd.uri = value["@id"];
                  } else if (k2.startsWith("@"))
                    ;
                  else if (ignore.includes(k2))
                    ;
                  else {
                    if (Array.isArray(value[k2])) {
                      for (let value2 of value[k2]) {
                        if (value2[k2]) {
                          if (!textAdded.includes(value2[k2])) {
                            textAdded.push(value2[k2]);
                            toAdd.label.push(value2[k2]);
                          }
                        } else if (value2["@id"]) {
                          toAdd.uri = value2["@id"];
                          for (let labelUri of ["http://www.w3.org/2000/01/rdf-schema#label", "http://www.loc.gov/mads/rdf/v1#authoritativeLabel", "http://id.loc.gov/ontologies/bibframe/code"]) {
                            if (value2[labelUri]) {
                              for (let vl of value2[labelUri]) {
                                toAdd.label.push(vl[labelUri]);
                              }
                            }
                          }
                          results.push(toAdd);
                          toAdd = {
                            uri: null,
                            label: [],
                            children: []
                          };
                        }
                      }
                    }
                  }
                }
                if (toAdd.uri !== null || toAdd.label.length > 0) {
                  results.push(toAdd);
                }
              }
            }
          }
          return results;
        }
      },
      mounted() {
      }
    };
    const __injectCSSVars__$7 = () => {
      useCssVars((_ctx) => ({
        "191b16fa": _ctx.preferenceStore.returnValue("--n-edit-main-splitpane-opac-font-size"),
        "6ddb5122": _ctx.preferenceStore.returnValue("--n-edit-main-splitpane-opac-font-size", true) + 0.25 + "em",
        "1ee6d191": _ctx.preferenceStore.returnValue("--c-edit-main-splitpane-opac-font-family"),
        "da29904c": _ctx.preferenceStore.returnValue("--c-edit-main-splitpane-opac-font-color"),
        "383b57ef": _ctx.preferenceStore.returnValue("--n-edit-main-splitpane-opac-font-size", true) / 2 + "em",
        "46fded1c": _ctx.preferenceStore.returnValue("--c-edit-main-splitpane-opac-highlight-background-color"),
        "cb2f78d8": _ctx.preferenceStore.returnValue("--c-edit-main-splitpane-opac-empty-indicator-color"),
        "b8122e24": _ctx.preferenceStore.returnValue("--n-edit-main-splitpane-opac-font-size", true) / 1 + "em",
        "3d4d7341": _ctx.preferenceStore.returnValue("--n-edit-main-splitpane-opac-font-size", true) - 0.15 + "em",
        "5b8503bf": _ctx.preferenceStore.returnValue("--c-general-icon-item-color")
      }));
    };
    const __setup__$7 = _sfc_main$f.setup;
    _sfc_main$f.setup = __setup__$7 ? (props, ctx) => {
      __injectCSSVars__$7();
      return __setup__$7(props, ctx);
    } : __injectCSSVars__$7;
    const _withScopeId$7 = (n2) => (pushScopeId("data-v-26179d73"), n2 = n2(), popScopeId(), n2);
    const _hoisted_1$c = { key: 0 };
    const _hoisted_2$8 = {
      key: 0,
      width: "1.5em",
      height: "1.1em",
      version: "1.1",
      xmlns: "http://www.w3.org/2000/svg"
    };
    const _hoisted_3$7 = ["fill"];
    const _hoisted_4$7 = ["fill"];
    const _hoisted_5$7 = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createBaseVNode("path", { d: "m5 50l45-45 45 45-45 45z" }, null, -1));
    const _hoisted_6$7 = [
      _hoisted_5$7
    ];
    const _hoisted_7$7 = {
      key: 2,
      viewBox: "0 -32 50 72",
      version: "1.1",
      xmlns: "http://www.w3.org/2000/svg"
    };
    const _hoisted_8$6 = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createBaseVNode("rect", {
      width: "40px",
      height: "40px",
      class: "item-icon"
    }, null, -1));
    const _hoisted_9$6 = [
      _hoisted_8$6
    ];
    const _hoisted_10$6 = {
      key: 3,
      version: "1.1",
      viewBox: "0 -20 100 100",
      xmlns: "http://www.w3.org/2000/svg"
    };
    const _hoisted_11$6 = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createBaseVNode("path", {
      fill: "royalblue",
      d: "m62.113 24.66 1.9023-15.238 18.875 32.691-7.5469 20.004 15.238 1.9023-32.691 18.875-20.004-7.5469-1.9023 15.238-18.875-32.691 7.5469-20.004-15.238-1.9023 32.691-18.875zm-17.684 15.695-4.0781 15.215 15.215 4.0781 4.0781-15.215z",
      "fill-rule": "evenodd"
    }, null, -1));
    const _hoisted_12$6 = [
      _hoisted_11$6
    ];
    const _hoisted_13$6 = {
      key: 4,
      class: "sidebar-header-text"
    };
    const _hoisted_14$6 = {
      key: 5,
      class: "sidebar-header-text"
    };
    const _hoisted_15$6 = {
      key: 6,
      class: "sidebar-header-text"
    };
    const _hoisted_16$6 = {
      key: 7,
      class: "sidebar-header-text"
    };
    const _hoisted_17$5 = {
      class: "sidebar-opac-ul",
      role: "list"
    };
    const _hoisted_18$5 = ["onClick"];
    const _hoisted_19$5 = ["onClick"];
    const _hoisted_20$5 = {
      style: {},
      class: "sidebar-opac-li-value"
    };
    const _hoisted_21$5 = ["href"];
    const _hoisted_22$5 = { class: "sidebar-opac-li-value-text" };
    const _hoisted_23$4 = { class: "sidebar-opac-li-value-text" };
    function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.activeProfile.rtOrder, (profileName) => {
        return openBlock(), createElementBlock("div", {
          class: "sidebar",
          key: profileName
        }, [
          _ctx.activeProfile.rt[profileName].noData != true ? (openBlock(), createElementBlock("div", _hoisted_1$c, [
            createBaseVNode("div", {
              class: normalizeClass({ "container-type-icon": true, "sidebar-spacer": profileName.split(":").slice(-1)[0] == "Instance" || profileName.split(":").slice(-1)[0] == "Item" })
            }, [
              profileName.split(":").slice(-1)[0] == "Work" ? (openBlock(), createElementBlock("svg", _hoisted_2$8, [
                createBaseVNode("circle", {
                  fill: _ctx.preferenceStore.returnValue("--c-general-icon-work-color"),
                  cx: "0.55em",
                  cy: "0.6em",
                  r: "0.45em"
                }, null, 8, _hoisted_3$7)
              ])) : createCommentVNode("", true),
              profileName.includes("Instance") ? (openBlock(), createElementBlock("svg", {
                key: 1,
                fill: _ctx.preferenceStore.returnValue("--c-general-icon-instance-color"),
                width: "20px",
                height: "20px",
                version: "1.1",
                viewBox: "0 0 100 100",
                xmlns: "http://www.w3.org/2000/svg"
              }, _hoisted_6$7, 8, _hoisted_4$7)) : createCommentVNode("", true),
              profileName.includes(":Item") ? (openBlock(), createElementBlock("svg", _hoisted_7$7, _hoisted_9$6)) : createCommentVNode("", true),
              profileName.endsWith(":Hub") ? (openBlock(), createElementBlock("svg", _hoisted_10$6, _hoisted_12$6)) : createCommentVNode("", true),
              profileName.split(":").slice(-1)[0] == "Work" ? (openBlock(), createElementBlock("span", _hoisted_13$6, toDisplayString$2(_ctx.$t("message.wordWork")), 1)) : createCommentVNode("", true),
              profileName.split(":").slice(-1)[0] == "Instance" ? (openBlock(), createElementBlock("span", _hoisted_14$6, toDisplayString$2(_ctx.$t("message.wordInstance")), 1)) : createCommentVNode("", true),
              profileName.split(":").slice(-1)[0] == "Item" ? (openBlock(), createElementBlock("span", _hoisted_15$6, toDisplayString$2(_ctx.$t("message.wordItem")), 1)) : createCommentVNode("", true),
              profileName.split(":").slice(-1)[0] == "Hub" ? (openBlock(), createElementBlock("span", _hoisted_16$6, toDisplayString$2(_ctx.$t("message.wordHub")), 1)) : createCommentVNode("", true)
            ], 2)
          ])) : createCommentVNode("", true),
          createBaseVNode("ul", _hoisted_17$5, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.activeProfile.rt[profileName].ptOrder, (profileCompoent, idx) => {
              return openBlock(), createElementBlock(Fragment, { key: profileCompoent }, [
                _ctx.activeProfile.rt[profileName].pt[profileCompoent].hasData ? (openBlock(), createElementBlock("li", {
                  key: 0,
                  onClick: withModifiers(($event) => _ctx.activeComponent = _ctx.activeProfile.rt[profileName].pt[profileCompoent], ["stop"]),
                  class: "sidebar-opac-li sidebar-opac-li-empty"
                }, [
                  createBaseVNode("a", {
                    style: { "font-size": "0.95em" },
                    href: "#",
                    onClick: withModifiers(($event) => _ctx.activeComponent = _ctx.activeProfile.rt[profileName].pt[profileCompoent], ["stop"]),
                    class: "sidebar-property-ul-alink"
                  }, toDisplayString$2(_ctx.activeProfile.rt[profileName].pt[profileCompoent].propertyLabel), 9, _hoisted_19$5),
                  (openBlock(true), createElementBlock(Fragment, null, renderList($options.buildDisplayObjects(_ctx.activeProfile.rt[profileName].pt[profileCompoent].userValue), (value) => {
                    return openBlock(), createElementBlock("div", _hoisted_20$5, [
                      value.uri !== null ? (openBlock(), createElementBlock("a", {
                        key: 0,
                        href: value.uri,
                        target: "_blank"
                      }, [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(value.label, (l2) => {
                          return openBlock(), createElementBlock("div", _hoisted_22$5, toDisplayString$2(l2), 1);
                        }), 256))
                      ], 8, _hoisted_21$5)) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(value.label, (l2) => {
                        return openBlock(), createElementBlock("div", _hoisted_23$4, toDisplayString$2(l2), 1);
                      }), 256))
                    ]);
                  }), 256))
                ], 8, _hoisted_18$5)) : createCommentVNode("", true)
              ], 64);
            }), 128))
          ])
        ]);
      }), 128);
    }
    const Opac = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$e], ["__scopeId", "data-v-26179d73"]]);
    var t = { d: (e2, n2) => {
      for (var o3 in n2)
        t.o(n2, o3) && !t.o(e2, o3) && Object.defineProperty(e2, o3, { enumerable: true, get: n2[o3] });
    }, o: (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2) }, n$2 = {};
    function o$1(e2, t2) {
      (null == t2 || t2 > e2.length) && (t2 = e2.length);
      for (var n2 = 0, o3 = new Array(t2); n2 < t2; n2++)
        o3[n2] = e2[n2];
      return o3;
    }
    function r$1(e2, t2) {
      if (e2) {
        if ("string" == typeof e2)
          return o$1(e2, t2);
        var n2 = Object.prototype.toString.call(e2).slice(8, -1);
        return "Object" === n2 && e2.constructor && (n2 = e2.constructor.name), "Map" === n2 || "Set" === n2 ? Array.from(e2) : "Arguments" === n2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2) ? o$1(e2, t2) : void 0;
      }
    }
    function a$1(e2) {
      return function(e3) {
        if (Array.isArray(e3))
          return o$1(e3);
      }(e2) || function(e3) {
        if ("undefined" != typeof Symbol && null != e3[Symbol.iterator] || null != e3["@@iterator"])
          return Array.from(e3);
      }(e2) || r$1(e2) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }();
    }
    function l$1(e2, t2, n2) {
      return t2 in e2 ? Object.defineProperty(e2, t2, { value: n2, enumerable: true, configurable: true, writable: true }) : e2[t2] = n2, e2;
    }
    t.d(n$2, { Z: () => j });
    const c$2 = (s$1 = { computed: () => computed, createTextVNode: () => createTextVNode, createVNode: () => createVNode, defineComponent: () => defineComponent, reactive: () => reactive, ref: () => ref, watch: () => watch$1, watchEffect: () => watchEffect }, p$1 = {}, t.d(p$1, s$1), p$1), i$1 = (0, c$2.defineComponent)({ props: { data: { required: true, type: String }, onClick: Function }, render: function() {
      var e2 = this.data, t2 = this.onClick;
      return (0, c$2.createVNode)("span", { class: "vjs-tree-brackets", onClick: t2 }, [e2]);
    } }), u$2 = (0, c$2.defineComponent)({ emits: ["change", "update:modelValue"], props: { checked: { type: Boolean, default: false }, isMultiple: Boolean, onChange: Function }, setup: function(e2, t2) {
      var n2 = t2.emit;
      return { uiType: (0, c$2.computed)(function() {
        return e2.isMultiple ? "checkbox" : "radio";
      }), model: (0, c$2.computed)({ get: function() {
        return e2.checked;
      }, set: function(e3) {
        return n2("update:modelValue", e3);
      } }) };
    }, render: function() {
      var e2 = this.uiType, t2 = this.model, n2 = this.$emit;
      return (0, c$2.createVNode)("label", { class: ["vjs-check-controller", t2 ? "is-checked" : ""], onClick: function(e3) {
        return e3.stopPropagation();
      } }, [(0, c$2.createVNode)("span", { class: "vjs-check-controller-inner is-".concat(e2) }, null), (0, c$2.createVNode)("input", { checked: t2, class: "vjs-check-controller-original is-".concat(e2), type: e2, onChange: function() {
        return n2("change", t2);
      } }, null)]);
    } }), d$2 = (0, c$2.defineComponent)({ props: { nodeType: { required: true, type: String }, onClick: Function }, render: function() {
      var e2 = this.nodeType, t2 = this.onClick, n2 = "objectStart" === e2 || "arrayStart" === e2;
      return n2 || "objectCollapsed" === e2 || "arrayCollapsed" === e2 ? (0, c$2.createVNode)("span", { class: "vjs-carets vjs-carets-".concat(n2 ? "open" : "close"), onClick: t2 }, [(0, c$2.createVNode)("svg", { viewBox: "0 0 1024 1024", focusable: "false", "data-icon": "caret-down", width: "1em", height: "1em", fill: "currentColor", "aria-hidden": "true" }, [(0, c$2.createVNode)("path", { d: "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" }, null)])]) : null;
    } });
    var s$1, p$1;
    function h$1(e2) {
      return h$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
        return typeof e3;
      } : function(e3) {
        return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
      }, h$1(e2);
    }
    function f$1(e2) {
      return Object.prototype.toString.call(e2).slice(8, -1).toLowerCase();
    }
    function y$2(e2) {
      var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "root", n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, o3 = arguments.length > 3 ? arguments[3] : void 0, r2 = o3 || {}, a2 = r2.key, l2 = r2.index, c2 = r2.type, i2 = void 0 === c2 ? "content" : c2, u2 = r2.showComma, d2 = void 0 !== u2 && u2, s2 = r2.length, p2 = void 0 === s2 ? 1 : s2, h2 = f$1(e2);
      if ("array" === h2) {
        var g2 = v$1(e2.map(function(e3, o4, r3) {
          return y$2(e3, "".concat(t2, "[").concat(o4, "]"), n2 + 1, { index: o4, showComma: o4 !== r3.length - 1, length: p2, type: i2 });
        }));
        return [y$2("[", t2, n2, { showComma: false, key: a2, length: e2.length, type: "arrayStart" })[0]].concat(g2, y$2("]", t2, n2, { showComma: d2, length: e2.length, type: "arrayEnd" })[0]);
      }
      if ("object" === h2) {
        var b2 = Object.keys(e2), m2 = v$1(b2.map(function(o4, r3, a3) {
          return y$2(e2[o4], /^[a-zA-Z_]\w*$/.test(o4) ? "".concat(t2, ".").concat(o4) : "".concat(t2, '["').concat(o4, '"]'), n2 + 1, { key: o4, showComma: r3 !== a3.length - 1, length: p2, type: i2 });
        }));
        return [y$2("{", t2, n2, { showComma: false, key: a2, index: l2, length: b2.length, type: "objectStart" })[0]].concat(m2, y$2("}", t2, n2, { showComma: d2, length: b2.length, type: "objectEnd" })[0]);
      }
      return [{ content: e2, level: n2, key: a2, index: l2, path: t2, showComma: d2, length: p2, type: i2 }];
    }
    function v$1(e2) {
      if ("function" == typeof Array.prototype.flat)
        return e2.flat();
      for (var t2 = a$1(e2), n2 = []; t2.length; ) {
        var o3 = t2.shift();
        Array.isArray(o3) ? t2.unshift.apply(t2, a$1(o3)) : n2.push(o3);
      }
      return n2;
    }
    function g$2(e2) {
      var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new WeakMap();
      if (null == e2)
        return e2;
      if (e2 instanceof Date)
        return new Date(e2);
      if (e2 instanceof RegExp)
        return new RegExp(e2);
      if ("object" !== h$1(e2))
        return e2;
      if (t2.get(e2))
        return t2.get(e2);
      if (Array.isArray(e2)) {
        var n2 = e2.map(function(e3) {
          return g$2(e3, t2);
        });
        return t2.set(e2, n2), n2;
      }
      var o3 = {};
      for (var r2 in e2)
        o3[r2] = g$2(e2[r2], t2);
      return t2.set(e2, o3), o3;
    }
    function b$2(e2, t2) {
      var n2 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var o3 = Object.getOwnPropertySymbols(e2);
        t2 && (o3 = o3.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), n2.push.apply(n2, o3);
      }
      return n2;
    }
    function m$2(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var n2 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? b$2(Object(n2), true).forEach(function(t3) {
          l$1(e2, t3, n2[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(n2)) : b$2(Object(n2)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(n2, t3));
        });
      }
      return e2;
    }
    var C$2 = { showLength: { type: Boolean, default: false }, showDoubleQuotes: { type: Boolean, default: true }, renderNodeKey: Function, renderNodeValue: Function, selectableType: String, showSelectController: { type: Boolean, default: false }, showLine: { type: Boolean, default: true }, showLineNumber: { type: Boolean, default: false }, selectOnClickNode: { type: Boolean, default: true }, nodeSelectable: { type: Function, default: function() {
      return true;
    } }, highlightSelectedNode: { type: Boolean, default: true }, showIcon: { type: Boolean, default: false }, theme: { type: String, default: "light" }, showKeyValueSpace: { type: Boolean, default: true }, editable: { type: Boolean, default: false }, editableTrigger: { type: String, default: "click" }, onNodeClick: { type: Function }, onBracketsClick: { type: Function }, onIconClick: { type: Function }, onValueChange: { type: Function } };
    const k$1 = (0, c$2.defineComponent)({ name: "TreeNode", props: m$2(m$2({}, C$2), {}, { node: { type: Object, required: true }, collapsed: Boolean, checked: Boolean, style: Object, onSelectedChange: { type: Function } }), emits: ["nodeClick", "bracketsClick", "iconClick", "selectedChange", "valueChange"], setup: function(e2, t2) {
      var n2 = t2.emit, o3 = (0, c$2.computed)(function() {
        return f$1(e2.node.content);
      }), r2 = (0, c$2.computed)(function() {
        return "vjs-value vjs-value-".concat(o3.value);
      }), a2 = (0, c$2.computed)(function() {
        return e2.showDoubleQuotes ? '"'.concat(e2.node.key, '"') : e2.node.key;
      }), l2 = (0, c$2.computed)(function() {
        return "multiple" === e2.selectableType;
      }), s2 = (0, c$2.computed)(function() {
        return "single" === e2.selectableType;
      }), p2 = (0, c$2.computed)(function() {
        return e2.nodeSelectable(e2.node) && (l2.value || s2.value);
      }), h2 = (0, c$2.reactive)({ editing: false }), y2 = function(t3) {
        var o4, r3, a3 = "null" === (r3 = null === (o4 = t3.target) || void 0 === o4 ? void 0 : o4.value) ? null : "undefined" === r3 ? void 0 : "true" === r3 || "false" !== r3 && (r3[0] + r3[r3.length - 1] === '""' || r3[0] + r3[r3.length - 1] === "''" ? r3.slice(1, -1) : "number" == typeof Number(r3) && !isNaN(Number(r3)) || "NaN" === r3 ? Number(r3) : r3);
        n2("valueChange", a3, e2.node.path);
      }, v2 = (0, c$2.computed)(function() {
        var t3, n3 = null === (t3 = e2.node) || void 0 === t3 ? void 0 : t3.content;
        return null === n3 ? n3 = "null" : void 0 === n3 && (n3 = "undefined"), "string" === o3.value ? '"'.concat(n3, '"') : n3 + "";
      }), g2 = function() {
        var t3 = e2.renderNodeValue;
        return t3 ? t3({ node: e2.node, defaultValue: v2.value }) : v2.value;
      }, b2 = function() {
        n2("bracketsClick", !e2.collapsed, e2.node);
      }, m2 = function() {
        n2("iconClick", !e2.collapsed, e2.node);
      }, C2 = function() {
        n2("selectedChange", e2.node);
      }, k2 = function() {
        n2("nodeClick", e2.node), p2.value && e2.selectOnClickNode && n2("selectedChange", e2.node);
      }, w2 = function(t3) {
        if (e2.editable && !h2.editing) {
          h2.editing = true;
          var n3 = function e3(n4) {
            var o4;
            n4.target !== t3.target && (null === (o4 = n4.target) || void 0 === o4 ? void 0 : o4.parentElement) !== t3.target && (h2.editing = false, document.removeEventListener("click", e3));
          };
          document.removeEventListener("click", n3), document.addEventListener("click", n3);
        }
      };
      return function() {
        var t3, n3 = e2.node;
        return (0, c$2.createVNode)("div", { class: { "vjs-tree-node": true, "has-selector": e2.showSelectController, "has-carets": e2.showIcon, "is-highlight": e2.highlightSelectedNode && e2.checked, dark: "dark" === e2.theme }, onClick: k2, style: e2.style }, [e2.showLineNumber && (0, c$2.createVNode)("span", { class: "vjs-node-index" }, [n3.id + 1]), e2.showSelectController && p2.value && "objectEnd" !== n3.type && "arrayEnd" !== n3.type && (0, c$2.createVNode)(u$2, { isMultiple: l2.value, checked: e2.checked, onChange: C2 }, null), (0, c$2.createVNode)("div", { class: "vjs-indent" }, [Array.from(Array(n3.level)).map(function(t4, n4) {
          return (0, c$2.createVNode)("div", { key: n4, class: { "vjs-indent-unit": true, "has-line": e2.showLine } }, null);
        }), e2.showIcon && (0, c$2.createVNode)(d$2, { nodeType: n3.type, onClick: m2 }, null)]), n3.key && (0, c$2.createVNode)("span", { class: "vjs-key" }, [(t3 = e2.renderNodeKey, t3 ? t3({ node: e2.node, defaultKey: a2.value || "" }) : a2.value), (0, c$2.createVNode)("span", { class: "vjs-colon" }, [":".concat(e2.showKeyValueSpace ? " " : "")])]), (0, c$2.createVNode)("span", null, ["content" !== n3.type && n3.content ? (0, c$2.createVNode)(i$1, { data: n3.content.toString(), onClick: b2 }, null) : (0, c$2.createVNode)("span", { class: r2.value, onClick: !e2.editable || e2.editableTrigger && "click" !== e2.editableTrigger ? void 0 : w2, onDblclick: e2.editable && "dblclick" === e2.editableTrigger ? w2 : void 0 }, [e2.editable && h2.editing ? (0, c$2.createVNode)("input", { value: v2.value, onChange: y2, style: { padding: "3px 8px", border: "1px solid #eee", boxShadow: "none", boxSizing: "border-box", borderRadius: 5, fontFamily: "inherit" } }, null) : g2()]), n3.showComma && (0, c$2.createVNode)("span", null, [","]), e2.showLength && e2.collapsed && (0, c$2.createVNode)("span", { class: "vjs-comment" }, [(0, c$2.createTextVNode)(" // "), n3.length, (0, c$2.createTextVNode)(" items ")])])]);
      };
    } });
    function w$2(e2, t2) {
      var n2 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var o3 = Object.getOwnPropertySymbols(e2);
        t2 && (o3 = o3.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), n2.push.apply(n2, o3);
      }
      return n2;
    }
    function N(e2) {
      for (var t2 = 1; t2 < arguments.length; t2++) {
        var n2 = null != arguments[t2] ? arguments[t2] : {};
        t2 % 2 ? w$2(Object(n2), true).forEach(function(t3) {
          l$1(e2, t3, n2[t3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(n2)) : w$2(Object(n2)).forEach(function(t3) {
          Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(n2, t3));
        });
      }
      return e2;
    }
    const j = (0, c$2.defineComponent)({ name: "Tree", props: N(N({}, C$2), {}, { data: { type: [String, Number, Boolean, Array, Object], default: null }, collapsedNodeLength: { type: Number, default: 1 / 0 }, deep: { type: Number, default: 1 / 0 }, pathCollapsible: { type: Function, default: function() {
      return false;
    } }, rootPath: { type: String, default: "root" }, virtual: { type: Boolean, default: false }, height: { type: Number, default: 400 }, itemHeight: { type: Number, default: 20 }, selectedValue: { type: [String, Array], default: function() {
      return "";
    } }, collapsedOnClickBrackets: { type: Boolean, default: true }, style: Object, onSelectedChange: { type: Function }, theme: { type: String, default: "light" } }), slots: ["renderNodeKey", "renderNodeValue"], emits: ["nodeClick", "bracketsClick", "iconClick", "selectedChange", "update:selectedValue", "update:data"], setup: function(e2, t2) {
      var n2 = t2.emit, o3 = t2.slots, i2 = (0, c$2.ref)(), u2 = (0, c$2.computed)(function() {
        return y$2(e2.data, e2.rootPath);
      }), d2 = function(t3, n3) {
        return u2.value.reduce(function(o4, r2) {
          var a2, c2 = r2.level >= t3 || r2.length >= n3, i3 = null === (a2 = e2.pathCollapsible) || void 0 === a2 ? void 0 : a2.call(e2, r2);
          return "objectStart" !== r2.type && "arrayStart" !== r2.type || !c2 && !i3 ? o4 : N(N({}, o4), {}, l$1({}, r2.path, 1));
        }, {});
      }, s2 = (0, c$2.reactive)({ translateY: 0, visibleData: null, hiddenPaths: d2(e2.deep, e2.collapsedNodeLength) }), p2 = (0, c$2.computed)(function() {
        for (var e3 = null, t3 = [], n3 = u2.value.length, o4 = 0; o4 < n3; o4++) {
          var r2 = N(N({}, u2.value[o4]), {}, { id: o4 }), a2 = s2.hiddenPaths[r2.path];
          if (e3 && e3.path === r2.path) {
            var l2 = "objectStart" === e3.type, c2 = N(N(N({}, r2), e3), {}, { showComma: r2.showComma, content: l2 ? "{...}" : "[...]", type: l2 ? "objectCollapsed" : "arrayCollapsed" });
            e3 = null, t3.push(c2);
          } else {
            if (a2 && !e3) {
              e3 = r2;
              continue;
            }
            if (e3)
              continue;
            t3.push(r2);
          }
        }
        return t3;
      }), h2 = (0, c$2.computed)(function() {
        var t3 = e2.selectedValue;
        return t3 && "multiple" === e2.selectableType && Array.isArray(t3) ? t3 : [t3];
      }), f2 = (0, c$2.computed)(function() {
        return !e2.selectableType || e2.selectOnClickNode || e2.showSelectController ? "" : "When selectableType is not null, selectOnClickNode and showSelectController cannot be false at the same time, because this will cause the selection to fail.";
      }), v2 = function() {
        var t3 = p2.value;
        if (e2.virtual) {
          var n3, o4 = e2.height / e2.itemHeight, r2 = (null === (n3 = i2.value) || void 0 === n3 ? void 0 : n3.scrollTop) || 0, a2 = Math.floor(r2 / e2.itemHeight), l2 = a2 < 0 ? 0 : a2 + o4 > t3.length ? t3.length - o4 : a2;
          l2 < 0 && (l2 = 0);
          var c2 = l2 + o4;
          s2.translateY = l2 * e2.itemHeight, s2.visibleData = t3.filter(function(e3, t4) {
            return t4 >= l2 && t4 < c2;
          });
        } else
          s2.visibleData = t3;
      }, b2 = function() {
        v2();
      }, m2 = function(t3) {
        var o4, l2, c2 = t3.path, i3 = e2.selectableType;
        if ("multiple" === i3) {
          var u3 = h2.value.findIndex(function(e3) {
            return e3 === c2;
          }), d3 = a$1(h2.value);
          -1 !== u3 ? d3.splice(u3, 1) : d3.push(c2), n2("update:selectedValue", d3), n2("selectedChange", d3, a$1(h2.value));
        } else if ("single" === i3 && h2.value[0] !== c2) {
          var s3 = (o4 = h2.value, l2 = 1, function(e3) {
            if (Array.isArray(e3))
              return e3;
          }(o4) || function(e3, t4) {
            var n3 = null == e3 ? null : "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
            if (null != n3) {
              var o5, r2, a2 = [], l3 = true, c3 = false;
              try {
                for (n3 = n3.call(e3); !(l3 = (o5 = n3.next()).done) && (a2.push(o5.value), !t4 || a2.length !== t4); l3 = true)
                  ;
              } catch (e4) {
                c3 = true, r2 = e4;
              } finally {
                try {
                  l3 || null == n3.return || n3.return();
                } finally {
                  if (c3)
                    throw r2;
                }
              }
              return a2;
            }
          }(o4, l2) || r$1(o4, l2) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }())[0], p3 = c2;
          n2("update:selectedValue", p3), n2("selectedChange", p3, s3);
        }
      }, C2 = function(e3) {
        n2("nodeClick", e3);
      }, w2 = function(e3, t3) {
        if (e3)
          s2.hiddenPaths = N(N({}, s2.hiddenPaths), {}, l$1({}, t3, 1));
        else {
          var n3 = N({}, s2.hiddenPaths);
          delete n3[t3], s2.hiddenPaths = n3;
        }
      }, j2 = function(t3, o4) {
        e2.collapsedOnClickBrackets && w2(t3, o4.path), n2("bracketsClick", t3, o4);
      }, S2 = function(e3, t3) {
        w2(e3, t3.path), n2("iconClick", e3, t3);
      }, O2 = function(t3, o4) {
        var r2 = g$2(e2.data), a2 = e2.rootPath;
        new Function("data", "val", "data".concat(o4.slice(a2.length), "=val"))(r2, t3), n2("update:data", r2);
      };
      return (0, c$2.watchEffect)(function() {
        f2.value && function(e3) {
          throw new Error("[VueJSONPretty] ".concat(e3));
        }(f2.value);
      }), (0, c$2.watchEffect)(function() {
        p2.value && v2();
      }), (0, c$2.watch)(function() {
        return e2.deep;
      }, function(t3) {
        t3 && (s2.hiddenPaths = d2(t3, e2.collapsedNodeLength));
      }), (0, c$2.watch)(function() {
        return e2.collapsedNodeLength;
      }, function(t3) {
        t3 && (s2.hiddenPaths = d2(e2.deep, t3));
      }), function() {
        var t3, n3, r2 = null !== (t3 = e2.renderNodeKey) && void 0 !== t3 ? t3 : o3.renderNodeKey, a2 = null !== (n3 = e2.renderNodeValue) && void 0 !== n3 ? n3 : o3.renderNodeValue, l2 = s2.visibleData && s2.visibleData.map(function(t4) {
          return (0, c$2.createVNode)(k$1, { key: t4.id, node: t4, collapsed: !!s2.hiddenPaths[t4.path], theme: e2.theme, showDoubleQuotes: e2.showDoubleQuotes, showLength: e2.showLength, checked: h2.value.includes(t4.path), selectableType: e2.selectableType, showLine: e2.showLine, showLineNumber: e2.showLineNumber, showSelectController: e2.showSelectController, selectOnClickNode: e2.selectOnClickNode, nodeSelectable: e2.nodeSelectable, highlightSelectedNode: e2.highlightSelectedNode, editable: e2.editable, editableTrigger: e2.editableTrigger, showIcon: e2.showIcon, showKeyValueSpace: e2.showKeyValueSpace, renderNodeKey: r2, renderNodeValue: a2, onNodeClick: C2, onBracketsClick: j2, onIconClick: S2, onSelectedChange: m2, onValueChange: O2, style: e2.itemHeight && 20 !== e2.itemHeight ? { lineHeight: "".concat(e2.itemHeight, "px") } : {} }, null);
        });
        return (0, c$2.createVNode)("div", { ref: i2, class: { "vjs-tree": true, "is-virtual": e2.virtual, dark: "dark" === e2.theme }, onScroll: e2.virtual ? b2 : void 0, style: e2.showLineNumber ? N({ paddingLeft: "".concat(12 * Number(u2.value.length.toString().length), "px") }, e2.style) : e2.style }, [e2.virtual ? (0, c$2.createVNode)("div", { class: "vjs-tree-list", style: { height: "".concat(e2.height, "px") } }, [(0, c$2.createVNode)("div", { class: "vjs-tree-list-holder", style: { height: "".concat(p2.value.length * e2.itemHeight, "px") } }, [(0, c$2.createVNode)("div", { class: "vjs-tree-list-holder-inner", style: { transform: "translateY(".concat(s2.translateY, "px)") } }, [l2])])]) : l2]);
      };
    } });
    var S$2 = n$2.Z;
    const _sfc_main$e = {
      components: {
        VueFinalModal: Ro$2,
        VueDragResize,
        VueJsonPretty: S$2
      },
      data() {
        return {
          width: 0,
          height: 0,
          top: 100,
          left: 0,
          initalHeight: 800,
          initalLeft: 400,
          renderProperties: [],
          rangeValue: {},
          fontValue: {},
          booleanValue: {}
        };
      },
      computed: {
        // other computed properties
        // ...
        // gives access to this.counterStore and this.userStore
        ...mapStores(usePreferenceStore),
        // // gives read access to this.count and this.double
        ...mapState(usePreferenceStore, ["debugModalData"]),
        ...mapWritableState(usePreferenceStore, ["showDebugModal"])
      },
      watch: {
        showDebugModal(newVal, oldVal) {
          console.log(newVal, oldVal);
        }
      },
      methods: {
        dragResize: function(newRect) {
          this.width = newRect.width;
          this.height = newRect.height;
          this.top = newRect.top;
          this.left = newRect.left;
          this.$refs.debugContent.style.height = newRect.height + "px";
        },
        onSelectElement(event2) {
          const tagName = event2.target.tagName;
          if (tagName === "INPUT" || tagName === "TEXTAREA" || tagName === "SELECT") {
            event2.stopPropagation();
          }
        }
      },
      mounted() {
        this.$nextTick(() => {
        });
      }
    };
    const _hoisted_1$b = { class: "menu-buttons" };
    function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_vue_json_pretty = resolveComponent("vue-json-pretty");
      const _component_VueDragResize = resolveComponent("VueDragResize");
      const _component_VueFinalModal = resolveComponent("VueFinalModal");
      return openBlock(), createBlock(_component_VueFinalModal, {
        "display-directive": "show",
        "hide-overlay": true,
        "overlay-transition": "vfm-fade"
      }, {
        default: withCtx(() => [
          createVNode(_component_VueDragResize, {
            "is-active": true,
            w: 800,
            h: $data.initalHeight,
            x: $data.initalLeft,
            class: "debug-modal",
            onResizing: $options.dragResize,
            onDragging: $options.dragResize,
            sticks: ["br"],
            stickSize: 22
          }, {
            default: withCtx(() => [
              createBaseVNode("div", {
                id: "debug-content",
                ref: "debugContent",
                onMousedown: _cache[1] || (_cache[1] = ($event) => $options.onSelectElement($event)),
                onTouchstart: _cache[2] || (_cache[2] = ($event) => $options.onSelectElement($event))
              }, [
                createBaseVNode("div", _hoisted_1$b, [
                  createBaseVNode("button", {
                    class: "close-button",
                    onPointerup: _cache[0] || (_cache[0] = ($event) => _ctx.showDebugModal = false)
                  }, "X", 32)
                ]),
                createVNode(_component_vue_json_pretty, {
                  path: "res",
                  highlightMouseoverNode: true,
                  collapsedOnClickBrackets: true,
                  data: _ctx.debugModalData
                }, null, 8, ["data"])
              ], 544)
            ]),
            _: 1
          }, 8, ["h", "x", "onResizing", "onDragging"])
        ]),
        _: 1
      });
    }
    const Debug = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$d], ["__scopeId", "data-v-f1477a07"]]);
    const _sfc_main$d = {
      data() {
        return {};
      },
      computed: {
        // other computed properties
        // ...
        // gives access to this.counterStore and this.userStore
        ...mapStores(useProfileStore, usePreferenceStore),
        // // gives read access to this.count and this.double
        ...mapState(useProfileStore, ["profilesLoaded", "activeProfile", "rtLookup", "activeComponent"]),
        ...mapState(usePreferenceStore, ["styleDefault"]),
        ...mapWritableState(useProfileStore, ["activeComponent"])
      },
      methods: {},
      mounted() {
      }
    };
    const __injectCSSVars__$6 = () => {
      useCssVars((_ctx) => ({
        "383b5786": _ctx.preferenceStore.returnValue("--n-edit-main-splitpane-opac-font-size", true) + 0.25 + "em",
        "04fabdad": _ctx.preferenceStore.returnValue("--c-edit-main-splitpane-opac-font-family"),
        "aa494f84": _ctx.preferenceStore.returnValue("--c-edit-main-splitpane-opac-font-color"),
        "038b8c0b": _ctx.preferenceStore.returnValue("--n-edit-main-splitpane-opac-font-size", true) / 2 + "em",
        "5ae83c54": _ctx.preferenceStore.returnValue("--c-edit-main-splitpane-opac-highlight-background-color"),
        "6288bcb0": _ctx.preferenceStore.returnValue("--c-edit-main-splitpane-opac-empty-indicator-color"),
        "6f471d0a": _ctx.preferenceStore.returnValue("--n-edit-main-splitpane-opac-font-size", true) / 1 + "em",
        "07ad79a5": _ctx.preferenceStore.returnValue("--n-edit-main-splitpane-opac-font-size", true) - 0.15 + "em",
        "4510cbba": _ctx.preferenceStore.returnValue("--c-general-icon-item-color")
      }));
    };
    const __setup__$6 = _sfc_main$d.setup;
    _sfc_main$d.setup = __setup__$6 ? (props, ctx) => {
      __injectCSSVars__$6();
      return __setup__$6(props, ctx);
    } : __injectCSSVars__$6;
    const _sfc_main$c = {
      components: { Splitpanes: M$1, Pane: g$3, Properties, EditPanel, Nav, Opac, Debug },
      data() {
        return {
          test: 1
        };
      },
      computed: {
        // other computed properties
        // ...
        // gives access to this.counterStore and this.userStore
        ...mapStores(usePreferenceStore, useProfileStore),
        ...mapState(usePreferenceStore, ["styleDefault", "panelDisplay"]),
        ...mapState(useProfileStore, ["profilesLoaded"]),
        ...mapWritableState(usePreferenceStore, ["showDebugModal", "activeProfile"])
        // // gives read access to this.count and this.double
        // ...mapState(usePreferenceStore, ['profilesLoaded']),
      },
      methods: {
        returnPixleAsPercent: function(pixles) {
          return pixles / window.innerHeight * 100;
        }
      },
      mounted: function() {
        console.log(this.$route.params);
        if (this.profilesLoaded) {
          this.profileStore.loadRecordFromBackend(this.$route.params.recordId);
        }
      },
      created: function() {
        this.profileStore.$subscribe(async (mutation, state) => {
          console.log(state.profilesLoaded, Object.keys(state.activeProfile).length);
          if (state.profilesLoaded && Object.keys(state.activeProfile).length == 0) {
            this.profileStore.loadRecordFromBackend(this.$route.params.recordId);
          }
        }, { detached: false });
      }
    };
    const __injectCSSVars__$5 = () => {
      useCssVars((_ctx) => ({
        "2f59baef": _ctx.preferenceStore.returnValue("--c-edit-main-splitpane-nav-background-color"),
        "7c70787e": _ctx.preferenceStore.returnValue("--c-edit-main-splitpane-properties-background-color"),
        "b2b1541e": _ctx.preferenceStore.returnValue("--c-edit-main-splitpane-opac-background-color")
      }));
    };
    const __setup__$5 = _sfc_main$c.setup;
    _sfc_main$c.setup = __setup__$5 ? (props, ctx) => {
      __injectCSSVars__$5();
      return __setup__$5(props, ctx);
    } : __injectCSSVars__$5;
    function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Nav = resolveComponent("Nav");
      const _component_pane = resolveComponent("pane");
      const _component_Properties = resolveComponent("Properties");
      const _component_EditPanel = resolveComponent("EditPanel");
      const _component_Opac = resolveComponent("Opac");
      const _component_Xml = resolveComponent("Xml");
      const _component_splitpanes = resolveComponent("splitpanes");
      const _component_Debug = resolveComponent("Debug");
      return openBlock(), createBlock(_component_splitpanes, {
        class: "default-theme",
        horizontal: ""
      }, {
        default: withCtx(() => [
          createVNode(_component_pane, {
            class: "header",
            size: $options.returnPixleAsPercent(_ctx.preferenceStore.returnValue("--n-edit-main-splitpane-nav-height", true))
          }, {
            default: withCtx(() => [
              createVNode(_component_Nav)
            ]),
            _: 1
          }, 8, ["size"]),
          createVNode(_component_pane, null, {
            default: withCtx(() => [
              createVNode(_component_splitpanes, null, {
                default: withCtx(() => [
                  _ctx.panelDisplay.properties ? (openBlock(), createBlock(_component_pane, {
                    key: 0,
                    class: normalizeClass({ "edit-main-splitpane-properties": true, "edit-main-splitpane-no-scrollbar": _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-properties-no-scrollbar") }),
                    size: _ctx.preferenceStore.returnValue("--n-edit-main-splitpane-properties-width"),
                    "min-size": "5"
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_Properties)
                    ]),
                    _: 1
                  }, 8, ["class", "size"])) : createCommentVNode("", true),
                  _ctx.panelDisplay.dualEdit ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    createVNode(_component_pane, {
                      class: normalizeClass({ "edit-main-splitpane-edit": true, "edit-main-splitpane-edit-no-scrollbar": _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-no-scrollbar") }),
                      size: _ctx.preferenceStore.returnValue("--n-edit-main-splitpane-edit-width")
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_EditPanel, { instanceMode: false })
                      ]),
                      _: 1
                    }, 8, ["class", "size"]),
                    createVNode(_component_pane, {
                      class: normalizeClass({ "edit-main-splitpane-edit": true, "edit-main-splitpane-edit-no-scrollbar": _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-no-scrollbar") }),
                      size: _ctx.preferenceStore.returnValue("--n-edit-main-splitpane-edit-width")
                    }, {
                      default: withCtx(() => [
                        createVNode(_component_EditPanel, { instanceMode: true })
                      ]),
                      _: 1
                    }, 8, ["class", "size"])
                  ], 64)) : (openBlock(), createBlock(_component_pane, {
                    key: 2,
                    class: normalizeClass({ "edit-main-splitpane-edit": true, "edit-main-splitpane-edit-no-scrollbar": _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-no-scrollbar") }),
                    size: _ctx.preferenceStore.returnValue("--n-edit-main-splitpane-edit-width")
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString$2(this.activeProfile ? Object.keys(this.activeProfile).length : "") + " ", 1),
                      (openBlock(), createBlock(_component_EditPanel, {
                        key: $data.test,
                        instanceMode: false
                      }))
                    ]),
                    _: 1
                  }, 8, ["class", "size"])),
                  _ctx.panelDisplay.opac ? (openBlock(), createBlock(_component_pane, {
                    key: 3,
                    class: normalizeClass({ "edit-main-splitpane-opac": true, "edit-main-splitpane-no-scrollbar": _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-opac-no-scrollbar") }),
                    size: _ctx.preferenceStore.returnValue("--n-edit-main-splitpane-opac-width")
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_Opac)
                    ]),
                    _: 1
                  }, 8, ["class", "size"])) : createCommentVNode("", true),
                  _ctx.panelDisplay.xml ? (openBlock(), createBlock(_component_pane, {
                    key: 4,
                    class: normalizeClass({ "edit-main-splitpane-xml": true, "edit-main-splitpane-no-scrollbar": _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-opac-no-scrollbar") }),
                    size: _ctx.preferenceStore.returnValue("--n-edit-main-splitpane-opac-width")
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_Xml)
                    ]),
                    _: 1
                  }, 8, ["class", "size"])) : createCommentVNode("", true)
                ]),
                _: 1
              })
            ]),
            _: 1
          }),
          _ctx.showDebugModal == true ? (openBlock(), createBlock(_component_Debug, {
            key: 0,
            modelValue: _ctx.showDebugModal,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.showDebugModal = $event)
          }, null, 8, ["modelValue"])) : createCommentVNode("", true)
        ]),
        _: 1
      });
    }
    const Edit = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$c], ["__scopeId", "data-v-fce5b1f3"]]);
    var defaultLocale$1 = "en";
    var localesData$1 = {};
    var lowercaseLocaleLookup = {};
    function getDefaultLocale() {
      return defaultLocale$1;
    }
    function setDefaultLocale(locale) {
      defaultLocale$1 = locale;
    }
    function getLocaleData$1(locale) {
      return localesData$1[locale];
    }
    function addLocaleData$1(localeData) {
      if (!localeData) {
        throw new Error("No locale data passed");
      }
      localesData$1[localeData.locale] = localeData;
      lowercaseLocaleLookup[localeData.locale.toLowerCase()] = localeData.locale;
    }
    function resolveLocale$1(locale) {
      if (localesData$1[locale]) {
        return locale;
      }
      if (lowercaseLocaleLookup[locale.toLowerCase()]) {
        return lowercaseLocaleLookup[locale.toLowerCase()];
      }
    }
    function resolveLocale(locale) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var localeMatcher = options.localeMatcher || "lookup";
      switch (localeMatcher) {
        case "lookup":
          return resolveLocaleLookup(locale);
        case "best fit":
          return resolveLocaleLookup(locale);
        default:
          throw new RangeError('Invalid "localeMatcher" option: '.concat(localeMatcher));
      }
    }
    function resolveLocaleLookup(locale) {
      var resolvedLocale = resolveLocale$1(locale);
      if (resolvedLocale) {
        return resolvedLocale;
      }
      var parts = locale.split("-");
      while (locale.length > 1) {
        parts.pop();
        locale = parts.join("-");
        var _resolvedLocale = resolveLocale$1(locale);
        if (_resolvedLocale) {
          return _resolvedLocale;
        }
      }
    }
    var $ = {
      af: function af(n2) {
        return n2 == 1 ? "one" : "other";
      },
      am: function am(n2) {
        return n2 >= 0 && n2 <= 1 ? "one" : "other";
      },
      ar: function ar2(n2) {
        var s2 = String(n2).split("."), t0 = Number(s2[0]) == n2, n100 = t0 && s2[0].slice(-2);
        return n2 == 0 ? "zero" : n2 == 1 ? "one" : n2 == 2 ? "two" : n100 >= 3 && n100 <= 10 ? "few" : n100 >= 11 && n100 <= 99 ? "many" : "other";
      },
      ast: function ast(n2) {
        var s2 = String(n2).split("."), v0 = !s2[1];
        return n2 == 1 && v0 ? "one" : "other";
      },
      be: function be2(n2) {
        var s2 = String(n2).split("."), t0 = Number(s2[0]) == n2, n10 = t0 && s2[0].slice(-1), n100 = t0 && s2[0].slice(-2);
        return n10 == 1 && n100 != 11 ? "one" : n10 >= 2 && n10 <= 4 && (n100 < 12 || n100 > 14) ? "few" : t0 && n10 == 0 || n10 >= 5 && n10 <= 9 || n100 >= 11 && n100 <= 14 ? "many" : "other";
      },
      br: function br2(n2) {
        var s2 = String(n2).split("."), t0 = Number(s2[0]) == n2, n10 = t0 && s2[0].slice(-1), n100 = t0 && s2[0].slice(-2), n1000000 = t0 && s2[0].slice(-6);
        return n10 == 1 && n100 != 11 && n100 != 71 && n100 != 91 ? "one" : n10 == 2 && n100 != 12 && n100 != 72 && n100 != 92 ? "two" : (n10 == 3 || n10 == 4 || n10 == 9) && (n100 < 10 || n100 > 19) && (n100 < 70 || n100 > 79) && (n100 < 90 || n100 > 99) ? "few" : n2 != 0 && t0 && n1000000 == 0 ? "many" : "other";
      },
      bs: function bs(n2) {
        var s2 = String(n2).split("."), i2 = s2[0], f2 = s2[1] || "", v0 = !s2[1], i10 = i2.slice(-1), i100 = i2.slice(-2), f10 = f2.slice(-1), f100 = f2.slice(-2);
        return v0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11 ? "one" : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) || f10 >= 2 && f10 <= 4 && (f100 < 12 || f100 > 14) ? "few" : "other";
      },
      ca: function ca(n2) {
        var s2 = String(n2).split("."), i2 = s2[0], v0 = !s2[1], i1000000 = i2.slice(-6);
        return n2 == 1 && v0 ? "one" : i2 != 0 && i1000000 == 0 && v0 ? "many" : "other";
      },
      ceb: function ceb(n2) {
        var s2 = String(n2).split("."), i2 = s2[0], f2 = s2[1] || "", v0 = !s2[1], i10 = i2.slice(-1), f10 = f2.slice(-1);
        return v0 && (i2 == 1 || i2 == 2 || i2 == 3) || v0 && i10 != 4 && i10 != 6 && i10 != 9 || !v0 && f10 != 4 && f10 != 6 && f10 != 9 ? "one" : "other";
      },
      cs: function cs(n2) {
        var s2 = String(n2).split("."), i2 = s2[0], v0 = !s2[1];
        return n2 == 1 && v0 ? "one" : i2 >= 2 && i2 <= 4 && v0 ? "few" : !v0 ? "many" : "other";
      },
      cy: function cy(n2) {
        return n2 == 0 ? "zero" : n2 == 1 ? "one" : n2 == 2 ? "two" : n2 == 3 ? "few" : n2 == 6 ? "many" : "other";
      },
      da: function da(n2) {
        var s2 = String(n2).split("."), i2 = s2[0], t0 = Number(s2[0]) == n2;
        return n2 == 1 || !t0 && (i2 == 0 || i2 == 1) ? "one" : "other";
      },
      dsb: function dsb(n2) {
        var s2 = String(n2).split("."), i2 = s2[0], f2 = s2[1] || "", v0 = !s2[1], i100 = i2.slice(-2), f100 = f2.slice(-2);
        return v0 && i100 == 1 || f100 == 1 ? "one" : v0 && i100 == 2 || f100 == 2 ? "two" : v0 && (i100 == 3 || i100 == 4) || f100 == 3 || f100 == 4 ? "few" : "other";
      },
      dz: function dz(n2) {
        return "other";
      },
      es: function es2(n2) {
        var s2 = String(n2).split("."), i2 = s2[0], v0 = !s2[1], i1000000 = i2.slice(-6);
        return n2 == 1 ? "one" : i2 != 0 && i1000000 == 0 && v0 ? "many" : "other";
      },
      ff: function ff(n2) {
        return n2 >= 0 && n2 < 2 ? "one" : "other";
      },
      fr: function fr2(n2) {
        var s2 = String(n2).split("."), i2 = s2[0], v0 = !s2[1], i1000000 = i2.slice(-6);
        return n2 >= 0 && n2 < 2 ? "one" : i2 != 0 && i1000000 == 0 && v0 ? "many" : "other";
      },
      ga: function ga(n2) {
        var s2 = String(n2).split("."), t0 = Number(s2[0]) == n2;
        return n2 == 1 ? "one" : n2 == 2 ? "two" : t0 && n2 >= 3 && n2 <= 6 ? "few" : t0 && n2 >= 7 && n2 <= 10 ? "many" : "other";
      },
      gd: function gd(n2) {
        var s2 = String(n2).split("."), t0 = Number(s2[0]) == n2;
        return n2 == 1 || n2 == 11 ? "one" : n2 == 2 || n2 == 12 ? "two" : t0 && n2 >= 3 && n2 <= 10 || t0 && n2 >= 13 && n2 <= 19 ? "few" : "other";
      },
      he: function he2(n2) {
        var s2 = String(n2).split("."), i2 = s2[0], v0 = !s2[1];
        return i2 == 1 && v0 || i2 == 0 && !v0 ? "one" : i2 == 2 && v0 ? "two" : "other";
      },
      is: function is(n2) {
        var s2 = String(n2).split("."), i2 = s2[0], t2 = (s2[1] || "").replace(/0+$/, ""), t0 = Number(s2[0]) == n2, i10 = i2.slice(-1), i100 = i2.slice(-2);
        return t0 && i10 == 1 && i100 != 11 || t2 % 10 == 1 && t2 % 100 != 11 ? "one" : "other";
      },
      ksh: function ksh(n2) {
        return n2 == 0 ? "zero" : n2 == 1 ? "one" : "other";
      },
      lt: function lt2(n2) {
        var s2 = String(n2).split("."), f2 = s2[1] || "", t0 = Number(s2[0]) == n2, n10 = t0 && s2[0].slice(-1), n100 = t0 && s2[0].slice(-2);
        return n10 == 1 && (n100 < 11 || n100 > 19) ? "one" : n10 >= 2 && n10 <= 9 && (n100 < 11 || n100 > 19) ? "few" : f2 != 0 ? "many" : "other";
      },
      lv: function lv(n2) {
        var s2 = String(n2).split("."), f2 = s2[1] || "", v2 = f2.length, t0 = Number(s2[0]) == n2, n10 = t0 && s2[0].slice(-1), n100 = t0 && s2[0].slice(-2), f100 = f2.slice(-2), f10 = f2.slice(-1);
        return t0 && n10 == 0 || n100 >= 11 && n100 <= 19 || v2 == 2 && f100 >= 11 && f100 <= 19 ? "zero" : n10 == 1 && n100 != 11 || v2 == 2 && f10 == 1 && f100 != 11 || v2 != 2 && f10 == 1 ? "one" : "other";
      },
      mk: function mk(n2) {
        var s2 = String(n2).split("."), i2 = s2[0], f2 = s2[1] || "", v0 = !s2[1], i10 = i2.slice(-1), i100 = i2.slice(-2), f10 = f2.slice(-1), f100 = f2.slice(-2);
        return v0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11 ? "one" : "other";
      },
      mt: function mt2(n2) {
        var s2 = String(n2).split("."), t0 = Number(s2[0]) == n2, n100 = t0 && s2[0].slice(-2);
        return n2 == 1 ? "one" : n2 == 2 ? "two" : n2 == 0 || n100 >= 3 && n100 <= 10 ? "few" : n100 >= 11 && n100 <= 19 ? "many" : "other";
      },
      pa: function pa(n2) {
        return n2 == 0 || n2 == 1 ? "one" : "other";
      },
      pl: function pl(n2) {
        var s2 = String(n2).split("."), i2 = s2[0], v0 = !s2[1], i10 = i2.slice(-1), i100 = i2.slice(-2);
        return n2 == 1 && v0 ? "one" : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) ? "few" : v0 && i2 != 1 && (i10 == 0 || i10 == 1) || v0 && i10 >= 5 && i10 <= 9 || v0 && i100 >= 12 && i100 <= 14 ? "many" : "other";
      },
      pt: function pt2(n2) {
        var s2 = String(n2).split("."), i2 = s2[0], v0 = !s2[1], i1000000 = i2.slice(-6);
        return i2 == 0 || i2 == 1 ? "one" : i2 != 0 && i1000000 == 0 && v0 ? "many" : "other";
      },
      ro: function ro2(n2) {
        var s2 = String(n2).split("."), v0 = !s2[1], t0 = Number(s2[0]) == n2, n100 = t0 && s2[0].slice(-2);
        return n2 == 1 && v0 ? "one" : !v0 || n2 == 0 || n2 != 1 && n100 >= 1 && n100 <= 19 ? "few" : "other";
      },
      ru: function ru2(n2) {
        var s2 = String(n2).split("."), i2 = s2[0], v0 = !s2[1], i10 = i2.slice(-1), i100 = i2.slice(-2);
        return v0 && i10 == 1 && i100 != 11 ? "one" : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) ? "few" : v0 && i10 == 0 || v0 && i10 >= 5 && i10 <= 9 || v0 && i100 >= 11 && i100 <= 14 ? "many" : "other";
      },
      se: function se2(n2) {
        return n2 == 1 ? "one" : n2 == 2 ? "two" : "other";
      },
      si: function si(n2) {
        var s2 = String(n2).split("."), i2 = s2[0], f2 = s2[1] || "";
        return n2 == 0 || n2 == 1 || i2 == 0 && f2 == 1 ? "one" : "other";
      },
      sl: function sl(n2) {
        var s2 = String(n2).split("."), i2 = s2[0], v0 = !s2[1], i100 = i2.slice(-2);
        return v0 && i100 == 1 ? "one" : v0 && i100 == 2 ? "two" : v0 && (i100 == 3 || i100 == 4) || !v0 ? "few" : "other";
      }
    };
    $.as = $.am;
    $.az = $.af;
    $.bg = $.af;
    $.bn = $.am;
    $.brx = $.af;
    $.ce = $.af;
    $.chr = $.af;
    $.de = $.ast;
    $.ee = $.af;
    $.el = $.af;
    $.en = $.ast;
    $.et = $.ast;
    $.eu = $.af;
    $.fa = $.am;
    $.fi = $.ast;
    $.fil = $.ceb;
    $.fo = $.af;
    $.fur = $.af;
    $.fy = $.ast;
    $.gl = $.ast;
    $.gu = $.am;
    $.ha = $.af;
    $.hi = $.am;
    $.hr = $.bs;
    $.hsb = $.dsb;
    $.hu = $.af;
    $.hy = $.ff;
    $.ia = $.ast;
    $.id = $.dz;
    $.ig = $.dz;
    $.it = $.ca;
    $.ja = $.dz;
    $.jgo = $.af;
    $.jv = $.dz;
    $.ka = $.af;
    $.kea = $.dz;
    $.kk = $.af;
    $.kl = $.af;
    $.km = $.dz;
    $.kn = $.am;
    $.ko = $.dz;
    $.ks = $.af;
    $.ku = $.af;
    $.ky = $.af;
    $.lb = $.af;
    $.lkt = $.dz;
    $.lo = $.dz;
    $.ml = $.af;
    $.mn = $.af;
    $.mr = $.af;
    $.ms = $.dz;
    $.my = $.dz;
    $.nb = $.af;
    $.ne = $.af;
    $.nl = $.ast;
    $.nn = $.af;
    $.no = $.af;
    $.or = $.af;
    $.pcm = $.am;
    $.ps = $.af;
    $.rm = $.af;
    $.sah = $.dz;
    $.sc = $.ast;
    $.sd = $.af;
    $.sk = $.cs;
    $.so = $.af;
    $.sq = $.af;
    $.sr = $.bs;
    $.su = $.dz;
    $.sv = $.ast;
    $.sw = $.ast;
    $.ta = $.af;
    $.te = $.af;
    $.th = $.dz;
    $.ti = $.pa;
    $.tk = $.af;
    $.to = $.dz;
    $.tr = $.af;
    $.ug = $.af;
    $.uk = $.ru;
    $.ur = $.ast;
    $.uz = $.af;
    $.vi = $.dz;
    $.wae = $.af;
    $.wo = $.dz;
    $.xh = $.af;
    $.yi = $.ast;
    $.yo = $.dz;
    $.yue = $.dz;
    $.zh = $.dz;
    $.zu = $.am;
    function getPluralRulesLocale(locale) {
      if (locale === "pt-PT") {
        return locale;
      }
      return getLanguageFromLanguageTag(locale);
    }
    var LANGUAGE_REG_EXP = /^([a-z0-9]+)/i;
    function getLanguageFromLanguageTag(languageTag) {
      var match = languageTag.match(LANGUAGE_REG_EXP);
      if (!match) {
        throw new TypeError("Invalid locale: ".concat(languageTag));
      }
      return match[1];
    }
    function _classCallCheck$3(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$3(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$3(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties$3(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties$3(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    var PluralRules = /* @__PURE__ */ function() {
      function PluralRules2(locale, options) {
        _classCallCheck$3(this, PluralRules2);
        var locales = PluralRules2.supportedLocalesOf(locale);
        if (locales.length === 0) {
          throw new RangeError("Unsupported locale: " + locale);
        }
        if (options && options.type !== "cardinal") {
          throw new RangeError('Only "cardinal" "type" is supported');
        }
        this.$ = $[getPluralRulesLocale(locales[0])];
      }
      _createClass$3(PluralRules2, [{
        key: "select",
        value: function select(number2) {
          return this.$(number2);
        }
      }], [{
        key: "supportedLocalesOf",
        value: function supportedLocalesOf(locales) {
          if (typeof locales === "string") {
            locales = [locales];
          }
          return locales.filter(function(locale) {
            return $[getPluralRulesLocale(locale)];
          });
        }
      }]);
      return PluralRules2;
    }();
    function _typeof$5(obj) {
      "@babel/helpers - typeof";
      return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof$5(obj);
    }
    function ownKeys$9(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols2 = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols2 = symbols2.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols2);
      }
      return keys;
    }
    function _objectSpread$9(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? ownKeys$9(Object(source), true).forEach(function(key2) {
          _defineProperty$9(target, key2, source[key2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$9(Object(source)).forEach(function(key2) {
          Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
        });
      }
      return target;
    }
    function _defineProperty$9(obj, key2, value) {
      if (key2 in obj) {
        Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key2] = value;
      }
      return obj;
    }
    function _slicedToArray$1(arr, i2) {
      return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i2) || _unsupportedIterableToArray$2(arr, i2) || _nonIterableRest$1();
    }
    function _nonIterableRest$1() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray$2(o3, minLen) {
      if (!o3)
        return;
      if (typeof o3 === "string")
        return _arrayLikeToArray$2(o3, minLen);
      var n2 = Object.prototype.toString.call(o3).slice(8, -1);
      if (n2 === "Object" && o3.constructor)
        n2 = o3.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o3);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray$2(o3, minLen);
    }
    function _arrayLikeToArray$2(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
        arr2[i2] = arr[i2];
      }
      return arr2;
    }
    function _iterableToArrayLimit$1(arr, i2) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e2;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i2 && _arr.length === i2)
            break;
        }
      } catch (err) {
        _d = true;
        _e2 = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e2;
        }
      }
      return _arr;
    }
    function _arrayWithHoles$1(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _classCallCheck$2(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$2(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$2(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties$2(Constructor.prototype, protoProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    var UNITS = ["second", "minute", "hour", "day", "week", "month", "quarter", "year"];
    var NUMERIC_VALUES = ["auto", "always"];
    var STYLE_VALUES = ["long", "short", "narrow"];
    var LOCALE_MATCHER_VALUES = ["lookup", "best fit"];
    var RelativeTimeFormat = /* @__PURE__ */ function() {
      function RelativeTimeFormat2() {
        var locales = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck$2(this, RelativeTimeFormat2);
        var numeric = options.numeric, style = options.style, localeMatcher = options.localeMatcher;
        this.numeric = "always";
        this.style = "long";
        this.localeMatcher = "lookup";
        if (numeric !== void 0) {
          if (NUMERIC_VALUES.indexOf(numeric) < 0) {
            throw new RangeError('Invalid "numeric" option: '.concat(numeric));
          }
          this.numeric = numeric;
        }
        if (style !== void 0) {
          if (STYLE_VALUES.indexOf(style) < 0) {
            throw new RangeError('Invalid "style" option: '.concat(style));
          }
          this.style = style;
        }
        if (localeMatcher !== void 0) {
          if (LOCALE_MATCHER_VALUES.indexOf(localeMatcher) < 0) {
            throw new RangeError('Invalid "localeMatcher" option: '.concat(localeMatcher));
          }
          this.localeMatcher = localeMatcher;
        }
        if (typeof locales === "string") {
          locales = [locales];
        }
        locales.push(getDefaultLocale());
        this.locale = RelativeTimeFormat2.supportedLocalesOf(locales, {
          localeMatcher: this.localeMatcher
        })[0];
        if (!this.locale) {
          throw new Error("No supported locale was found");
        }
        if (PluralRules.supportedLocalesOf(this.locale).length > 0) {
          this.pluralRules = new PluralRules(this.locale);
        } else {
          console.warn('"'.concat(this.locale, '" locale is not supported'));
        }
        if (typeof Intl !== "undefined" && Intl.NumberFormat) {
          this.numberFormat = new Intl.NumberFormat(this.locale);
          this.numberingSystem = this.numberFormat.resolvedOptions().numberingSystem;
        } else {
          this.numberingSystem = "latn";
        }
        this.locale = resolveLocale(this.locale, {
          localeMatcher: this.localeMatcher
        });
      }
      _createClass$2(RelativeTimeFormat2, [{
        key: "format",
        value: function format2() {
          var _parseFormatArgs = parseFormatArgs(arguments), _parseFormatArgs2 = _slicedToArray$1(_parseFormatArgs, 2), number2 = _parseFormatArgs2[0], unit = _parseFormatArgs2[1];
          return this.getRule(number2, unit).replace("{0}", this.formatNumber(Math.abs(number2)));
        }
        /**
         * Formats time `number` in `units` (either in past or in future).
         * @param {number} number - Time interval value.
         * @param {string} unit - Time interval measurement unit.
         * @return {Object[]} The parts (`{ type, value, unit? }`).
         * @throws {RangeError} If unit is not one of "second", "minute", "hour", "day", "week", "month", "quarter".
         * @example
         * // Version 1 (deprecated).
         * // Returns [
         * //   { type: "literal", value: "in " },
         * //   { type: "day", value: "100" },
         * //   { type: "literal", value: " days" }
         * // ]
         * rtf.formatToParts(100, "day")
         * //
         * // Version 2.
         * // Returns [
         * //   { type: "literal", value: "in " },
         * //   { type: "integer", value: "100", unit: "day" },
         * //   { type: "literal", value: " days" }
         * // ]
         * rtf.formatToParts(100, "day")
         */
      }, {
        key: "formatToParts",
        value: function formatToParts() {
          var _parseFormatArgs3 = parseFormatArgs(arguments), _parseFormatArgs4 = _slicedToArray$1(_parseFormatArgs3, 2), number2 = _parseFormatArgs4[0], unit = _parseFormatArgs4[1];
          var rule = this.getRule(number2, unit);
          var valueIndex = rule.indexOf("{0}");
          if (valueIndex < 0) {
            return [{
              type: "literal",
              value: rule
            }];
          }
          var parts = [];
          if (valueIndex > 0) {
            parts.push({
              type: "literal",
              value: rule.slice(0, valueIndex)
            });
          }
          parts = parts.concat(this.formatNumberToParts(Math.abs(number2)).map(function(part) {
            return _objectSpread$9(_objectSpread$9({}, part), {}, {
              unit
            });
          }));
          if (valueIndex + "{0}".length < rule.length - 1) {
            parts.push({
              type: "literal",
              value: rule.slice(valueIndex + "{0}".length)
            });
          }
          return parts;
        }
        /**
         * Returns formatting rule for `value` in `units` (either in past or in future).
         * @param {number} value - Time interval value.
         * @param {string} unit - Time interval measurement unit.
         * @return {string}
         * @throws {RangeError} If unit is not one of "second", "minute", "hour", "day", "week", "month", "quarter".
         * @example
         * // Returns "{0} days ago"
         * getRule(-2, "day")
         */
      }, {
        key: "getRule",
        value: function getRule(value, unit) {
          var unitMessages = getLocaleData$1(this.locale)[this.style][unit];
          if (typeof unitMessages === "string") {
            return unitMessages;
          }
          if (this.numeric === "auto") {
            if (value === -2 || value === -1) {
              var message = unitMessages["previous".concat(value === -1 ? "" : "-" + Math.abs(value))];
              if (message) {
                return message;
              }
            } else if (value === 1 || value === 2) {
              var _message = unitMessages["next".concat(value === 1 ? "" : "-" + Math.abs(value))];
              if (_message) {
                return _message;
              }
            } else if (value === 0) {
              if (unitMessages.current) {
                return unitMessages.current;
              }
            }
          }
          var pluralizedMessages = unitMessages[isNegative(value) ? "past" : "future"];
          if (typeof pluralizedMessages === "string") {
            return pluralizedMessages;
          }
          var quantifier = this.pluralRules && this.pluralRules.select(Math.abs(value)) || "other";
          return pluralizedMessages[quantifier] || pluralizedMessages.other;
        }
        /**
         * Formats a number into a string.
         * Uses `Intl.NumberFormat` when available.
         * @param  {number} number
         * @return {string}
         */
      }, {
        key: "formatNumber",
        value: function formatNumber(number2) {
          return this.numberFormat ? this.numberFormat.format(number2) : String(number2);
        }
        /**
         * Formats a number into a list of parts.
         * Uses `Intl.NumberFormat` when available.
         * @param  {number} number
         * @return {object[]}
         */
      }, {
        key: "formatNumberToParts",
        value: function formatNumberToParts(number2) {
          return this.numberFormat && this.numberFormat.formatToParts ? this.numberFormat.formatToParts(number2) : [{
            type: "integer",
            value: this.formatNumber(number2)
          }];
        }
        /**
         * Returns a new object with properties reflecting the locale and date and time formatting options computed during initialization of this DateTimeFormat object.
         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/resolvedOptions
         * @return {Object}
         */
      }, {
        key: "resolvedOptions",
        value: function resolvedOptions() {
          return {
            locale: this.locale,
            style: this.style,
            numeric: this.numeric,
            numberingSystem: this.numberingSystem
          };
        }
      }]);
      return RelativeTimeFormat2;
    }();
    RelativeTimeFormat.supportedLocalesOf = function(locales) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (typeof locales === "string") {
        locales = [locales];
      } else if (!Array.isArray(locales)) {
        throw new TypeError('Invalid "locales" argument');
      }
      return locales.filter(function(locale) {
        return resolveLocale(locale, options);
      });
    };
    RelativeTimeFormat.addLocale = addLocaleData$1;
    RelativeTimeFormat.setDefaultLocale = setDefaultLocale;
    RelativeTimeFormat.getDefaultLocale = getDefaultLocale;
    RelativeTimeFormat.PluralRules = PluralRules;
    var UNIT_ERROR = 'Invalid "unit" argument';
    function parseUnit(unit) {
      if (_typeof$5(unit) === "symbol") {
        throw new TypeError(UNIT_ERROR);
      }
      if (typeof unit !== "string") {
        throw new RangeError("".concat(UNIT_ERROR, ": ").concat(unit));
      }
      if (unit[unit.length - 1] === "s") {
        unit = unit.slice(0, unit.length - 1);
      }
      if (UNITS.indexOf(unit) < 0) {
        throw new RangeError("".concat(UNIT_ERROR, ": ").concat(unit));
      }
      return unit;
    }
    var NUMBER_ERROR = 'Invalid "number" argument';
    function parseNumber(value) {
      value = Number(value);
      if (Number.isFinite) {
        if (!Number.isFinite(value)) {
          throw new RangeError("".concat(NUMBER_ERROR, ": ").concat(value));
        }
      }
      return value;
    }
    function isNegativeZero(number2) {
      return 1 / number2 === -Infinity;
    }
    function isNegative(number2) {
      return number2 < 0 || number2 === 0 && isNegativeZero(number2);
    }
    function parseFormatArgs(args) {
      if (args.length < 2) {
        throw new TypeError('"unit" argument is required');
      }
      return [parseNumber(args[0]), parseUnit(args[1])];
    }
    function _typeof$4(obj) {
      "@babel/helpers - typeof";
      return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof$4(obj);
    }
    function _classCallCheck$1(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties$1(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass$1(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties$1(Constructor.prototype, protoProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    var Cache = /* @__PURE__ */ function() {
      function Cache2() {
        _classCallCheck$1(this, Cache2);
        this.cache = {};
      }
      _createClass$1(Cache2, [{
        key: "get",
        value: function get2() {
          var cache2 = this.cache;
          for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {
            keys[_key] = arguments[_key];
          }
          for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
            var key2 = _keys[_i];
            if (_typeof$4(cache2) !== "object") {
              return;
            }
            cache2 = cache2[key2];
          }
          return cache2;
        }
      }, {
        key: "put",
        value: function put() {
          for (var _len2 = arguments.length, keys = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            keys[_key2] = arguments[_key2];
          }
          var value = keys.pop();
          var lastKey = keys.pop();
          var cache2 = this.cache;
          for (var _i2 = 0, _keys2 = keys; _i2 < _keys2.length; _i2++) {
            var key2 = _keys2[_i2];
            if (_typeof$4(cache2[key2]) !== "object") {
              cache2[key2] = {};
            }
            cache2 = cache2[key2];
          }
          return cache2[lastKey] = value;
        }
      }]);
      return Cache2;
    }();
    function _typeof$3(obj) {
      "@babel/helpers - typeof";
      return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof$3(obj);
    }
    function _createForOfIteratorHelperLoose$1(o3, allowArrayLike) {
      var it2 = typeof Symbol !== "undefined" && o3[Symbol.iterator] || o3["@@iterator"];
      if (it2)
        return (it2 = it2.call(o3)).next.bind(it2);
      if (Array.isArray(o3) || (it2 = _unsupportedIterableToArray$1(o3)) || allowArrayLike) {
        if (it2)
          o3 = it2;
        var i2 = 0;
        return function() {
          if (i2 >= o3.length)
            return { done: true };
          return { done: false, value: o3[i2++] };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray$1(o3, minLen) {
      if (!o3)
        return;
      if (typeof o3 === "string")
        return _arrayLikeToArray$1(o3, minLen);
      var n2 = Object.prototype.toString.call(o3).slice(8, -1);
      if (n2 === "Object" && o3.constructor)
        n2 = o3.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o3);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray$1(o3, minLen);
    }
    function _arrayLikeToArray$1(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
        arr2[i2] = arr[i2];
      }
      return arr2;
    }
    function chooseLocale(locales, isLocaleDataAvailable) {
      for (var _iterator = _createForOfIteratorHelperLoose$1(locales), _step; !(_step = _iterator()).done; ) {
        var locale = _step.value;
        if (isLocaleDataAvailable(locale)) {
          return locale;
        }
        var parts = locale.split("-");
        while (parts.length > 1) {
          parts.pop();
          locale = parts.join("-");
          if (isLocaleDataAvailable(locale)) {
            return locale;
          }
        }
      }
      throw new Error("No locale data has been registered for any of the locales: ".concat(locales.join(", ")));
    }
    function intlDateTimeFormatSupported() {
      var isIntlAvailable = (typeof Intl === "undefined" ? "undefined" : _typeof$3(Intl)) === "object";
      return isIntlAvailable && typeof Intl.DateTimeFormat === "function";
    }
    function _typeof$2(obj) {
      "@babel/helpers - typeof";
      return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof$2(obj);
    }
    function isStyleObject(object) {
      return isObject(object) && (Array.isArray(object.steps) || // `gradation` property is deprecated: it has been renamed to `steps`.
      Array.isArray(object.gradation) || // `flavour` property is deprecated: it has been renamed to `labels`.
      Array.isArray(object.flavour) || typeof object.flavour === "string" || Array.isArray(object.labels) || typeof object.labels === "string" || // `units` property is deprecated.
      Array.isArray(object.units) || // `custom` property is deprecated.
      typeof object.custom === "function");
    }
    var OBJECT_CONSTRUCTOR = {}.constructor;
    function isObject(object) {
      return _typeof$2(object) !== void 0 && object !== null && object.constructor === OBJECT_CONSTRUCTOR;
    }
    var minute = 60;
    var hour = 60 * minute;
    var day = 24 * hour;
    var week = 7 * day;
    var month = 30.44 * day;
    var year = 146097 / 400 * day;
    function getSecondsInUnit(unit) {
      switch (unit) {
        case "second":
          return 1;
        case "minute":
          return minute;
        case "hour":
          return hour;
        case "day":
          return day;
        case "week":
          return week;
        case "month":
          return month;
        case "year":
          return year;
      }
    }
    function getStepDenominator(step) {
      if (step.factor !== void 0) {
        return step.factor;
      }
      return getSecondsInUnit(step.unit || step.formatAs) || 1;
    }
    function getRoundFunction(round2) {
      switch (round2) {
        case "floor":
          return Math.floor;
        default:
          return Math.round;
      }
    }
    function getDiffRatioToNextRoundedNumber(round2) {
      switch (round2) {
        case "floor":
          return 1;
        default:
          return 0.5;
      }
    }
    function _typeof$1(obj) {
      "@babel/helpers - typeof";
      return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof$1(obj);
    }
    function getStepMinTime(step, _ref) {
      var prevStep = _ref.prevStep, timestamp = _ref.timestamp, now = _ref.now, future = _ref.future, round2 = _ref.round;
      var minTime;
      if (prevStep) {
        if (prevStep.id || prevStep.unit) {
          minTime = step["threshold_for_".concat(prevStep.id || prevStep.unit)];
        }
      }
      if (minTime === void 0) {
        if (step.threshold !== void 0) {
          minTime = step.threshold;
          if (typeof minTime === "function") {
            minTime = minTime(now, future);
          }
        }
      }
      if (minTime === void 0) {
        minTime = step.minTime;
      }
      if (_typeof$1(minTime) === "object") {
        if (prevStep && prevStep.id && minTime[prevStep.id] !== void 0) {
          minTime = minTime[prevStep.id];
        } else {
          minTime = minTime["default"];
        }
      }
      if (typeof minTime === "function") {
        minTime = minTime(timestamp, {
          future,
          getMinTimeForUnit: function getMinTimeForUnit(toUnit, fromUnit) {
            return _getMinTimeForUnit(toUnit, fromUnit || prevStep && prevStep.formatAs, {
              round: round2
            });
          }
        });
      }
      if (minTime === void 0) {
        if (step.test) {
          if (step.test(timestamp, {
            now,
            future
          })) {
            minTime = 0;
          } else {
            minTime = 9007199254740991;
          }
        }
      }
      if (minTime === void 0) {
        if (prevStep) {
          if (step.formatAs && prevStep.formatAs) {
            minTime = _getMinTimeForUnit(step.formatAs, prevStep.formatAs, {
              round: round2
            });
          }
        } else {
          minTime = 0;
        }
      }
      if (minTime === void 0) {
        console.warn("[javascript-time-ago] A step should specify `minTime`:\n" + JSON.stringify(step, null, 2));
      }
      return minTime;
    }
    function _getMinTimeForUnit(toUnit, fromUnit, _ref2) {
      var round2 = _ref2.round;
      var toUnitAmount = getSecondsInUnit(toUnit);
      var fromUnitAmount;
      if (fromUnit === "now") {
        fromUnitAmount = getSecondsInUnit(toUnit);
      } else {
        fromUnitAmount = getSecondsInUnit(fromUnit);
      }
      if (toUnitAmount !== void 0 && fromUnitAmount !== void 0) {
        return toUnitAmount - fromUnitAmount * (1 - getDiffRatioToNextRoundedNumber(round2));
      }
    }
    function ownKeys$8(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols2 = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols2 = symbols2.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols2);
      }
      return keys;
    }
    function _objectSpread$8(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? ownKeys$8(Object(source), true).forEach(function(key2) {
          _defineProperty$8(target, key2, source[key2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$8(Object(source)).forEach(function(key2) {
          Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
        });
      }
      return target;
    }
    function _defineProperty$8(obj, key2, value) {
      if (key2 in obj) {
        Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key2] = value;
      }
      return obj;
    }
    function getStep(steps2, secondsPassed, _ref) {
      var now = _ref.now, future = _ref.future, round2 = _ref.round, units = _ref.units;
      steps2 = filterStepsByUnits(steps2, units);
      var step = _getStep(steps2, secondsPassed, {
        now,
        future,
        round: round2
      });
      {
        if (step) {
          var prevStep = steps2[steps2.indexOf(step) - 1];
          var nextStep = steps2[steps2.indexOf(step) + 1];
          return [prevStep, step, nextStep];
        }
        return [void 0, void 0, steps2[0]];
      }
    }
    function _getStep(steps2, secondsPassed, _ref2) {
      var now = _ref2.now, future = _ref2.future, round2 = _ref2.round;
      if (steps2.length === 0) {
        return;
      }
      var i2 = getStepIndex(steps2, secondsPassed, {
        now,
        future: future || secondsPassed < 0,
        round: round2
      });
      if (i2 === -1) {
        return;
      }
      var step = steps2[i2];
      if (step.granularity) {
        var secondsPassedGranular = getRoundFunction(round2)(Math.abs(secondsPassed) / getStepDenominator(step) / step.granularity) * step.granularity;
        if (secondsPassedGranular === 0 && i2 > 0) {
          return steps2[i2 - 1];
        }
      }
      return step;
    }
    function getStepIndex(steps2, secondsPassed, options) {
      var i2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      var minTime = getStepMinTime(steps2[i2], _objectSpread$8({
        prevStep: steps2[i2 - 1],
        timestamp: options.now - secondsPassed * 1e3
      }, options));
      if (minTime === void 0) {
        return i2 - 1;
      }
      if (Math.abs(secondsPassed) < minTime) {
        return i2 - 1;
      }
      if (i2 === steps2.length - 1) {
        return i2;
      }
      return getStepIndex(steps2, secondsPassed, options, i2 + 1);
    }
    function filterStepsByUnits(steps2, units) {
      return steps2.filter(function(_ref3) {
        var unit = _ref3.unit, formatAs = _ref3.formatAs;
        unit = unit || formatAs;
        if (unit) {
          return units.indexOf(unit) >= 0;
        }
        return true;
      });
    }
    function getTimeToNextUpdateForUnit(unit, timestamp, _ref) {
      var now = _ref.now, round2 = _ref.round;
      if (!getSecondsInUnit(unit)) {
        return;
      }
      var unitDenominator = getSecondsInUnit(unit) * 1e3;
      var future = timestamp > now;
      var preciseAmount = Math.abs(timestamp - now);
      var roundedAmount = getRoundFunction(round2)(preciseAmount / unitDenominator) * unitDenominator;
      if (future) {
        if (roundedAmount > 0) {
          return preciseAmount - roundedAmount + getDiffToPreviousRoundedNumber(round2, unitDenominator);
        } else {
          return preciseAmount - roundedAmount + 1;
        }
      }
      return -(preciseAmount - roundedAmount) + getDiffToNextRoundedNumber(round2, unitDenominator);
    }
    function getDiffToNextRoundedNumber(round2, unitDenominator) {
      return getDiffRatioToNextRoundedNumber(round2) * unitDenominator;
    }
    function getDiffToPreviousRoundedNumber(round2, unitDenominator) {
      return (1 - getDiffRatioToNextRoundedNumber(round2)) * unitDenominator + 1;
    }
    var YEAR = 365 * 24 * 60 * 60 * 1e3;
    var INFINITY = 1e3 * YEAR;
    function getTimeToNextUpdate(date2, step, _ref) {
      var prevStep = _ref.prevStep, nextStep = _ref.nextStep, now = _ref.now, future = _ref.future, round2 = _ref.round;
      var timestamp = date2.getTime ? date2.getTime() : date2;
      var getTimeToNextUpdateForUnit$1 = function getTimeToNextUpdateForUnit$12(unit2) {
        return getTimeToNextUpdateForUnit(unit2, timestamp, {
          now,
          round: round2
        });
      };
      var timeToStepChange = getTimeToStepChange(future ? step : nextStep, timestamp, {
        future,
        now,
        round: round2,
        prevStep: future ? prevStep : step
        // isFirstStep: future && isFirstStep
      });
      if (timeToStepChange === void 0) {
        return;
      }
      var timeToNextUpdate;
      if (step) {
        if (step.getTimeToNextUpdate) {
          timeToNextUpdate = step.getTimeToNextUpdate(timestamp, {
            getTimeToNextUpdateForUnit: getTimeToNextUpdateForUnit$1,
            getRoundFunction,
            now,
            future,
            round: round2
          });
        }
        if (timeToNextUpdate === void 0) {
          var unit = step.unit || step.formatAs;
          if (unit) {
            timeToNextUpdate = getTimeToNextUpdateForUnit$1(unit);
          }
        }
      }
      if (timeToNextUpdate === void 0) {
        return timeToStepChange;
      }
      return Math.min(timeToNextUpdate, timeToStepChange);
    }
    function getStepChangesAt(currentOrNextStep, timestamp, _ref2) {
      var now = _ref2.now, future = _ref2.future, round2 = _ref2.round, prevStep = _ref2.prevStep;
      var minTime = getStepMinTime(currentOrNextStep, {
        timestamp,
        now,
        future,
        round: round2,
        prevStep
      });
      if (minTime === void 0) {
        return;
      }
      if (future) {
        return timestamp - minTime * 1e3 + 1;
      } else {
        if (minTime === 0 && timestamp === now) {
          return INFINITY;
        }
        return timestamp + minTime * 1e3;
      }
    }
    function getTimeToStepChange(step, timestamp, _ref3) {
      var now = _ref3.now, future = _ref3.future, round2 = _ref3.round, prevStep = _ref3.prevStep;
      if (step) {
        var stepChangesAt = getStepChangesAt(step, timestamp, {
          now,
          future,
          round: round2,
          prevStep
        });
        if (stepChangesAt === void 0) {
          return;
        }
        return stepChangesAt - now;
      } else {
        if (future) {
          return timestamp - now + 1;
        } else {
          return INFINITY;
        }
      }
    }
    var localesData = {};
    function getLocaleData(locale) {
      return localesData[locale];
    }
    function addLocaleData(localeData) {
      if (!localeData) {
        throw new Error("[javascript-time-ago] No locale data passed.");
      }
      localesData[localeData.locale] = localeData;
    }
    const round$1 = [{
      formatAs: "now"
    }, {
      formatAs: "second"
    }, {
      formatAs: "minute"
    }, {
      formatAs: "hour"
    }, {
      formatAs: "day"
    }, {
      formatAs: "week"
    }, {
      formatAs: "month"
    }, {
      formatAs: "year"
    }];
    const round = {
      steps: round$1,
      labels: "long"
    };
    function ownKeys$7(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols2 = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols2 = symbols2.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols2);
      }
      return keys;
    }
    function _objectSpread$7(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? ownKeys$7(Object(source), true).forEach(function(key2) {
          _defineProperty$7(target, key2, source[key2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$7(Object(source)).forEach(function(key2) {
          Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
        });
      }
      return target;
    }
    function _defineProperty$7(obj, key2, value) {
      if (key2 in obj) {
        Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key2] = value;
      }
      return obj;
    }
    const defaultStyle = _objectSpread$7(_objectSpread$7({}, round), {}, {
      // Skip "seconds".
      steps: round.steps.filter(function(step) {
        return step.formatAs !== "second";
      })
    });
    const approximate$1 = [{
      // This step returns the amount of seconds
      // by dividing the amount of seconds by `1`.
      factor: 1,
      // "now" labels are used for formatting the output.
      unit: "now"
    }, {
      // When the language doesn't support `now` unit,
      // the first step is ignored, and it uses this `second` unit.
      threshold: 1,
      // `threshold_for_now` should be the same as `threshold` on minutes.
      threshold_for_now: 45.5,
      // This step returns the amount of seconds
      // by dividing the amount of seconds by `1`.
      factor: 1,
      // "second" labels are used for formatting the output.
      unit: "second"
    }, {
      // `threshold` should be the same as `threshold_for_now` on seconds.
      threshold: 45.5,
      // Return the amount of minutes by dividing the amount
      // of seconds by the amount of seconds in a minute.
      factor: minute,
      // "minute" labels are used for formatting the output.
      unit: "minute"
    }, {
      // This step is effective starting from 2.5 minutes.
      threshold: 2.5 * minute,
      // Allow only 5-minute increments of minutes starting from 2.5 minutes.
      // `granularity` — (advanced) Time interval value "granularity".
      // For example, it could be set to `5` for minutes to allow only 5-minute increments
      // when formatting time intervals: `0 minutes`, `5 minutes`, `10 minutes`, etc.
      // Perhaps this feature will be removed because there seem to be no use cases
      // of it in the real world.
      granularity: 5,
      // Return the amount of minutes by dividing the amount
      // of seconds by the amount of seconds in a minute.
      factor: minute,
      // "minute" labels are used for formatting the output.
      unit: "minute"
    }, {
      // This step is effective starting from 22.5 minutes.
      threshold: 22.5 * minute,
      // Return the amount of minutes by dividing the amount
      // of seconds by the amount of seconds in  half-an-hour.
      factor: 0.5 * hour,
      // "half-hour" labels are used for formatting the output.
      // (if available, which is no longer the case)
      unit: "half-hour"
    }, {
      // This step is effective starting from 42.5 minutes.
      threshold: 42.5 * minute,
      threshold_for_minute: 52.5 * minute,
      // Return the amount of minutes by dividing the amount
      // of seconds by the amount of seconds in an hour.
      factor: hour,
      // "hour" labels are used for formatting the output.
      unit: "hour"
    }, {
      // This step is effective starting from 20.5 hours.
      threshold: 20.5 / 24 * day,
      // Return the amount of minutes by dividing the amount
      // of seconds by the amount of seconds in a day.
      factor: day,
      // "day" labels are used for formatting the output.
      unit: "day"
    }, {
      // This step is effective starting from 5.5 days.
      threshold: 5.5 * day,
      // Return the amount of minutes by dividing the amount
      // of seconds by the amount of seconds in a week.
      factor: week,
      // "week" labels are used for formatting the output.
      unit: "week"
    }, {
      // This step is effective starting from 3.5 weeks.
      threshold: 3.5 * week,
      // Return the amount of minutes by dividing the amount
      // of seconds by the amount of seconds in a month.
      factor: month,
      // "month" labels are used for formatting the output.
      unit: "month"
    }, {
      // This step is effective starting from 10.5 months.
      threshold: 10.5 * month,
      // Return the amount of minutes by dividing the amount
      // of seconds by the amount of seconds in a year.
      factor: year,
      // "year" labels are used for formatting the output.
      unit: "year"
    }];
    const approximate = {
      gradation: approximate$1,
      flavour: "long",
      units: ["now", "minute", "hour", "day", "week", "month", "year"]
    };
    const approximateTime = {
      gradation: approximate$1,
      flavour: "long-time",
      units: ["now", "minute", "hour", "day", "week", "month", "year"]
    };
    function getDate(value) {
      return value instanceof Date ? value : new Date(value);
    }
    var steps = [{
      formatAs: "second"
    }, {
      formatAs: "minute"
    }, {
      formatAs: "hour"
    }];
    var formatters = {};
    var monthAndDay = {
      minTime: function minTime(timestamp, _ref) {
        _ref.future;
        var getMinTimeForUnit = _ref.getMinTimeForUnit;
        return getMinTimeForUnit("day");
      },
      format: function format2(value, locale) {
        if (!formatters[locale]) {
          formatters[locale] = {};
        }
        if (!formatters[locale].dayMonth) {
          formatters[locale].dayMonth = new Intl.DateTimeFormat(locale, {
            month: "short",
            day: "numeric"
          });
        }
        return formatters[locale].dayMonth.format(getDate(value));
      }
    };
    var yearMonthAndDay = {
      minTime: function minTime(timestamp, _ref2) {
        var future = _ref2.future;
        if (future) {
          var maxFittingNow = new Date(new Date(timestamp).getFullYear(), 0).getTime() - 1;
          return (timestamp - maxFittingNow) / 1e3;
        } else {
          var minFittingNow = new Date(new Date(timestamp).getFullYear() + 1, 0).getTime();
          return (minFittingNow - timestamp) / 1e3;
        }
      },
      format: function format2(value, locale) {
        if (!formatters[locale]) {
          formatters[locale] = {};
        }
        if (!formatters[locale].dayMonthYear) {
          formatters[locale].dayMonthYear = new Intl.DateTimeFormat(locale, {
            year: "numeric",
            month: "short",
            day: "numeric"
          });
        }
        return formatters[locale].dayMonthYear.format(getDate(value));
      }
    };
    if (intlDateTimeFormatSupported()) {
      steps.push(monthAndDay, yearMonthAndDay);
    } else {
      steps.push({
        formatAs: "day"
      }, {
        formatAs: "week"
      }, {
        formatAs: "month"
      }, {
        formatAs: "year"
      });
    }
    const twitter = {
      steps,
      labels: [
        // "mini" labels are only defined for a few languages.
        "mini",
        // "short-time" labels are only defined for a few languages.
        "short-time",
        // "narrow" and "short" labels are defined for all languages.
        // "narrow" labels can sometimes be weird (like "+5d."),
        // but "short" labels have the " ago" part, so "narrow" seem
        // more appropriate.
        // "short" labels would have been more appropriate if they
        // didn't have the " ago" part, hence the "short-time" above.
        "narrow",
        // Since "narrow" labels are always present, "short" element
        // of this array can be removed.
        "short"
      ]
    };
    function ownKeys$6(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols2 = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols2 = symbols2.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols2);
      }
      return keys;
    }
    function _objectSpread$6(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? ownKeys$6(Object(source), true).forEach(function(key2) {
          _defineProperty$6(target, key2, source[key2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$6(Object(source)).forEach(function(key2) {
          Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
        });
      }
      return target;
    }
    function _defineProperty$6(obj, key2, value) {
      if (key2 in obj) {
        Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key2] = value;
      }
      return obj;
    }
    const twitterNow = _objectSpread$6(_objectSpread$6({}, twitter), {}, {
      // Add "now".
      steps: [{
        formatAs: "now"
      }].concat(twitter.steps)
    });
    function ownKeys$5(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols2 = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols2 = symbols2.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols2);
      }
      return keys;
    }
    function _objectSpread$5(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? ownKeys$5(Object(source), true).forEach(function(key2) {
          _defineProperty$5(target, key2, source[key2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function(key2) {
          Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
        });
      }
      return target;
    }
    function _defineProperty$5(obj, key2, value) {
      if (key2 in obj) {
        Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key2] = value;
      }
      return obj;
    }
    const twitterMinute = _objectSpread$5(_objectSpread$5({}, twitter), {}, {
      // Skip "seconds".
      steps: twitter.steps.filter(function(step) {
        return step.formatAs !== "second";
      })
    });
    function ownKeys$4(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols2 = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols2 = symbols2.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols2);
      }
      return keys;
    }
    function _objectSpread$4(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? ownKeys$4(Object(source), true).forEach(function(key2) {
          _defineProperty$4(target, key2, source[key2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function(key2) {
          Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
        });
      }
      return target;
    }
    function _defineProperty$4(obj, key2, value) {
      if (key2 in obj) {
        Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key2] = value;
      }
      return obj;
    }
    const twitterMinuteNow = _objectSpread$4(_objectSpread$4({}, twitterMinute), {}, {
      // Add "now".
      steps: [{
        formatAs: "now"
      }].concat(twitterMinute.steps)
    });
    function ownKeys$3(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols2 = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols2 = symbols2.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols2);
      }
      return keys;
    }
    function _objectSpread$3(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? ownKeys$3(Object(source), true).forEach(function(key2) {
          _defineProperty$3(target, key2, source[key2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function(key2) {
          Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
        });
      }
      return target;
    }
    function _defineProperty$3(obj, key2, value) {
      if (key2 in obj) {
        Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key2] = value;
      }
      return obj;
    }
    const twitterFirstMinute = _objectSpread$3(_objectSpread$3({}, twitter), {}, {
      // Skip "seconds".
      steps: twitter.steps.filter(function(step) {
        return step.formatAs !== "second";
      }).map(function(step) {
        return step.formatAs === "minute" ? _objectSpread$3(_objectSpread$3({}, step), {}, {
          minTime: minute
        }) : step;
      })
    });
    const mini = {
      steps: [{
        formatAs: "second"
      }, {
        formatAs: "minute"
      }, {
        formatAs: "hour"
      }, {
        formatAs: "day"
      }, {
        formatAs: "month"
      }, {
        formatAs: "year"
      }],
      labels: [
        // "mini" labels are only defined for a few languages.
        "mini",
        // "short-time" labels are only defined for a few languages.
        "short-time",
        // "narrow" and "short" labels are defined for all languages.
        // "narrow" labels can sometimes be weird (like "+5d."),
        // but "short" labels have the " ago" part, so "narrow" seem
        // more appropriate.
        // "short" labels would have been more appropriate if they
        // didn't have the " ago" part, hence the "short-time" above.
        "narrow",
        // Since "narrow" labels are always present, "short" element
        // of this array can be removed.
        "short"
      ]
    };
    function ownKeys$2(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols2 = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols2 = symbols2.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols2);
      }
      return keys;
    }
    function _objectSpread$2(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? ownKeys$2(Object(source), true).forEach(function(key2) {
          _defineProperty$2(target, key2, source[key2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function(key2) {
          Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
        });
      }
      return target;
    }
    function _defineProperty$2(obj, key2, value) {
      if (key2 in obj) {
        Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key2] = value;
      }
      return obj;
    }
    const miniNow = _objectSpread$2(_objectSpread$2({}, mini), {}, {
      // Add "now".
      steps: [{
        formatAs: "now"
      }].concat(mini.steps)
    });
    function ownKeys$1(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols2 = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols2 = symbols2.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols2);
      }
      return keys;
    }
    function _objectSpread$1(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? ownKeys$1(Object(source), true).forEach(function(key2) {
          _defineProperty$1(target, key2, source[key2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key2) {
          Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
        });
      }
      return target;
    }
    function _defineProperty$1(obj, key2, value) {
      if (key2 in obj) {
        Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key2] = value;
      }
      return obj;
    }
    const miniMinute = _objectSpread$1(_objectSpread$1({}, mini), {}, {
      // Skip "seconds".
      steps: mini.steps.filter(function(step) {
        return step.formatAs !== "second";
      })
    });
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols2 = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols2 = symbols2.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols2);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? ownKeys(Object(source), true).forEach(function(key2) {
          _defineProperty(target, key2, source[key2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key2) {
          Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
        });
      }
      return target;
    }
    function _defineProperty(obj, key2, value) {
      if (key2 in obj) {
        Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key2] = value;
      }
      return obj;
    }
    const miniMinuteNow = _objectSpread(_objectSpread({}, miniMinute), {}, {
      // Add "now".
      steps: [{
        formatAs: "now"
      }].concat(miniMinute.steps)
    });
    function getStyleByName(style) {
      switch (style) {
        case "default":
        case "round":
          return round;
        case "round-minute":
          return defaultStyle;
        case "approximate":
          return approximate;
        case "time":
        case "approximate-time":
          return approximateTime;
        case "mini":
          return mini;
        case "mini-now":
          return miniNow;
        case "mini-minute":
          return miniMinute;
        case "mini-minute-now":
          return miniMinuteNow;
        case "twitter":
          return twitter;
        case "twitter-now":
          return twitterNow;
        case "twitter-minute":
          return twitterMinute;
        case "twitter-minute-now":
          return twitterMinuteNow;
        case "twitter-first-minute":
          return twitterFirstMinute;
        default:
          return approximate;
      }
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    function _createForOfIteratorHelperLoose(o3, allowArrayLike) {
      var it2 = typeof Symbol !== "undefined" && o3[Symbol.iterator] || o3["@@iterator"];
      if (it2)
        return (it2 = it2.call(o3)).next.bind(it2);
      if (Array.isArray(o3) || (it2 = _unsupportedIterableToArray(o3)) || allowArrayLike) {
        if (it2)
          o3 = it2;
        var i2 = 0;
        return function() {
          if (i2 >= o3.length)
            return { done: true };
          return { done: false, value: o3[i2++] };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _slicedToArray(arr, i2) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o3, minLen) {
      if (!o3)
        return;
      if (typeof o3 === "string")
        return _arrayLikeToArray(o3, minLen);
      var n2 = Object.prototype.toString.call(o3).slice(8, -1);
      if (n2 === "Object" && o3.constructor)
        n2 = o3.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o3);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return _arrayLikeToArray(o3, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
        arr2[i2] = arr[i2];
      }
      return arr2;
    }
    function _iterableToArrayLimit(arr, i2) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e2;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i2 && _arr.length === i2)
            break;
        }
      } catch (err) {
        _d = true;
        _e2 = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e2;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    var TimeAgo = /* @__PURE__ */ function() {
      function TimeAgo2() {
        var locales = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, polyfill = _ref.polyfill;
        _classCallCheck(this, TimeAgo2);
        if (typeof locales === "string") {
          locales = [locales];
        }
        this.locale = chooseLocale(locales.concat(TimeAgo2.getDefaultLocale()), getLocaleData);
        if (typeof Intl !== "undefined") {
          if (Intl.NumberFormat) {
            this.numberFormat = new Intl.NumberFormat(this.locale);
          }
        }
        if (polyfill === false) {
          this.IntlRelativeTimeFormat = Intl.RelativeTimeFormat;
          this.IntlPluralRules = Intl.PluralRules;
        } else {
          this.IntlRelativeTimeFormat = RelativeTimeFormat;
          this.IntlPluralRules = RelativeTimeFormat.PluralRules;
        }
        this.relativeTimeFormatCache = new Cache();
        this.pluralRulesCache = new Cache();
      }
      _createClass(TimeAgo2, [{
        key: "format",
        value: function format2(input, style, options) {
          if (!options) {
            if (style && !isStyle(style)) {
              options = style;
              style = void 0;
            } else {
              options = {};
            }
          }
          if (!style) {
            style = defaultStyle;
          }
          if (typeof style === "string") {
            style = getStyleByName(style);
          }
          var timestamp = getTimestamp(input);
          var _this$getLabels = this.getLabels(style.flavour || style.labels), labels = _this$getLabels.labels, labelsType = _this$getLabels.labelsType;
          var now;
          if (style.now !== void 0) {
            now = style.now;
          }
          if (now === void 0 && options.now !== void 0) {
            now = options.now;
          }
          if (now === void 0) {
            now = Date.now();
          }
          var secondsPassed = (now - timestamp) / 1e3;
          var future = options.future || secondsPassed < 0;
          var nowLabel = getNowLabel(labels, getLocaleData(this.locale).now, getLocaleData(this.locale)["long"], future);
          if (style.custom) {
            var custom = style.custom({
              now,
              date: new Date(timestamp),
              time: timestamp,
              elapsed: secondsPassed,
              locale: this.locale
            });
            if (custom !== void 0) {
              return custom;
            }
          }
          var units = getTimeIntervalMeasurementUnits(
            // Controlling `style.steps` through `style.units` seems to be deprecated:
            // create a new custom `style` instead.
            style.units,
            labels,
            nowLabel
          );
          var round2 = options.round || style.round;
          var _getStep2 = getStep(
            // "gradation" is a legacy name for "steps".
            // For historical reasons, "approximate" steps are used by default.
            // In the next major version, there'll be no default for `steps`.
            style.gradation || style.steps || defaultStyle.steps,
            secondsPassed,
            {
              now,
              units,
              round: round2,
              future,
              getNextStep: true
            }
          ), _getStep22 = _slicedToArray(_getStep2, 3), prevStep = _getStep22[0], step = _getStep22[1], nextStep = _getStep22[2];
          var formattedDate = this.formatDateForStep(timestamp, step, secondsPassed, {
            labels,
            labelsType,
            nowLabel,
            now,
            future,
            round: round2
          }) || "";
          if (options.getTimeToNextUpdate) {
            var timeToNextUpdate = getTimeToNextUpdate(timestamp, step, {
              nextStep,
              prevStep,
              now,
              future,
              round: round2
            });
            return [formattedDate, timeToNextUpdate];
          }
          return formattedDate;
        }
      }, {
        key: "formatDateForStep",
        value: function formatDateForStep(timestamp, step, secondsPassed, _ref2) {
          var _this = this;
          var labels = _ref2.labels, labelsType = _ref2.labelsType, nowLabel = _ref2.nowLabel, now = _ref2.now, future = _ref2.future, round2 = _ref2.round;
          if (!step) {
            return;
          }
          if (step.format) {
            return step.format(timestamp, this.locale, {
              formatAs: function formatAs(unit2, value) {
                return _this.formatValue(value, unit2, {
                  labels,
                  future
                });
              },
              now,
              future
            });
          }
          var unit = step.unit || step.formatAs;
          if (!unit) {
            throw new Error("[javascript-time-ago] Each step must define either `formatAs` or `format()`. Step: ".concat(JSON.stringify(step)));
          }
          if (unit === "now") {
            return nowLabel;
          }
          var amount = Math.abs(secondsPassed) / getStepDenominator(step);
          if (step.granularity) {
            amount = getRoundFunction(round2)(amount / step.granularity) * step.granularity;
          }
          var valueForFormatting = -1 * Math.sign(secondsPassed) * getRoundFunction(round2)(amount);
          if (valueForFormatting === 0) {
            if (future) {
              valueForFormatting = 0;
            } else {
              valueForFormatting = -0;
            }
          }
          switch (labelsType) {
            case "long":
            case "short":
            case "narrow":
              return this.getFormatter(labelsType).format(valueForFormatting, unit);
            default:
              return this.formatValue(valueForFormatting, unit, {
                labels,
                future
              });
          }
        }
        /**
         * Mimicks what `Intl.RelativeTimeFormat` does for additional locale styles.
         * @param  {number} value
         * @param  {string} unit
         * @param  {object} options.labels — Relative time labels.
         * @param  {boolean} [options.future] — Tells how to format value `0`: as "future" (`true`) or "past" (`false`). Is `false` by default, but should have been `true` actually.
         * @return {string}
         */
      }, {
        key: "formatValue",
        value: function formatValue(value, unit, _ref3) {
          var labels = _ref3.labels, future = _ref3.future;
          return this.getFormattingRule(labels, unit, value, {
            future
          }).replace("{0}", this.formatNumber(Math.abs(value)));
        }
        /**
         * Returns formatting rule for `value` in `units` (either in past or in future).
         * @param {object} formattingRules — Relative time labels for different units.
         * @param {string} unit - Time interval measurement unit.
         * @param {number} value - Time interval value.
         * @param  {boolean} [options.future] — Tells how to format value `0`: as "future" (`true`) or "past" (`false`). Is `false` by default.
         * @return {string}
         * @example
         * // Returns "{0} days ago"
         * getFormattingRule(en.long, "day", -2, 'en')
         */
      }, {
        key: "getFormattingRule",
        value: function getFormattingRule(formattingRules, unit, value, _ref4) {
          var future = _ref4.future;
          this.locale;
          formattingRules = formattingRules[unit];
          if (typeof formattingRules === "string") {
            return formattingRules;
          }
          var pastOrFuture = value === 0 ? future ? "future" : "past" : value < 0 ? "past" : "future";
          var quantifierRules = formattingRules[pastOrFuture] || formattingRules;
          if (typeof quantifierRules === "string") {
            return quantifierRules;
          }
          var quantifier = this.getPluralRules().select(Math.abs(value));
          return quantifierRules[quantifier] || quantifierRules.other;
        }
        /**
         * Formats a number into a string.
         * Uses `Intl.NumberFormat` when available.
         * @param  {number} number
         * @return {string}
         */
      }, {
        key: "formatNumber",
        value: function formatNumber(number2) {
          return this.numberFormat ? this.numberFormat.format(number2) : String(number2);
        }
        /**
         * Returns an `Intl.RelativeTimeFormat` for a given `labelsType`.
         * @param {string} labelsType
         * @return {object} `Intl.RelativeTimeFormat` instance
         */
      }, {
        key: "getFormatter",
        value: function getFormatter(labelsType) {
          return this.relativeTimeFormatCache.get(this.locale, labelsType) || this.relativeTimeFormatCache.put(this.locale, labelsType, new this.IntlRelativeTimeFormat(this.locale, {
            style: labelsType
          }));
        }
        /**
         * Returns an `Intl.PluralRules` instance.
         * @return {object} `Intl.PluralRules` instance
         */
      }, {
        key: "getPluralRules",
        value: function getPluralRules() {
          return this.pluralRulesCache.get(this.locale) || this.pluralRulesCache.put(this.locale, new this.IntlPluralRules(this.locale));
        }
        /**
         * Gets localized labels for this type of labels.
         *
         * @param {(string|string[])} labelsType - Relative date/time labels type.
         *                                     If it's an array then all label types are tried
         *                                     until a suitable one is found.
         *
         * @returns {Object} Returns an object of shape { labelsType, labels }
         */
      }, {
        key: "getLabels",
        value: function getLabels() {
          var labelsType = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
          if (typeof labelsType === "string") {
            labelsType = [labelsType];
          }
          labelsType = labelsType.map(function(labelsType2) {
            switch (labelsType2) {
              case "tiny":
              case "mini-time":
                return "mini";
              default:
                return labelsType2;
            }
          });
          labelsType = labelsType.concat("long");
          var localeData = getLocaleData(this.locale);
          for (var _iterator = _createForOfIteratorHelperLoose(labelsType), _step; !(_step = _iterator()).done; ) {
            var _labelsType = _step.value;
            if (localeData[_labelsType]) {
              return {
                labelsType: _labelsType,
                labels: localeData[_labelsType]
              };
            }
          }
        }
      }]);
      return TimeAgo2;
    }();
    var defaultLocale = "en";
    TimeAgo.getDefaultLocale = function() {
      return defaultLocale;
    };
    TimeAgo.setDefaultLocale = function(locale) {
      return defaultLocale = locale;
    };
    TimeAgo.addDefaultLocale = function(localeData) {
      if (defaultLocaleHasBeenSpecified) {
        return console.error("[javascript-time-ago] `TimeAgo.addDefaultLocale()` can only be called once. To add other locales, use `TimeAgo.addLocale()`.");
      }
      defaultLocaleHasBeenSpecified = true;
      TimeAgo.setDefaultLocale(localeData.locale);
      TimeAgo.addLocale(localeData);
    };
    var defaultLocaleHasBeenSpecified;
    TimeAgo.addLocale = function(localeData) {
      addLocaleData(localeData);
      RelativeTimeFormat.addLocale(localeData);
    };
    TimeAgo.locale = TimeAgo.addLocale;
    TimeAgo.addLabels = function(locale, name, labels) {
      var localeData = getLocaleData(locale);
      if (!localeData) {
        addLocaleData({
          locale
        });
        localeData = getLocaleData(locale);
      }
      localeData[name] = labels;
    };
    function getTimestamp(input) {
      if (input.constructor === Date || isMockedDate(input)) {
        return input.getTime();
      }
      if (typeof input === "number") {
        return input;
      }
      throw new Error("Unsupported relative time formatter input: ".concat(_typeof(input), ", ").concat(input));
    }
    function isMockedDate(object) {
      return _typeof(object) === "object" && typeof object.getTime === "function";
    }
    function getTimeIntervalMeasurementUnits(allowedUnits, labels, nowLabel) {
      var units = Object.keys(labels);
      if (nowLabel) {
        units.push("now");
      }
      if (allowedUnits) {
        units = allowedUnits.filter(function(unit) {
          return unit === "now" || units.indexOf(unit) >= 0;
        });
      }
      return units;
    }
    function getNowLabel(labels, nowLabels, longLabels, future) {
      var nowLabel = labels.now || nowLabels && nowLabels.now;
      if (nowLabel) {
        if (typeof nowLabel === "string") {
          return nowLabel;
        }
        if (future) {
          return nowLabel.future;
        } else {
          return nowLabel.past;
        }
      }
      if (longLabels && longLabels.second && longLabels.second.current) {
        return longLabels.second.current;
      }
    }
    function isStyle(variable) {
      return typeof variable === "string" || isStyleObject(variable);
    }
    const en = {
      "locale": "en",
      "long": {
        "year": {
          "previous": "last year",
          "current": "this year",
          "next": "next year",
          "past": {
            "one": "{0} year ago",
            "other": "{0} years ago"
          },
          "future": {
            "one": "in {0} year",
            "other": "in {0} years"
          }
        },
        "quarter": {
          "previous": "last quarter",
          "current": "this quarter",
          "next": "next quarter",
          "past": {
            "one": "{0} quarter ago",
            "other": "{0} quarters ago"
          },
          "future": {
            "one": "in {0} quarter",
            "other": "in {0} quarters"
          }
        },
        "month": {
          "previous": "last month",
          "current": "this month",
          "next": "next month",
          "past": {
            "one": "{0} month ago",
            "other": "{0} months ago"
          },
          "future": {
            "one": "in {0} month",
            "other": "in {0} months"
          }
        },
        "week": {
          "previous": "last week",
          "current": "this week",
          "next": "next week",
          "past": {
            "one": "{0} week ago",
            "other": "{0} weeks ago"
          },
          "future": {
            "one": "in {0} week",
            "other": "in {0} weeks"
          }
        },
        "day": {
          "previous": "yesterday",
          "current": "today",
          "next": "tomorrow",
          "past": {
            "one": "{0} day ago",
            "other": "{0} days ago"
          },
          "future": {
            "one": "in {0} day",
            "other": "in {0} days"
          }
        },
        "hour": {
          "current": "this hour",
          "past": {
            "one": "{0} hour ago",
            "other": "{0} hours ago"
          },
          "future": {
            "one": "in {0} hour",
            "other": "in {0} hours"
          }
        },
        "minute": {
          "current": "this minute",
          "past": {
            "one": "{0} minute ago",
            "other": "{0} minutes ago"
          },
          "future": {
            "one": "in {0} minute",
            "other": "in {0} minutes"
          }
        },
        "second": {
          "current": "now",
          "past": {
            "one": "{0} second ago",
            "other": "{0} seconds ago"
          },
          "future": {
            "one": "in {0} second",
            "other": "in {0} seconds"
          }
        }
      },
      "short": {
        "year": {
          "previous": "last yr.",
          "current": "this yr.",
          "next": "next yr.",
          "past": "{0} yr. ago",
          "future": "in {0} yr."
        },
        "quarter": {
          "previous": "last qtr.",
          "current": "this qtr.",
          "next": "next qtr.",
          "past": {
            "one": "{0} qtr. ago",
            "other": "{0} qtrs. ago"
          },
          "future": {
            "one": "in {0} qtr.",
            "other": "in {0} qtrs."
          }
        },
        "month": {
          "previous": "last mo.",
          "current": "this mo.",
          "next": "next mo.",
          "past": "{0} mo. ago",
          "future": "in {0} mo."
        },
        "week": {
          "previous": "last wk.",
          "current": "this wk.",
          "next": "next wk.",
          "past": "{0} wk. ago",
          "future": "in {0} wk."
        },
        "day": {
          "previous": "yesterday",
          "current": "today",
          "next": "tomorrow",
          "past": {
            "one": "{0} day ago",
            "other": "{0} days ago"
          },
          "future": {
            "one": "in {0} day",
            "other": "in {0} days"
          }
        },
        "hour": {
          "current": "this hour",
          "past": "{0} hr. ago",
          "future": "in {0} hr."
        },
        "minute": {
          "current": "this minute",
          "past": "{0} min. ago",
          "future": "in {0} min."
        },
        "second": {
          "current": "now",
          "past": "{0} sec. ago",
          "future": "in {0} sec."
        }
      },
      "narrow": {
        "year": {
          "previous": "last yr.",
          "current": "this yr.",
          "next": "next yr.",
          "past": "{0}y ago",
          "future": "in {0}y"
        },
        "quarter": {
          "previous": "last qtr.",
          "current": "this qtr.",
          "next": "next qtr.",
          "past": "{0}q ago",
          "future": "in {0}q"
        },
        "month": {
          "previous": "last mo.",
          "current": "this mo.",
          "next": "next mo.",
          "past": "{0}mo ago",
          "future": "in {0}mo"
        },
        "week": {
          "previous": "last wk.",
          "current": "this wk.",
          "next": "next wk.",
          "past": "{0}w ago",
          "future": "in {0}w"
        },
        "day": {
          "previous": "yesterday",
          "current": "today",
          "next": "tomorrow",
          "past": "{0}d ago",
          "future": "in {0}d"
        },
        "hour": {
          "current": "this hour",
          "past": "{0}h ago",
          "future": "in {0}h"
        },
        "minute": {
          "current": "this minute",
          "past": "{0}m ago",
          "future": "in {0}m"
        },
        "second": {
          "current": "now",
          "past": "{0}s ago",
          "future": "in {0}s"
        }
      },
      "now": {
        "now": {
          "current": "now",
          "future": "in a moment",
          "past": "just now"
        }
      },
      "mini": {
        "year": "{0}yr",
        "month": "{0}mo",
        "week": "{0}wk",
        "day": "{0}d",
        "hour": "{0}h",
        "minute": "{0}m",
        "second": "{0}s",
        "now": "now"
      },
      "short-time": {
        "year": "{0} yr.",
        "month": "{0} mo.",
        "week": "{0} wk.",
        "day": {
          "one": "{0} day",
          "other": "{0} days"
        },
        "hour": "{0} hr.",
        "minute": "{0} min.",
        "second": "{0} sec."
      },
      "long-time": {
        "year": {
          "one": "{0} year",
          "other": "{0} years"
        },
        "month": {
          "one": "{0} month",
          "other": "{0} months"
        },
        "week": {
          "one": "{0} week",
          "other": "{0} weeks"
        },
        "day": {
          "one": "{0} day",
          "other": "{0} days"
        },
        "hour": {
          "one": "{0} hour",
          "other": "{0} hours"
        },
        "minute": {
          "one": "{0} minute",
          "other": "{0} minutes"
        },
        "second": {
          "one": "{0} second",
          "other": "{0} seconds"
        }
      }
    };
    TimeAgo.addDefaultLocale(en);
    const timeAgo = new TimeAgo("en-US");
    const decimalTranslator = short("0123456789");
    const _sfc_main$b = {
      components: { Splitpanes: M$1, Pane: g$3, Nav },
      data() {
        return {
          urlToLoad: "",
          continueRecords: [],
          urlToLoadIsHttp: false,
          searchByLccnResults: null,
          lccnToSearchTimeout: null,
          lccnLoadSelected: false
        };
      },
      computed: {
        // other computed properties
        // ...
        // gives access to this.counterStore and this.userStore
        ...mapStores(usePreferenceStore),
        ...mapState(usePreferenceStore, ["styleDefault", "panelDisplay"]),
        ...mapState(useConfigStore, ["testData"]),
        ...mapState(useProfileStore, ["startingPoints", "profiles"]),
        ...mapWritableState(useProfileStore, ["activeProfile"]),
        // // gives read access to this.count and this.double
        // ...mapState(usePreferenceStore, ['profilesLoaded']),
        startingPointsFiltered() {
          let points = [];
          for (let k2 in this.startingPoints) {
            if (this.startingPoints[k2].work && this.startingPoints[k2].instance) {
              points.push(this.startingPoints[k2]);
            }
          }
          return points;
        }
      },
      methods: {
        returnTimeAgo: function(timestamp) {
          console.log(timestamp, timestamp * 1e3, Date.now());
          return timeAgo.format(timestamp * 1e3);
        },
        returnPixleAsPercent: function(pixles) {
          return pixles / window.innerHeight * 100;
        },
        loadTestData: function(filename) {
          this.urlToLoad = "/bfe2/quartz/test_files/" + filename;
          this.urlToLoadIsHttp = true;
        },
        loadYourRecord: async function() {
        },
        loadSearch: function() {
          this.lccnLoadSelected = null;
          if (this.urlToLoad.startsWith("http://") || this.urlToLoad.startsWith("https://")) {
            this.urlToLoadIsHttp = true;
            return false;
          } else {
            this.urlToLoadIsHttp = false;
          }
          if (this.urlToLoad.length < 8) {
            return false;
          }
          window.clearTimeout(this.lccnToSearchTimeout);
          this.searchByLccnResults = "Searching...";
          this.lccnToSearchTimeout = window.setTimeout(async () => {
            this.searchByLccnResults = await utilsNetwork.searchInstanceByLCCN(this.urlToLoad);
            console.log(this.searchByLccnResults);
          }, 500);
        },
        loadUrl: async function(useInstanceProfile, multiTestFlag) {
          if (this.lccnLoadSelected) {
            console.log(this.lccnLoadSelected.bfdbPackageURL);
            this.urlToLoad = this.lccnLoadSelected.bfdbPackageURL;
          }
          console.log(this.urlToLoad);
          if (this.urlToLoad.trim() !== "") {
            let xml = await utilsNetwork.fetchBfdbXML(this.urlToLoad);
            console.log(xml);
            utilsParse.parseXml(xml);
            console.log(utilsParse.hasItem);
          }
          let useProfile = null;
          for (let key2 in this.profiles) {
            if (this.profiles[key2].rtOrder.indexOf(useInstanceProfile) > -1) {
              useProfile = JSON.parse(JSON.stringify(this.profiles[key2]));
            }
          }
          if (useProfile === null) {
            alert("Cannot find profile.");
            return false;
          }
          if (this.urlToLoad.trim() !== "") {
            if (utilsParse.hasItem > 0) {
              Array.from(Array(utilsParse.hasItem)).map((_2, i2) => {
                let useItemRtLabel;
                useItemRtLabel = useInstanceProfile.replace(":Instance", ":Item");
                let foundCorrectItemProfile = false;
                for (let pkey in this.profiles) {
                  for (let rtkey in this.profiles[pkey].rt) {
                    if (rtkey == useItemRtLabel) {
                      let useRtLabel = useItemRtLabel + "-" + (i2 + 1);
                      let useItem = JSON.parse(JSON.stringify(this.profiles[pkey].rt[rtkey]));
                      for (let ptk in useItem.pt) {
                        useItem.pt[ptk]["@guid"] = short.generate();
                      }
                      foundCorrectItemProfile = true;
                      useProfile.rtOrder.push(useRtLabel);
                      useProfile.rt[useRtLabel] = useItem;
                    }
                  }
                }
                if (!foundCorrectItemProfile) {
                  console.warn("error: foundCorrectItemProfile not set ---------");
                  console.warn(this.rtLookup[useItemRtLabel]);
                }
              });
            }
          }
          if (!useProfile.log) {
            useProfile.log = [];
          }
          useProfile.log.push({ action: "loadInstance", from: this.urlToLoad });
          useProfile.procInfo = "update instance";
          if (!useProfile.eId) {
            let uuid = "e" + decimalTranslator.new();
            uuid = uuid.substring(0, 8);
            useProfile.eId = uuid;
          }
          if (!useProfile.user) {
            useProfile.user = this.preferenceStore.returnUserNameForSaving;
          }
          if (!useProfile.status) {
            useProfile.status = "unposted";
          }
          if (this.urlToLoad.trim() !== "") {
            let profileDataMerge = await utilsParse.transformRts(useProfile);
            this.activeProfile = profileDataMerge;
          } else {
            this.activeProfile = useProfile;
          }
          console.log("this.activeProfile", this.activeProfile);
          if (multiTestFlag) {
            this.$router.push(`/multiedit/`);
            return true;
          }
          this.$router.push(`/edit/${useProfile.eId}`);
        }
      },
      created: async function() {
        console.log(this.preferenceStore.returnUserNameForSaving);
        let records = await utilsNetwork.searchSavedRecords(this.preferenceStore.returnUserNameForSaving);
        console.log(records);
        let lccnLookup = {};
        this.continueRecords = [];
        for (let r2 of records) {
          if (r2.lccn && r2.lccn != "" && r2.lccn !== null) {
            if (!lccnLookup[r2.lccn]) {
              this.continueRecords.push(r2);
              lccnLookup[r2.lccn] = true;
            }
          }
        }
        console.log(this.continueRecords);
      }
    };
    const _withScopeId$6 = (n2) => (pushScopeId("data-v-1ea6ff35"), n2 = n2(), popScopeId(), n2);
    const _hoisted_1$a = { class: "load-columns" };
    const _hoisted_2$7 = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createBaseVNode("h1", null, [
      /* @__PURE__ */ createBaseVNode("span", {
        style: { "font-size": "1.15em", "vertical-align": "bottom", "margin-right": "5px" },
        class: "material-icons"
      }, "cloud_download"),
      /* @__PURE__ */ createBaseVNode("span", null, "Load")
    ], -1));
    const _hoisted_3$6 = { key: 0 };
    const _hoisted_4$6 = { key: 1 };
    const _hoisted_5$6 = { style: { "display": "flex" } };
    const _hoisted_6$6 = { style: { "flex": "2" } };
    const _hoisted_7$6 = { style: { "font-weight": "bold" } };
    const _hoisted_8$5 = { style: { "flex": "1" } };
    const _hoisted_9$5 = ["href"];
    const _hoisted_10$5 = ["for"];
    const _hoisted_11$5 = ["value", "id", "name"];
    const _hoisted_12$5 = {
      key: 0,
      style: { "font-weight": "bold", "margin-bottom": "1em" }
    };
    const _hoisted_13$5 = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createBaseVNode("h3", null, "Load with profile:", -1));
    const _hoisted_14$5 = { class: "load-buttons" };
    const _hoisted_15$5 = ["onClick", "disabled"];
    const _hoisted_16$5 = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createBaseVNode("hr", null, null, -1));
    const _hoisted_17$4 = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createBaseVNode("summary", null, "Test Data", -1));
    const _hoisted_18$4 = ["onClick"];
    const _hoisted_19$4 = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createBaseVNode("h1", null, [
      /* @__PURE__ */ createBaseVNode("span", {
        style: { "font-size": "1.25em", "vertical-align": "bottom", "margin-right": "3px" },
        class: "material-icons"
      }, "edit_note"),
      /* @__PURE__ */ createBaseVNode("span", null, "Your Records")
    ], -1));
    const _hoisted_20$4 = { class: "continue-record-list" };
    const _hoisted_21$4 = { class: "continue-record" };
    const _hoisted_22$4 = { class: "continue-record-title" };
    const _hoisted_23$3 = { key: 0 };
    const _hoisted_24$3 = { class: "continue-record-lastedit" };
    const _hoisted_25$3 = { key: 0 };
    const _hoisted_26$3 = { key: 1 };
    const _hoisted_27$3 = {
      key: 0,
      class: "material-icons",
      title: "Posted record"
    };
    const _hoisted_28$3 = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createBaseVNode("div", null, null, -1));
    function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Nav = resolveComponent("Nav");
      const _component_pane = resolveComponent("pane");
      const _component_router_link = resolveComponent("router-link");
      const _component_splitpanes = resolveComponent("splitpanes");
      return openBlock(), createBlock(_component_splitpanes, {
        class: "default-theme",
        horizontal: ""
      }, {
        default: withCtx(() => [
          createVNode(_component_pane, {
            class: "header",
            size: $options.returnPixleAsPercent(_ctx.preferenceStore.returnValue("--n-edit-main-splitpane-nav-height", true))
          }, {
            default: withCtx(() => [
              createVNode(_component_Nav)
            ]),
            _: 1
          }, 8, ["size"]),
          createVNode(_component_pane, null, {
            default: withCtx(() => [
              createVNode(_component_splitpanes, null, {
                default: withCtx(() => [
                  createVNode(_component_pane, { class: "load" }, {
                    default: withCtx(() => [
                      createBaseVNode("div", _hoisted_1$a, [
                        createBaseVNode("div", null, [
                          _hoisted_2$7,
                          createBaseVNode("form", {
                            ref: "urlToLoadForm",
                            onSubmit: _cache[2] || (_cache[2] = withModifiers((...args) => $options.loadUrl && $options.loadUrl(...args), ["prevent"]))
                          }, [
                            withDirectives(createBaseVNode("input", {
                              placeholder: "URL to resource or LCCN to search",
                              class: "url-to-load",
                              type: "text",
                              onInput: _cache[0] || (_cache[0] = (...args) => $options.loadSearch && $options.loadSearch(...args)),
                              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.urlToLoad = $event),
                              ref: "urlToLoad"
                            }, null, 544), [
                              [vModelText, $data.urlToLoad]
                            ])
                          ], 544),
                          createBaseVNode("ol", null, [
                            $data.searchByLccnResults && $data.searchByLccnResults.length === 0 ? (openBlock(), createElementBlock("li", _hoisted_3$6, "No results...")) : createCommentVNode("", true),
                            $data.searchByLccnResults && typeof $data.searchByLccnResults === "string" ? (openBlock(), createElementBlock("li", _hoisted_4$6, "Searching...")) : (openBlock(true), createElementBlock(Fragment, { key: 2 }, renderList($data.searchByLccnResults, (r2, idx) => {
                              return openBlock(), createElementBlock("li", {
                                key: r2.idURL
                              }, [
                                createBaseVNode("div", _hoisted_5$6, [
                                  createBaseVNode("div", _hoisted_6$6, [
                                    createTextVNode(toDisplayString$2(++idx) + ". ", 1),
                                    createBaseVNode("span", _hoisted_7$6, toDisplayString$2(r2.label), 1)
                                  ]),
                                  createBaseVNode("div", _hoisted_8$5, [
                                    createBaseVNode("a", {
                                      href: r2.bfdbURL,
                                      style: { "padding-right": "10px" },
                                      target: "_blank"
                                    }, "View on BFDB", 8, _hoisted_9$5),
                                    createBaseVNode("label", {
                                      for: "lccnsearch" + idx
                                    }, "Select", 8, _hoisted_10$5),
                                    withDirectives(createBaseVNode("input", {
                                      type: "radio",
                                      "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $data.lccnLoadSelected = $event),
                                      value: r2,
                                      name: "lccnToLoad",
                                      id: "lccnsearch" + idx
                                    }, null, 8, _hoisted_11$5), [
                                      [vModelRadio, $data.lccnLoadSelected]
                                    ])
                                  ])
                                ])
                              ]);
                            }), 128))
                          ]),
                          !$data.urlToLoadIsHttp && !$data.lccnLoadSelected ? (openBlock(), createElementBlock("div", _hoisted_12$5, " First Enter URL to resource or search for LCCN above to select profile. ")) : createCommentVNode("", true),
                          _hoisted_13$5,
                          createBaseVNode("div", _hoisted_14$5, [
                            (openBlock(true), createElementBlock(Fragment, null, renderList($options.startingPointsFiltered, (s2) => {
                              return openBlock(), createElementBlock("button", {
                                class: "load-button",
                                onClick: ($event) => $options.loadUrl(s2.instance),
                                disabled: $data.urlToLoadIsHttp || $data.lccnLoadSelected ? false : true
                              }, toDisplayString$2(s2.name), 9, _hoisted_15$5);
                            }), 256))
                          ]),
                          _hoisted_16$5,
                          createBaseVNode("details", null, [
                            _hoisted_17$4,
                            createBaseVNode("table", null, [
                              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.testData, (t2) => {
                                return openBlock(), createElementBlock("tr", null, [
                                  createBaseVNode("td", null, toDisplayString$2(t2.desc), 1),
                                  createBaseVNode("td", null, [
                                    createBaseVNode("button", {
                                      onClick: ($event) => $options.loadTestData(t2.filename)
                                    }, "Set URL", 8, _hoisted_18$4)
                                  ])
                                ]);
                              }), 256))
                            ])
                          ])
                        ]),
                        createBaseVNode("div", null, [
                          _hoisted_19$4,
                          createBaseVNode("div", null, [
                            createBaseVNode("ul", _hoisted_20$4, [
                              (openBlock(true), createElementBlock(Fragment, null, renderList($data.continueRecords, (record) => {
                                return openBlock(), createElementBlock("li", _hoisted_21$4, [
                                  createVNode(_component_router_link, {
                                    to: { name: "Edit", params: { recordId: record.eid } }
                                  }, {
                                    default: withCtx(() => [
                                      createBaseVNode("div", null, [
                                        createBaseVNode("span", _hoisted_22$4, toDisplayString$2(record.title), 1),
                                        record.contributor ? (openBlock(), createElementBlock("span", _hoisted_23$3, " by " + toDisplayString$2(record.contributor), 1)) : createCommentVNode("", true),
                                        createBaseVNode("span", null, " (" + toDisplayString$2(record.lccn) + ")", 1)
                                      ]),
                                      createBaseVNode("div", _hoisted_24$3, [
                                        record.status == "posted" ? (openBlock(), createElementBlock("span", _hoisted_25$3, "Posted")) : createCommentVNode("", true),
                                        record.status == "unposted" ? (openBlock(), createElementBlock("span", _hoisted_26$3, "last edited")) : createCommentVNode("", true),
                                        createTextVNode(),
                                        createBaseVNode("span", null, toDisplayString$2($options.returnTimeAgo(record.timestamp)), 1)
                                      ])
                                    ]),
                                    _: 2
                                  }, 1032, ["to"]),
                                  record.status == "posted" ? (openBlock(), createElementBlock("div", _hoisted_27$3, "check_box")) : createCommentVNode("", true)
                                ]);
                              }), 256))
                            ])
                          ])
                        ]),
                        _hoisted_28$3
                      ])
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        _: 1
      });
    }
    const Load = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$b], ["__scopeId", "data-v-1ea6ff35"]]);
    const _sfc_main$a = {
      components: { Splitpanes: M$1, Pane: g$3, Properties, EditPanel, Nav, Opac, Debug },
      data() {
        return {
          color: "blue"
        };
      },
      computed: {
        // other computed properties
        // ...
        // gives access to this.counterStore and this.userStore
        ...mapStores(usePreferenceStore),
        ...mapState(usePreferenceStore, ["styleDefault", "panelDisplay"]),
        ...mapWritableState(usePreferenceStore, ["showDebugModal"])
        // // gives read access to this.count and this.double
        // ...mapState(usePreferenceStore, ['profilesLoaded']),
      },
      methods: {
        returnPixleAsPercent: function(pixles) {
          return pixles / window.innerHeight * 100;
        }
      },
      created: function() {
      }
    };
    const __injectCSSVars__$4 = () => {
      useCssVars((_ctx) => ({
        "31fa65b6": _ctx.preferenceStore.returnValue("--c-edit-main-splitpane-nav-background-color"),
        "5a0489cc": _ctx.preferenceStore.returnValue("--c-edit-main-splitpane-properties-background-color"),
        "0fc7f7ec": _ctx.preferenceStore.returnValue("--c-edit-main-splitpane-opac-background-color")
      }));
    };
    const __setup__$4 = _sfc_main$a.setup;
    _sfc_main$a.setup = __setup__$4 ? (props, ctx) => {
      __injectCSSVars__$4();
      return __setup__$4(props, ctx);
    } : __injectCSSVars__$4;
    const _withScopeId$5 = (n2) => (pushScopeId("data-v-9d2f2c0b"), n2 = n2(), popScopeId(), n2);
    const _hoisted_1$9 = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createBaseVNode("template", null, null, -1));
    function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Nav = resolveComponent("Nav");
      const _component_pane = resolveComponent("pane");
      const _component_EditPanel = resolveComponent("EditPanel");
      const _component_splitpanes = resolveComponent("splitpanes");
      const _component_Debug = resolveComponent("Debug");
      return openBlock(), createBlock(_component_splitpanes, {
        class: "default-theme",
        horizontal: ""
      }, {
        default: withCtx(() => [
          createVNode(_component_pane, {
            class: "header",
            size: $options.returnPixleAsPercent(_ctx.preferenceStore.returnValue("--n-edit-main-splitpane-nav-height", true))
          }, {
            default: withCtx(() => [
              createVNode(_component_Nav)
            ]),
            _: 1
          }, 8, ["size"]),
          createVNode(_component_pane, null, {
            default: withCtx(() => [
              createVNode(_component_splitpanes, null, {
                default: withCtx(() => [
                  createVNode(_component_pane, {
                    class: normalizeClass({ "edit-main-splitpane-edit": true, "edit-main-splitpane-edit-no-scrollbar": _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-no-scrollbar") }),
                    size: _ctx.preferenceStore.returnValue("--n-edit-main-splitpane-edit-width")
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_EditPanel, { instanceMode: false })
                    ]),
                    _: 1
                  }, 8, ["class", "size"]),
                  createVNode(_component_pane, {
                    class: normalizeClass({ "edit-main-splitpane-edit": true, "edit-main-splitpane-edit-no-scrollbar": _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-no-scrollbar") }),
                    size: _ctx.preferenceStore.returnValue("--n-edit-main-splitpane-edit-width")
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_EditPanel, { instanceMode: false })
                    ]),
                    _: 1
                  }, 8, ["class", "size"]),
                  createVNode(_component_pane, {
                    class: normalizeClass({ "edit-main-splitpane-edit": true, "edit-main-splitpane-edit-no-scrollbar": _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-no-scrollbar") }),
                    size: _ctx.preferenceStore.returnValue("--n-edit-main-splitpane-edit-width")
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_EditPanel, { instanceMode: false })
                    ]),
                    _: 1
                  }, 8, ["class", "size"]),
                  _hoisted_1$9
                ]),
                _: 1
              })
            ]),
            _: 1
          }),
          _ctx.showDebugModal == true ? (openBlock(), createBlock(_component_Debug, {
            key: 0,
            modelValue: _ctx.showDebugModal,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.showDebugModal = $event)
          }, null, 8, ["modelValue"])) : createCommentVNode("", true)
        ]),
        _: 1
      });
    }
    const EditMulti = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$a], ["__scopeId", "data-v-9d2f2c0b"]]);
    const router = createRouter({
      history: createWebHistory("/bfe2/quartz/"),
      routes: [
        {
          path: "/",
          name: "home",
          component: Load
        },
        // {
        //   path: "/about",
        //   name: "about",
        //   // route level code-splitting
        //   // this generates a separate chunk (About.[hash].js) for this route
        //   // which is lazy-loaded when the route is visited.
        //   component: () => import("../views/AboutView.vue"),
        // },
        {
          path: "/edit/:recordId",
          name: "Edit",
          component: Edit
        },
        {
          path: "/multiedit/:recordId",
          name: "MultiEdit",
          component: EditMulti
        },
        {
          path: "/load/",
          name: "Load",
          component: Load
        }
      ]
    });
    const i18nMessages = {
      en: {
        message: {
          // 
          //  Components
          //
          //  --> general -> LoadingModal
          generalLoadingModalLoadingMsg: "Loading...",
          // when referencing the "Work", "Instance", "Item", "Hub" in the interface
          wordWork: "Work",
          wordInstance: "Instance",
          wordItem: "Item",
          wordHub: "Hub"
        },
        "--c-edit-main-splitpane-properties-background-color--desc": "hello"
      }
    };
    const sides = ["top", "right", "bottom", "left"];
    const alignments = ["start", "end"];
    const placements = /* @__PURE__ */ sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
    const min = Math.min;
    const max = Math.max;
    const oppositeSideMap = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    };
    const oppositeAlignmentMap = {
      start: "end",
      end: "start"
    };
    function clamp(start2, value, end2) {
      return max(start2, min(value, end2));
    }
    function evaluate(value, param) {
      return typeof value === "function" ? value(param) : value;
    }
    function getSide(placement) {
      return placement.split("-")[0];
    }
    function getAlignment(placement) {
      return placement.split("-")[1];
    }
    function getOppositeAxis(axis) {
      return axis === "x" ? "y" : "x";
    }
    function getAxisLength(axis) {
      return axis === "y" ? "height" : "width";
    }
    function getSideAxis(placement) {
      return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
    }
    function getAlignmentAxis(placement) {
      return getOppositeAxis(getSideAxis(placement));
    }
    function getAlignmentSides(placement, rects, rtl) {
      if (rtl === void 0) {
        rtl = false;
      }
      const alignment = getAlignment(placement);
      const alignmentAxis = getAlignmentAxis(placement);
      const length = getAxisLength(alignmentAxis);
      let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
      if (rects.reference[length] > rects.floating[length]) {
        mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
      }
      return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
    }
    function getExpandedPlacements(placement) {
      const oppositePlacement = getOppositePlacement(placement);
      return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
    }
    function getOppositeAlignmentPlacement(placement) {
      return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
    }
    function getSideList(side, isStart, rtl) {
      const lr2 = ["left", "right"];
      const rl = ["right", "left"];
      const tb = ["top", "bottom"];
      const bt2 = ["bottom", "top"];
      switch (side) {
        case "top":
        case "bottom":
          if (rtl)
            return isStart ? rl : lr2;
          return isStart ? lr2 : rl;
        case "left":
        case "right":
          return isStart ? tb : bt2;
        default:
          return [];
      }
    }
    function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
      const alignment = getAlignment(placement);
      let list = getSideList(getSide(placement), direction === "start", rtl);
      if (alignment) {
        list = list.map((side) => side + "-" + alignment);
        if (flipAlignment) {
          list = list.concat(list.map(getOppositeAlignmentPlacement));
        }
      }
      return list;
    }
    function getOppositePlacement(placement) {
      return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
    }
    function expandPaddingObject(padding) {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...padding
      };
    }
    function getPaddingObject(padding) {
      return typeof padding !== "number" ? expandPaddingObject(padding) : {
        top: padding,
        right: padding,
        bottom: padding,
        left: padding
      };
    }
    function rectToClientRect(rect) {
      const {
        x: x2,
        y: y2,
        width,
        height
      } = rect;
      return {
        width,
        height,
        top: y2,
        left: x2,
        right: x2 + width,
        bottom: y2 + height,
        x: x2,
        y: y2
      };
    }
    function computeCoordsFromPlacement(_ref, placement, rtl) {
      let {
        reference: reference2,
        floating
      } = _ref;
      const sideAxis = getSideAxis(placement);
      const alignmentAxis = getAlignmentAxis(placement);
      const alignLength = getAxisLength(alignmentAxis);
      const side = getSide(placement);
      const isVertical = sideAxis === "y";
      const commonX = reference2.x + reference2.width / 2 - floating.width / 2;
      const commonY = reference2.y + reference2.height / 2 - floating.height / 2;
      const commonAlign = reference2[alignLength] / 2 - floating[alignLength] / 2;
      let coords;
      switch (side) {
        case "top":
          coords = {
            x: commonX,
            y: reference2.y - floating.height
          };
          break;
        case "bottom":
          coords = {
            x: commonX,
            y: reference2.y + reference2.height
          };
          break;
        case "right":
          coords = {
            x: reference2.x + reference2.width,
            y: commonY
          };
          break;
        case "left":
          coords = {
            x: reference2.x - floating.width,
            y: commonY
          };
          break;
        default:
          coords = {
            x: reference2.x,
            y: reference2.y
          };
      }
      switch (getAlignment(placement)) {
        case "start":
          coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
          break;
        case "end":
          coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
          break;
      }
      return coords;
    }
    const computePosition = async (reference2, floating, config2) => {
      const {
        placement = "bottom",
        strategy = "absolute",
        middleware = [],
        platform
      } = config2;
      const validMiddleware = middleware.filter(Boolean);
      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));
      let rects = await platform.getElementRects({
        reference: reference2,
        floating,
        strategy
      });
      let {
        x: x2,
        y: y2
      } = computeCoordsFromPlacement(rects, placement, rtl);
      let statefulPlacement = placement;
      let middlewareData = {};
      let resetCount = 0;
      for (let i2 = 0; i2 < validMiddleware.length; i2++) {
        const {
          name,
          fn: fn2
        } = validMiddleware[i2];
        const {
          x: nextX,
          y: nextY,
          data,
          reset
        } = await fn2({
          x: x2,
          y: y2,
          initialPlacement: placement,
          placement: statefulPlacement,
          strategy,
          middlewareData,
          rects,
          platform,
          elements: {
            reference: reference2,
            floating
          }
        });
        x2 = nextX != null ? nextX : x2;
        y2 = nextY != null ? nextY : y2;
        middlewareData = {
          ...middlewareData,
          [name]: {
            ...middlewareData[name],
            ...data
          }
        };
        if (reset && resetCount <= 50) {
          resetCount++;
          if (typeof reset === "object") {
            if (reset.placement) {
              statefulPlacement = reset.placement;
            }
            if (reset.rects) {
              rects = reset.rects === true ? await platform.getElementRects({
                reference: reference2,
                floating,
                strategy
              }) : reset.rects;
            }
            ({
              x: x2,
              y: y2
            } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
          }
          i2 = -1;
        }
      }
      return {
        x: x2,
        y: y2,
        placement: statefulPlacement,
        strategy,
        middlewareData
      };
    };
    async function detectOverflow(state, options) {
      var _await$platform$isEle;
      if (options === void 0) {
        options = {};
      }
      const {
        x: x2,
        y: y2,
        platform,
        rects,
        elements,
        strategy
      } = state;
      const {
        boundary = "clippingAncestors",
        rootBoundary = "viewport",
        elementContext = "floating",
        altBoundary = false,
        padding = 0
      } = evaluate(options, state);
      const paddingObject = getPaddingObject(padding);
      const altContext = elementContext === "floating" ? "reference" : "floating";
      const element = elements[altBoundary ? altContext : elementContext];
      const clippingClientRect = rectToClientRect(await platform.getClippingRect({
        element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating)),
        boundary,
        rootBoundary,
        strategy
      }));
      const rect = elementContext === "floating" ? {
        x: x2,
        y: y2,
        width: rects.floating.width,
        height: rects.floating.height
      } : rects.reference;
      const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));
      const offsetScale = await (platform.isElement == null ? void 0 : platform.isElement(offsetParent)) ? await (platform.getScale == null ? void 0 : platform.getScale(offsetParent)) || {
        x: 1,
        y: 1
      } : {
        x: 1,
        y: 1
      };
      const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
        elements,
        rect,
        offsetParent,
        strategy
      }) : rect);
      return {
        top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
        bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
        left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
        right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
      };
    }
    const arrow = (options) => ({
      name: "arrow",
      options,
      async fn(state) {
        const {
          x: x2,
          y: y2,
          placement,
          rects,
          platform,
          elements,
          middlewareData
        } = state;
        const {
          element,
          padding = 0
        } = evaluate(options, state) || {};
        if (element == null) {
          return {};
        }
        const paddingObject = getPaddingObject(padding);
        const coords = {
          x: x2,
          y: y2
        };
        const axis = getAlignmentAxis(placement);
        const length = getAxisLength(axis);
        const arrowDimensions = await platform.getDimensions(element);
        const isYAxis = axis === "y";
        const minProp = isYAxis ? "top" : "left";
        const maxProp = isYAxis ? "bottom" : "right";
        const clientProp = isYAxis ? "clientHeight" : "clientWidth";
        const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
        const startDiff = coords[axis] - rects.reference[axis];
        const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));
        let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
        if (!clientSize || !await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent))) {
          clientSize = elements.floating[clientProp] || rects.floating[length];
        }
        const centerToReference = endDiff / 2 - startDiff / 2;
        const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
        const minPadding = min(paddingObject[minProp], largestPossiblePadding);
        const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
        const min$12 = minPadding;
        const max2 = clientSize - arrowDimensions[length] - maxPadding;
        const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
        const offset2 = clamp(min$12, center, max2);
        const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$12 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
        const alignmentOffset = shouldAddOffset ? center < min$12 ? center - min$12 : center - max2 : 0;
        return {
          [axis]: coords[axis] + alignmentOffset,
          data: {
            [axis]: offset2,
            centerOffset: center - offset2 - alignmentOffset,
            ...shouldAddOffset && {
              alignmentOffset
            }
          },
          reset: shouldAddOffset
        };
      }
    });
    function getPlacementList(alignment, autoAlignment, allowedPlacements) {
      const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter((placement) => getAlignment(placement) === alignment), ...allowedPlacements.filter((placement) => getAlignment(placement) !== alignment)] : allowedPlacements.filter((placement) => getSide(placement) === placement);
      return allowedPlacementsSortedByAlignment.filter((placement) => {
        if (alignment) {
          return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
        }
        return true;
      });
    }
    const autoPlacement = function(options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: "autoPlacement",
        options,
        async fn(state) {
          var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
          const {
            rects,
            middlewareData,
            placement,
            platform,
            elements
          } = state;
          const {
            crossAxis = false,
            alignment,
            allowedPlacements = placements,
            autoAlignment = true,
            ...detectOverflowOptions
          } = evaluate(options, state);
          const placements$12 = alignment !== void 0 || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
          const overflow = await detectOverflow(state, detectOverflowOptions);
          const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
          const currentPlacement = placements$12[currentIndex];
          if (currentPlacement == null) {
            return {};
          }
          const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));
          if (placement !== currentPlacement) {
            return {
              reset: {
                placement: placements$12[0]
              }
            };
          }
          const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];
          const allOverflows = [...((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || [], {
            placement: currentPlacement,
            overflows: currentOverflows
          }];
          const nextPlacement = placements$12[currentIndex + 1];
          if (nextPlacement) {
            return {
              data: {
                index: currentIndex + 1,
                overflows: allOverflows
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
          const placementsSortedByMostSpace = allOverflows.map((d2) => {
            const alignment2 = getAlignment(d2.placement);
            return [d2.placement, alignment2 && crossAxis ? (
              // Check along the mainAxis and main crossAxis side.
              d2.overflows.slice(0, 2).reduce((acc, v2) => acc + v2, 0)
            ) : (
              // Check only the mainAxis.
              d2.overflows[0]
            ), d2.overflows];
          }).sort((a2, b2) => a2[1] - b2[1]);
          const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter((d2) => d2[2].slice(
            0,
            // Aligned placements should not check their opposite crossAxis
            // side.
            getAlignment(d2[0]) ? 2 : 3
          ).every((v2) => v2 <= 0));
          const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
          if (resetPlacement !== placement) {
            return {
              data: {
                index: currentIndex + 1,
                overflows: allOverflows
              },
              reset: {
                placement: resetPlacement
              }
            };
          }
          return {};
        }
      };
    };
    const flip = function(options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: "flip",
        options,
        async fn(state) {
          var _middlewareData$arrow, _middlewareData$flip;
          const {
            placement,
            middlewareData,
            rects,
            initialPlacement,
            platform,
            elements
          } = state;
          const {
            mainAxis: checkMainAxis = true,
            crossAxis: checkCrossAxis = true,
            fallbackPlacements: specifiedFallbackPlacements,
            fallbackStrategy = "bestFit",
            fallbackAxisSideDirection = "none",
            flipAlignment = true,
            ...detectOverflowOptions
          } = evaluate(options, state);
          if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
            return {};
          }
          const side = getSide(placement);
          const isBasePlacement = getSide(initialPlacement) === initialPlacement;
          const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
          const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
          if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
            fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
          }
          const placements2 = [initialPlacement, ...fallbackPlacements];
          const overflow = await detectOverflow(state, detectOverflowOptions);
          const overflows = [];
          let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
          if (checkMainAxis) {
            overflows.push(overflow[side]);
          }
          if (checkCrossAxis) {
            const sides2 = getAlignmentSides(placement, rects, rtl);
            overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
          }
          overflowsData = [...overflowsData, {
            placement,
            overflows
          }];
          if (!overflows.every((side2) => side2 <= 0)) {
            var _middlewareData$flip2, _overflowsData$filter;
            const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
            const nextPlacement = placements2[nextIndex];
            if (nextPlacement) {
              return {
                data: {
                  index: nextIndex,
                  overflows: overflowsData
                },
                reset: {
                  placement: nextPlacement
                }
              };
            }
            let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
            if (!resetPlacement) {
              switch (fallbackStrategy) {
                case "bestFit": {
                  var _overflowsData$map$so;
                  const placement2 = (_overflowsData$map$so = overflowsData.map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
                  if (placement2) {
                    resetPlacement = placement2;
                  }
                  break;
                }
                case "initialPlacement":
                  resetPlacement = initialPlacement;
                  break;
              }
            }
            if (placement !== resetPlacement) {
              return {
                reset: {
                  placement: resetPlacement
                }
              };
            }
          }
          return {};
        }
      };
    };
    async function convertValueToCoords(state, options) {
      const {
        placement,
        platform,
        elements
      } = state;
      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isVertical = getSideAxis(placement) === "y";
      const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
      const crossAxisMulti = rtl && isVertical ? -1 : 1;
      const rawValue = evaluate(options, state);
      let {
        mainAxis,
        crossAxis,
        alignmentAxis
      } = typeof rawValue === "number" ? {
        mainAxis: rawValue,
        crossAxis: 0,
        alignmentAxis: null
      } : {
        mainAxis: 0,
        crossAxis: 0,
        alignmentAxis: null,
        ...rawValue
      };
      if (alignment && typeof alignmentAxis === "number") {
        crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
      }
      return isVertical ? {
        x: crossAxis * crossAxisMulti,
        y: mainAxis * mainAxisMulti
      } : {
        x: mainAxis * mainAxisMulti,
        y: crossAxis * crossAxisMulti
      };
    }
    const offset = function(options) {
      if (options === void 0) {
        options = 0;
      }
      return {
        name: "offset",
        options,
        async fn(state) {
          var _middlewareData$offse, _middlewareData$arrow;
          const {
            x: x2,
            y: y2,
            placement,
            middlewareData
          } = state;
          const diffCoords = await convertValueToCoords(state, options);
          if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
            return {};
          }
          return {
            x: x2 + diffCoords.x,
            y: y2 + diffCoords.y,
            data: {
              ...diffCoords,
              placement
            }
          };
        }
      };
    };
    const shift = function(options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: "shift",
        options,
        async fn(state) {
          const {
            x: x2,
            y: y2,
            placement
          } = state;
          const {
            mainAxis: checkMainAxis = true,
            crossAxis: checkCrossAxis = false,
            limiter = {
              fn: (_ref) => {
                let {
                  x: x3,
                  y: y3
                } = _ref;
                return {
                  x: x3,
                  y: y3
                };
              }
            },
            ...detectOverflowOptions
          } = evaluate(options, state);
          const coords = {
            x: x2,
            y: y2
          };
          const overflow = await detectOverflow(state, detectOverflowOptions);
          const crossAxis = getSideAxis(getSide(placement));
          const mainAxis = getOppositeAxis(crossAxis);
          let mainAxisCoord = coords[mainAxis];
          let crossAxisCoord = coords[crossAxis];
          if (checkMainAxis) {
            const minSide = mainAxis === "y" ? "top" : "left";
            const maxSide = mainAxis === "y" ? "bottom" : "right";
            const min2 = mainAxisCoord + overflow[minSide];
            const max2 = mainAxisCoord - overflow[maxSide];
            mainAxisCoord = clamp(min2, mainAxisCoord, max2);
          }
          if (checkCrossAxis) {
            const minSide = crossAxis === "y" ? "top" : "left";
            const maxSide = crossAxis === "y" ? "bottom" : "right";
            const min2 = crossAxisCoord + overflow[minSide];
            const max2 = crossAxisCoord - overflow[maxSide];
            crossAxisCoord = clamp(min2, crossAxisCoord, max2);
          }
          const limitedCoords = limiter.fn({
            ...state,
            [mainAxis]: mainAxisCoord,
            [crossAxis]: crossAxisCoord
          });
          return {
            ...limitedCoords,
            data: {
              x: limitedCoords.x - x2,
              y: limitedCoords.y - y2
            }
          };
        }
      };
    };
    const size = function(options) {
      if (options === void 0) {
        options = {};
      }
      return {
        name: "size",
        options,
        async fn(state) {
          const {
            placement,
            rects,
            platform,
            elements
          } = state;
          const {
            apply: apply2 = () => {
            },
            ...detectOverflowOptions
          } = evaluate(options, state);
          const overflow = await detectOverflow(state, detectOverflowOptions);
          const side = getSide(placement);
          const alignment = getAlignment(placement);
          const isYAxis = getSideAxis(placement) === "y";
          const {
            width,
            height
          } = rects.floating;
          let heightSide;
          let widthSide;
          if (side === "top" || side === "bottom") {
            heightSide = side;
            widthSide = alignment === (await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
          } else {
            widthSide = side;
            heightSide = alignment === "end" ? "top" : "bottom";
          }
          const overflowAvailableHeight = height - overflow[heightSide];
          const overflowAvailableWidth = width - overflow[widthSide];
          const noShift = !state.middlewareData.shift;
          let availableHeight = overflowAvailableHeight;
          let availableWidth = overflowAvailableWidth;
          if (isYAxis) {
            const maximumClippingWidth = width - overflow.left - overflow.right;
            availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
          } else {
            const maximumClippingHeight = height - overflow.top - overflow.bottom;
            availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
          }
          if (noShift && !alignment) {
            const xMin = max(overflow.left, 0);
            const xMax = max(overflow.right, 0);
            const yMin = max(overflow.top, 0);
            const yMax = max(overflow.bottom, 0);
            if (isYAxis) {
              availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
            } else {
              availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
            }
          }
          await apply2({
            ...state,
            availableWidth,
            availableHeight
          });
          const nextDimensions = await platform.getDimensions(elements.floating);
          if (width !== nextDimensions.width || height !== nextDimensions.height) {
            return {
              reset: {
                rects: true
              }
            };
          }
          return {};
        }
      };
    };
    function n$1(t2) {
      var e2;
      return (null == (e2 = t2.ownerDocument) ? void 0 : e2.defaultView) || window;
    }
    function o(t2) {
      return n$1(t2).getComputedStyle(t2);
    }
    const i = Math.min, r = Math.max, l = Math.round;
    function c$1(t2) {
      const e2 = o(t2);
      let n2 = parseFloat(e2.width), i2 = parseFloat(e2.height);
      const r2 = t2.offsetWidth, c2 = t2.offsetHeight, s2 = l(n2) !== r2 || l(i2) !== c2;
      return s2 && (n2 = r2, i2 = c2), { width: n2, height: i2, fallback: s2 };
    }
    function s(t2) {
      return h(t2) ? (t2.nodeName || "").toLowerCase() : "";
    }
    let f;
    function u$1() {
      if (f)
        return f;
      const t2 = navigator.userAgentData;
      return t2 && Array.isArray(t2.brands) ? (f = t2.brands.map((t3) => t3.brand + "/" + t3.version).join(" "), f) : navigator.userAgent;
    }
    function a(t2) {
      return t2 instanceof n$1(t2).HTMLElement;
    }
    function d$1(t2) {
      return t2 instanceof n$1(t2).Element;
    }
    function h(t2) {
      return t2 instanceof n$1(t2).Node;
    }
    function p(t2) {
      if ("undefined" == typeof ShadowRoot)
        return false;
      return t2 instanceof n$1(t2).ShadowRoot || t2 instanceof ShadowRoot;
    }
    function g$1(t2) {
      const { overflow: e2, overflowX: n2, overflowY: i2, display: r2 } = o(t2);
      return /auto|scroll|overlay|hidden|clip/.test(e2 + i2 + n2) && !["inline", "contents"].includes(r2);
    }
    function m$1(t2) {
      return ["table", "td", "th"].includes(s(t2));
    }
    function y$1(t2) {
      const e2 = /firefox/i.test(u$1()), n2 = o(t2), i2 = n2.backdropFilter || n2.WebkitBackdropFilter;
      return "none" !== n2.transform || "none" !== n2.perspective || !!i2 && "none" !== i2 || e2 && "filter" === n2.willChange || e2 && !!n2.filter && "none" !== n2.filter || ["transform", "perspective"].some((t3) => n2.willChange.includes(t3)) || ["paint", "layout", "strict", "content"].some((t3) => {
        const e3 = n2.contain;
        return null != e3 && e3.includes(t3);
      });
    }
    function x() {
      return !/^((?!chrome|android).)*safari/i.test(u$1());
    }
    function w$1(t2) {
      return ["html", "body", "#document"].includes(s(t2));
    }
    function v(t2) {
      return d$1(t2) ? t2 : t2.contextElement;
    }
    const b$1 = { x: 1, y: 1 };
    function L(t2) {
      const e2 = v(t2);
      if (!a(e2))
        return b$1;
      const n2 = e2.getBoundingClientRect(), { width: o3, height: i2, fallback: r2 } = c$1(e2);
      let s2 = (r2 ? l(n2.width) : n2.width) / o3, f2 = (r2 ? l(n2.height) : n2.height) / i2;
      return s2 && Number.isFinite(s2) || (s2 = 1), f2 && Number.isFinite(f2) || (f2 = 1), { x: s2, y: f2 };
    }
    function E(t2, e2, o3, i2) {
      var r2, l2;
      void 0 === e2 && (e2 = false), void 0 === o3 && (o3 = false);
      const c2 = t2.getBoundingClientRect(), s2 = v(t2);
      let f2 = b$1;
      e2 && (i2 ? d$1(i2) && (f2 = L(i2)) : f2 = L(t2));
      const u2 = s2 ? n$1(s2) : window, a2 = !x() && o3;
      let h2 = (c2.left + (a2 && (null == (r2 = u2.visualViewport) ? void 0 : r2.offsetLeft) || 0)) / f2.x, p2 = (c2.top + (a2 && (null == (l2 = u2.visualViewport) ? void 0 : l2.offsetTop) || 0)) / f2.y, g2 = c2.width / f2.x, m2 = c2.height / f2.y;
      if (s2) {
        const t3 = n$1(s2), e3 = i2 && d$1(i2) ? n$1(i2) : i2;
        let o4 = t3.frameElement;
        for (; o4 && i2 && e3 !== t3; ) {
          const t4 = L(o4), e4 = o4.getBoundingClientRect(), i3 = getComputedStyle(o4);
          e4.x += (o4.clientLeft + parseFloat(i3.paddingLeft)) * t4.x, e4.y += (o4.clientTop + parseFloat(i3.paddingTop)) * t4.y, h2 *= t4.x, p2 *= t4.y, g2 *= t4.x, m2 *= t4.y, h2 += e4.x, p2 += e4.y, o4 = n$1(o4).frameElement;
        }
      }
      return { width: g2, height: m2, top: p2, right: h2 + g2, bottom: p2 + m2, left: h2, x: h2, y: p2 };
    }
    function R(t2) {
      return ((h(t2) ? t2.ownerDocument : t2.document) || window.document).documentElement;
    }
    function T(t2) {
      return d$1(t2) ? { scrollLeft: t2.scrollLeft, scrollTop: t2.scrollTop } : { scrollLeft: t2.pageXOffset, scrollTop: t2.pageYOffset };
    }
    function C$1(t2) {
      return E(R(t2)).left + T(t2).scrollLeft;
    }
    function F(t2) {
      if ("html" === s(t2))
        return t2;
      const e2 = t2.assignedSlot || t2.parentNode || p(t2) && t2.host || R(t2);
      return p(e2) ? e2.host : e2;
    }
    function W$1(t2) {
      const e2 = F(t2);
      return w$1(e2) ? e2.ownerDocument.body : a(e2) && g$1(e2) ? e2 : W$1(e2);
    }
    function D(t2, e2) {
      var o3;
      void 0 === e2 && (e2 = []);
      const i2 = W$1(t2), r2 = i2 === (null == (o3 = t2.ownerDocument) ? void 0 : o3.body), l2 = n$1(i2);
      return r2 ? e2.concat(l2, l2.visualViewport || [], g$1(i2) ? i2 : []) : e2.concat(i2, D(i2));
    }
    function S$1(e2, i2, l2) {
      return "viewport" === i2 ? rectToClientRect(function(t2, e3) {
        const o3 = n$1(t2), i3 = R(t2), r2 = o3.visualViewport;
        let l3 = i3.clientWidth, c2 = i3.clientHeight, s2 = 0, f2 = 0;
        if (r2) {
          l3 = r2.width, c2 = r2.height;
          const t3 = x();
          (t3 || !t3 && "fixed" === e3) && (s2 = r2.offsetLeft, f2 = r2.offsetTop);
        }
        return { width: l3, height: c2, x: s2, y: f2 };
      }(e2, l2)) : d$1(i2) ? rectToClientRect(function(t2, e3) {
        const n2 = E(t2, true, "fixed" === e3), o3 = n2.top + t2.clientTop, i3 = n2.left + t2.clientLeft, r2 = a(t2) ? L(t2) : { x: 1, y: 1 };
        return { width: t2.clientWidth * r2.x, height: t2.clientHeight * r2.y, x: i3 * r2.x, y: o3 * r2.y };
      }(i2, l2)) : rectToClientRect(function(t2) {
        const e3 = R(t2), n2 = T(t2), i3 = t2.ownerDocument.body, l3 = r(e3.scrollWidth, e3.clientWidth, i3.scrollWidth, i3.clientWidth), c2 = r(e3.scrollHeight, e3.clientHeight, i3.scrollHeight, i3.clientHeight);
        let s2 = -n2.scrollLeft + C$1(t2);
        const f2 = -n2.scrollTop;
        return "rtl" === o(i3).direction && (s2 += r(e3.clientWidth, i3.clientWidth) - l3), { width: l3, height: c2, x: s2, y: f2 };
      }(R(e2)));
    }
    function A(t2) {
      return a(t2) && "fixed" !== o(t2).position ? t2.offsetParent : null;
    }
    function H(t2) {
      const e2 = n$1(t2);
      let i2 = A(t2);
      for (; i2 && m$1(i2) && "static" === o(i2).position; )
        i2 = A(i2);
      return i2 && ("html" === s(i2) || "body" === s(i2) && "static" === o(i2).position && !y$1(i2)) ? e2 : i2 || function(t3) {
        let e3 = F(t3);
        for (; a(e3) && !w$1(e3); ) {
          if (y$1(e3))
            return e3;
          e3 = F(e3);
        }
        return null;
      }(t2) || e2;
    }
    function O(t2, e2, n2) {
      const o3 = a(e2), i2 = R(e2), r2 = E(t2, true, "fixed" === n2, e2);
      let l2 = { scrollLeft: 0, scrollTop: 0 };
      const c2 = { x: 0, y: 0 };
      if (o3 || !o3 && "fixed" !== n2)
        if (("body" !== s(e2) || g$1(i2)) && (l2 = T(e2)), a(e2)) {
          const t3 = E(e2, true);
          c2.x = t3.x + e2.clientLeft, c2.y = t3.y + e2.clientTop;
        } else
          i2 && (c2.x = C$1(i2));
      return { x: r2.left + l2.scrollLeft - c2.x, y: r2.top + l2.scrollTop - c2.y, width: r2.width, height: r2.height };
    }
    const P = { getClippingRect: function(t2) {
      let { element: e2, boundary: n2, rootBoundary: l2, strategy: c2 } = t2;
      const f2 = "clippingAncestors" === n2 ? function(t3, e3) {
        const n3 = e3.get(t3);
        if (n3)
          return n3;
        let i2 = D(t3).filter((t4) => d$1(t4) && "body" !== s(t4)), r2 = null;
        const l3 = "fixed" === o(t3).position;
        let c3 = l3 ? F(t3) : t3;
        for (; d$1(c3) && !w$1(c3); ) {
          const t4 = o(c3), e4 = y$1(c3);
          (l3 ? e4 || r2 : e4 || "static" !== t4.position || !r2 || !["absolute", "fixed"].includes(r2.position)) ? r2 = t4 : i2 = i2.filter((t5) => t5 !== c3), c3 = F(c3);
        }
        return e3.set(t3, i2), i2;
      }(e2, this._c) : [].concat(n2), u2 = [...f2, l2], a2 = u2[0], h2 = u2.reduce((t3, n3) => {
        const o3 = S$1(e2, n3, c2);
        return t3.top = r(o3.top, t3.top), t3.right = i(o3.right, t3.right), t3.bottom = i(o3.bottom, t3.bottom), t3.left = r(o3.left, t3.left), t3;
      }, S$1(e2, a2, c2));
      return { width: h2.right - h2.left, height: h2.bottom - h2.top, x: h2.left, y: h2.top };
    }, convertOffsetParentRelativeRectToViewportRelativeRect: function(t2) {
      let { rect: e2, offsetParent: n2, strategy: o3 } = t2;
      const i2 = a(n2), r2 = R(n2);
      if (n2 === r2)
        return e2;
      let l2 = { scrollLeft: 0, scrollTop: 0 }, c2 = { x: 1, y: 1 };
      const f2 = { x: 0, y: 0 };
      if ((i2 || !i2 && "fixed" !== o3) && (("body" !== s(n2) || g$1(r2)) && (l2 = T(n2)), a(n2))) {
        const t3 = E(n2);
        c2 = L(n2), f2.x = t3.x + n2.clientLeft, f2.y = t3.y + n2.clientTop;
      }
      return { width: e2.width * c2.x, height: e2.height * c2.y, x: e2.x * c2.x - l2.scrollLeft * c2.x + f2.x, y: e2.y * c2.y - l2.scrollTop * c2.y + f2.y };
    }, isElement: d$1, getDimensions: function(t2) {
      return a(t2) ? c$1(t2) : t2.getBoundingClientRect();
    }, getOffsetParent: H, getDocumentElement: R, getScale: L, async getElementRects(t2) {
      let { reference: e2, floating: n2, strategy: o3 } = t2;
      const i2 = this.getOffsetParent || H, r2 = this.getDimensions;
      return { reference: O(e2, await i2(n2), o3), floating: { x: 0, y: 0, ...await r2(n2) } };
    }, getClientRects: (t2) => Array.from(t2.getClientRects()), isRTL: (t2) => "rtl" === o(t2).direction };
    const B$1 = (t2, n2, o3) => {
      const i2 = /* @__PURE__ */ new Map(), r2 = { platform: P, ...o3 }, l2 = { ...r2.platform, _c: i2 };
      return computePosition(t2, n2, { ...r2, platform: l2 });
    };
    function $e(e2, t2) {
      for (const o3 in t2)
        Object.prototype.hasOwnProperty.call(t2, o3) && (typeof t2[o3] == "object" && e2[o3] ? $e(e2[o3], t2[o3]) : e2[o3] = t2[o3]);
    }
    const u = {
      // Disable popper components
      disabled: false,
      // Default position offset along main axis (px)
      distance: 5,
      // Default position offset along cross axis (px)
      skidding: 0,
      // Default container where the tooltip will be appended
      container: "body",
      // Element used to compute position and size boundaries
      boundary: void 0,
      // Skip delay & CSS transitions when another popper is shown, so that the popper appear to instanly move to the new position.
      instantMove: false,
      // Auto destroy tooltip DOM nodes (ms)
      disposeTimeout: 0,
      // Triggers on the popper itself
      popperTriggers: [],
      // Positioning strategy
      strategy: "absolute",
      // Prevent overflow
      preventOverflow: true,
      // Flip to the opposite placement if needed
      flip: true,
      // Shift on the cross axis to prevent the popper from overflowing
      shift: true,
      // Overflow padding (px)
      overflowPadding: 0,
      // Arrow padding (px)
      arrowPadding: 0,
      // Compute arrow overflow (useful to hide it)
      arrowOverflow: true,
      // Themes
      themes: {
        tooltip: {
          // Default tooltip placement relative to target element
          placement: "top",
          // Default events that trigger the tooltip
          triggers: ["hover", "focus", "touch"],
          // Close tooltip on click on tooltip target
          hideTriggers: (e2) => [...e2, "click"],
          // Delay (ms)
          delay: {
            show: 200,
            hide: 0
          },
          // Update popper on content resize
          handleResize: false,
          // Enable HTML content in directive
          html: false,
          // Displayed when tooltip content is loading
          loadingContent: "..."
        },
        dropdown: {
          // Default dropdown placement relative to target element
          placement: "bottom",
          // Default events that trigger the dropdown
          triggers: ["click"],
          // Delay (ms)
          delay: 0,
          // Update popper on content resize
          handleResize: true,
          // Hide on clock outside
          autoHide: true
        },
        menu: {
          $extend: "dropdown",
          triggers: ["hover", "focus"],
          popperTriggers: ["hover", "focus"],
          delay: {
            show: 0,
            hide: 400
          }
        }
      }
    };
    function S(e2, t2) {
      let o3 = u.themes[e2] || {}, i2;
      do
        i2 = o3[t2], typeof i2 > "u" ? o3.$extend ? o3 = u.themes[o3.$extend] || {} : (o3 = null, i2 = u[t2]) : o3 = null;
      while (o3);
      return i2;
    }
    function Je(e2) {
      const t2 = [e2];
      let o3 = u.themes[e2] || {};
      do
        o3.$extend && !o3.$resetCss ? (t2.push(o3.$extend), o3 = u.themes[o3.$extend] || {}) : o3 = null;
      while (o3);
      return t2.map((i2) => `v-popper--theme-${i2}`);
    }
    function se(e2) {
      const t2 = [e2];
      let o3 = u.themes[e2] || {};
      do
        o3.$extend ? (t2.push(o3.$extend), o3 = u.themes[o3.$extend] || {}) : o3 = null;
      while (o3);
      return t2;
    }
    let w = false;
    if (typeof window < "u") {
      w = false;
      try {
        const e2 = Object.defineProperty({}, "passive", {
          get() {
            w = true;
          }
        });
        window.addEventListener("test", null, e2);
      } catch {
      }
    }
    let we = false;
    typeof window < "u" && typeof navigator < "u" && (we = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream);
    const ve = ["auto", "top", "bottom", "left", "right"].reduce((e2, t2) => e2.concat([
      t2,
      `${t2}-start`,
      `${t2}-end`
    ]), []), ne = {
      hover: "mouseenter",
      focus: "focus",
      click: "click",
      touch: "touchstart",
      pointer: "pointerdown"
    }, re = {
      hover: "mouseleave",
      focus: "blur",
      click: "click",
      touch: "touchend",
      pointer: "pointerup"
    };
    function pe(e2, t2) {
      const o3 = e2.indexOf(t2);
      o3 !== -1 && e2.splice(o3, 1);
    }
    function W() {
      return new Promise((e2) => requestAnimationFrame(() => {
        requestAnimationFrame(e2);
      }));
    }
    const d = [];
    let g = null;
    const ae = {};
    function de(e2) {
      let t2 = ae[e2];
      return t2 || (t2 = ae[e2] = []), t2;
    }
    let Y = function() {
    };
    typeof window < "u" && (Y = window.Element);
    function n(e2) {
      return function(t2) {
        return S(t2.theme, e2);
      };
    }
    const G = "__floating-vue__popper", K = () => /* @__PURE__ */ defineComponent({
      name: "VPopper",
      provide() {
        return {
          [G]: {
            parentPopper: this
          }
        };
      },
      inject: {
        [G]: { default: null }
      },
      props: {
        theme: {
          type: String,
          required: true
        },
        targetNodes: {
          type: Function,
          required: true
        },
        referenceNode: {
          type: Function,
          default: null
        },
        popperNode: {
          type: Function,
          required: true
        },
        shown: {
          type: Boolean,
          default: false
        },
        showGroup: {
          type: String,
          default: null
        },
        // eslint-disable-next-line vue/require-prop-types
        ariaId: {
          default: null
        },
        disabled: {
          type: Boolean,
          default: n("disabled")
        },
        positioningDisabled: {
          type: Boolean,
          default: n("positioningDisabled")
        },
        placement: {
          type: String,
          default: n("placement"),
          validator: (e2) => ve.includes(e2)
        },
        delay: {
          type: [String, Number, Object],
          default: n("delay")
        },
        distance: {
          type: [Number, String],
          default: n("distance")
        },
        skidding: {
          type: [Number, String],
          default: n("skidding")
        },
        triggers: {
          type: Array,
          default: n("triggers")
        },
        showTriggers: {
          type: [Array, Function],
          default: n("showTriggers")
        },
        hideTriggers: {
          type: [Array, Function],
          default: n("hideTriggers")
        },
        popperTriggers: {
          type: Array,
          default: n("popperTriggers")
        },
        popperShowTriggers: {
          type: [Array, Function],
          default: n("popperShowTriggers")
        },
        popperHideTriggers: {
          type: [Array, Function],
          default: n("popperHideTriggers")
        },
        container: {
          type: [String, Object, Y, Boolean],
          default: n("container")
        },
        boundary: {
          type: [String, Y],
          default: n("boundary")
        },
        strategy: {
          type: String,
          validator: (e2) => ["absolute", "fixed"].includes(e2),
          default: n("strategy")
        },
        autoHide: {
          type: [Boolean, Function],
          default: n("autoHide")
        },
        handleResize: {
          type: Boolean,
          default: n("handleResize")
        },
        instantMove: {
          type: Boolean,
          default: n("instantMove")
        },
        eagerMount: {
          type: Boolean,
          default: n("eagerMount")
        },
        popperClass: {
          type: [String, Array, Object],
          default: n("popperClass")
        },
        computeTransformOrigin: {
          type: Boolean,
          default: n("computeTransformOrigin")
        },
        /**
         * @deprecated
         */
        autoMinSize: {
          type: Boolean,
          default: n("autoMinSize")
        },
        autoSize: {
          type: [Boolean, String],
          default: n("autoSize")
        },
        /**
         * @deprecated
         */
        autoMaxSize: {
          type: Boolean,
          default: n("autoMaxSize")
        },
        autoBoundaryMaxSize: {
          type: Boolean,
          default: n("autoBoundaryMaxSize")
        },
        preventOverflow: {
          type: Boolean,
          default: n("preventOverflow")
        },
        overflowPadding: {
          type: [Number, String],
          default: n("overflowPadding")
        },
        arrowPadding: {
          type: [Number, String],
          default: n("arrowPadding")
        },
        arrowOverflow: {
          type: Boolean,
          default: n("arrowOverflow")
        },
        flip: {
          type: Boolean,
          default: n("flip")
        },
        shift: {
          type: Boolean,
          default: n("shift")
        },
        shiftCrossAxis: {
          type: Boolean,
          default: n("shiftCrossAxis")
        },
        noAutoFocus: {
          type: Boolean,
          default: n("noAutoFocus")
        },
        disposeTimeout: {
          type: Number,
          default: n("disposeTimeout")
        }
      },
      emits: {
        show: () => true,
        hide: () => true,
        "update:shown": (e2) => true,
        "apply-show": () => true,
        "apply-hide": () => true,
        "close-group": () => true,
        "close-directive": () => true,
        "auto-hide": () => true,
        resize: () => true
      },
      data() {
        return {
          isShown: false,
          isMounted: false,
          skipTransition: false,
          classes: {
            showFrom: false,
            showTo: false,
            hideFrom: false,
            hideTo: true
          },
          result: {
            x: 0,
            y: 0,
            placement: "",
            strategy: this.strategy,
            arrow: {
              x: 0,
              y: 0,
              centerOffset: 0
            },
            transformOrigin: null
          },
          shownChildren: /* @__PURE__ */ new Set(),
          lastAutoHide: true
        };
      },
      computed: {
        popperId() {
          return this.ariaId != null ? this.ariaId : this.randomId;
        },
        shouldMountContent() {
          return this.eagerMount || this.isMounted;
        },
        slotData() {
          return {
            popperId: this.popperId,
            isShown: this.isShown,
            shouldMountContent: this.shouldMountContent,
            skipTransition: this.skipTransition,
            autoHide: typeof this.autoHide == "function" ? this.lastAutoHide : this.autoHide,
            show: this.show,
            hide: this.hide,
            handleResize: this.handleResize,
            onResize: this.onResize,
            classes: {
              ...this.classes,
              popperClass: this.popperClass
            },
            result: this.positioningDisabled ? null : this.result,
            attrs: this.$attrs
          };
        },
        parentPopper() {
          var e2;
          return (e2 = this[G]) == null ? void 0 : e2.parentPopper;
        },
        hasPopperShowTriggerHover() {
          var e2, t2;
          return ((e2 = this.popperTriggers) == null ? void 0 : e2.includes("hover")) || ((t2 = this.popperShowTriggers) == null ? void 0 : t2.includes("hover"));
        }
      },
      watch: {
        shown: "$_autoShowHide",
        disabled(e2) {
          e2 ? this.dispose() : this.init();
        },
        async container() {
          this.isShown && (this.$_ensureTeleport(), await this.$_computePosition());
        },
        ...[
          "triggers",
          "positioningDisabled"
        ].reduce((e2, t2) => (e2[t2] = "$_refreshListeners", e2), {}),
        ...[
          "placement",
          "distance",
          "skidding",
          "boundary",
          "strategy",
          "overflowPadding",
          "arrowPadding",
          "preventOverflow",
          "shift",
          "shiftCrossAxis",
          "flip"
        ].reduce((e2, t2) => (e2[t2] = "$_computePosition", e2), {})
      },
      created() {
        this.$_isDisposed = true, this.randomId = `popper_${[Math.random(), Date.now()].map((e2) => e2.toString(36).substring(2, 10)).join("_")}`, this.autoMinSize && console.warn('[floating-vue] `autoMinSize` option is deprecated. Use `autoSize="min"` instead.'), this.autoMaxSize && console.warn("[floating-vue] `autoMaxSize` option is deprecated. Use `autoBoundaryMaxSize` instead.");
      },
      mounted() {
        this.init(), this.$_detachPopperNode();
      },
      activated() {
        this.$_autoShowHide();
      },
      deactivated() {
        this.hide();
      },
      beforeUnmount() {
        this.dispose();
      },
      methods: {
        show({ event: e2 = null, skipDelay: t2 = false, force: o3 = false } = {}) {
          var i2, s2;
          (i2 = this.parentPopper) != null && i2.lockedChild && this.parentPopper.lockedChild !== this || (this.$_pendingHide = false, (o3 || !this.disabled) && (((s2 = this.parentPopper) == null ? void 0 : s2.lockedChild) === this && (this.parentPopper.lockedChild = null), this.$_scheduleShow(e2, t2), this.$emit("show"), this.$_showFrameLocked = true, requestAnimationFrame(() => {
            this.$_showFrameLocked = false;
          })), this.$emit("update:shown", true));
        },
        hide({ event: e2 = null, skipDelay: t2 = false } = {}) {
          var o3;
          if (!this.$_hideInProgress) {
            if (this.shownChildren.size > 0) {
              this.$_pendingHide = true;
              return;
            }
            if (this.hasPopperShowTriggerHover && this.$_isAimingPopper()) {
              this.parentPopper && (this.parentPopper.lockedChild = this, clearTimeout(this.parentPopper.lockedChildTimer), this.parentPopper.lockedChildTimer = setTimeout(() => {
                this.parentPopper.lockedChild === this && (this.parentPopper.lockedChild.hide({ skipDelay: t2 }), this.parentPopper.lockedChild = null);
              }, 1e3));
              return;
            }
            ((o3 = this.parentPopper) == null ? void 0 : o3.lockedChild) === this && (this.parentPopper.lockedChild = null), this.$_pendingHide = false, this.$_scheduleHide(e2, t2), this.$emit("hide"), this.$emit("update:shown", false);
          }
        },
        init() {
          var e2;
          this.$_isDisposed && (this.$_isDisposed = false, this.isMounted = false, this.$_events = [], this.$_preventShow = false, this.$_referenceNode = ((e2 = this.referenceNode) == null ? void 0 : e2.call(this)) ?? this.$el, this.$_targetNodes = this.targetNodes().filter((t2) => t2.nodeType === t2.ELEMENT_NODE), this.$_popperNode = this.popperNode(), this.$_innerNode = this.$_popperNode.querySelector(".v-popper__inner"), this.$_arrowNode = this.$_popperNode.querySelector(".v-popper__arrow-container"), this.$_swapTargetAttrs("title", "data-original-title"), this.$_detachPopperNode(), this.triggers.length && this.$_addEventListeners(), this.shown && this.show());
        },
        dispose() {
          this.$_isDisposed || (this.$_isDisposed = true, this.$_removeEventListeners(), this.hide({ skipDelay: true }), this.$_detachPopperNode(), this.isMounted = false, this.isShown = false, this.$_updateParentShownChildren(false), this.$_swapTargetAttrs("data-original-title", "title"));
        },
        async onResize() {
          this.isShown && (await this.$_computePosition(), this.$emit("resize"));
        },
        async $_computePosition() {
          if (this.$_isDisposed || this.positioningDisabled)
            return;
          const e2 = {
            strategy: this.strategy,
            middleware: []
          };
          (this.distance || this.skidding) && e2.middleware.push(offset({
            mainAxis: this.distance,
            crossAxis: this.skidding
          }));
          const t2 = this.placement.startsWith("auto");
          if (t2 ? e2.middleware.push(autoPlacement({
            alignment: this.placement.split("-")[1] ?? ""
          })) : e2.placement = this.placement, this.preventOverflow && (this.shift && e2.middleware.push(shift({
            padding: this.overflowPadding,
            boundary: this.boundary,
            crossAxis: this.shiftCrossAxis
          })), !t2 && this.flip && e2.middleware.push(flip({
            padding: this.overflowPadding,
            boundary: this.boundary
          }))), e2.middleware.push(arrow({
            element: this.$_arrowNode,
            padding: this.arrowPadding
          })), this.arrowOverflow && e2.middleware.push({
            name: "arrowOverflow",
            fn: ({ placement: i2, rects: s2, middlewareData: r2 }) => {
              let p2;
              const { centerOffset: a2 } = r2.arrow;
              return i2.startsWith("top") || i2.startsWith("bottom") ? p2 = Math.abs(a2) > s2.reference.width / 2 : p2 = Math.abs(a2) > s2.reference.height / 2, {
                data: {
                  overflow: p2
                }
              };
            }
          }), this.autoMinSize || this.autoSize) {
            const i2 = this.autoSize ? this.autoSize : this.autoMinSize ? "min" : null;
            e2.middleware.push({
              name: "autoSize",
              fn: ({ rects: s2, placement: r2, middlewareData: p2 }) => {
                var h2;
                if ((h2 = p2.autoSize) != null && h2.skip)
                  return {};
                let a2, l2;
                return r2.startsWith("top") || r2.startsWith("bottom") ? a2 = s2.reference.width : l2 = s2.reference.height, this.$_innerNode.style[i2 === "min" ? "minWidth" : i2 === "max" ? "maxWidth" : "width"] = a2 != null ? `${a2}px` : null, this.$_innerNode.style[i2 === "min" ? "minHeight" : i2 === "max" ? "maxHeight" : "height"] = l2 != null ? `${l2}px` : null, {
                  data: {
                    skip: true
                  },
                  reset: {
                    rects: true
                  }
                };
              }
            });
          }
          (this.autoMaxSize || this.autoBoundaryMaxSize) && (this.$_innerNode.style.maxWidth = null, this.$_innerNode.style.maxHeight = null, e2.middleware.push(size({
            boundary: this.boundary,
            padding: this.overflowPadding,
            apply: ({ availableWidth: i2, availableHeight: s2 }) => {
              this.$_innerNode.style.maxWidth = i2 != null ? `${i2}px` : null, this.$_innerNode.style.maxHeight = s2 != null ? `${s2}px` : null;
            }
          })));
          const o3 = await B$1(this.$_referenceNode, this.$_popperNode, e2);
          Object.assign(this.result, {
            x: o3.x,
            y: o3.y,
            placement: o3.placement,
            strategy: o3.strategy,
            arrow: {
              ...o3.middlewareData.arrow,
              ...o3.middlewareData.arrowOverflow
            }
          });
        },
        $_scheduleShow(e2 = null, t2 = false) {
          if (this.$_updateParentShownChildren(true), this.$_hideInProgress = false, clearTimeout(this.$_scheduleTimer), g && this.instantMove && g.instantMove && g !== this.parentPopper) {
            g.$_applyHide(true), this.$_applyShow(true);
            return;
          }
          t2 ? this.$_applyShow() : this.$_scheduleTimer = setTimeout(this.$_applyShow.bind(this), this.$_computeDelay("show"));
        },
        $_scheduleHide(e2 = null, t2 = false) {
          if (this.shownChildren.size > 0) {
            this.$_pendingHide = true;
            return;
          }
          this.$_updateParentShownChildren(false), this.$_hideInProgress = true, clearTimeout(this.$_scheduleTimer), this.isShown && (g = this), t2 ? this.$_applyHide() : this.$_scheduleTimer = setTimeout(this.$_applyHide.bind(this), this.$_computeDelay("hide"));
        },
        $_computeDelay(e2) {
          const t2 = this.delay;
          return parseInt(t2 && t2[e2] || t2 || 0);
        },
        async $_applyShow(e2 = false) {
          clearTimeout(this.$_disposeTimer), clearTimeout(this.$_scheduleTimer), this.skipTransition = e2, !this.isShown && (this.$_ensureTeleport(), await W(), await this.$_computePosition(), await this.$_applyShowEffect(), this.positioningDisabled || this.$_registerEventListeners([
            ...D(this.$_referenceNode),
            ...D(this.$_popperNode)
          ], "scroll", () => {
            this.$_computePosition();
          }));
        },
        async $_applyShowEffect() {
          if (this.$_hideInProgress)
            return;
          if (this.computeTransformOrigin) {
            const t2 = this.$_referenceNode.getBoundingClientRect(), o3 = this.$_popperNode.querySelector(".v-popper__wrapper"), i2 = o3.parentNode.getBoundingClientRect(), s2 = t2.x + t2.width / 2 - (i2.left + o3.offsetLeft), r2 = t2.y + t2.height / 2 - (i2.top + o3.offsetTop);
            this.result.transformOrigin = `${s2}px ${r2}px`;
          }
          this.isShown = true, this.$_applyAttrsToTarget({
            "aria-describedby": this.popperId,
            "data-popper-shown": ""
          });
          const e2 = this.showGroup;
          if (e2) {
            let t2;
            for (let o3 = 0; o3 < d.length; o3++)
              t2 = d[o3], t2.showGroup !== e2 && (t2.hide(), t2.$emit("close-group"));
          }
          d.push(this), document.body.classList.add("v-popper--some-open");
          for (const t2 of se(this.theme))
            de(t2).push(this), document.body.classList.add(`v-popper--some-open--${t2}`);
          this.$emit("apply-show"), this.classes.showFrom = true, this.classes.showTo = false, this.classes.hideFrom = false, this.classes.hideTo = false, await W(), this.classes.showFrom = false, this.classes.showTo = true, this.noAutoFocus || this.$_popperNode.focus();
        },
        async $_applyHide(e2 = false) {
          if (this.shownChildren.size > 0) {
            this.$_pendingHide = true, this.$_hideInProgress = false;
            return;
          }
          if (clearTimeout(this.$_scheduleTimer), !this.isShown)
            return;
          this.skipTransition = e2, pe(d, this), d.length === 0 && document.body.classList.remove("v-popper--some-open");
          for (const o3 of se(this.theme)) {
            const i2 = de(o3);
            pe(i2, this), i2.length === 0 && document.body.classList.remove(`v-popper--some-open--${o3}`);
          }
          g === this && (g = null), this.isShown = false, this.$_applyAttrsToTarget({
            "aria-describedby": void 0,
            "data-popper-shown": void 0
          }), clearTimeout(this.$_disposeTimer);
          const t2 = this.disposeTimeout;
          t2 !== null && (this.$_disposeTimer = setTimeout(() => {
            this.$_popperNode && (this.$_detachPopperNode(), this.isMounted = false);
          }, t2)), this.$_removeEventListeners("scroll"), this.$emit("apply-hide"), this.classes.showFrom = false, this.classes.showTo = false, this.classes.hideFrom = true, this.classes.hideTo = false, await W(), this.classes.hideFrom = false, this.classes.hideTo = true;
        },
        $_autoShowHide() {
          this.shown ? this.show() : this.hide();
        },
        $_ensureTeleport() {
          if (this.$_isDisposed)
            return;
          let e2 = this.container;
          if (typeof e2 == "string" ? e2 = window.document.querySelector(e2) : e2 === false && (e2 = this.$_targetNodes[0].parentNode), !e2)
            throw new Error("No container for popover: " + this.container);
          e2.appendChild(this.$_popperNode), this.isMounted = true;
        },
        $_addEventListeners() {
          const e2 = (o3) => {
            this.isShown && !this.$_hideInProgress || (o3.usedByTooltip = true, !this.$_preventShow && this.show({ event: o3 }));
          };
          this.$_registerTriggerListeners(this.$_targetNodes, ne, this.triggers, this.showTriggers, e2), this.$_registerTriggerListeners([this.$_popperNode], ne, this.popperTriggers, this.popperShowTriggers, e2);
          const t2 = (o3) => {
            o3.usedByTooltip || this.hide({ event: o3 });
          };
          this.$_registerTriggerListeners(this.$_targetNodes, re, this.triggers, this.hideTriggers, t2), this.$_registerTriggerListeners([this.$_popperNode], re, this.popperTriggers, this.popperHideTriggers, t2);
        },
        $_registerEventListeners(e2, t2, o3) {
          this.$_events.push({ targetNodes: e2, eventType: t2, handler: o3 }), e2.forEach((i2) => i2.addEventListener(t2, o3, w ? {
            passive: true
          } : void 0));
        },
        $_registerTriggerListeners(e2, t2, o3, i2, s2) {
          let r2 = o3;
          i2 != null && (r2 = typeof i2 == "function" ? i2(r2) : i2), r2.forEach((p2) => {
            const a2 = t2[p2];
            a2 && this.$_registerEventListeners(e2, a2, s2);
          });
        },
        $_removeEventListeners(e2) {
          const t2 = [];
          this.$_events.forEach((o3) => {
            const { targetNodes: i2, eventType: s2, handler: r2 } = o3;
            !e2 || e2 === s2 ? i2.forEach((p2) => p2.removeEventListener(s2, r2)) : t2.push(o3);
          }), this.$_events = t2;
        },
        $_refreshListeners() {
          this.$_isDisposed || (this.$_removeEventListeners(), this.$_addEventListeners());
        },
        $_handleGlobalClose(e2, t2 = false) {
          this.$_showFrameLocked || (this.hide({ event: e2 }), e2.closePopover ? this.$emit("close-directive") : this.$emit("auto-hide"), t2 && (this.$_preventShow = true, setTimeout(() => {
            this.$_preventShow = false;
          }, 300)));
        },
        $_detachPopperNode() {
          this.$_popperNode.parentNode && this.$_popperNode.parentNode.removeChild(this.$_popperNode);
        },
        $_swapTargetAttrs(e2, t2) {
          for (const o3 of this.$_targetNodes) {
            const i2 = o3.getAttribute(e2);
            i2 && (o3.removeAttribute(e2), o3.setAttribute(t2, i2));
          }
        },
        $_applyAttrsToTarget(e2) {
          for (const t2 of this.$_targetNodes)
            for (const o3 in e2) {
              const i2 = e2[o3];
              i2 == null ? t2.removeAttribute(o3) : t2.setAttribute(o3, i2);
            }
        },
        $_updateParentShownChildren(e2) {
          let t2 = this.parentPopper;
          for (; t2; )
            e2 ? t2.shownChildren.add(this.randomId) : (t2.shownChildren.delete(this.randomId), t2.$_pendingHide && t2.hide()), t2 = t2.parentPopper;
        },
        $_isAimingPopper() {
          const e2 = this.$_referenceNode.getBoundingClientRect();
          if (y >= e2.left && y <= e2.right && _ >= e2.top && _ <= e2.bottom) {
            const t2 = this.$_popperNode.getBoundingClientRect(), o3 = y - c, i2 = _ - m, r2 = t2.left + t2.width / 2 - c + (t2.top + t2.height / 2) - m + t2.width + t2.height, p2 = c + o3 * r2, a2 = m + i2 * r2;
            return C(c, m, p2, a2, t2.left, t2.top, t2.left, t2.bottom) || // Left edge
            C(c, m, p2, a2, t2.left, t2.top, t2.right, t2.top) || // Top edge
            C(c, m, p2, a2, t2.right, t2.top, t2.right, t2.bottom) || // Right edge
            C(c, m, p2, a2, t2.left, t2.bottom, t2.right, t2.bottom);
          }
          return false;
        }
      },
      render() {
        return this.$slots.default(this.slotData);
      }
    });
    typeof document < "u" && typeof window < "u" && (we ? (document.addEventListener("touchstart", le, w ? {
      passive: true,
      capture: true
    } : true), document.addEventListener("touchend", Ze, w ? {
      passive: true,
      capture: true
    } : true)) : (window.addEventListener("mousedown", le, true), window.addEventListener("click", Qe, true)), window.addEventListener("resize", ot));
    function le(e2) {
      for (let t2 = 0; t2 < d.length; t2++) {
        const o3 = d[t2];
        try {
          const i2 = o3.popperNode();
          o3.$_mouseDownContains = i2.contains(e2.target);
        } catch {
        }
      }
    }
    function Qe(e2) {
      ye(e2);
    }
    function Ze(e2) {
      ye(e2, true);
    }
    function ye(e2, t2 = false) {
      const o3 = {};
      for (let i2 = d.length - 1; i2 >= 0; i2--) {
        const s2 = d[i2];
        try {
          const r2 = s2.$_containsGlobalTarget = et(s2, e2);
          s2.$_pendingHide = false, requestAnimationFrame(() => {
            if (s2.$_pendingHide = false, !o3[s2.randomId] && he(s2, r2, e2)) {
              if (s2.$_handleGlobalClose(e2, t2), !e2.closeAllPopover && e2.closePopover && r2) {
                let a2 = s2.parentPopper;
                for (; a2; )
                  o3[a2.randomId] = true, a2 = a2.parentPopper;
                return;
              }
              let p2 = s2.parentPopper;
              for (; p2 && he(p2, p2.$_containsGlobalTarget, e2); ) {
                p2.$_handleGlobalClose(e2, t2);
                p2 = p2.parentPopper;
              }
            }
          });
        } catch {
        }
      }
    }
    function et(e2, t2) {
      const o3 = e2.popperNode();
      return e2.$_mouseDownContains || o3.contains(t2.target);
    }
    function he(e2, t2, o3) {
      return o3.closeAllPopover || o3.closePopover && t2 || tt(e2, o3) && !t2;
    }
    function tt(e2, t2) {
      if (typeof e2.autoHide == "function") {
        const o3 = e2.autoHide(t2);
        return e2.lastAutoHide = o3, o3;
      }
      return e2.autoHide;
    }
    function ot(e2) {
      for (let t2 = 0; t2 < d.length; t2++)
        d[t2].$_computePosition(e2);
    }
    let c = 0, m = 0, y = 0, _ = 0;
    typeof window < "u" && window.addEventListener("mousemove", (e2) => {
      c = y, m = _, y = e2.clientX, _ = e2.clientY;
    }, w ? {
      passive: true
    } : void 0);
    function C(e2, t2, o3, i2, s2, r2, p2, a2) {
      const l2 = ((p2 - s2) * (t2 - r2) - (a2 - r2) * (e2 - s2)) / ((a2 - r2) * (o3 - e2) - (p2 - s2) * (i2 - t2)), h2 = ((o3 - e2) * (t2 - r2) - (i2 - t2) * (e2 - s2)) / ((a2 - r2) * (o3 - e2) - (p2 - s2) * (i2 - t2));
      return l2 >= 0 && l2 <= 1 && h2 >= 0 && h2 <= 1;
    }
    const it = {
      extends: K()
    }, M = (e2, t2) => {
      const o3 = e2.__vccOpts || e2;
      for (const [i2, s2] of t2)
        o3[i2] = s2;
      return o3;
    };
    function st(e2, t2, o3, i2, s2, r2) {
      return openBlock(), createElementBlock("div", {
        ref: "reference",
        class: normalizeClass(["v-popper", {
          "v-popper--shown": e2.slotData.isShown
        }])
      }, [
        renderSlot(e2.$slots, "default", normalizeProps(guardReactiveProps(e2.slotData)))
      ], 2);
    }
    const nt = /* @__PURE__ */ M(it, [["render", st]]);
    function rt() {
      var e2 = window.navigator.userAgent, t2 = e2.indexOf("MSIE ");
      if (t2 > 0)
        return parseInt(e2.substring(t2 + 5, e2.indexOf(".", t2)), 10);
      var o3 = e2.indexOf("Trident/");
      if (o3 > 0) {
        var i2 = e2.indexOf("rv:");
        return parseInt(e2.substring(i2 + 3, e2.indexOf(".", i2)), 10);
      }
      var s2 = e2.indexOf("Edge/");
      return s2 > 0 ? parseInt(e2.substring(s2 + 5, e2.indexOf(".", s2)), 10) : -1;
    }
    let z;
    function U() {
      U.init || (U.init = true, z = rt() !== -1);
    }
    var B = {
      name: "ResizeObserver",
      props: {
        emitOnMount: {
          type: Boolean,
          default: false
        },
        ignoreWidth: {
          type: Boolean,
          default: false
        },
        ignoreHeight: {
          type: Boolean,
          default: false
        }
      },
      emits: [
        "notify"
      ],
      mounted() {
        U(), nextTick(() => {
          this._w = this.$el.offsetWidth, this._h = this.$el.offsetHeight, this.emitOnMount && this.emitSize();
        });
        const e2 = document.createElement("object");
        this._resizeObject = e2, e2.setAttribute("aria-hidden", "true"), e2.setAttribute("tabindex", -1), e2.onload = this.addResizeHandlers, e2.type = "text/html", z && this.$el.appendChild(e2), e2.data = "about:blank", z || this.$el.appendChild(e2);
      },
      beforeUnmount() {
        this.removeResizeHandlers();
      },
      methods: {
        compareAndNotify() {
          (!this.ignoreWidth && this._w !== this.$el.offsetWidth || !this.ignoreHeight && this._h !== this.$el.offsetHeight) && (this._w = this.$el.offsetWidth, this._h = this.$el.offsetHeight, this.emitSize());
        },
        emitSize() {
          this.$emit("notify", {
            width: this._w,
            height: this._h
          });
        },
        addResizeHandlers() {
          this._resizeObject.contentDocument.defaultView.addEventListener("resize", this.compareAndNotify), this.compareAndNotify();
        },
        removeResizeHandlers() {
          this._resizeObject && this._resizeObject.onload && (!z && this._resizeObject.contentDocument && this._resizeObject.contentDocument.defaultView.removeEventListener("resize", this.compareAndNotify), this.$el.removeChild(this._resizeObject), this._resizeObject.onload = null, this._resizeObject = null);
        }
      }
    };
    const pt = /* @__PURE__ */ withScopeId();
    pushScopeId("data-v-b329ee4c");
    const at = {
      class: "resize-observer",
      tabindex: "-1"
    };
    popScopeId();
    const dt = /* @__PURE__ */ pt((e2, t2, o3, i2, s2, r2) => (openBlock(), createBlock("div", at)));
    B.render = dt;
    B.__scopeId = "data-v-b329ee4c";
    B.__file = "src/components/ResizeObserver.vue";
    const J = (e2 = "theme") => ({
      computed: {
        themeClass() {
          return Je(this[e2]);
        }
      }
    }), lt = /* @__PURE__ */ defineComponent({
      name: "VPopperContent",
      components: {
        ResizeObserver: B
      },
      mixins: [
        J()
      ],
      props: {
        popperId: String,
        theme: String,
        shown: Boolean,
        mounted: Boolean,
        skipTransition: Boolean,
        autoHide: Boolean,
        handleResize: Boolean,
        classes: Object,
        result: Object
      },
      emits: [
        "hide",
        "resize"
      ],
      methods: {
        toPx(e2) {
          return e2 != null && !isNaN(e2) ? `${e2}px` : null;
        }
      }
    }), ht = ["id", "aria-hidden", "tabindex", "data-popper-placement"], ut = {
      ref: "inner",
      class: "v-popper__inner"
    }, ft = /* @__PURE__ */ createBaseVNode("div", { class: "v-popper__arrow-outer" }, null, -1), ct = /* @__PURE__ */ createBaseVNode("div", { class: "v-popper__arrow-inner" }, null, -1), mt = [
      ft,
      ct
    ];
    function gt(e2, t2, o3, i2, s2, r2) {
      const p2 = resolveComponent("ResizeObserver");
      return openBlock(), createElementBlock("div", {
        id: e2.popperId,
        ref: "popover",
        class: normalizeClass(["v-popper__popper", [
          e2.themeClass,
          e2.classes.popperClass,
          {
            "v-popper__popper--shown": e2.shown,
            "v-popper__popper--hidden": !e2.shown,
            "v-popper__popper--show-from": e2.classes.showFrom,
            "v-popper__popper--show-to": e2.classes.showTo,
            "v-popper__popper--hide-from": e2.classes.hideFrom,
            "v-popper__popper--hide-to": e2.classes.hideTo,
            "v-popper__popper--skip-transition": e2.skipTransition,
            "v-popper__popper--arrow-overflow": e2.result && e2.result.arrow.overflow,
            "v-popper__popper--no-positioning": !e2.result
          }
        ]]),
        style: normalizeStyle(e2.result ? {
          position: e2.result.strategy,
          transform: `translate3d(${Math.round(e2.result.x)}px,${Math.round(e2.result.y)}px,0)`
        } : void 0),
        "aria-hidden": e2.shown ? "false" : "true",
        tabindex: e2.autoHide ? 0 : void 0,
        "data-popper-placement": e2.result ? e2.result.placement : void 0,
        onKeyup: t2[2] || (t2[2] = withKeys((a2) => e2.autoHide && e2.$emit("hide"), ["esc"]))
      }, [
        createBaseVNode("div", {
          class: "v-popper__backdrop",
          onClick: t2[0] || (t2[0] = (a2) => e2.autoHide && e2.$emit("hide"))
        }),
        createBaseVNode("div", {
          class: "v-popper__wrapper",
          style: normalizeStyle(e2.result ? {
            transformOrigin: e2.result.transformOrigin
          } : void 0)
        }, [
          createBaseVNode("div", ut, [
            e2.mounted ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createBaseVNode("div", null, [
                renderSlot(e2.$slots, "default")
              ]),
              e2.handleResize ? (openBlock(), createBlock(p2, {
                key: 0,
                onNotify: t2[1] || (t2[1] = (a2) => e2.$emit("resize", a2))
              })) : createCommentVNode("", true)
            ], 64)) : createCommentVNode("", true)
          ], 512),
          createBaseVNode("div", {
            ref: "arrow",
            class: "v-popper__arrow-container",
            style: normalizeStyle(e2.result ? {
              left: e2.toPx(e2.result.arrow.x),
              top: e2.toPx(e2.result.arrow.y)
            } : void 0)
          }, mt, 4)
        ], 4)
      ], 46, ht);
    }
    const Q = /* @__PURE__ */ M(lt, [["render", gt]]), Z = {
      methods: {
        show(...e2) {
          return this.$refs.popper.show(...e2);
        },
        hide(...e2) {
          return this.$refs.popper.hide(...e2);
        },
        dispose(...e2) {
          return this.$refs.popper.dispose(...e2);
        },
        onResize(...e2) {
          return this.$refs.popper.onResize(...e2);
        }
      }
    }, $t = /* @__PURE__ */ defineComponent({
      name: "VPopperWrapper",
      components: {
        Popper: nt,
        PopperContent: Q
      },
      mixins: [
        Z,
        J("finalTheme")
      ],
      props: {
        theme: {
          type: String,
          default: null
        },
        referenceNode: {
          type: Function,
          default: null
        },
        shown: {
          type: Boolean,
          default: false
        },
        showGroup: {
          type: String,
          default: null
        },
        // eslint-disable-next-line vue/require-prop-types
        ariaId: {
          default: null
        },
        disabled: {
          type: Boolean,
          default: void 0
        },
        positioningDisabled: {
          type: Boolean,
          default: void 0
        },
        placement: {
          type: String,
          default: void 0
        },
        delay: {
          type: [String, Number, Object],
          default: void 0
        },
        distance: {
          type: [Number, String],
          default: void 0
        },
        skidding: {
          type: [Number, String],
          default: void 0
        },
        triggers: {
          type: Array,
          default: void 0
        },
        showTriggers: {
          type: [Array, Function],
          default: void 0
        },
        hideTriggers: {
          type: [Array, Function],
          default: void 0
        },
        popperTriggers: {
          type: Array,
          default: void 0
        },
        popperShowTriggers: {
          type: [Array, Function],
          default: void 0
        },
        popperHideTriggers: {
          type: [Array, Function],
          default: void 0
        },
        container: {
          type: [String, Object, Element, Boolean],
          default: void 0
        },
        boundary: {
          type: [String, Element],
          default: void 0
        },
        strategy: {
          type: String,
          default: void 0
        },
        autoHide: {
          type: [Boolean, Function],
          default: void 0
        },
        handleResize: {
          type: Boolean,
          default: void 0
        },
        instantMove: {
          type: Boolean,
          default: void 0
        },
        eagerMount: {
          type: Boolean,
          default: void 0
        },
        popperClass: {
          type: [String, Array, Object],
          default: void 0
        },
        computeTransformOrigin: {
          type: Boolean,
          default: void 0
        },
        /**
         * @deprecated
         */
        autoMinSize: {
          type: Boolean,
          default: void 0
        },
        autoSize: {
          type: [Boolean, String],
          default: void 0
        },
        /**
         * @deprecated
         */
        autoMaxSize: {
          type: Boolean,
          default: void 0
        },
        autoBoundaryMaxSize: {
          type: Boolean,
          default: void 0
        },
        preventOverflow: {
          type: Boolean,
          default: void 0
        },
        overflowPadding: {
          type: [Number, String],
          default: void 0
        },
        arrowPadding: {
          type: [Number, String],
          default: void 0
        },
        arrowOverflow: {
          type: Boolean,
          default: void 0
        },
        flip: {
          type: Boolean,
          default: void 0
        },
        shift: {
          type: Boolean,
          default: void 0
        },
        shiftCrossAxis: {
          type: Boolean,
          default: void 0
        },
        noAutoFocus: {
          type: Boolean,
          default: void 0
        },
        disposeTimeout: {
          type: Number,
          default: void 0
        }
      },
      emits: {
        show: () => true,
        hide: () => true,
        "update:shown": (e2) => true,
        "apply-show": () => true,
        "apply-hide": () => true,
        "close-group": () => true,
        "close-directive": () => true,
        "auto-hide": () => true,
        resize: () => true
      },
      computed: {
        finalTheme() {
          return this.theme ?? this.$options.vPopperTheme;
        }
      },
      methods: {
        getTargetNodes() {
          return Array.from(this.$el.children).filter((e2) => e2 !== this.$refs.popperContent.$el);
        }
      }
    });
    function wt(e2, t2, o3, i2, s2, r2) {
      const p2 = resolveComponent("PopperContent"), a2 = resolveComponent("Popper");
      return openBlock(), createBlock(a2, mergeProps({ ref: "popper" }, e2.$props, {
        theme: e2.finalTheme,
        "target-nodes": e2.getTargetNodes,
        "popper-node": () => e2.$refs.popperContent.$el,
        class: [
          e2.themeClass
        ],
        onShow: t2[0] || (t2[0] = () => e2.$emit("show")),
        onHide: t2[1] || (t2[1] = () => e2.$emit("hide")),
        "onUpdate:shown": t2[2] || (t2[2] = (l2) => e2.$emit("update:shown", l2)),
        onApplyShow: t2[3] || (t2[3] = () => e2.$emit("apply-show")),
        onApplyHide: t2[4] || (t2[4] = () => e2.$emit("apply-hide")),
        onCloseGroup: t2[5] || (t2[5] = () => e2.$emit("close-group")),
        onCloseDirective: t2[6] || (t2[6] = () => e2.$emit("close-directive")),
        onAutoHide: t2[7] || (t2[7] = () => e2.$emit("auto-hide")),
        onResize: t2[8] || (t2[8] = () => e2.$emit("resize"))
      }), {
        default: withCtx(({
          popperId: l2,
          isShown: h2,
          shouldMountContent: E2,
          skipTransition: L2,
          autoHide: D2,
          show: I2,
          hide: v2,
          handleResize: F2,
          onResize: R2,
          classes: j2,
          result: Me2
        }) => [
          renderSlot(e2.$slots, "default", {
            shown: h2,
            show: I2,
            hide: v2
          }),
          createVNode(p2, {
            ref: "popperContent",
            "popper-id": l2,
            theme: e2.finalTheme,
            shown: h2,
            mounted: E2,
            "skip-transition": L2,
            "auto-hide": D2,
            "handle-resize": F2,
            classes: j2,
            result: Me2,
            onHide: v2,
            onResize: R2
          }, {
            default: withCtx(() => [
              renderSlot(e2.$slots, "popper", {
                shown: h2,
                hide: v2
              })
            ]),
            _: 2
          }, 1032, ["popper-id", "theme", "shown", "mounted", "skip-transition", "auto-hide", "handle-resize", "classes", "result", "onHide", "onResize"])
        ]),
        _: 3
      }, 16, ["theme", "target-nodes", "popper-node", "class"]);
    }
    const k = /* @__PURE__ */ M($t, [["render", wt]]), _e = {
      ...k,
      name: "VDropdown",
      vPopperTheme: "dropdown"
    }, Te = {
      ...k,
      name: "VMenu",
      vPopperTheme: "menu"
    }, Pe = {
      ...k,
      name: "VTooltip",
      vPopperTheme: "tooltip"
    }, vt = /* @__PURE__ */ defineComponent({
      name: "VTooltipDirective",
      components: {
        Popper: K(),
        PopperContent: Q
      },
      mixins: [
        Z
      ],
      inheritAttrs: false,
      props: {
        theme: {
          type: String,
          default: "tooltip"
        },
        html: {
          type: Boolean,
          default: (e2) => S(e2.theme, "html")
        },
        content: {
          type: [String, Number, Function],
          default: null
        },
        loadingContent: {
          type: String,
          default: (e2) => S(e2.theme, "loadingContent")
        },
        targetNodes: {
          type: Function,
          required: true
        }
      },
      data() {
        return {
          asyncContent: null
        };
      },
      computed: {
        isContentAsync() {
          return typeof this.content == "function";
        },
        loading() {
          return this.isContentAsync && this.asyncContent == null;
        },
        finalContent() {
          return this.isContentAsync ? this.loading ? this.loadingContent : this.asyncContent : this.content;
        }
      },
      watch: {
        content: {
          handler() {
            this.fetchContent(true);
          },
          immediate: true
        },
        async finalContent() {
          await this.$nextTick(), this.$refs.popper.onResize();
        }
      },
      created() {
        this.$_fetchId = 0;
      },
      methods: {
        fetchContent(e2) {
          if (typeof this.content == "function" && this.$_isShown && (e2 || !this.$_loading && this.asyncContent == null)) {
            this.asyncContent = null, this.$_loading = true;
            const t2 = ++this.$_fetchId, o3 = this.content(this);
            o3.then ? o3.then((i2) => this.onResult(t2, i2)) : this.onResult(t2, o3);
          }
        },
        onResult(e2, t2) {
          e2 === this.$_fetchId && (this.$_loading = false, this.asyncContent = t2);
        },
        onShow() {
          this.$_isShown = true, this.fetchContent();
        },
        onHide() {
          this.$_isShown = false;
        }
      }
    }), yt = ["innerHTML"], _t = ["textContent"];
    function Tt(e2, t2, o3, i2, s2, r2) {
      const p2 = resolveComponent("PopperContent"), a2 = resolveComponent("Popper");
      return openBlock(), createBlock(a2, mergeProps({ ref: "popper" }, e2.$attrs, {
        theme: e2.theme,
        "target-nodes": e2.targetNodes,
        "popper-node": () => e2.$refs.popperContent.$el,
        onApplyShow: e2.onShow,
        onApplyHide: e2.onHide
      }), {
        default: withCtx(({
          popperId: l2,
          isShown: h2,
          shouldMountContent: E2,
          skipTransition: L2,
          autoHide: D2,
          hide: I2,
          handleResize: v2,
          onResize: F2,
          classes: R2,
          result: j2
        }) => [
          createVNode(p2, {
            ref: "popperContent",
            class: normalizeClass({
              "v-popper--tooltip-loading": e2.loading
            }),
            "popper-id": l2,
            theme: e2.theme,
            shown: h2,
            mounted: E2,
            "skip-transition": L2,
            "auto-hide": D2,
            "handle-resize": v2,
            classes: R2,
            result: j2,
            onHide: I2,
            onResize: F2
          }, {
            default: withCtx(() => [
              e2.html ? (openBlock(), createElementBlock("div", {
                key: 0,
                innerHTML: e2.finalContent
              }, null, 8, yt)) : (openBlock(), createElementBlock("div", {
                key: 1,
                textContent: toDisplayString$2(e2.finalContent)
              }, null, 8, _t))
            ]),
            _: 2
          }, 1032, ["class", "popper-id", "theme", "shown", "mounted", "skip-transition", "auto-hide", "handle-resize", "classes", "result", "onHide", "onResize"])
        ]),
        _: 1
      }, 16, ["theme", "target-nodes", "popper-node", "onApplyShow", "onApplyHide"]);
    }
    const Se = /* @__PURE__ */ M(vt, [["render", Tt]]), be = "v-popper--has-tooltip";
    function Pt(e2, t2) {
      let o3 = e2.placement;
      if (!o3 && t2)
        for (const i2 of ve)
          t2[i2] && (o3 = i2);
      return o3 || (o3 = S(e2.theme || "tooltip", "placement")), o3;
    }
    function Ce(e2, t2, o3) {
      let i2;
      const s2 = typeof t2;
      return s2 === "string" ? i2 = { content: t2 } : t2 && s2 === "object" ? i2 = t2 : i2 = { content: false }, i2.placement = Pt(i2, o3), i2.targetNodes = () => [e2], i2.referenceNode = () => e2, i2;
    }
    let q, b, St = 0;
    function bt() {
      if (q)
        return;
      b = ref([]), q = createApp({
        name: "VTooltipDirectiveApp",
        setup() {
          return {
            directives: b
          };
        },
        render() {
          return this.directives.map((t2) => h$4(Se, {
            ...t2.options,
            shown: t2.shown || t2.options.shown,
            key: t2.id
          }));
        },
        devtools: {
          hide: true
        }
      });
      const e2 = document.createElement("div");
      document.body.appendChild(e2), q.mount(e2);
    }
    function Ct(e2, t2, o3) {
      bt();
      const i2 = ref(Ce(e2, t2, o3)), s2 = ref(false), r2 = {
        id: St++,
        options: i2,
        shown: s2
      };
      return b.value.push(r2), e2.classList && e2.classList.add(be), e2.$_popper = {
        options: i2,
        item: r2,
        show() {
          s2.value = true;
        },
        hide() {
          s2.value = false;
        }
      };
    }
    function ze(e2) {
      if (e2.$_popper) {
        const t2 = b.value.indexOf(e2.$_popper.item);
        t2 !== -1 && b.value.splice(t2, 1), delete e2.$_popper, delete e2.$_popperOldShown, delete e2.$_popperMountTarget;
      }
      e2.classList && e2.classList.remove(be);
    }
    function ue(e2, { value: t2, modifiers: o3 }) {
      const i2 = Ce(e2, t2, o3);
      if (!i2.content || S(i2.theme || "tooltip", "disabled"))
        ze(e2);
      else {
        let s2;
        e2.$_popper ? (s2 = e2.$_popper, s2.options.value = i2) : s2 = Ct(e2, t2, o3), typeof t2.shown < "u" && t2.shown !== e2.$_popperOldShown && (e2.$_popperOldShown = t2.shown, t2.shown ? s2.show() : s2.hide());
      }
    }
    const ee = {
      beforeMount: ue,
      updated: ue,
      beforeUnmount(e2) {
        ze(e2);
      }
    };
    function fe(e2) {
      e2.addEventListener("click", Ae), e2.addEventListener("touchstart", Ne, w ? {
        passive: true
      } : false);
    }
    function ce(e2) {
      e2.removeEventListener("click", Ae), e2.removeEventListener("touchstart", Ne), e2.removeEventListener("touchend", He), e2.removeEventListener("touchcancel", Oe);
    }
    function Ae(e2) {
      const t2 = e2.currentTarget;
      e2.closePopover = !t2.$_vclosepopover_touch, e2.closeAllPopover = t2.$_closePopoverModifiers && !!t2.$_closePopoverModifiers.all;
    }
    function Ne(e2) {
      if (e2.changedTouches.length === 1) {
        const t2 = e2.currentTarget;
        t2.$_vclosepopover_touch = true;
        const o3 = e2.changedTouches[0];
        t2.$_vclosepopover_touchPoint = o3, t2.addEventListener("touchend", He), t2.addEventListener("touchcancel", Oe);
      }
    }
    function He(e2) {
      const t2 = e2.currentTarget;
      if (t2.$_vclosepopover_touch = false, e2.changedTouches.length === 1) {
        const o3 = e2.changedTouches[0], i2 = t2.$_vclosepopover_touchPoint;
        e2.closePopover = Math.abs(o3.screenY - i2.screenY) < 20 && Math.abs(o3.screenX - i2.screenX) < 20, e2.closeAllPopover = t2.$_closePopoverModifiers && !!t2.$_closePopoverModifiers.all;
      }
    }
    function Oe(e2) {
      const t2 = e2.currentTarget;
      t2.$_vclosepopover_touch = false;
    }
    const te = {
      beforeMount(e2, { value: t2, modifiers: o3 }) {
        e2.$_closePopoverModifiers = o3, (typeof t2 > "u" || t2) && fe(e2);
      },
      updated(e2, { value: t2, oldValue: o3, modifiers: i2 }) {
        e2.$_closePopoverModifiers = i2, t2 !== o3 && (typeof t2 > "u" || t2 ? fe(e2) : ce(e2));
      },
      beforeUnmount(e2) {
        ce(e2);
      }
    };
    function zt(e2, t2 = {}) {
      e2.$_vTooltipInstalled || (e2.$_vTooltipInstalled = true, $e(u, t2), e2.directive("tooltip", ee), e2.directive("close-popper", te), e2.component("VTooltip", Pe), e2.component("VDropdown", _e), e2.component("VMenu", Te));
    }
    const qt = {
      // eslint-disable-next-line no-undef
      version: "2.0.0",
      install: zt,
      options: u
    };
    const _sfc_main$9 = {
      name: "Ref",
      components: {
        // EditLabelRemark,
        // Main : () => import('@/components/panels/edit/fields/Main.vue')
      },
      props: {
        structure: Object,
        propertyPath: Array,
        level: Number,
        guid: String
        // parentStructure: Array,
        // parentStructureObj: Object,
        // profileCompoent: String,
        // parentURI: String,
        // profileName: String,
        // nested: Boolean,
        // isMini: Boolean,
        // dynamic: String,
        // ptGuid: String,
        // bnodeProperty: String,
      },
      data: function() {
        return {
          manualOverride: null
          // multiTemplateSelect: "",
          // multiTemplateSelectURI: "",
          // multiTemplateSelectOptions: [],
          // activeTemplate: null,
          // propertyTemplatesOrderLookup: {},
          // propertyTemplatesOrderTypeLookup: {},
          // labels: labels,
          // internalAssignID:false,
        };
      },
      computed: {
        ...mapStores(useProfileStore),
        ...mapStores(usePreferenceStore),
        ...mapState(useProfileStore, ["rtLookup"]),
        thisRtTemplate() {
          if (this.manualOverride !== null) {
            for (let tmpid of this.structure.valueConstraint.valueTemplateRefs) {
              console.log("tmpid", tmpid);
              if (tmpid === this.manualOverride) {
                let use = JSON.parse(JSON.stringify(this.rtLookup[tmpid]));
                console.log(use);
                return use;
              }
            }
            return true;
          }
          let useId = this.structure.valueConstraint.valueTemplateRefs[0];
          let foundBetter = false;
          let userValue = this.structure.userValue;
          if (userValue[this.structure.propertyURI] && userValue[this.structure.propertyURI][0]) {
            userValue = this.structure.userValue[this.structure.propertyURI][0];
          }
          if (userValue["@type"]) {
            this.structure.valueConstraint.valueTemplateRefs.forEach((tmpid) => {
              if (foundBetter)
                return false;
              if (this.rtLookup[tmpid].resourceURI === userValue["@type"]) {
                useId = tmpid;
                foundBetter = true;
              }
              for (let key2 in userValue) {
                if (Array.isArray(userValue[key2])) {
                  for (let val of userValue[key2]) {
                    if (val["@type"] && this.rtLookup[tmpid].resourceURI === val["@type"]) {
                      useId = tmpid;
                      foundBetter = true;
                    }
                  }
                }
              }
            });
          }
          if (this.rtLookup[useId]) {
            let use = JSON.parse(JSON.stringify(this.rtLookup[useId]));
            return use;
          } else {
            console.warn("Could not find the template in the rtLookup: ", useId);
          }
        },
        allRtTemplate() {
          let templates = [];
          for (let id2 of this.structure.valueConstraint.valueTemplateRefs) {
            templates.push(JSON.parse(JSON.stringify(this.rtLookup[id2])));
          }
          return templates;
        }
      },
      // computed: mapState({
      // rtLookup: 'rtLookup',
      // activeInput: 'activeInput',
      // activeProfile: 'activeProfile',
      // settingsDisplayMode: 'settingsDisplayMode',
      // assignedId (){
      //   // return uiUtils.assignID(this.structure,this.parentStructure)
      //   if (this.internalAssignID){
      //     return this.internalAssignID
      //   }else{
      //     this.internalAssignID = uiUtils.assignID(this.structure,this.parentStructure)
      //     return this.internalAssignID
      //   }           
      // },  
      // to access local state with `this`, a normal function must be used
      // lookupVocab (state) {
      //   // let uri = this.structure.valueConstraint.useValuesFrom[0]
      //   // let returnVal = []
      //   // Object.keys(state.lookupLibrary).forEach((s)=>{
      //   // })
      //   // if (state.lookupLibrary[this.structure.valueConstraint.useValuesFrom[0]]){
      //   //   return state.lookupLibrary[this.structure.valueConstraint.useValuesFrom[0]]
      //   // }else{
      //   //   return []
      //   // }
      //   return state.lookupLibrary[this.structure.valueConstraint.useValuesFrom[0]]
      // }
      // }),
      created: function() {
      },
      methods: {
        templateChange(event2) {
          let nextRef = this.allRtTemplate.filter((v2) => {
            return v2.id === event2.target.value;
          })[0];
          let thisRef = this.thisRtTemplate;
          this.profileStore.changeRefTemplate(this.guid, this.propertyPath, nextRef, thisRef);
          this.manualOverride = event2.target.value;
        }
        // buildPropertyTemplatesOrderLookup: function(){
        //   this.propertyTemplatesOrderLookup = {}
        //   this.activeTemplate.propertyTemplates.forEach((pt, i)=>{
        //     this.propertyTemplatesOrderLookup[pt.propertyURI+pt.propertyLabel] = i
        //   })
        //   // fill in the order type, start end or middle, solo
        //   if (this.activeTemplate.propertyTemplates.length==1){
        //     let useId = this.activeTemplate.propertyTemplates[0].propertyURI + this.activeTemplate.propertyTemplates[0].propertyLabel
        //     this.propertyTemplatesOrderTypeLookup[useId] = 'solo'
        //   }else if (this.activeTemplate.propertyTemplates.length==2){
        //     let useId = this.activeTemplate.propertyTemplates[0].propertyURI + this.activeTemplate.propertyTemplates[0].propertyLabel
        //     this.propertyTemplatesOrderTypeLookup[useId] = 'start'
        //     useId = this.activeTemplate.propertyTemplates[1].propertyURI + this.activeTemplate.propertyTemplates[1].propertyLabel
        //     this.propertyTemplatesOrderTypeLookup[useId] = 'end'
        //   }else if (this.activeTemplate.propertyTemplates.length>2){
        //     this.activeTemplate.propertyTemplates.forEach((pt, i)=>{
        //       if (i == 0){
        //         this.propertyTemplatesOrderTypeLookup[pt.propertyURI+pt.propertyLabel] = 'start'
        //       } else if (i == this.activeTemplate.propertyTemplates.length-1){
        //         this.propertyTemplatesOrderTypeLookup[pt.propertyURI+pt.propertyLabel] = 'end'
        //       } else {
        //         this.propertyTemplatesOrderTypeLookup[pt.propertyURI+pt.propertyLabel] = 'middle'
        //       }
        //     })
        //   }
        // },
        // multiTemplateSelectKeydown: function(event, buttonPush){
        //   // if they click the button fake the event like they pressed arrow key
        //   if (buttonPush=== true){
        //     event = {
        //       key : 'ArrowRight',
        //       // the input
        //       target: event.target.parentNode.querySelector('input')
        //     }
        //     // put focus back on input so the keys work if used
        //     event.target.parentNode.querySelector('input').focus()
        //   }
        //   if (event.key==='ArrowRight' || event.key==='ArrowLeft'){
        //     // get the current pos, and if we are at the end loop back to the beginning
        //     let nextRefID
        //     let currentRefID
        //     if (event.key==='ArrowRight'){
        //       let currPos = this.structure.valueConstraint.valueTemplateRefs.indexOf(this.multiTemplateSelectURI)
        //       currentRefID = this.structure.valueConstraint.valueTemplateRefs[currPos]          
        //       if (currPos+1 > this.structure.valueConstraint.valueTemplateRefs.length-1){
        //         currPos=-1
        //       }
        //       nextRefID = this.structure.valueConstraint.valueTemplateRefs[currPos+1]
        //     }else{
        //       let currPos = this.structure.valueConstraint.valueTemplateRefs.indexOf(this.multiTemplateSelectURI)
        //       currentRefID = this.structure.valueConstraint.valueTemplateRefs[currPos]
        //       if (currPos == 0){
        //         currPos=this.structure.valueConstraint.valueTemplateRefs.length
        //       }
        //       nextRefID = this.structure.valueConstraint.valueTemplateRefs[currPos-1]
        //     }
        //     // get the profile ready before we change the UI
        //     this.$store.dispatch("refTemplateChange", { self: this, profileName:this.profileName, profileComponet: this.profileCompoent, structure: this.structure, template:this.activeTemplate, parentId: this.structure.parentId, nextRef:this.rtLookup[nextRefID], thisRef: this.rtLookup[currentRefID] }).then(() => {
        //       let nextRef = JSON.parse(JSON.stringify(this.rtLookup[nextRefID]))
        //       this.multiTemplateSelect = nextRef.resourceLabel
        //       this.multiTemplateSelectURI = nextRefID
        //       this.activeTemplate = nextRef
        //       this.buildPropertyTemplatesOrderLookup()
        //       this.focused(event)
        //       uiUtils.renderBorders(true)  
        //     }) 
        //   }else if (event.key==='Tab'){
        //     return true
        //   }else{
        //     event.preventDefault();
        //     return false        
        //   }
        // },
        // focused: function(event){
        //   // just make sure it is turned on so they can nav out of the field
        //   this.$nextTick(()=>{
        //      this.$store.dispatch("enableMacroNav")
        //   })
        //   this.$store.dispatch("setActiveInput", { self: this, id: event.target.id, profileCompoent: this.profileCompoent, profileName: this.profileName }).then(()=>{
        //     // now focus the side bars
        //     this.$nextTick(()=>{
        //       uiUtils.focusSidebars()
        //     })
        //   })
        // } 
      }
    };
    const _hoisted_1$8 = ["value", "selected"];
    const _hoisted_2$6 = ["value", "selected"];
    function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Main = resolveComponent("Main");
      return openBlock(), createElementBlock(Fragment, null, [
        $props.structure.valueConstraint.valueTemplateRefs.length > 1 ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-inline-mode") == true ? (openBlock(), createElementBlock("select", {
            key: 0,
            style: { "display": "inline", "width": "20px", "border-color": "whitesmoke" },
            onChange: _cache[0] || (_cache[0] = ($event) => $options.templateChange($event))
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList($options.allRtTemplate, (rt2) => {
              return openBlock(), createElementBlock("option", {
                value: rt2.id,
                selected: rt2.id === $options.thisRtTemplate.id
              }, toDisplayString$2(rt2.resourceLabel), 9, _hoisted_1$8);
            }), 256))
          ], 32)) : (openBlock(), createElementBlock("select", {
            key: 1,
            onChange: _cache[1] || (_cache[1] = ($event) => $options.templateChange($event))
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList($options.allRtTemplate, (rt2) => {
              return openBlock(), createElementBlock("option", {
                value: rt2.id,
                selected: rt2.id === $options.thisRtTemplate.id
              }, toDisplayString$2(rt2.resourceLabel), 9, _hoisted_2$6);
            }), 256))
          ], 32))
        ], 64)) : createCommentVNode("", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList($options.thisRtTemplate.propertyTemplates, (pt2, idx) => {
          return openBlock(), createBlock(_component_Main, {
            level: $props.level,
            propertyPath: $props.propertyPath,
            nested: true,
            guid: $props.guid,
            inheritedStructure: $options.thisRtTemplate.propertyTemplates[idx]
          }, null, 8, ["level", "propertyPath", "guid", "inheritedStructure"]);
        }), 256))
      ], 64);
    }
    const Ref = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$9], ["__scopeId", "data-v-305c4d78"]]);
    const _sfc_main$8 = {
      name: "AuthTypeIcon",
      components: {},
      props: {
        type: String,
        passClass: String
      },
      data: function() {
        return {};
      },
      created: function() {
      },
      computed: {
        useIcon() {
          const iconPersonal = ["person_2"];
          const iconCorporate = ["corporate_fare"];
          const iconTitle = ["title"];
          const iconNameTitle = ["title", "person_2"];
          const iconConference = ["meeting_room"];
          const iconGeographic = ["map"];
          const iconGenre = ["bookmark"];
          const iconSubjectComplex = ["topic"];
          const iconSubjectTopic = ["topic", "title"];
          if (this.type && typeof this.type === "string") {
            let type = this.type;
            type = type.replace("http://www.loc.gov/mads/rdf/v1#", "");
            if (type == "PersonalName")
              return iconPersonal;
            if (type == "CorporateName")
              return iconCorporate;
            if (type == "NameTitle")
              return iconNameTitle;
            if (type == "Title")
              return iconTitle;
            if (type == "ConferenceName")
              return iconConference;
            if (type == "Geographic")
              return iconGeographic;
            if (type == "GenreForm")
              return iconGenre;
            if (type == "ComplexSubject")
              return iconSubjectComplex;
            if (type == "Topic")
              return iconSubjectTopic;
            if (type == "http://id.loc.gov/ontologies/bibframe/Person")
              return iconPersonal;
            if (type == "http://id.loc.gov/ontologies/bibframe/Place")
              return iconGeographic;
            if (type == "http://id.loc.gov/ontologies/bibframe/Topic")
              return iconSubjectTopic;
            if (type == "http://id.loc.gov/ontologies/bibframe/Organization")
              return iconCorporate;
            if (type == "http://id.loc.gov/ontologies/bibframe/GenreForm")
              return iconGenre;
            if (type == "http://id.loc.gov/ontologies/bibframe/Agent")
              return iconPersonal;
          }
          return [];
        }
      },
      methods: {}
    };
    function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(true), createElementBlock(Fragment, null, renderList($options.useIcon, (icon) => {
        return openBlock(), createElementBlock("span", {
          class: normalizeClass(["material-icons-two-tone", $props.passClass])
        }, toDisplayString$2(icon), 3);
      }), 256);
    }
    const AuthTypeIcon = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$8], ["__scopeId", "data-v-0cb20626"]]);
    const _sfc_main$7 = {
      components: {
        VueFinalModal: Ro$2,
        AuthTypeIcon
      },
      props: {
        // structure of the field that owns this modal
        structure: Object,
        // the inital search value starting the search
        searchValue: String
      },
      data() {
        return {
          modeSelect: null,
          searchValueLocal: null,
          searchTimeout: null,
          activeComplexSearch: [],
          activeComplexSearchInProgress: false,
          initalSearchState: true,
          activeContext: null
        };
      },
      computed: {
        // other computed properties
        // ...
        // gives access to this.counterStore and this.userStore
        ...mapStores(usePreferenceStore),
        // // // gives read access to this.count and this.double
        // ...mapState(usePreferenceStore, ['showPrefModal','showPrefModalGroup','styleDefault', 'showPrefModalGroup', 'fontFamilies']),
        // array of the pssobile groups from the stlyes
        ...mapState(useConfigStore, ["lookupConfig"]),
        modalSelectOptions() {
          let options = [];
          this.structure.valueConstraint.useValuesFrom.forEach((l2) => {
            if (this.lookupConfig[l2]) {
              this.lookupConfig[l2].modes.forEach((mode) => {
                Object.keys(mode).forEach((k2) => {
                  options.push({ label: k2, urls: mode[k2].url, processor: this.lookupConfig[l2].processor, minCharBeforeSearch: this.lookupConfig[l2].minCharBeforeSearch ? this.lookupConfig[l2].minCharBeforeSearch : false, all: mode[k2].all });
                  if (!this.modeSelect && mode[k2].all) {
                    this.modeSelect = k2;
                  }
                });
              });
            }
          });
          return options;
        },
        modalSelectOptionsLabels() {
          return this.modalSelectOptions.map((o3) => {
            return o3.label;
          });
        }
      },
      watch: {
        // watching the search input, when it changes kick off a search
        searchValueLocal: async function() {
          this.doSearch();
        },
        modeSelect: async function() {
          this.doSearch();
        }
      },
      methods: {
        // watching the search input, when it changes kick off a search
        doSearch: async function() {
          if (!this.searchValueLocal) {
            return false;
          }
          if (this.searchValueLocal.trim() == "") {
            return false;
          }
          if (this.searchValueLocal.length < 3) {
            if (this.searchValueLocal.match(/[\u3040-\u30ff\u3400-\u4dbf\u4e00-\u9fff\uf900-\ufaff\uff66-\uff9f]/))
              ;
            else {
              let minCharBeforeSearch = 3;
              this.modalSelectOptions.forEach((a2) => {
                if (a2.minCharBeforeSearch && a2.minCharBeforeSearch < minCharBeforeSearch) {
                  minCharBeforeSearch = a2.minCharBeforeSearch;
                }
              });
              if (this.searchValueLocal.length < minCharBeforeSearch) {
                return false;
              }
            }
          }
          window.clearTimeout(this.searchTimeout);
          let searchPayload = {
            processor: null,
            url: [],
            searchValueLocal: this.searchValueLocal
          };
          this.modalSelectOptions.forEach((a2) => {
            if (a2.label == this.modeSelect) {
              searchPayload.processor = a2.processor;
              searchPayload.url.push(a2.urls.replace("<QUERY>", this.searchValueLocal));
            }
          });
          this.searchTimeout = window.setTimeout(async () => {
            this.activeComplexSearchInProgress = true;
            this.activeComplexSearch = [];
            this.activeComplexSearch = await utilsNetwork.searchComplex(searchPayload);
            this.activeComplexSearchInProgress = false;
            this.initalSearchState = false;
          }, 400);
        },
        inputKeydown: function(event2) {
          if (event2.key === "ArrowDown") {
            this.$refs.selectOptions.focus();
            this.$refs.selectOptions.value = this.activeComplexSearch[0].uri;
            this.selectChange();
          }
        },
        selectNav: function(event2) {
          if (event2.target.selectedIndex == 0) {
            if (event2.key === "ArrowUp") {
              if (this.$refs.inputLookup) {
                this.$refs.inputLookup.focus();
                this.$nextTick(() => {
                  window.setTimeout(() => {
                    this.$refs.inputLookup.setSelectionRange(1e3, 1e3);
                  }, 10);
                });
              }
            }
          }
          if (event2.key === "Enter" && event2.shiftKey) {
            console.log("emitComplexValue", this.activeContext);
            this.$emit("emitComplexValue", this.activeContext);
          }
        },
        selectChange: async function() {
          let toLoad = this.activeComplexSearch[this.$refs.selectOptions.selectedIndex];
          console.log(toLoad);
          this.activeContext = {
            "contextValue": true,
            "source": [],
            "type": toLoad.literal ? "Literal Value" : null,
            "variant": [],
            "uri": toLoad.literal ? null : toLoad.uri,
            "title": toLoad.label,
            "contributor": [],
            "date": null,
            "genreForm": null,
            "nodeMap": {},
            "precoordinated": false,
            "literal": true,
            "loading": true
          };
          let results = await utilsNetwork.returnContext(toLoad.uri);
          results.loading = false;
          if (toLoad.uri != this.activeComplexSearch[this.$refs.selectOptions.selectedIndex].uri) {
            return false;
          }
          this.activeContext = results;
        },
        rewriteURI: function(uri) {
          if (!uri) {
            return false;
          }
          if (uri.includes("bibframe.example.org")) {
            return false;
          }
          if (uri.includes("/resources/hubs/") || uri.includes("/resources/works/") || uri.includes("/resources/instances/") || uri.includes("/resources/items/")) {
            uri = uri.replace("https://id.loc.gov/", config.returnUrls().bfdb);
            uri = uri.replace("http://id.loc.gov/", config.returnUrls().bfdb);
          }
          return uri;
        }
      },
      updated: function() {
        this.$nextTick(() => {
          this.$nextTick(() => {
            if (this.$refs.inputLookup) {
              this.$refs.inputLookup.focus();
            }
            this.searchValueLocal = this.searchValue;
            if (this.$refs.complexLookupModalContainer) {
              let modalStopsAt = this.$refs.complexLookupModalContainer.getBoundingClientRect().height + this.$refs.complexLookupModalContainer.getBoundingClientRect().top;
              let selectHeight = modalStopsAt - this.$refs.selectOptions.getBoundingClientRect().y;
              this.$refs.selectOptions.style.height = selectHeight - 1 + "px";
              this.$refs.complexLookupModalDisplay.style.height = this.$refs.complexLookupModalContainer.getBoundingClientRect().height + "px";
            }
          });
        });
      },
      mounted() {
        if (this.modeSelect === null) {
          this.modeSelect = this.modalSelectOptions[0].label;
        }
      }
    };
    const _withScopeId$4 = (n2) => (pushScopeId("data-v-a051dd3d"), n2 = n2(), popScopeId(), n2);
    const _hoisted_1$7 = {
      ref: "complexLookupModalContainer",
      class: "complex-lookup-modal-container"
    };
    const _hoisted_2$5 = { class: "complex-lookup-modal-container-parts" };
    const _hoisted_3$5 = { class: "complex-lookup-modal-search" };
    const _hoisted_4$5 = {
      key: 0,
      class: "toggle-btn-grp cssonly"
    };
    const _hoisted_5$5 = ["value"];
    const _hoisted_6$5 = {
      onclick: "",
      class: "toggle-btn"
    };
    const _hoisted_7$5 = { key: 0 };
    const _hoisted_8$4 = { key: 1 };
    const _hoisted_9$4 = ["data-label", "value", "innerHTML"];
    const _hoisted_10$4 = {
      ref: "complexLookupModalDisplay",
      class: "complex-lookup-modal-display"
    };
    const _hoisted_11$4 = ["data-tooltip"];
    const _hoisted_12$4 = { class: "complex-lookup-modal-display-type-buttons" };
    const _hoisted_13$4 = { class: "modal-context-data-title" };
    const _hoisted_14$4 = {
      key: 0,
      style: { "background": "pink" }
    };
    const _hoisted_15$4 = ["href"];
    const _hoisted_16$4 = { class: "complex-lookup-modal-display-buttons" };
    const _hoisted_17$3 = { key: 0 };
    const _hoisted_18$3 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("div", { class: "modal-context-data-title modal-context-data-title-add-gap" }, "Variants:", -1));
    const _hoisted_19$3 = { class: "modal-context-data-title modal-context-data-title-add-gap" };
    const _hoisted_20$3 = { key: 1 };
    const _hoisted_21$3 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("div", { class: "modal-context-data-title modal-context-data-title-add-gap" }, "Sources:", -1));
    const _hoisted_22$3 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("div", null, null, -1));
    function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_AuthTypeIcon = resolveComponent("AuthTypeIcon");
      const _component_VueFinalModal = resolveComponent("VueFinalModal");
      return openBlock(), createBlock(_component_VueFinalModal, {
        "hide-overlay": false,
        "overlay-transition": "vfm-fade",
        "content-transition": "vfm-fade",
        "click-to-close": true,
        "esc-to-close": true,
        background: "non-interactive",
        "lock-scroll": true,
        class: "complex-lookup-modal",
        "content-class": "complex-lookup-modal-content"
      }, {
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_1$7, [
            createBaseVNode("div", _hoisted_2$5, [
              createBaseVNode("div", _hoisted_3$5, [
                _ctx.preferenceStore.returnValue("--b-edit-complex-use-select-dropdown") === false ? (openBlock(), createElementBlock("div", _hoisted_4$5, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList($options.modalSelectOptions, (opt) => {
                    return openBlock(), createElementBlock("div", null, [
                      withDirectives(createBaseVNode("input", {
                        type: "radio",
                        value: opt.label,
                        class: "search-mode-radio",
                        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.modeSelect = $event),
                        name: "searchMode"
                      }, null, 8, _hoisted_5$5), [
                        [vModelRadio, $data.modeSelect]
                      ]),
                      createBaseVNode("label", _hoisted_6$5, toDisplayString$2(opt.label), 1)
                    ]);
                  }), 256))
                ])) : createCommentVNode("", true),
                _ctx.preferenceStore.returnValue("--b-edit-complex-use-select-dropdown") === true ? withDirectives((openBlock(), createElementBlock("select", {
                  key: 1,
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.modeSelect = $event)
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList($options.modalSelectOptions, (opt) => {
                    return openBlock(), createElementBlock("option", null, toDisplayString$2(opt.label), 1);
                  }), 256))
                ], 512)), [
                  [vModelSelect, $data.modeSelect]
                ]) : createCommentVNode("", true),
                withDirectives(createBaseVNode("input", {
                  class: "lookup-input",
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.searchValueLocal = $event),
                  ref: "inputLookup",
                  onKeydown: _cache[3] || (_cache[3] = ($event) => $options.inputKeydown($event)),
                  type: "text"
                }, null, 544), [
                  [vModelText, $data.searchValueLocal]
                ]),
                createBaseVNode("div", null, [
                  createBaseVNode("select", {
                    size: "100",
                    ref: "selectOptions",
                    class: "modal-entity-select",
                    onChange: _cache[4] || (_cache[4] = ($event) => $options.selectChange($event)),
                    onKeydown: _cache[5] || (_cache[5] = ($event) => $options.selectNav($event))
                  }, [
                    $data.activeComplexSearch.length == 0 && $data.activeComplexSearchInProgress == false && $data.initalSearchState != true ? (openBlock(), createElementBlock("option", _hoisted_7$5, " No results found. ")) : createCommentVNode("", true),
                    $data.activeComplexSearchInProgress == true ? (openBlock(), createElementBlock("option", _hoisted_8$4, " Searching... ")) : createCommentVNode("", true),
                    (openBlock(true), createElementBlock(Fragment, null, renderList($data.activeComplexSearch, (r2, idx) => {
                      return openBlock(), createElementBlock("option", {
                        "data-label": r2.label,
                        value: r2.uri,
                        key: idx,
                        style: normalizeStyle(r2.depreciated ? "color:red" : ""),
                        class: "complex-lookup-result",
                        innerHTML: " " + r2.label + (r2.literal ? " [Literal]" : "")
                      }, null, 12, _hoisted_9$4);
                    }), 128))
                  ], 544)
                ])
              ]),
              createBaseVNode("div", _hoisted_10$4, [
                $data.activeContext !== null ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  createBaseVNode("h3", null, [
                    createBaseVNode("span", {
                      class: "modal-context-icon simptip-position-top",
                      "data-tooltip": "Type: " + $data.activeContext.type
                    }, [
                      $data.activeContext.type ? (openBlock(), createBlock(_component_AuthTypeIcon, {
                        key: 0,
                        type: $data.activeContext.type
                      }, null, 8, ["type"])) : createCommentVNode("", true)
                    ], 8, _hoisted_11$4),
                    createTextVNode(toDisplayString$2($data.activeContext.title), 1)
                  ]),
                  createBaseVNode("div", _hoisted_12$4, [
                    createBaseVNode("div", null, [
                      createBaseVNode("div", _hoisted_13$4, toDisplayString$2($data.activeContext.type), 1),
                      $data.activeContext.depreciated ? (openBlock(), createElementBlock("div", _hoisted_14$4, " DEPRECIATED AUTHORITY ")) : createCommentVNode("", true),
                      createBaseVNode("a", {
                        style: { "color": "#2c3e50", "float": "none", "border": "none", "border-radius": "0", "background-color": "transparent", "font-size": "1em", "padding": "0" },
                        href: $options.rewriteURI($data.activeContext.uri),
                        target: "_blank"
                      }, "view on id.loc.gov", 8, _hoisted_15$4)
                    ]),
                    createBaseVNode("div", _hoisted_16$4, [
                      createBaseVNode("button", {
                        onClick: _cache[6] || (_cache[6] = ($event) => _ctx.$emit("emitComplexValue", $data.activeContext))
                      }, "Add [Shift+Enter]"),
                      createBaseVNode("button", {
                        onClick: _cache[7] || (_cache[7] = ($event) => _ctx.$emit("hideComplexModal"))
                      }, "Cancel [ESC]")
                    ])
                  ]),
                  $data.activeContext.variant && $data.activeContext.variant.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_17$3, [
                    _hoisted_18$3,
                    createBaseVNode("ul", null, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList($data.activeContext.variant, (v2, idx) => {
                        return openBlock(), createElementBlock("li", {
                          class: "modal-context-data-li",
                          key: "var" + idx
                        }, toDisplayString$2(v2), 1);
                      }), 128))
                    ])
                  ])) : createCommentVNode("", true),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(Object.keys($data.activeContext.nodeMap), (key2) => {
                    return openBlock(), createElementBlock("div", { key: key2 }, [
                      createBaseVNode("div", _hoisted_19$3, toDisplayString$2(key2) + ":", 1),
                      createBaseVNode("ul", null, [
                        (openBlock(true), createElementBlock(Fragment, null, renderList($data.activeContext.nodeMap[key2], (v2, idx) => {
                          return openBlock(), createElementBlock("li", {
                            class: "modal-context-data-li",
                            key: key2 + idx
                          }, toDisplayString$2(v2), 1);
                        }), 128))
                      ])
                    ]);
                  }), 128)),
                  $data.activeContext.source && $data.activeContext.source.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_20$3, [
                    _hoisted_21$3,
                    createBaseVNode("ul", null, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList($data.activeContext.source, (v2, idx) => {
                        return openBlock(), createElementBlock("li", {
                          class: "modal-context-data-li",
                          key: "sources-" + idx
                        }, toDisplayString$2(v2), 1);
                      }), 128))
                    ])
                  ])) : createCommentVNode("", true)
                ], 64)) : createCommentVNode("", true),
                _hoisted_22$3
              ], 512)
            ])
          ], 512)
        ]),
        _: 1
      });
    }
    const ComplexLookupModal = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7], ["__scopeId", "data-v-a051dd3d"]]);
    const debounce = (callback, wait) => {
      let timeoutId = null;
      return (...args) => {
        window.clearTimeout(timeoutId);
        timeoutId = window.setTimeout(() => {
          callback.apply(null, args);
        }, wait);
      };
    };
    const _sfc_main$6 = {
      name: "SubjectEditor",
      components: {
        VueFinalModal: Ro$2,
        AuthTypeIcon
      },
      props: {
        structure: Object,
        searchValue: String
      },
      watch: {
        // // watch when the undoindex changes, means they are undoing redoing, so refresh the
        // // value in the acutal input box
        searchValue: function() {
          this.subjectString = this.searchValue;
          this.linkModeString = this.searchValue;
        }
      },
      data: function() {
        return {
          subjectEditorMode: "subjectEditorMode",
          contextData: { nodeMap: {} },
          subjectString: "",
          components: [],
          lookup: {},
          searchResults: null,
          activeSearch: false,
          pickPostion: 0,
          pickLookup: {},
          activeComponent: null,
          oldActiveComponent: null,
          activeComponentIndex: 0,
          oldActiveComponentIndex: 99,
          contextRequestInProgress: false,
          componetLookup: {},
          localContextCache: {},
          nextInputIsTypeSelection: false,
          typeLookup: {},
          okayToAdd: false,
          lowResMode: false,
          searchMode: "LCSHNAF",
          linkModeString: "",
          linkModeResults: false,
          linkModeSearching: false,
          showTypes: false,
          activeTypes: {
            "madsrdf:Topic": { label: "Topic / Heading ($a $x)", value: "madsrdf:Topic", selected: false },
            "madsrdf:GenreForm": { label: "Genre ($v)", value: "madsrdf:GenreForm", selected: false },
            "madsrdf:Geographic": { label: "Geographic ($z)", value: "madsrdf:Geographic", selected: false },
            "madsrdf:Temporal": { label: "Chronological ($y)", value: "madsrdf:Temporal", selected: false }
          }
        };
      },
      computed: {},
      methods: {
        /**
        * Kicks off search when the link mode string is changed
        * @return {void}
        */
        linkModeTextChange: async function(event2) {
          this.$refs.subjectInput.focus();
          if (event2.key === "Enter" && event2.shiftKey === false) {
            console.log("Starting search");
            this.linkModeResults = false;
            this.linkModeSearching = true;
            this.linkModeResults = await utilsNetwork.subjectLinkModeResolveLCSH(this.linkModeString);
            this.linkModeSearching = false;
            console.log(this.linkModeResults);
          } else if (event2.key === "Enter" && event2.shiftKey === true) {
            this.addLinkMode();
          }
          if (event2.preventDefault) {
            event2.preventDefault();
          }
          return false;
        },
        focusInput: function() {
          this.$nextTick(() => {
            let timeoutFocus = window.setTimeout(() => {
              if (this.$refs.subjectInput) {
                this.$refs.subjectInput.focus();
                window.clearTimeout(timeoutFocus);
              }
            }, 10);
          });
        },
        /**
        * Change state to display different interface
        * @param {string} mode - which mode to use "build" "link"
        * @return {array} - An array of the pts, but only occuring once
        */
        editorModeSwitch: function(mode) {
          this.subjectEditorMode = mode;
          if (mode == "build") {
            this.subjectString = this.linkModeString;
            this.subjectStringChanged();
          } else {
            this.linkModeString = this.subjectString;
          }
          this.$nextTick(() => {
            this.$refs.subjectInput.focus();
          });
        },
        searchModeSwitch: function(mode) {
          this.searchMode = mode;
          if (this.activeComponent && this.activeComponent.label) {
            this.searchApis(this.activeComponent.label, this.subjectString, this);
          }
          this.$refs.subjectInput.focus();
        },
        // some context messing here, pass the debounce func a ref to the vue "this" as that to ref in the function callback
        searchApis: debounce(async (searchString, searchStringFull, that) => {
          that.searchResults = null;
          that.x = "Seaching...";
          that.pickPostion = 0;
          searchString = searchString.trim().normalize();
          searchStringFull = searchStringFull.trim().normalize();
          let ti = window.setInterval(() => {
            that.activeSearch = (!that.activeSearch ? "" : that.activeSearch) + ".";
          }, 100);
          let tiBackup = window.setTimeout(() => {
            window.clearInterval(ti);
            that.activeSearch = false;
          }, 1e4);
          searchString = searchString.replaceAll("‑", "-");
          searchStringFull = searchStringFull.replaceAll("‑", "-");
          that.searchResults = await utilsNetwork.subjectSearch(searchString, searchStringFull, that.searchMode);
          for (let s2 of that.searchResults.names) {
            s2.labelOrginal = s2.label;
            s2.label = s2.label.replaceAll("-", "‑");
          }
          for (let s2 of that.searchResults.subjectsComplex) {
            s2.labelOrginal = s2.label;
            s2.complex = true;
            s2.label = s2.label.replaceAll("-", "‑");
          }
          for (let s2 of that.searchResults.subjectsSimple) {
            if (s2.suggestLabel && s2.suggestLabel.includes("(DEPRECATED")) {
              s2.suggestLabel = s2.suggestLabel.split("(DEPRECATED")[0] + "(DEPRECATED)";
            }
          }
          for (let s2 of that.searchResults.hierarchicalGeographic) {
            if (s2.suggestLabel && s2.suggestLabel.includes(" (USE ")) {
              s2.suggestLabel = s2.label;
            }
          }
          if (that.searchMode == "WORKS" || that.searchMode == "HUBS") {
            for (let s2 of that.searchResults.subjectsSimple) {
              if (s2.suggestLabel && s2.suggestLabel.includes(" (USE ")) {
                s2.suggestLabel = s2.label;
              }
            }
            for (let s2 of that.searchResults.subjectsComplex) {
              if (s2.suggestLabel && s2.suggestLabel.includes(" (USE ")) {
                s2.suggestLabel = s2.label;
              }
            }
          }
          for (let s2 of that.searchResults.hierarchicalGeographic) {
            s2.labelOrginal = s2.label;
            s2.hierarchicalGeographic = true;
            s2.label = s2.label.replaceAll("-", "‑");
          }
          if (that.searchResults.hierarchicalGeographic.length > 0 && that.searchResults.subjectsComplex.length == 0) {
            that.searchResults.subjectsComplex = that.searchResults.hierarchicalGeographic;
          }
          that.pickLookup = {};
          that.pickPostion = that.searchResults.subjectsSimple.length + that.searchResults.subjectsComplex.length - 1;
          for (let x2 in that.searchResults.subjectsComplex) {
            that.pickLookup[x2] = that.searchResults.subjectsComplex[x2];
          }
          for (let x2 in that.searchResults.subjectsSimple) {
            that.pickLookup[parseInt(x2) + parseInt(that.searchResults.subjectsComplex.length)] = that.searchResults.subjectsSimple[x2];
          }
          for (let x2 in that.searchResults.names) {
            that.pickLookup[(that.searchResults.names.length - x2) * -1] = that.searchResults.names[x2];
          }
          for (let k2 in that.pickLookup) {
            that.pickLookup[k2].picked = false;
            if (searchString.toLowerCase() == that.pickLookup[k2].label.toLowerCase() && !that.pickLookup[k2].literal) {
              if (that.pickLookup[k2].label.replaceAll("‑", "-") == that.activeComponent.label.replaceAll("‑", "-") && that.activeComponent.uri) {
                if (that.activeComponent.uri == that.pickLookup[k2].uri) {
                  console.log("that.activeComponent", that.activeComponent);
                  that.pickPostion = k2;
                  that.pickLookup[k2].picked = true;
                  that.selectContext();
                }
              } else {
                if (that.subjectString.replaceAll("‑", "-") != searchStringFull.replaceAll("‑", "-")) {
                  break;
                }
                if (that.pickLookup[k2].label != that.activeComponent.label) {
                  break;
                }
                that.pickPostion = k2;
                that.pickLookup[k2].picked = true;
                that.selectContext();
              }
            }
          }
          if (that.pickLookup[that.pickPostion] && !that.pickLookup[that.pickPostion].literal) {
            that.contextRequestInProgress = true;
            that.contextData = await utilsNetwork.returnContext(that.pickLookup[that.pickPostion].uri);
            if (that.contextData) {
              that.localContextCache[that.contextData.uri] = JSON.parse(JSON.stringify(that.contextData));
            }
          }
          window.clearInterval(ti);
          window.clearTimeout(tiBackup);
          that.activeSearch = false;
          that.$nextTick(() => {
            that.checkToolBarHeight();
            let smallest_size = 1e3;
            for (let el of document.getElementsByClassName("fake-option")) {
              if (el.offsetHeight < smallest_size && el.offsetHeight != 0) {
                smallest_size = el.offsetHeight;
              }
            }
            for (let el of document.getElementsByClassName("fake-option")) {
              if (el.offsetHeight > smallest_size) {
                let startFontSize = 1.25;
                while (el.offsetHeight > smallest_size) {
                  startFontSize = startFontSize - 0.01;
                  el.style.fontSize = startFontSize + "em";
                  if (startFontSize <= 0.01) {
                    el.style.fontSize = "1.25em";
                    break;
                  }
                }
              }
            }
          });
        }, 500),
        navStringClick: function(event2) {
          event2.key = "ArrowLeft";
          this.navString(event2);
        },
        navString: function(event2) {
          if (event2.key == "ArrowLeft" || event2.key == "ArrowRight") {
            if (!event2.target) {
              event2 = { target: this.$refs.subjectInput };
            }
            for (let c2 of this.components) {
              if (event2.target.selectionStart >= c2.posStart && event2.target.selectionStart <= c2.posEnd + 1) {
                this.activeComponent = c2;
                this.activeComponentIndex = c2.id;
                break;
              }
            }
            if (this.oldActiveComponentIndex != this.activeComponentIndex) {
              this.updateAvctiveTypeSelected();
              this.subjectStringChanged(event2);
              this.oldActiveComponentIndex = this.activeComponentIndex;
            } else if (this.activeComponent.uri === null) {
              this.updateAvctiveTypeSelected();
              this.subjectStringChanged(event2);
            }
          }
        },
        loadContext: async function(pickPostion) {
          this.pickPostion = pickPostion;
          if (this.pickLookup[this.pickPostion].literal) {
            return false;
          }
          this.contextRequestInProgress = true;
          this.contextData = await utilsNetwork.returnContext(this.pickLookup[this.pickPostion].uri);
          if (this.contextData) {
            this.localContextCache[this.contextData.uri] = JSON.parse(JSON.stringify(this.contextData));
          }
          this.contextRequestInProgress = false;
        },
        selectContext: function(pickPostion) {
          if (pickPostion) {
            this.pickPostion = pickPostion;
          }
          if (this.pickLookup[this.pickPostion].complex) {
            this.subjectString = this.pickLookup[this.pickPostion].label;
            this.activeComponentIndex = 0;
            this.componetLookup = {};
            this.componetLookup[this.activeComponentIndex] = {};
            this.componetLookup[this.activeComponentIndex][this.pickLookup[this.pickPostion].label] = this.pickLookup[this.pickPostion];
            for (let k2 in this.pickLookup) {
              this.pickLookup[k2].picked = false;
            }
            this.typeLookup[this.activeComponentIndex] = "madsrdf:Topic";
            this.pickLookup[this.pickPostion].picked = true;
            this.subjectStringChanged();
            this.$refs.subjectInput.focus();
          } else {
            console.log("1", JSON.parse(JSON.stringify(this.componetLookup)));
            let splitString = this.subjectString.split("--");
            splitString[this.activeComponentIndex] = this.pickLookup[this.pickPostion].label.replaceAll("-", "‑");
            this.subjectString = splitString.join("--");
            if (!this.componetLookup[this.activeComponentIndex]) {
              this.componetLookup[this.activeComponentIndex] = {};
            }
            this.componetLookup[this.activeComponentIndex][this.pickLookup[this.pickPostion].label.replaceAll("-", "‑")] = this.pickLookup[this.pickPostion];
            for (let k2 in this.pickLookup) {
              this.pickLookup[k2].picked = false;
            }
            this.pickLookup[this.pickPostion].picked = true;
            console.log("2", JSON.parse(JSON.stringify(this.componetLookup)));
            this.subjectStringChanged();
          }
        },
        navInput: function(event2) {
          if (event2.key == "ArrowUp") {
            if (parseInt(this.pickPostion) <= this.searchResults.names.length * -1) {
              return false;
            }
            this.loadContext(parseInt(this.pickPostion) - 1);
            event2.preventDefault();
            return false;
          } else if (event2.key == "ArrowDown") {
            if (parseInt(this.pickPostion) >= this.searchResults.subjectsSimple.length - 1 + this.searchResults.subjectsComplex.length) {
              return false;
            }
            this.loadContext(parseInt(this.pickPostion) + 1);
            event2.preventDefault();
            return false;
          } else if (event2.key == "Enter") {
            if (event2.shiftKey) {
              this.add();
              return;
            }
            this.selectContext();
          } else if (event2.ctrlKey && event2.key == "1") {
            this.searchModeSwitch("LCSHNAF");
          } else if (event2.ctrlKey && event2.key == "2") {
            this.searchModeSwitch("GEO");
          } else if (event2.ctrlKey && event2.key == "3") {
            this.searchModeSwitch("WORKS");
          } else if (this.searchMode == "GEO" && event2.key == "-") {
            if (this.components.length > 0) {
              let lastC = this.components[this.components.length - 1];
              console.log(lastC);
              if (lastC.uri) {
                return true;
              }
              if (this.subjectString.slice(-1) == "-") {
                return true;
              }
            }
            let start2 = event2.target.selectionStart;
            let end2 = event2.target.selectionEnd;
            console.log(this.subjectString.substring(0, start2), "|", this.subjectString.substring(end2, this.subjectString.length));
            this.subjectString = this.subjectString.substring(0, start2) + "‑" + this.subjectString.substring(end2, this.subjectString.length);
            this.subjectString = this.subjectString.trim();
            this.$nextTick(() => {
              console.log(start2, end2);
              event2.target.setSelectionRange(start2 + 1, end2 + 1);
            });
            this.subjectStringChanged();
            event2.preventDefault();
            return false;
          }
        },
        updateAvctiveTypeSelected: function() {
          for (let k2 in this.activeTypes) {
            this.activeTypes[k2].selected = false;
          }
          if (this.activeComponent && this.activeComponent.type) {
            if (this.activeTypes[this.activeComponent.type]) {
              this.activeTypes[this.activeComponent.type].selected = true;
            }
          }
        },
        setTypeClick: function(event2, type) {
          this.typeLookup[this.activeComponentIndex] = type;
          this.subjectStringChanged();
          this.$refs.subjectInput.focus();
        },
        renderHintBoxes: function() {
          this.$nextTick(() => {
            let activeLeft = 0;
            for (let com of this.components) {
              if (this.$refs["cBackground" + com.id] && this.$refs["cBackground" + com.id][0]) {
                this.$refs["cBackground" + com.id][0].style.left = `${activeLeft}px`;
                activeLeft = activeLeft + this.$refs["cBackground" + com.id][0].offsetWidth + 11;
              }
            }
          });
        },
        validateOkayToAdd: function() {
          this.okayToAdd = false;
          let allHaveURI = true;
          let allHaveType = true;
          for (let c2 of this.components) {
            if (!c2.uri && !c2.literal) {
              allHaveURI = false;
            }
            if (!c2.type) {
              allHaveType = false;
            }
          }
          if (allHaveURI && allHaveType) {
            this.okayToAdd = true;
          }
          if (allHaveURI && !allHaveType && this.components.length == 1) {
            this.okayToAdd = true;
          }
        },
        subjectStringChanged: async function(event2) {
          if (event2 && event2.data === "$") {
            this.nextInputIsTypeSelection = true;
            return false;
          }
          if (event2 && this.nextInputIsTypeSelection) {
            if (event2.data.toLowerCase() === "a" || event2.data.toLowerCase() === "x") {
              this.typeLookup[this.activeComponentIndex] = "madsrdf:Topic";
              this.subjectString = this.subjectString.replace("$" + event2.data, "");
            }
            if (event2.data.toLowerCase() === "v") {
              this.typeLookup[this.activeComponentIndex] = "madsrdf:GenreForm";
              this.subjectString = this.subjectString.replace("$" + event2.data, "");
            }
            if (event2.data.toLowerCase() === "z") {
              this.typeLookup[this.activeComponentIndex] = "madsrdf:Geographic";
              this.subjectString = this.subjectString.replace("$" + event2.data, "");
            }
            if (event2.data.toLowerCase() === "y") {
              this.typeLookup[this.activeComponentIndex] = "madsrdf:Temporal";
              this.subjectString = this.subjectString.replace("$" + event2.data, "");
            }
            this.nextInputIsTypeSelection = false;
            this.subjectStringChanged();
          } else {
            if (event2) {
              this.searchResults = null;
            }
          }
          this.showTypes = true;
          if (this.subjectString.length == 0) {
            this.activeComponent = null;
            this.activeComponentIndex = 0;
            this.componetLookup = {};
            this.typeLookup = {};
          }
          let subjectStringSplit = this.subjectString.split("--");
          this.components = [];
          let id2 = 0;
          let activePosStart = 0;
          for (let ss of subjectStringSplit) {
            let uri = null;
            let type = null;
            let literal = null;
            if (this.componetLookup[id2] && this.componetLookup[id2][ss]) {
              uri = this.componetLookup[id2][ss].uri;
              literal = this.componetLookup[id2][ss].literal;
            }
            if (this.typeLookup[id2]) {
              type = this.typeLookup[id2];
            }
            this.components.push({
              label: ss,
              uri,
              id: id2,
              type,
              complex: ss.includes("‑"),
              literal,
              posStart: activePosStart,
              posEnd: activePosStart + ss.length - 1
            });
            activePosStart = activePosStart + ss.length + 2;
            this.renderHintBoxes();
            id2++;
          }
          if (event2) {
            for (let c2 of this.components) {
              if (event2.target.selectionStart >= c2.posStart && event2.target.selectionStart <= c2.posEnd + 1) {
                this.activeComponent = c2;
                this.activeComponentIndex = c2.id;
                if (c2.label.trim() != "" && !c2.label.endsWith("-")) {
                  this.searchApis(c2.label, event2.target.value, this);
                } else if (/[0-9]{4}\??-/.test(c2.label)) {
                  this.searchApis(c2.label, event2.target.value, this);
                } else if (/,\s[0-9]{4}-/.test(c2.label)) {
                  this.searchApis(c2.label, event2.target.value, this);
                }
                break;
              }
            }
          } else {
            this.activeComponent = this.components[this.activeComponentIndex];
          }
          this.updateAvctiveTypeSelected();
          if (this.components.length == 1 && this.components[0].complex) {
            this.showTypes = false;
          }
          this.validateOkayToAdd();
          this.$nextTick(() => {
            this.checkToolBarHeight();
            window.setTimeout(() => {
              for (let x2 of this.components) {
                if (this.localContextCache[x2.uri]) {
                  if (this.localContextCache[x2.uri].nodeMap && this.localContextCache[x2.uri].nodeMap["MADS Collection"] && this.localContextCache[x2.uri].nodeMap["MADS Collection"].includes("GeographicSubdivisions")) {
                    x2.type = "madsrdf:Geographic";
                  }
                  if (this.localContextCache[x2.uri].type === "GenreForm") {
                    x2.type = "madsrdf:GenreForm";
                  }
                  if (this.localContextCache[x2.uri].type === "Temporal") {
                    x2.type = "madsrdf:Temporal";
                  }
                  if (this.localContextCache[x2.uri].type === "Geographic") {
                    x2.type = "madsrdf:Geographic";
                  }
                  if (this.localContextCache[x2.uri].type === "Topic") {
                    x2.type = "madsrdf:Topic";
                  }
                }
              }
              this.components[0].type = "madsrdf:Topic";
              this.updateAvctiveTypeSelected();
              this.validateOkayToAdd();
            }, 100);
          });
        },
        /**
        * Emits the components back to the complex component to add to the system
        * uses this.linkModeResults
        * @return {void}
        */
        addLinkMode: function() {
          let sendResults = [];
          console.log(this.linkModeResults);
          if (this.linkModeResults) {
            if (this.linkModeResults.resultType && this.linkModeResults.resultType === "COMPLEX") {
              sendResults.push({
                complex: true,
                id: 0,
                label: this.linkModeResults.hit.label,
                literal: false,
                posEnd: 0,
                posStart: 0,
                type: "madsrdf:Topic",
                uri: this.linkModeResults.hit.uri
              });
            } else {
              for (const [i2, v2] of this.linkModeResults.hit.entries()) {
                sendResults.push({
                  complex: false,
                  id: i2,
                  label: v2.label,
                  literal: v2.literal,
                  posEnd: 0,
                  posStart: 0,
                  type: v2.heading.rdfType.replace("http://www.loc.gov/mads/rdf/v1#", "madsrdf:"),
                  uri: v2.uri
                });
              }
            }
          }
          console.log("sendResults", sendResults);
          this.$emit("subjectAdded", sendResults);
          console.log("ADDDD");
        },
        add: function() {
          console.log("this.components", this.components);
          for (let c2 of this.components) {
            c2.label = c2.label.replaceAll("‑", "-");
            if (c2.uri && c2.uri.includes("id.loc.gov/authorities/names/") && this.localContextCache && this.localContextCache[c2.uri]) {
              c2.type = this.localContextCache[c2.uri].typeFull.replace("http://www.loc.gov/mads/rdf/v1#", "madsrdf:");
            }
          }
          console.log(this.localContextCache);
          console.log(this.components);
          this.$emit("subjectAdded", this.components);
        },
        closeEditor: function() {
          this.$emit("hideSubjectModal", true);
        },
        checkToolBarHeight: function() {
          if (this.$refs.toolbar && this.$refs.toolbar.getBoundingClientRect().bottom > window.innerHeight) {
            this.lowResMode = true;
            this.$emit("lowResModeActivate", true);
          }
        },
        loadUserValue: function(userValue) {
          this.components = [];
          this.lookup = {};
          this.searchResults = null;
          this.activeSearch = false;
          this.pickPostion = 0;
          this.pickLookup = {};
          this.activeComponent = null;
          this.oldActiveComponent = null;
          this.activeComponentIndex = 0;
          this.oldActiveComponentIndex = 99;
          this.contextRequestInProgress = false;
          this.componetLookup = {};
          this.nextInputIsTypeSelection = false;
          this.typeLookup = {};
          this.okayToAdd = false;
          this.showTypes = false;
          if (!userValue) {
            return;
          }
          if (typeof userValue == "string") {
            if (userValue.slice(-1) == ".") {
              userValue = userValue.slice(0, -1);
            }
            this.subjectString = userValue;
            this.linkModeString = userValue;
            this.$nextTick(() => {
              this.navString({ key: "ArrowRight" });
            });
            return;
          }
          if (userValue["http://id.loc.gov/ontologies/bibframe/subject"] && userValue["http://id.loc.gov/ontologies/bibframe/subject"][0]) {
            userValue = userValue["http://id.loc.gov/ontologies/bibframe/subject"][0];
          }
          let completeLabel = null;
          let linkModeValue = "";
          if (userValue["http://www.loc.gov/mads/rdf/v1#componentList"]) {
            let authLabels = [];
            let componentLabelParts = [];
            if (userValue["http://www.w3.org/2000/01/rdf-schema#label"]) {
              if (userValue["http://www.w3.org/2000/01/rdf-schema#label"].length > 0) {
                authLabels = userValue["http://www.w3.org/2000/01/rdf-schema#label"][0]["http://www.w3.org/2000/01/rdf-schema#label"].split("--");
                completeLabel = userValue["http://www.w3.org/2000/01/rdf-schema#label"][0]["http://www.w3.org/2000/01/rdf-schema#label"];
              }
            } else if (userValue["http://www.loc.gov/mads/rdf/v1#authoritativeLabel"]) {
              if (userValue["http://www.loc.gov/mads/rdf/v1#authoritativeLabel"].length > 0) {
                authLabels = userValue["http://www.loc.gov/mads/rdf/v1#authoritativeLabel"][0]["http://www.loc.gov/mads/rdf/v1#authoritativeLabel"].split("--");
                completeLabel = userValue["http://www.loc.gov/mads/rdf/v1#authoritativeLabel"][0]["http://www.loc.gov/mads/rdf/v1#authoritativeLabel"];
              }
            }
            let id2 = 0;
            let activePosStart = 0;
            console.log("userValue['http://www.loc.gov/mads/rdf/v1#componentList']", userValue["http://www.loc.gov/mads/rdf/v1#componentList"]);
            for (let component of userValue["http://www.loc.gov/mads/rdf/v1#componentList"]) {
              let label2 = "";
              let uri = null;
              let type = null;
              let marcType = "";
              let literal = false;
              if (component["@id"]) {
                uri = component["@id"];
              }
              if (component["http://www.loc.gov/mads/rdf/v1#authoritativeLabel"] && component["http://www.loc.gov/mads/rdf/v1#authoritativeLabel"].length > 0) {
                if (component["http://www.loc.gov/mads/rdf/v1#authoritativeLabel"][0]["http://www.loc.gov/mads/rdf/v1#authoritativeLabel"]) {
                  label2 = component["http://www.loc.gov/mads/rdf/v1#authoritativeLabel"][0]["http://www.loc.gov/mads/rdf/v1#authoritativeLabel"];
                }
              } else if (component["http://www.w3.org/2000/01/rdf-schema#label"] && component["http://www.w3.org/2000/01/rdf-schema#label"].length > 0) {
                if (component["http://www.w3.org/2000/01/rdf-schema#label"][0]["http://www.w3.org/2000/01/rdf-schema#label"]) {
                  label2 = component["http://www.w3.org/2000/01/rdf-schema#label"][0]["http://www.w3.org/2000/01/rdf-schema#label"];
                }
              }
              if (component["@type"]) {
                if (component["@type"] == "http://www.loc.gov/mads/rdf/v1#Geographic") {
                  type = "madsrdf:Geographic";
                  marcType = "z";
                }
                if (component["@type"] == "http://www.loc.gov/mads/rdf/v1#Topic") {
                  type = "madsrdf:Topic";
                  marcType = "a";
                  if (id2 > 0) {
                    marcType = "x";
                  }
                }
                if (component["@type"] == "http://www.loc.gov/mads/rdf/v1#GenreForm") {
                  type = "madsrdf:GenreForm";
                  marcType = "v";
                }
                if (component["@type"] == "http://www.loc.gov/mads/rdf/v1#Temporal") {
                  type = "madsrdf:Temporal";
                  marcType = "y";
                }
              }
              if (label2 == "" && authLabels[id2]) {
                label2 = authLabels[id2];
              }
              linkModeValue = linkModeValue + "$" + marcType + label2;
              let toAdd = {
                label: label2,
                uri,
                id: id2,
                type,
                complex: label2.includes("‑"),
                literal,
                posStart: activePosStart,
                posEnd: activePosStart + label2.length - 1
              };
              componentLabelParts.push(label2);
              this.components.push(toAdd);
              if (!this.componetLookup[id2]) {
                this.componetLookup[id2] = {};
              }
              if (type) {
                this.typeLookup[id2] = type;
              }
              this.componetLookup[id2][label2] = toAdd;
              activePosStart = activePosStart + label2.length + 2;
              id2++;
            }
            completeLabel = componentLabelParts.join("--");
          } else {
            if (userValue["http://www.loc.gov/mads/rdf/v1#authoritativeLabel"]) {
              completeLabel = userValue["http://www.loc.gov/mads/rdf/v1#authoritativeLabel"][0]["http://www.loc.gov/mads/rdf/v1#authoritativeLabel"];
            } else if (userValue["http://www.w3.org/2000/01/rdf-schema#label"]) {
              completeLabel = userValue["http://www.w3.org/2000/01/rdf-schema#label"][0]["http://www.w3.org/2000/01/rdf-schema#label"];
            }
            if (completeLabel.slice(-1) == ".") {
              completeLabel = completeLabel.slice(0, -1);
            }
            linkModeValue = "$a" + completeLabel;
          }
          console.log("linkModeValue", linkModeValue);
          this.linkModeString = linkModeValue;
          this.subjectString = completeLabel;
          this.$nextTick(() => {
            this.navString({ key: "ArrowRight" });
          });
        }
      },
      created: function() {
        this.loadUserValue();
      },
      before: function() {
      }
    };
    const _withScopeId$3 = (n2) => (pushScopeId("data-v-a0c8b9c8"), n2 = n2(), popScopeId(), n2);
    const _hoisted_1$6 = {
      ref: "complexLookupModalContainer",
      class: "complex-lookup-modal-container"
    };
    const _hoisted_2$4 = { style: { "position": "relative" } };
    const _hoisted_3$4 = { style: { "position": "absolute", "right": "2em", "top": "0.25em", "z-index": "100" } };
    const _hoisted_4$4 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("svg", {
      fill: "#F2F2F2",
      width: "20px",
      height: "20px",
      version: "1.1",
      viewBox: "0 0 100 100",
      xmlns: "http://www.w3.org/2000/svg"
    }, [
      /* @__PURE__ */ createBaseVNode("g", null, [
        /* @__PURE__ */ createBaseVNode("path", { d: "m45.898 79.102h-38c-0.80078 0-1.5 0.69922-1.5 1.5v15.398c0 0.80078 0.69922 1.5 1.5 1.5h38c0.80078 0 1.5-0.69922 1.5-1.5v-15.398c-0.097657-0.80078-0.69922-1.5-1.5-1.5z" }),
        /* @__PURE__ */ createBaseVNode("path", { d: "m92.199 79.102h-38c-0.80078 0-1.5 0.69922-1.5 1.5v15.398c0 0.80078 0.69922 1.5 1.5 1.5h38c0.80078 0 1.5-0.69922 1.5-1.5v-15.398c0-0.80078-0.69922-1.5-1.5-1.5z" }),
        /* @__PURE__ */ createBaseVNode("path", { d: "m92.199 31.602h-38c-0.80078 0-1.5 0.69922-1.5 1.5v15.5c0 0.80078 0.69922 1.5 1.5 1.5h38c0.80078 0 1.5-0.69922 1.5-1.5v-15.5c0-0.90234-0.69922-1.5-1.5-1.5z" }),
        /* @__PURE__ */ createBaseVNode("path", { d: "m7.8008 73.699h14.398c0.80078 0 1.5-0.69922 1.5-1.5v-15.398c0-0.80078-0.69922-1.5-1.5-1.5h-14.398c-0.80078 0-1.5 0.69922-1.5 1.5v15.5c0 0.80078 0.69922 1.3984 1.5 1.3984z" }),
        /* @__PURE__ */ createBaseVNode("path", { d: "m30.5 73.699h39.102c0.80078 0 1.5-0.69922 1.5-1.5v-15.398c0-0.80078-0.69922-1.5-1.5-1.5h-39.102c-0.80078 0-1.5 0.69922-1.5 1.5v15.5c0 0.80078 0.69922 1.3984 1.5 1.3984z" }),
        /* @__PURE__ */ createBaseVNode("path", { d: "m92.199 55.301h-14.398c-0.80078 0-1.5 0.69922-1.5 1.5v15.5c0 0.80078 0.69922 1.5 1.5 1.5h14.398c0.80078 0 1.5-0.69922 1.5-1.5v-15.5c0-0.80078-0.69922-1.5-1.5-1.5z" }),
        /* @__PURE__ */ createBaseVNode("path", { d: "m24.199 26.199v15.199l-2.1016-2.1016c-0.80078-0.80078-2.1016-0.80078-3 0-0.80078 0.80078-0.80078 2.1016 0 3l5.6016 5.6016c0.39844 0.39844 0.89844 0.60156 1.5 0.60156 0.5 0 1.1016-0.19922 1.5-0.60156l5.6016-5.6016c0.80078-0.80078 0.80078-2.1016 0-3-0.80078-0.80078-2.1016-0.80078-3 0l-2.1016 2.1016v-15.199z" }),
        /* @__PURE__ */ createBaseVNode("path", { d: "m7.8008 20.898h38c0.80078 0 1.5-0.69922 1.5-1.5v-15.398c0-0.80078-0.69922-1.5-1.5-1.5h-38c-0.80078 0-1.5 0.69922-1.5 1.5v15.5c0 0.69922 0.69922 1.3984 1.5 1.3984z" })
      ])
    ], -1));
    const _hoisted_5$4 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("svg", {
      fill: "#F2F2F2",
      width: "20px",
      height: "20px",
      version: "1.1",
      viewBox: "0 0 100 100",
      xmlns: "http://www.w3.org/2000/svg"
    }, [
      /* @__PURE__ */ createBaseVNode("g", { "fill-rule": "evenodd" }, [
        /* @__PURE__ */ createBaseVNode("path", { d: "m45.867 41.266-4.6016 4.6016c-4.6211-2.6719-10.633-2.0312-14.586 1.9219l-16.891 16.891c-4.7188 4.7188-4.7188 12.367 0 17.086l8.4453 8.4453c4.7188 4.7188 12.367 4.7188 17.086 0l16.891-16.891c3.9531-3.9531 4.5938-9.9648 1.9219-14.586l4.6016-4.6016c4.6211 2.6719 10.633 2.0312 14.586-1.9219l16.891-16.891c4.7188-4.7188 4.7188-12.367 0-17.086l-8.4453-8.4453c-4.7188-4.7188-12.367-4.7188-17.086 0l-16.891 16.891c-3.9531 3.9531-4.5938 9.9648-1.9219 14.586zm-6.6211 23.512-12.469 12.473-4.0273-4.0273 12.473-12.469zm6.7305-14.777 4.0234 4.0234 4.0234-4.0234-4.0234-4.0234zm31.273-23.223-12.473 12.469-4.0234-4.0234 12.469-12.473z" }),
        /* @__PURE__ */ createBaseVNode("path", { d: "m23.484 27.902 4.418 4.418c1.2227 1.2227 3.1992 1.2227 4.4219 0 1.2188-1.2188 1.2188-3.1992 0-4.418l-4.4219-4.418c-1.2188-1.2227-3.1992-1.2227-4.418 0-1.2188 1.2188-1.2188 3.1992 0 4.418z" }),
        /* @__PURE__ */ createBaseVNode("path", { d: "m76.516 72.098-4.418-4.418c-1.2188-1.2227-3.1992-1.2227-4.418 0-1.2227 1.2188-1.2227 3.1992 0 4.418l4.418 4.418c1.2188 1.2227 3.1992 1.2227 4.418 0 1.2227-1.2188 1.2227-3.1992 0-4.418z" }),
        /* @__PURE__ */ createBaseVNode("path", { d: "m38.086 17.605 1.6172 6.0352c0.44531 1.668 2.1602 2.6562 3.8281 2.2109 1.6641-0.44531 2.6562-2.1602 2.207-3.8281l-1.6172-6.0352c-0.44531-1.668-2.1602-2.6562-3.8281-2.2109-1.6641 0.44531-2.6562 2.1602-2.207 3.8281z" }),
        /* @__PURE__ */ createBaseVNode("path", { d: "m61.914 82.395-1.6172-6.0352c-0.44531-1.668-2.1602-2.6562-3.8281-2.2109-1.6641 0.44531-2.6562 2.1602-2.207 3.8281l1.6172 6.0352c0.44531 1.668 2.1602 2.6562 3.8242 2.2109 1.668-0.44531 2.6562-2.1602 2.2109-3.8281z" }),
        /* @__PURE__ */ createBaseVNode("path", { d: "m15.988 44.121 6.0352 1.6172c1.668 0.44531 3.3828-0.54297 3.8281-2.2109 0.44531-1.6641-0.54297-3.3789-2.2109-3.8242l-6.0352-1.6172c-1.668-0.44922-3.3828 0.54297-3.8281 2.207-0.44531 1.668 0.54297 3.3828 2.2109 3.8281z" }),
        /* @__PURE__ */ createBaseVNode("path", { d: "m84.012 55.879-6.0352-1.6172c-1.668-0.44531-3.3828 0.54297-3.8281 2.2109-0.44922 1.6641 0.54297 3.3789 2.207 3.8242l6.0391 1.6172c1.6641 0.44922 3.3789-0.54297 3.8281-2.207 0.44531-1.668-0.54297-3.3828-2.2109-3.8281z" })
      ])
    ], -1));
    const _hoisted_6$4 = {
      id: "search-in-holder",
      style: { "position": "absolute", "top": "0" }
    };
    const _hoisted_7$4 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("span", null, "Search In:", -1));
    const _hoisted_8$3 = { style: { "flex": "1", "align-self": "flex-end" } };
    const _hoisted_9$3 = { key: 0 };
    const _hoisted_10$3 = { key: 1 };
    const _hoisted_11$3 = { key: 0 };
    const _hoisted_12$3 = ["onClick", "onMouseover", "data-id"];
    const _hoisted_13$3 = { key: 0 };
    const _hoisted_14$3 = { key: 1 };
    const _hoisted_15$3 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("span", null, " [LCNAF]", -1));
    const _hoisted_16$3 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("hr", null, null, -1));
    const _hoisted_17$2 = { key: 1 };
    const _hoisted_18$2 = ["onClick", "onMouseover", "data-id"];
    const _hoisted_19$2 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("span", null, null, -1));
    const _hoisted_20$2 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("hr", null, null, -1));
    const _hoisted_21$2 = { key: 2 };
    const _hoisted_22$2 = ["onClick", "onMouseover", "data-id"];
    const _hoisted_23$2 = { key: 0 };
    const _hoisted_24$2 = { key: 1 };
    const _hoisted_25$2 = {
      key: 0,
      style: { "font-weight": "bold" }
    };
    const _hoisted_26$2 = {
      key: 1,
      class: "modal-context",
      style: {}
    };
    const _hoisted_27$2 = ["data-tooltip"];
    const _hoisted_28$2 = { class: "modal-context-data-title" };
    const _hoisted_29$2 = ["href"];
    const _hoisted_30$2 = { key: 0 };
    const _hoisted_31$2 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("div", { class: "modal-context-data-title" }, "Variants:", -1));
    const _hoisted_32$2 = { class: "modal-context-data-title" };
    const _hoisted_33$2 = { key: 1 };
    const _hoisted_34$2 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("div", { class: "modal-context-data-title" }, "Sources:", -1));
    const _hoisted_35$2 = { class: "" };
    const _hoisted_36$2 = { class: "component-container-fake-input" };
    const _hoisted_37$2 = { style: { "display": "flex" } };
    const _hoisted_38$2 = { style: { "flex": "1", "position": "relative" } };
    const _hoisted_39$2 = {
      autocomplete: "off",
      style: { "height": "3em" }
    };
    const _hoisted_40$2 = {
      ref: "toolbar",
      style: { "display": "flex" }
    };
    const _hoisted_41$2 = { style: { "flex": "2" } };
    const _hoisted_42$2 = ["onClick"];
    const _hoisted_43$2 = { style: { "flex": "1" } };
    const _hoisted_44$2 = {
      key: 1,
      style: { "padding": "5px" }
    };
    const _hoisted_45$1 = {
      class: "component-container-fake-input",
      style: { "margin-top": "2em" }
    };
    const _hoisted_46$1 = { style: { "display": "flex" } };
    const _hoisted_47$1 = { style: { "flex": "1", "position": "relative" } };
    const _hoisted_48$1 = {
      autocomplete: "off",
      style: { "height": "3em" }
    };
    const _hoisted_49 = { key: 0 };
    const _hoisted_50 = { key: 0 };
    const _hoisted_51 = { key: 1 };
    const _hoisted_52 = { key: 0 };
    const _hoisted_53 = {
      key: 0,
      class: "link-mode-subdivision"
    };
    const _hoisted_54 = ["href"];
    const _hoisted_55 = {
      key: 0,
      class: "link-mode-subdivision"
    };
    const _hoisted_56 = ["href"];
    const _hoisted_57 = {
      key: 2,
      style: { "color": "darkred" }
    };
    const _hoisted_58 = { style: { "display": "flex" } };
    const _hoisted_59 = { style: { "flex": "2" } };
    const _hoisted_60 = { key: 0 };
    const _hoisted_61 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("span", { id: "loading-icon" }, "⟳", -1));
    const _hoisted_62 = { style: { "flex": "1" } };
    function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_AuthTypeIcon = resolveComponent("AuthTypeIcon");
      const _component_VueFinalModal = resolveComponent("VueFinalModal");
      return openBlock(), createBlock(_component_VueFinalModal, {
        "hide-overlay": false,
        "overlay-transition": "vfm-fade",
        "content-transition": "vfm-fade",
        "click-to-close": true,
        "esc-to-close": true,
        onClosed: _cache[19] || (_cache[19] = ($event) => $options.closeEditor()),
        background: "non-interactive",
        "lock-scroll": true,
        class: "complex-lookup-modal",
        "content-class": "complex-lookup-modal-content"
      }, {
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_1$6, [
            createBaseVNode("div", _hoisted_2$4, [
              createBaseVNode("div", _hoisted_3$4, [
                createBaseVNode("button", {
                  onClick: _cache[0] || (_cache[0] = ($event) => $options.editorModeSwitch("build")),
                  "data-tooltip": "Build LCSH headings using a lookup list",
                  class: "subjectEditorModeButtons simptip-position-left",
                  style: { "margin-right": "1em", "background-color": "black", "height": "2em", "display": "inline-flex" }
                }, [
                  _hoisted_4$4,
                  createBaseVNode("span", {
                    class: normalizeClass([{ "subjectEditorModeTextEnabled": _ctx.subjectEditorMode === "build" }])
                  }, "Build Mode", 2)
                ]),
                createBaseVNode("button", {
                  onClick: _cache[1] || (_cache[1] = ($event) => $options.editorModeSwitch("link")),
                  "data-tooltip": "Build LCSH headings by entering a MARC encoded string",
                  class: "subjectEditorModeButtons simptip-position-left",
                  style: { "background-color": "black", "height": "2em", "display": "inline-flex" }
                }, [
                  _hoisted_5$4,
                  createBaseVNode("span", {
                    class: normalizeClass([{ "subjectEditorModeTextEnabled": _ctx.subjectEditorMode === "link" }])
                  }, "Link Mode", 2)
                ])
              ]),
              _ctx.subjectEditorMode == "build" ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(["subject-editor-container", { "subject-editor-container-lowres": _ctx.lowResMode }])
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(["subject-editor-container-left", { "subject-editor-container-left-lowres": _ctx.lowResMode }])
                }, [
                  createBaseVNode("div", _hoisted_6$4, [
                    _hoisted_7$4,
                    createBaseVNode("button", {
                      onClick: _cache[2] || (_cache[2] = ($event) => $options.searchModeSwitch("LCSHNAF")),
                      "data-tooltip": "Shortcut: CTRL+ALT+1",
                      class: normalizeClass(["simptip-position-bottom", { "active": _ctx.searchMode === "LCSHNAF" }])
                    }, "LCSH/NAF", 2),
                    createBaseVNode("button", {
                      onClick: _cache[3] || (_cache[3] = ($event) => $options.searchModeSwitch("GEO")),
                      "data-tooltip": "Shortcut: CTRL+ALT+2",
                      class: normalizeClass(["simptip-position-bottom", { "active": _ctx.searchMode === "GEO" }])
                    }, "Indirect Geo", 2),
                    createBaseVNode("button", {
                      onClick: _cache[4] || (_cache[4] = ($event) => $options.searchModeSwitch("WORKS")),
                      "data-tooltip": "Shortcut: CTRL+ALT+3",
                      class: normalizeClass(["simptip-position-bottom", { "active": _ctx.searchMode === "WORKS" }])
                    }, "Works", 2),
                    createBaseVNode("button", {
                      onClick: _cache[5] || (_cache[5] = ($event) => $options.searchModeSwitch("HUBS")),
                      "data-tooltip": "Shortcut: CTRL+ALT+4",
                      class: normalizeClass(["simptip-position-bottom", { "active": _ctx.searchMode === "HUBS" }])
                    }, "Hubs", 2)
                  ]),
                  createBaseVNode("div", _hoisted_8$3, [
                    _ctx.activeSearch !== false ? (openBlock(), createElementBlock("div", _hoisted_9$3, toDisplayString$2(_ctx.activeSearch), 1)) : createCommentVNode("", true),
                    _ctx.searchResults !== null ? (openBlock(), createElementBlock("div", _hoisted_10$3, [
                      _ctx.searchResults.names.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_11$3, [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.searchResults.names, (name, idx) => {
                          return openBlock(), createElementBlock("div", {
                            onClick: ($event) => $options.selectContext((_ctx.searchResults.names.length - idx) * -1),
                            onMouseover: ($event) => $options.loadContext((_ctx.searchResults.names.length - idx) * -1),
                            "data-id": (_ctx.searchResults.names.length - idx) * -1,
                            key: name.uri,
                            class: normalizeClass(["fake-option", { "unselected": _ctx.pickPostion != (_ctx.searchResults.names.length - idx) * -1, "selected": _ctx.pickPostion == (_ctx.searchResults.names.length - idx) * -1, "picked": _ctx.pickLookup[(_ctx.searchResults.names.length - idx) * -1] && _ctx.pickLookup[(_ctx.searchResults.names.length - idx) * -1].picked }])
                          }, [
                            name.suggestLabel.length > 41 ? (openBlock(), createElementBlock("span", _hoisted_13$3, toDisplayString$2(name.suggestLabel.substring(0, 41)) + "...", 1)) : (openBlock(), createElementBlock("span", _hoisted_14$3, toDisplayString$2(name.suggestLabel), 1)),
                            _hoisted_15$3
                          ], 42, _hoisted_12$3);
                        }), 128)),
                        _hoisted_16$3
                      ])) : createCommentVNode("", true),
                      _ctx.searchResults.subjectsComplex.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_17$2, [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.searchResults.subjectsComplex, (subjectC, idx) => {
                          return openBlock(), createElementBlock("div", {
                            onClick: ($event) => $options.selectContext(idx),
                            onMouseover: ($event) => $options.loadContext(idx),
                            "data-id": idx,
                            key: subjectC.uri,
                            class: normalizeClass(["fake-option", { "unselected": _ctx.pickPostion != idx, "selected": _ctx.pickPostion == idx, "picked": _ctx.pickLookup[idx] && _ctx.pickLookup[idx].picked }])
                          }, [
                            createTextVNode(toDisplayString$2(subjectC.suggestLabel), 1),
                            _hoisted_19$2
                          ], 42, _hoisted_18$2);
                        }), 128)),
                        _hoisted_20$2
                      ])) : createCommentVNode("", true),
                      _ctx.searchResults.subjectsSimple.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_21$2, [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.searchResults.subjectsSimple, (subject, idx) => {
                          return openBlock(), createElementBlock("div", {
                            onClick: ($event) => $options.selectContext(_ctx.searchResults.subjectsComplex.length + idx),
                            onMouseover: ($event) => $options.loadContext(_ctx.searchResults.subjectsComplex.length + idx),
                            "data-id": _ctx.searchResults.subjectsComplex.length + idx,
                            key: subject.uri,
                            class: normalizeClass(["fake-option", { "unselected": _ctx.pickPostion != _ctx.searchResults.subjectsComplex.length + idx, "selected": _ctx.pickPostion == _ctx.searchResults.subjectsComplex.length + idx, "picked": _ctx.pickLookup[_ctx.searchResults.subjectsComplex.length + idx] && _ctx.pickLookup[_ctx.searchResults.subjectsComplex.length + idx].picked, "literal-option": subject.literal }])
                          }, [
                            createTextVNode(toDisplayString$2(subject.suggestLabel), 1),
                            subject.literal ? (openBlock(), createElementBlock("span", _hoisted_23$2, toDisplayString$2(subject.label), 1)) : createCommentVNode("", true),
                            createTextVNode(),
                            subject.literal ? (openBlock(), createElementBlock("span", _hoisted_24$2, "[Literal]")) : createCommentVNode("", true)
                          ], 42, _hoisted_22$2);
                        }), 128))
                      ])) : createCommentVNode("", true)
                    ])) : createCommentVNode("", true)
                  ]),
                  createBaseVNode("div", {
                    class: normalizeClass(["subject-editor-container-right", { "subject-editor-container-right-lowres": _ctx.lowResMode }])
                  }, [
                    _ctx.contextRequestInProgress ? (openBlock(), createElementBlock("div", _hoisted_25$2, "Retrieving data...")) : createCommentVNode("", true),
                    Object.keys(_ctx.contextData).length > 0 ? (openBlock(), createElementBlock("div", _hoisted_26$2, [
                      createBaseVNode("h3", null, [
                        createBaseVNode("span", {
                          class: "modal-context-icon simptip-position-top",
                          "data-tooltip": "Type: " + _ctx.contextData.type
                        }, [
                          _ctx.contextData.type ? (openBlock(), createBlock(_component_AuthTypeIcon, {
                            key: 0,
                            type: _ctx.contextData.type
                          }, null, 8, ["type"])) : createCommentVNode("", true)
                        ], 8, _hoisted_27$2),
                        createTextVNode(toDisplayString$2(_ctx.contextData.title), 1)
                      ]),
                      createBaseVNode("div", _hoisted_28$2, toDisplayString$2(_ctx.contextData.type), 1),
                      createBaseVNode("a", {
                        style: { "color": "#2c3e50" },
                        href: _ctx.contextData.uri,
                        target: "_blank"
                      }, "view on id.loc.gov", 8, _hoisted_29$2),
                      _ctx.contextData.variant && _ctx.contextData.variant.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_30$2, [
                        _hoisted_31$2,
                        createBaseVNode("ul", null, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.contextData.variant, (v2, idx) => {
                            return openBlock(), createElementBlock("li", {
                              class: "modal-context-data-li",
                              key: "var" + idx
                            }, toDisplayString$2(v2), 1);
                          }), 128))
                        ])
                      ])) : createCommentVNode("", true),
                      (openBlock(true), createElementBlock(Fragment, null, renderList(Object.keys(_ctx.contextData.nodeMap), (key2) => {
                        return openBlock(), createElementBlock("div", { key: key2 }, [
                          createBaseVNode("div", _hoisted_32$2, toDisplayString$2(key2) + ":", 1),
                          createBaseVNode("ul", null, [
                            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.contextData.nodeMap[key2], (v2) => {
                              return openBlock(), createElementBlock("li", {
                                class: "modal-context-data-li",
                                key: v2
                              }, toDisplayString$2(v2), 1);
                            }), 128))
                          ])
                        ]);
                      }), 128)),
                      _ctx.contextData.source && _ctx.contextData.source.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_33$2, [
                        _hoisted_34$2,
                        createBaseVNode("ul", null, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.contextData.source, (v2) => {
                            return openBlock(), createElementBlock("li", {
                              class: "modal-context-data-li",
                              key: v2
                            }, toDisplayString$2(v2), 1);
                          }), 128))
                        ])
                      ])) : createCommentVNode("", true)
                    ])) : createCommentVNode("", true)
                  ], 2)
                ], 2),
                createBaseVNode("div", _hoisted_35$2, [
                  createBaseVNode("div", _hoisted_36$2, [
                    createBaseVNode("div", _hoisted_37$2, [
                      createBaseVNode("div", _hoisted_38$2, [
                        createBaseVNode("form", _hoisted_39$2, [
                          withDirectives(createBaseVNode("input", {
                            onKeydown: [
                              _cache[6] || (_cache[6] = withKeys(withModifiers((...args) => $options.navInput && $options.navInput(...args), ["prevent"]), ["enter"])),
                              _cache[9] || (_cache[9] = (...args) => $options.navInput && $options.navInput(...args))
                            ],
                            placeholder: "Enter Subject Headings Here",
                            ref: "subjectInput",
                            autocomplete: "off",
                            type: "text",
                            "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => _ctx.subjectString = $event),
                            onInput: _cache[8] || (_cache[8] = (...args) => $options.subjectStringChanged && $options.subjectStringChanged(...args)),
                            onKeyup: _cache[10] || (_cache[10] = (...args) => $options.navString && $options.navString(...args)),
                            onClick: _cache[11] || (_cache[11] = (...args) => $options.navStringClick && $options.navStringClick(...args)),
                            class: "input-single-subject subject-input"
                          }, null, 544), [
                            [vModelText, _ctx.subjectString]
                          ])
                        ]),
                        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.components, (c2, idx) => {
                          return openBlock(), createElementBlock("div", {
                            ref_for: true,
                            ref: "cBackground" + idx,
                            class: normalizeClass(["color-holder", { "color-holder-okay": c2.uri !== null || c2.literal }, { "color-holder-type-okay": c2.type !== null || _ctx.showTypes === false }]),
                            key: idx
                          }, toDisplayString$2(c2.label), 3);
                        }), 128))
                      ])
                    ])
                  ]),
                  createBaseVNode("div", _hoisted_40$2, [
                    createBaseVNode("div", _hoisted_41$2, [
                      _ctx.showTypes ? (openBlock(), createElementBlock("ol", {
                        key: 0,
                        class: normalizeClass(["type-list-ol", { "type-list-ol-lowres": _ctx.lowResMode }])
                      }, [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.activeTypes, (type) => {
                          return openBlock(), createElementBlock("li", {
                            class: normalizeClass(["type-item", { "type-item-selected": type.selected }]),
                            key: type.value,
                            onClick: ($event) => $options.setTypeClick($event, type.value)
                          }, toDisplayString$2(type.label), 11, _hoisted_42$2);
                        }), 128))
                      ], 2)) : createCommentVNode("", true)
                    ]),
                    createBaseVNode("div", _hoisted_43$2, [
                      _ctx.lowResMode ? (openBlock(), createElementBlock("button", {
                        key: 0,
                        onClick: _cache[12] || (_cache[12] = (...args) => $options.closeEditor && $options.closeEditor(...args)),
                        style: { "float": "right", "margin": "0.6em", "background-color": "white", "border": "solid 1px rgb(42,42,42)", "color": "rgb(42,42,42)" },
                        class: normalizeClass([{ "add-button-lowres": _ctx.lowResMode }])
                      }, "Close", 2)) : createCommentVNode("", true),
                      _ctx.okayToAdd == true ? (openBlock(), createElementBlock("button", {
                        key: 1,
                        style: { "float": "right", "margin": "0.6em" },
                        onClick: _cache[13] || (_cache[13] = (...args) => $options.add && $options.add(...args)),
                        class: normalizeClass([{ "add-button-lowres": _ctx.lowResMode }])
                      }, "Add [SHIFT+Enter]", 2)) : _ctx.okayToAdd == false && _ctx.subjectString.length == 0 ? (openBlock(), createElementBlock("button", {
                        key: 2,
                        disabled: "",
                        style: { "float": "right", "margin": "0.6em", "display": "none" },
                        class: normalizeClass([{ "add-button-lowres": _ctx.lowResMode }])
                      }, "Can't Add", 2)) : _ctx.okayToAdd == false ? (openBlock(), createElementBlock("button", {
                        key: 3,
                        disabled: "",
                        style: { "float": "right", "margin": "0.6em" },
                        class: normalizeClass([{ "add-button-lowres": _ctx.lowResMode }])
                      }, "Can't Add", 2)) : createCommentVNode("", true)
                    ])
                  ], 512)
                ])
              ], 2)) : (openBlock(), createElementBlock("div", _hoisted_44$2, [
                createBaseVNode("div", _hoisted_45$1, [
                  createBaseVNode("div", _hoisted_46$1, [
                    createBaseVNode("div", _hoisted_47$1, [
                      createBaseVNode("form", _hoisted_48$1, [
                        withDirectives(createBaseVNode("input", {
                          onKeydown: _cache[14] || (_cache[14] = withKeys(withModifiers((...args) => $options.linkModeTextChange && $options.linkModeTextChange(...args), ["prevent"]), ["enter"])),
                          placeholder: "Enter MARC encoded LCSH value",
                          autocomplete: "off",
                          type: "text",
                          "onUpdate:modelValue": _cache[15] || (_cache[15] = ($event) => _ctx.linkModeString = $event),
                          ref: "subjectInput",
                          class: "input-single-subject subject-input"
                        }, null, 544), [
                          [vModelText, _ctx.linkModeString]
                        ])
                      ])
                    ])
                  ])
                ]),
                !_ctx.linkModeSearching ? (openBlock(), createElementBlock("ul", _hoisted_49, [
                  _ctx.linkModeResults === false ? (openBlock(), createElementBlock("li", _hoisted_50, "Enter MARC subject string above (with $ signs for subdivdion seperation) and press enter key")) : createCommentVNode("", true)
                ])) : createCommentVNode("", true),
                !_ctx.linkModeSearching ? (openBlock(), createElementBlock("ol", _hoisted_51, [
                  _ctx.linkModeResults !== false ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    _ctx.linkModeResults.resultType && _ctx.linkModeResults.resultType == "COMPLEX" ? (openBlock(), createElementBlock("li", _hoisted_52, [
                      createBaseVNode("span", {
                        class: normalizeClass({ "link-mode-good-heading": _ctx.linkModeResults.hit.uri, "link-mode-bad-heading": !_ctx.linkModeResults.hit.uri })
                      }, toDisplayString$2(_ctx.linkModeResults.hit.label), 3),
                      _ctx.linkModeResults.hit.heading && _ctx.linkModeResults.hit.heading.subdivision ? (openBlock(), createElementBlock("span", _hoisted_53, "(subdivision)")) : createCommentVNode("", true),
                      _ctx.linkModeResults.hit.uri ? (openBlock(), createElementBlock("a", {
                        key: 1,
                        class: "link-mode-good-heading-alink",
                        target: "_blank",
                        href: _ctx.linkModeResults.hit.uri
                      }, toDisplayString$2(_ctx.linkModeResults.hit.uri.split("/")[_ctx.linkModeResults.hit.uri.split("/").length - 1]), 9, _hoisted_54)) : createCommentVNode("", true)
                    ])) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(_ctx.linkModeResults.hit, (hit, idx) => {
                      return openBlock(), createElementBlock("li", { key: idx }, [
                        createBaseVNode("span", {
                          class: normalizeClass({ "link-mode-good-heading": hit.uri, "link-mode-bad-heading": !hit.uri })
                        }, toDisplayString$2(hit.label), 3),
                        hit.heading && hit.heading.subdivision ? (openBlock(), createElementBlock("span", _hoisted_55, "(subdivision)")) : createCommentVNode("", true),
                        hit.uri ? (openBlock(), createElementBlock("a", {
                          key: 1,
                          class: "link-mode-good-heading-alink",
                          target: "_blank",
                          href: hit.uri
                        }, toDisplayString$2(hit.uri.split("/")[hit.uri.split("/").length - 1]), 9, _hoisted_56)) : createCommentVNode("", true)
                      ]);
                    }), 128))
                  ], 64)) : createCommentVNode("", true)
                ])) : createCommentVNode("", true),
                _ctx.linkModeResults && _ctx.linkModeResults.resultType && _ctx.linkModeResults.resultType == "ERROR" ? (openBlock(), createElementBlock("span", _hoisted_57, toDisplayString$2(_ctx.linkModeResults.msg), 1)) : createCommentVNode("", true),
                createBaseVNode("div", _hoisted_58, [
                  createBaseVNode("div", _hoisted_59, [
                    _ctx.linkModeSearching ? (openBlock(), createElementBlock("h1", _hoisted_60, [
                      _hoisted_61,
                      createTextVNode(" Working...")
                    ])) : createCommentVNode("", true),
                    _ctx.linkModeSearching === false ? (openBlock(), createElementBlock("button", {
                      key: 1,
                      style: { "margin-right": "1em", "margin-left": "2em" },
                      onClick: _cache[16] || (_cache[16] = ($event) => $options.linkModeTextChange({ key: "Enter", shiftKey: false }))
                    }, "Link Components [Enter]")) : createCommentVNode("", true),
                    _ctx.linkModeResults !== false ? (openBlock(), createElementBlock("button", {
                      key: 2,
                      style: {},
                      onClick: _cache[17] || (_cache[17] = (...args) => $options.addLinkMode && $options.addLinkMode(...args))
                    }, "Add Heading [SHIFT+Enter]")) : createCommentVNode("", true)
                  ]),
                  createBaseVNode("div", _hoisted_62, [
                    createBaseVNode("button", {
                      style: { "float": "right", "margin-right": "1em" },
                      onClick: _cache[18] || (_cache[18] = (...args) => $options.closeEditor && $options.closeEditor(...args))
                    }, "Close")
                  ])
                ])
              ]))
            ])
          ], 512)
        ]),
        _: 1
      });
    }
    const SubjectEditor = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6], ["__scopeId", "data-v-a0c8b9c8"]]);
    const _sfc_main$5 = {
      name: "EditLabelDereference",
      components: {},
      props: {
        URI: String
      },
      data: function() {
        return {
          displayLabel: ""
        };
      },
      created: function() {
      },
      computed: {
        displayLabelValue() {
          this.fetchLabel();
          return this.displayLabel;
        }
      },
      methods: {
        fetchLabel: function() {
          if (this.URI) {
            if (this.URI.startsWith("http://") || this.URI.startsWith("https://")) {
              if (this.URI.includes("id.loc.gov")) {
                if (this.URI.includes("/resources/instances/") || this.URI.includes("/resources/works/") || this.URI.includes("/resources/hubs/") || this.URI.includes("/vocabulary/")) {
                  if (this.URI.endsWith("/")) {
                    this.URI = this.URI.slice(0, -1);
                  }
                  let URL2 = this.URI + ".nt";
                  URL2 = URL2.replace("http://", "https://");
                  let cache2 = sessionStorage.getItem(URL2);
                  if (cache2) {
                    this.displayLabel = cache2;
                  } else {
                    let self2 = this;
                    fetch(URL2, { method: "HEAD" }).then(
                      function(response) {
                        let preflabel = response.headers.get("x-preflabel");
                        if (response.headers.get("x-preflabel-encoded")) {
                          preflabel = decodeURIComponent(response.headers.get("x-preflabel-encoded"));
                        }
                        if (preflabel) {
                          self2.displayLabel = preflabel;
                          sessionStorage.setItem(URL2, preflabel);
                        }
                      }
                    ).catch(function() {
                    });
                  }
                } else {
                  if (this.URI == "http://id.loc.gov/authorities/subjects") {
                    this.displayLabel = "Library of Congress subject headings";
                  }
                }
              } else {
                this.displayLabel = this.URI;
              }
            } else {
              this.displayLabel = this.URI;
            }
          } else {
            this.displayLabel = "NO URI PASSED?";
          }
        }
      }
    };
    const _hoisted_1$5 = { class: "trigger-open" };
    function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("span", _hoisted_1$5, toDisplayString$2($options.displayLabelValue), 1);
    }
    const LabelDereference = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5]]);
    const _sfc_main$4 = {
      props: {
        type: String,
        guid: String,
        clickmode: Boolean,
        small: Boolean,
        fieldGuid: String
      },
      data() {
        return {
          showActionButtonMenu: false,
          showActionButtonMenuTimer: null
        };
      },
      computed: {
        ...mapStores(usePreferenceStore),
        ...mapStores(useProfileStore),
        ...mapState(usePreferenceStore, ["scriptShifterOptions"]),
        ...mapWritableState(usePreferenceStore, ["debugModalData", "showDebugModal"]),
        useOpenModes() {
          return ["click", "touch"];
        }
      },
      methods: {
        menuClosed: function() {
        },
        showDebug: function() {
          this.debugModalData = this.profileStore.returnStructureByComponentGuid(this.guid);
          this.showDebugModal = true;
        },
        duplicateComponent: function() {
          this.profileStore.duplicateComponent(this.profileStore.returnStructureByComponentGuid(this.guid)["@guid"]);
        },
        addComponent: function() {
        }
        // /**
        // * When the mouse moves over the relevant elements open the action menu
        // * if they move again it will clear any close timer
        // * @return {void}
        // */
        // actionButtonShow: function(){
        //   this.showActionButtonMenu=true
        //   window.clearTimeout(this.showActionButtonMenuTimer)
        // },
        // /**
        // * When the mouse moves out of the menu start the time to close it 
        // * @return {void}
        // */
        // startHideActionButton: function(){
        //   this.showActionButtonMenuTimer = window.setTimeout(()=>{
        //     this.showActionButtonMenu=false
        //   },500)
        // },
        // /**
        // * When they click on a command in the list, emit the command and clean up interface
        // * @return {void}
        // */
        // actionClick(cmd){
        //     this.$emit('actionButtonCommand', cmd)
        //     this.showActionButtonMenu=false
        // }
      },
      watch: {}
    };
    const __injectCSSVars__$3 = () => {
      useCssVars((_ctx) => ({
        "67d76e5f": _ctx.preferenceStore.returnValue("--n-edit-general-action-button-size"),
        "4f78ad34": _ctx.preferenceStore.returnValue("--c-edit-general-action-button-color"),
        "c13f8e52": _ctx.preferenceStore.returnValue("--c-edit-general-action-button-background-color"),
        "52bf637a": _ctx.preferenceStore.returnValue("--n-edit-general-action-button-border-width"),
        "3500cb56": _ctx.preferenceStore.returnValue("--c-edit-general-action-button-border-color"),
        "4e3dc339": _ctx.preferenceStore.returnValue("--n-edit-general-action-button-border-radius"),
        "37539f53": _ctx.preferenceStore.returnValue("--n-edit-general-action-button-continer-background-color"),
        "06929074": _ctx.preferenceStore.returnValue("--n-edit-general-action-button-continer-border-width"),
        "121a0688": _ctx.preferenceStore.returnValue("--c-edit-general-action-button-continer-border-color"),
        "1c93c728": _ctx.preferenceStore.returnValue("--n-edit-general-action-button-continer-border-radius"),
        "0d3c20ad": _ctx.preferenceStore.returnValue("--c-edit-general-action-button-continer-color"),
        "0899a314": _ctx.preferenceStore.returnValue("--n-edit-general-action-button-continer-font-size"),
        "746f31ba": _ctx.preferenceStore.returnValue("--n-edit-general-action-button-continer-background-highlight-color")
      }));
    };
    const __setup__$3 = _sfc_main$4.setup;
    _sfc_main$4.setup = __setup__$3 ? (props, ctx) => {
      __injectCSSVars__$3();
      return __setup__$3(props, ctx);
    } : __injectCSSVars__$3;
    const _withScopeId$2 = (n2) => (pushScopeId("data-v-0f66a0f2"), n2 = n2(), popScopeId(), n2);
    const _hoisted_1$4 = { class: "material-icons action-button-icon" };
    const _hoisted_2$3 = ["onClick"];
    const _hoisted_3$3 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("span", {
      class: "material-icons icon",
      style: { "font-size": "95%", "vertical-align": "middle", "padding-right": "5px" }
    }, "translate", -1));
    const _hoisted_4$3 = ["onClick"];
    const _hoisted_5$3 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("span", {
      class: "material-icons icon",
      style: { "font-size": "95%", "vertical-align": "middle", "padding-right": "5px" }
    }, "translate", -1));
    const _hoisted_6$3 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("br", null, null, -1));
    const _hoisted_7$3 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("hr", null, null, -1));
    function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_VMenu = resolveComponent("VMenu");
      return openBlock(), createBlock(_component_VMenu, {
        triggers: $options.useOpenModes,
        onHide: $options.menuClosed
      }, {
        popper: withCtx(() => [
          $props.type == "literal" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(Object.keys(_ctx.scriptShifterOptions), (lang) => {
              return openBlock(), createElementBlock(Fragment, null, [
                _ctx.scriptShifterOptions[lang].s2r ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  style: { "width": "100%" },
                  class: "",
                  onClick: ($event) => _ctx.$emit("actionButtonCommand", "trans", { lang, dir: "s2r", fieldGuid: $props.fieldGuid })
                }, [
                  _hoisted_3$3,
                  createBaseVNode("span", null, toDisplayString$2(_ctx.scriptShifterOptions[lang].name) + " S2R", 1)
                ], 8, _hoisted_2$3)) : createCommentVNode("", true),
                _ctx.scriptShifterOptions[lang].r2s ? (openBlock(), createElementBlock("button", {
                  key: 1,
                  style: { "width": "100%" },
                  class: "",
                  onClick: ($event) => _ctx.$emit("actionButtonCommand", "trans", { lang, dir: "r2s", fieldGuid: $props.fieldGuid })
                }, [
                  _hoisted_5$3,
                  createBaseVNode("span", null, toDisplayString$2(_ctx.scriptShifterOptions[lang].name) + " R2S", 1)
                ], 8, _hoisted_4$3)) : createCommentVNode("", true)
              ], 64);
            }), 256)),
            createBaseVNode("button", {
              style: { "width": "100%" },
              class: "",
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("actionButtonCommand", "addField"))
            }, " Additonal Literal "),
            _hoisted_6$3
          ], 64)) : createCommentVNode("", true),
          $props.type == "lookupSimple" ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [], 64)) : createCommentVNode("", true),
          $props.type == "lookupComplex" ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [], 64)) : createCommentVNode("", true),
          _hoisted_7$3,
          createBaseVNode("button", {
            style: { "width": "100%" },
            class: "",
            onClick: _cache[1] || (_cache[1] = ($event) => $options.showDebug())
          }, " Debug "),
          createBaseVNode("button", {
            style: { "width": "100%" },
            class: "",
            onClick: _cache[2] || (_cache[2] = ($event) => $options.duplicateComponent())
          }, " Duplicate Component ")
        ]),
        default: withCtx(() => [
          createBaseVNode("button", {
            class: normalizeClass({ "action-button": true, "small-mode": $props.small })
          }, [
            createBaseVNode("span", _hoisted_1$4, toDisplayString$2(_ctx.preferenceStore.returnValue("--s-edit-general-action-button-icon")), 1)
          ], 2)
        ]),
        _: 1
      }, 8, ["triggers", "onHide"]);
    }
    const ActionButton = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4], ["__scopeId", "data-v-0f66a0f2"]]);
    const _sfc_main$3 = {
      name: "LookupComplex",
      components: {
        ComplexLookupModal,
        SubjectEditor,
        LabelDereference,
        AuthTypeIcon,
        ActionButton
        // Keypress: () => import('vue-keypress'),
        // EditSubjectEditor,
        // // EditLabelRemark,
        // EditLabelDereference
      },
      props: {
        structure: Object,
        // parentStructure: Array,
        // profileCompoent: String,
        // parentStructureObj: Object,
        // profileName: String,
        // activeTemplate: Object,
        // parentURI: String,
        // isMini: Boolean,
        // bnodeProperty: String,
        guid: String,
        nested: Boolean,
        propertyPath: Array,
        level: Number
      },
      data: function() {
        return {
          displayModal: false,
          displaySubjectModal: false,
          showActionButton: false,
          searchValue: null
          // lookups: this.structure.valueConstraint.useValuesFrom,
          // lookupConfig: config.lookupConfig,
          // modeSelect: null,
          // searchValue: "",
          // searchTimeout: null,
          // selectLastIndex: null,
          // initalSearchState: true,
          // selectNavTimeout: null,
          // componentKey: 0,
          // displaySelectedDetails: false,
          // doubleDelete: false,
          // precoordinated: [],
          // displayPreCoordinated: false,
          // displayLabel: null,
          // displayLabelDreferenced: null,
          // displayType: null,
          // displayGuid: null,
          // displayContext: {},
          // editLabelDereferenceKey: Date.now(),
          // contextRequestInProgress: false,
          // validated: false,
          // validationMessage: "",
          // lowResMode:false,
          // displayMini: false,
          // allowHubCreation: false,
          // userData: {},
          // internalAssignID: false,
        };
      },
      watch: {
        // // watch when the undoindex changes, means they are undoing redoing, so refresh the
        // // value in the acutal input box
        // undoCounter: function(){
        //     this.checkForUserData()
        // }
      },
      computed: {
        // other computed properties
        // ...
        // gives access to this.counterStore and this.userStore
        ...mapStores(useProfileStore),
        ...mapStores(useConfigStore),
        ...mapStores(usePreferenceStore),
        ...mapWritableState(useProfileStore, ["activeField", "activeProfile"]),
        complexLookupValues() {
          let values = this.profileStore.returnComplexLookupValueFromProfile(this.guid, this.propertyPath);
          return values;
        },
        myGuid() {
          return `${this.structure["@guid"]}--${this.guid}`;
        },
        inlineModeShouldDisplay() {
          return true;
        }
      },
      created: function() {
      },
      // computed:  mapState({
      //   lookupLibrary: 'lookupLibrary',
      //   activeInput: 'activeInput',
      //   activeProfile: 'activeProfile', 
      //   activeProfileMini: 'activeProfileMini',
      //   workingOnMiniProfile: 'workingOnMiniProfile',
      //   settingsDisplayMode: 'settingsDisplayMode',
      //   activeProfileName: 'activeProfileName',
      //   activeComplexSearch: 'activeComplexSearch',
      //   activeComplexSearchInProgress: 'activeComplexSearchInProgress',
      //   settingsLookupsUseTextSubjectEditor:'settingsLookupsUseTextSubjectEditor',
      //   contextData: 'contextData',
      //   undoCounter: 'undoCounter',
      //   assignedId (){
      //     if (this.internalAssignID){
      //       return this.internalAssignID
      //     }else{
      //       this.internalAssignID = uiUtils.assignID(this.structure,this.parentStructure,config)
      //       return this.internalAssignID
      //     }
      //     // return uiUtils.assignID(this.structure,this.parentStructure,config)
      //   },
      //   modalSelectOptions(){
      //     let options = []
      //     // add in the the defaul search ALL of everything possible
      //     //options.push({label: 'All', urls:null, processor:null})
      //     this.structure.valueConstraint.useValuesFrom.forEach((l)=>{
      //       if (this.lookupConfig[l]){
      //         this.lookupConfig[l].modes.forEach((mode)=>{
      //           Object.keys(mode).forEach((k)=>{
      //             options.push({label: k, urls:mode[k].url, processor:this.lookupConfig[l].processor, minCharBeforeSearch: (this.lookupConfig[l].minCharBeforeSearch ? this.lookupConfig[l].minCharBeforeSearch : false), all:mode[k].all })
      //             // mark the first All one we find as the first one
      //             if (!this.modeSelect && mode[k].all){
      //               this.modeSelect = k
      //             }
      //           })
      //         })
      //       }
      //     })
      //     return options
      //   },
      //   modalSelectOptionsLabels(){
      //     return this.modalSelectOptions.map((o)=>{return o.label})
      //   },
      //   // to access local state with `this`, a normal function must be used
      //   lookupVocab (state) {
      //     // let uri = this.structure.valueConstraint.useValuesFrom[0]
      //     // let returnVal = []
      //     // Object.keys(state.lookupLibrary).forEach((s)=>{
      //     //   
      //     // })
      //     // 
      //     // if (state.lookupLibrary[this.structure.valueConstraint.useValuesFrom[0]]){
      //     //   
      //     //   return state.lookupLibrary[this.structure.valueConstraint.useValuesFrom[0]]
      //     // }else{
      //     //   return []
      //     // }
      //     return state.lookupLibrary[this.structure.valueConstraint.useValuesFrom[0]]
      //   }
      // }),
      methods: {
        focusClick: function() {
          this.$refs.lookupInput.focus();
        },
        navKey: function(event2) {
          console.log(event2);
          if (event2 && event2.code === "ArrowUp") {
            utilsMisc.globalNav("up", event2.target);
          }
          if (event2 && event2.code === "ArrowDown") {
            utilsMisc.globalNav("down", event2.target);
          }
        },
        // showComplexModal: function(){
        //   console.log(configStore.useSubjectEditor)
        //   if (configStore.useSubjectEditor.contains(this.structure.propertyURI)){
        //     this.displaySubjectModal=true
        //   }else{
        //     this.displayModal=true
        //   }
        // },
        actionButtonCommand: function(cmd) {
          this.$refs.lookupInput.focus();
          console.log(this.$refs.lookupInput);
        },
        focused: function() {
          this.activeField = this.myGuid;
          if (this.preferenceStore.returnValue("--b-edit-general-action-button-display")) {
            this.showActionButton = true;
          } else {
            this.showActionButton = false;
          }
        },
        /**
        * emited from the modal to set the value
        * @return {object} profile
        */
        setComplexValue: function(contextValue) {
          delete contextValue.typeFull;
          this.profileStore.setValueComplex(this.guid, null, this.propertyPath, contextValue.uri, contextValue.title, contextValue.typeFull);
          this.searchValue = "";
          this.displayModal = false;
          this.$nextTick(() => {
            window.setTimeout(() => {
              this.$refs.lookupInput.focus();
            }, 10);
          });
        },
        // /**
        // * emited from the modal to set the value
        // * @return {object} profile
        // */    
        // setComplexSubjectValue: function(contextValue){
        //   delete contextValue.typeFull
        //   this.profileStore.setComplexSubjectValue(this.guid,null, this.propertyPath, contextValue.uri, contextValue.title, contextValue.typeFull)
        //   this.searchValue=''
        //   this.displaySubjectModal=false
        //   this.$nextTick(() => {
        //     window.setTimeout(()=>{
        //       this.$refs.lookupInput.focus()
        //     },10)
        //   })
        // },
        removeValue: function() {
          this.profileStore.removeValueComplex(this.guid, this.complexLookupValues[0]["@guid"]);
        },
        textInputEvent: function(event2) {
          if (this.complexLookupValues.length > 0) {
            this.searchValue = "";
            return false;
          }
          if (this.configStore.useSubjectEditor.includes(this.structure.propertyURI)) {
            this.displaySubjectModal = true;
            this.$nextTick(() => {
              this.$refs.subjectEditorModal.focusInput();
            });
          } else {
            this.displayModal = true;
          }
        },
        hideSubjectModal: function() {
          this.displaySubjectModal = false;
          this.searchValue = "";
          this.$nextTick(() => {
            window.setTimeout(() => {
              this.$refs.lookupInput.focus();
            }, 10);
          });
        },
        subjectAdded: function(components2) {
          this.profileStore.setValueSubject(this.guid, components2, this.propertyPath);
          this.hideSubjectModal();
        }
        // focusCurrentInput: uiUtils.focusCurrentInput,
        // returnAuthIcon: uiUtils.returnAuthIcon,
        // /**
        // * return the active profile if we are editing a mini inline profile or the normal active profile
        // * @return {object} profile
        // */
        // returnCorrectActiveProfile: function(){
        //   if (this.isMini){
        //     return this.activeProfileMini
        //   }else if (this.workingOnMiniProfile){
        //     return this.activeProfileMini
        //   }else{
        //     return this.activeProfile
        //   }
        // },
        // showMiniHubEdit: function(){
        //     this.closeModal()
        //     let payload = {
        //       useProfile: 'Hub',
        //       sourceId: this.assignedId,
        //       component: this
        //     }
        //     this.$emit('showMiniEditorEdit',payload);
        //     this.$parent.$emit('showMiniEditorEdit',payload);
        //     this.$parent.$parent.$emit('showMiniEditorEdit',payload);
        //     this.$parent.$parent.$parent.$emit('showMiniEditorEdit',payload);
        //     this.$parent.$parent.$parent.$parent.$emit('showMiniEditorEdit',payload);
        //     // this.$store.dispatch("setWorkingOnMiniProfile", { self: this, value: true }).then(() => {
        //     //   this.displayMini = true
        //     // })
        // },
        // returnGuid: function(){
        //   return parseProfile.returnGuid(this.activeProfile, this.profileCompoent, this.structure.propertyURI)
        // },
        // formatDisplayLabel: function(){
        //   // if the display label is a URI it means there is no RDFLabel in the data because that property is just deisgned to be a rdf:resource link with a @id 
        //   // not a full bnode with label data. So two options here request the label or if they just added it there might be a @context we can use
        //   let useTitle = false
        //   if (this.displayLabel.startsWith('http:')){
        //     let userData = parseProfile.returnUserValues(this.returnCorrectActiveProfile(), this.profileName, this.profileCompoent, this.structure.propertyURI, this.propertyPath)
        //     // look for a @context in any of the properties
        //     for (let key in userData){
        //       if (key == this.parentStructureObj.propertyURI){
        //         for (let d of userData[key]){
        //           for (let subKey in d){
        //             if (subKey == '@context'){                
        //               if (d[subKey].title){
        //                 useTitle = d[subKey].title
        //               }
        //             }
        //           }
        //         }
        //       }
        //     }
        //   }
        //     [100,500,1000,2000].forEach((ts)=>{
        //       window.setTimeout(()=>{
        //         let keepLooping = 0
        //         let orginalVal
        //         try{
        //           orginalVal = this.$refs.labelSpan.innerHTML
        //         }catch{
        //           return null
        //         }
        //         if (!this.displayLabelDreferenced){
        //           this.displayLabelDreferenced = this.$refs.labelSpan.innerText
        //         }
        //         while (this.$refs.labelSpan.parentNode.parentNode.clientWidth>this.$refs.fakeInputContainer.clientWidth - 60 && keepLooping < 1000){
        //           orginalVal = orginalVal.slice(0, -1)
        //           this.$refs.labelSpan.innerHTML = orginalVal + '...'
        //           // protect against infinite
        //           keepLooping++
        //         }
        //       },ts)
        //     })
        //   if (useTitle){
        //     // we have a title, but it might BE HUGE like really long, so see how big our container is an modify the displaly a little to make sure it fits
        //       // this.$nextTick(() => {
        //       //   // code in here will run after the below return has sent the value back and the UI has been updated
        //       //   // test if the label is now bigger than the container and if so do something about it
        //       //   if (this.$refs.fakeInputContainer.clientWidth - this.$refs.displayLabel.clientWidth < 100){
        //       //     console.log("HERE")
        //       //     this.$refs.displayLabelSpan.innerHTML = useTitle.substring(0,100) + '...'
        //       //   }
        //       //   // just do it one more time....
        //       //   this.$nextTick(() => {
        //       //     if (this.$refs.fakeInputContainer.clientWidth - this.$refs.displayLabel.clientWidth < 100){
        //       //       this.$refs.displayLabelSpan.innerHTML = useTitle.substring(0,50) + '....'
        //       //     }              
        //       //   })            
        //       // })
        //     return useTitle
        //   }else{
        //     return this.displayLabel  
        //   }
        // },
        // showEditLink: function(){
        //   let show = true
        //   if (this.displayLabel.includes('id.loc.gov/resources/works/')){
        //     show = false
        //   }
        //   if (this.displayLabel.includes('id.loc.gov/resources/hubs/')){
        //     show = false
        //   }
        //   if (this.structure.propertyURI=='http://www.loc.gov/mads/rdf/v1#Topic' && this.settingsLookupsUseTextSubjectEditor===false){
        //     show = false
        //   }
        //   return show
        // },
        // showRemoveLink: function(){
        //   let show = true
        //   if (this.displayLabel.includes('id.loc.gov/resources/works/')){
        //     show = false
        //   }
        //   return show
        // },
        // useSubjectEditor: function(){
        //   let use = false
        //   if (this.structure.propertyURI=='http://www.loc.gov/mads/rdf/v1#Topic'){
        //     use = true
        //   }
        //   if (this.parentStructureObj && this.parentStructureObj.propertyURI=='http://www.loc.gov/mads/rdf/v1#componentList'){
        //     use = true
        //   }
        //   if (this.settingsLookupsUseTextSubjectEditor===false){
        //     use = false
        //   }
        //   return use
        // },
        // validateHeading: function() {
        //     // dont validate some ID lookups until we can get reource lookups working correctly
        //     if (
        //       this.structure.propertyURI == 'http://id.loc.gov/ontologies/bibframe/Work' || 
        //       this.structure.propertyURI == 'http://id.loc.gov/ontologies/bibframe/Instance' || 
        //       this.structure.propertyURI == 'http://id.loc.gov/ontologies/bibframe/Item' ||
        //       // also don't validate relation properties
        //       this.structure.propertyURI == 'http://id.loc.gov/ontologies/bflc/relation'
        //     ){
        //       this.validated = validationUtil.headingNotChecked;
        //       this.validationMessage = validationUtil.getValidationMessage(this.validated)
        //     }
        //     if (this.validated === false) {
        //         //console.log("the this")
        //         //console.log(this)
        //         let userData = parseProfile.returnUserValues(this.returnCorrectActiveProfile(), this.profileName, this.profileCompoent, this.structure.propertyURI, this.propertyPath)
        //         // dis connect it from the source so it doesnt update the value, read only
        //         userData = JSON.parse(JSON.stringify(userData))
        //         // console.log("We are validTING THIS",userData)
        //         if (userData && this.parentStructureObj && this.parentStructureObj.propertyURI){
        //           // pass some more info to this process to help it
        //           userData.hintUri = this.parentStructureObj.propertyURI
        //         }
        //         if (userData !== false) {
        //             validationUtil.validateHeading(userData)
        //             .then((validationStatus) => {
        //               let orignalUserData = parseProfile.returnUserValues(this.returnCorrectActiveProfile(), this.profileName, this.profileCompoent, this.structure.propertyURI, this.propertyPath)
        //               // console.log("USERDATA 3",JSON.parse(JSON.stringify(userData)))
        //               this.validated = validationStatus;
        //               this.validationMessage = validationUtil.getValidationMessage(validationStatus);
        //               if (userData["http://id.loc.gov/ontologies/bibframe/agent"] !== undefined) {
        //                   // We have a contribution resource.
        //                   // What we need is the agent.
        //                   userData = userData["http://id.loc.gov/ontologies/bibframe/agent"][0];
        //               }
        //               if (orignalUserData["http://id.loc.gov/ontologies/bibframe/agent"] !== undefined) {
        //                   // We have a contribution resource.
        //                   // What we need is the agent.
        //                   orignalUserData = orignalUserData["http://id.loc.gov/ontologies/bibframe/agent"][0];
        //               }
        //               // console.log("this.displayContext",this.displayContext)
        //               // Do we need to set the display URI because the userData ID changed?
        //               if (userData["@id"] !== this.displayContext.uri) {
        //                   this.displayContext.uri = userData["@id"];
        //               }
        //               // Do we need to set the display labels because the userData label changed?
        //               var label = validationUtil.getLabel(userData);
        //               if (this.displayLabel != label) {
        //                   this.displayLabel = label;
        //               }
        //               if (this.displayContext.title != label) {
        //                   this.displayContext.title = label;
        //               }
        //               // console.log('userData is ',userData, 'for ', label)
        //               // console.log('orignalUserData is ',orignalUserData, 'for ', label)
        //               // if it is a name then when we validate also make sure that the 
        //               // uservalue is populated with the right stuff
        //               // sometimes a record will come in without a URI but it has a valid label
        //               if (!orignalUserData['@id']){
        //                 console.log("userData",userData)
        //                 console.log("userData",userData)
        //                 if (userData["@id"].includes('id.loc.gov/authorities/names/')){
        //                   this.$store.dispatch("fetchContext", { self: this, searchPayload: userData["@id"] }).then(() => {                      
        //                     // console.log("SETTING THE VALUE ON",this.profileName)
        //                     // console.log("USER VALUE WAS:",userData)
        //                     this.$store.dispatch("setValueComplex", { self: this, profileComponet: this.profileCompoent, template:this.profileName, structure: this.structure, parentStructure: this.parentStructureObj, propertyPath: this.propertyPath }).then(() => {
        //                       this.componentKey++
        //                     })  
        //                   })    
        //                 }
        //               }
        //             });
        //         }
        //     }
        //     return this.validated;
        // },
        // camelize: function (str) {
        //   return str.replace(/(?:^\w|[A-Z]|\b\w|\s+)/g, function(match, index) {
        //     if (+match === 0) return ""; // or if (/\s+/.test(match)) for white spaces
        //     return index === 0 ? match.toLowerCase() : match.toUpperCase();
        //   });
        // },
        // submitField: function(){
        //   return this.add()
        // },
        // rewriteURI: function(uri){
        //   if (!uri){
        //     return false
        //   }
        //   if (uri.includes('bibframe.example.org')){
        //     return false
        //   }
        //   if (uri.includes('/resources/hubs/') || uri.includes('/resources/works/') || uri.includes('/resources/instances/') || uri.includes('/resources/items/')){
        //     uri = uri.replace('https://id.loc.gov/', config.returnUrls().bfdb )
        //     uri = uri.replace('http://id.loc.gov/', config.returnUrls().bfdb )      
        //   }
        //   return uri
        // },
        // precoordinatedAddSubdivision: function(type){
        //   if (Object.keys(this.contextData).length==0) return false
        //   let label = this.contextData.title
        //   let uri  = this.contextData.uri
        //   let contextType = this.contextData.type
        //   // if they type is not in the context because it is a literal
        //   // then use the contxt it was added to the precoord with
        //   if (!this.contextData.typeFull){
        //     if (type == 'Topic'){
        //       this.contextData.typeFull = 'http://www.loc.gov/mads/rdf/v1#Topic'
        //       contextType = 'Topic'
        //     }else if (type == 'Geographic'){
        //       this.contextData.typeFull = 'http://www.loc.gov/mads/rdf/v1#Geographic'
        //       contextType = 'Geographic'
        //     }else if (type == 'Temporal'){
        //       this.contextData.typeFull = 'http://www.loc.gov/mads/rdf/v1#Temporal'
        //       contextType = 'Temporal'
        //     }else if (type == 'GenreForm'){
        //       this.contextData.typeFull = 'http://www.loc.gov/mads/rdf/v1#GenreForm'
        //       contextType = 'GenreForm'
        //     }
        //   }
        //   // console.log(type)
        //   // if (contextType != type){
        //   //   return false
        //   // }
        //   // console.log({uri:uri,label:label,type:contextType,typeFull:this.contextData.typeFull})
        //   this.precoordinated.push({uri:uri,label:label,type:contextType,typeFull:this.contextData.typeFull})
        //   this.$refs.searchInput.focus()
        // },
        // precoordinatedRemoveLast: function(){
        //   if (this.precoordinated.length>0){
        //     this.precoordinated.splice(-1,1)
        //   }
        // },
        // canBuildComplex: function(){
        //   if (this.structure.valueConstraint.useValuesFrom.indexOf('http://id.loc.gov/authorities/subjects')>-1) return true
        //   return false
        // },
        // togglePreCoordinated: function(event){
        //   if (this.displayPreCoordinated == false && this.displayModal == true){
        //     this.displayPreCoordinated = true
        //     if(event && event.event){
        //       event.event.preventDefault()
        //       return false
        //     }
        //   }else{
        //     this.displayPreCoordinated = false  
        //     if(event && event.event){
        //       event.event.preventDefault()
        //       return false
        //     }        
        //   }
        // },
        // doubleDeleteCheck: function(event){
        //   if (event && event.key && event.key==='Backspace'){ 
        //     if (this.doubleDelete){
        //       this.removeValue()
        //     }else{
        //       this.doubleDelete = true        
        //     }
        //   }else if(event.key!='ArrowUp' && event.key!='ArrowDown' && event.key!='Tab'){
        //     event.preventDefault()
        //     return false
        //   }
        // },
        // toggleSelectedDetails: function(){
        //   if (this.displaySelectedDetails){
        //     this.displaySelectedDetails = false
        //     // put the focus back on the input
        //     setTimeout(()=>{
        //       document.getElementById(this.assignedId).focus()
        //     },0)
        //   }else{
        //     this.displaySelectedDetails = true
        //   }
        // },
        // checkForUserData: function(){
        //   this.displayLabel = null
        //   this.displayType = null
        //   this.displayGuid = null
        //   let userValue 
        //   // let rootPropertyURI
        //   // if (this.isMini){
        //   //   userValue = parseProfile.returnUserValues(this.activeProfileMini, this.profileName, this.profileCompoent,this.structure.propertyURI)
        //   //   rootPropertyURI = parseProfile.returnRootPropertyURI(this.activeProfileMini, this.profileCompoent,this.structure.propertyURI)        
        //   // }else{
        //     userValue = parseProfile.returnUserValues(this.returnCorrectActiveProfile(), this.profileName, this.profileCompoent,this.structure.propertyURI, this.propertyPath)
        //     // rootPropertyURI = parseProfile.returnRootPropertyURI(this.returnCorrectActiveProfile(), this.profileCompoent,this.structure.propertyURI)        
        //   // }
        //   if (userValue['http://www.w3.org/2000/01/rdf-schema#label'] || userValue['http://www.loc.gov/mads/rdf/v1#authoritativeLabel'] || userValue['http://id.loc.gov/ontologies/bibframe/code']){
        //     if (userValue['http://www.w3.org/2000/01/rdf-schema#label']){
        //       this.displayLabel = userValue['http://www.w3.org/2000/01/rdf-schema#label'][0]['http://www.w3.org/2000/01/rdf-schema#label'] || userValue['http://www.w3.org/2000/01/rdf-schema#label']
        //     }else if (userValue['http://www.loc.gov/mads/rdf/v1#authoritativeLabel']){
        //       this.displayLabel = userValue['http://www.loc.gov/mads/rdf/v1#authoritativeLabel'][0]['http://www.loc.gov/mads/rdf/v1#authoritativeLabel'] || userValue['http://www.loc.gov/mads/rdf/v1#authoritativeLabel']
        //     }else if (userValue['http://www.w3.org/1999/02/22-rdf-syntax-ns#value']){
        //       this.displayLabel = userValue['http://www.w3.org/1999/02/22-rdf-syntax-ns#value'][0]['http://www.w3.org/1999/02/22-rdf-syntax-ns#value'] || userValue['http://www.w3.org/1999/02/22-rdf-syntax-ns#value']
        //     }else if (userValue['http://id.loc.gov/ontologies/bibframe/code']){
        //       this.displayLabel = userValue['http://id.loc.gov/ontologies/bibframe/code'][0]['http://id.loc.gov/ontologies/bibframe/code'] || userValue['http://id.loc.gov/ontologies/bibframe/code']
        //     }
        //     this.displayLabel = this.displayLabel.replace(/&amp;/g,'&')
        //     if (!this.displayLabel){
        //       console.log("ERROR GETTING this.displayLabel")
        //       console.log(userValue)
        //       console.log(this.parentStructure)
        //     }
        //     if (userValue['@type']){
        //       this.displayType = userValue['@type']
        //     }    
        //     if (userValue['@context']){
        //       this.displayContext = userValue['@context']
        //     }else{
        //       this.displayContext = {
        //         contextValue: true,
        //         uri: (userValue['@id']) ? userValue['@id'] : null,
        //         title: this.displayLabel,
        //         nodeMap: {}
        //       }
        //     }
        //   }else{
        //       // does the userValue returned have anything other than the metadata keys?
        //       let keys = Object.keys(userValue).filter((v) => { return (v != '@root') })
        //       if (keys.length>0){
        //         console.warn('---------------------------------------------')
        //         console.warn('Dont know how to extract the userValue for this complexLookup')
        //         console.warn(userValue)
        //         console.warn(this.structure)
        //         console.warn('---------------------------------------------')
        //       }
        //   }
        //   // // if it is a root level resource
        //   // if (this.structure.propertyURI == this.structure.userValue['@root']){
        //   //   this.displayLabel = "yeet"
        //   // }
        // },
        // activate: function(event){
        //   // this skips activating the modal if they are simply navigating through the main field list
        //   if (event.key==='ArrowDown' || event.key==='ArrowUp' || event.key==='ArrowRight' || event.key==='ArrowLeft' || event.key==='PageUp' || event.key==='PageDown' || event.key==='Tab' || event.key==='Control' || event.key==='Meta' || event.key==='Alt' || event.key==='Shift' || event.key==='CapsLock' || event.key==='=' || event.key ==='Backspace' || event.key ==='Home'){
        //     // the = key is for adding new 
        //     // if (!this.searchValue || (this.searchValue && this.searchValue.trim() == '')){
        //       return false
        //     // }
        //   }
        //   if (event.target.value.trim() == ''){
        //     return false
        //   }
        //   // turn on the modal
        //   this.displayModal = true
        //   this.initalSearchState = true
        //   // console.log('here',this.displayModal)
        //   this.searchValue = event.target.value
        //   this.$store.dispatch("clearContext", { self: this})
        //   this.$store.dispatch("clearLookupValuesComplex", { self: this}).then(() => {
        //     // clear the values from any previous attempt
        //     // but if there is a value kick off that same search again
        //     if (this.searchValue != ''){
        //       this.search()
        //     }
        //   })    
        //   event.preventDefault()
        //   // set the last input, but do it after the modal has been displaed
        //   setTimeout(()=>{
        //     if (document.getElementById(this.assignedId+'search')){
        //       //console.log('focus:',document.getElementById(this.assignedId+'search'))
        //       document.getElementById(this.assignedId+'search').focus()
        //     }
        //   },0)
        //   this.$store.dispatch("disableMacroNav", { self: this})
        //   this.$nextTick(() => {
        //     if (this.$refs.EditSubjectEditor){
        //       this.$refs.EditSubjectEditor.$refs.subjectInput.focus()
        //       this.$refs.EditSubjectEditor.loadUserValue(this.searchValue)
        //       this.$refs.EditSubjectEditor.checkToolBarHeight()
        //     }
        //   })
        //   event.target.value = ''
        //   return false
        // },
        // focused: function(event){     
        //   this.$store.dispatch("setActiveInput", { self: this, id: event.target.id, profileCompoent: this.profileCompoent, profileName: this.profileName }).then(()=>{
        //             console.log("event.target.id",event.target.id)
        //     // now focus the side bars
        //     this.$nextTick(()=>{
        //       uiUtils.focusSidebars()
        //     })
        //   })
        // },
        // closeModal: function(event){
        //   if (event && event.target && event.target.classList.contains('close')){
        //     this.displayModal = false
        //   }
        //   // if (event && event.target && !event.target.classList.contains('modaloverlay')){
        //   //   return false
        //   // }
        //   this.$store.dispatch("enableMacroNav", { self: this})
        //   this.lowResMode =false
        //   this.displayModal = false
        //   this.displayPreCoordinated = false
        //   this.precoordinated = []
        //   this.prec
        //   if (event && event.event) event.event.preventDefault()
        //   this.focusCurrentInput()
        // },
        // openEditor: function(){
        //   // close the little details pane if open
        //   this.displaySelectedDetails = false      
        //   this.$store.dispatch("setActiveInput", { self: this, id: this.assignedId, profileCompoent: this.profileCompoent, profileName: this.profileName }).then(()=>{
        //     // just make sure the parent input is focused if they clicked "edit" without it being focused
        //   })
        //   this.$store.dispatch("disableMacroNav", { self: this})
        //   this.displayModal = true
        //   if (this.useSubjectEditor()){
        //     this.$nextTick(() => {
        //       if (this.$refs.EditSubjectEditor){
        //         this.$refs.EditSubjectEditor.$refs.subjectInput.focus()
        //         this.$refs.EditSubjectEditor.loadUserValue(this.activeProfile.rt[this.activeProfileName].pt[this.profileCompoent].userValue)
        //         this.$refs.EditSubjectEditor.checkToolBarHeight()
        //       }
        //     })
        //   }else{
        //     if (this.displayLabelDreferenced && this.displayLabel.startsWith('http')){
        //       this.searchValue = this.displayLabelDreferenced
        //     }else{
        //       this.searchValue = this.displayLabel
        //     }
        //     this.initalSearchState = true
        //     this.search()
        //     this.$nextTick(() => {
        //       document.getElementById(this.assignedId+'search').focus()
        //     })
        //   }
        //   this.displayLabelDreferenced = null
        // },
        // // the modal content is telling this modal that things dont fit
        // lowResModeActivate: function() {
        //   this.lowResMode=true
        // },
        // selectChange: function(event){
        //   // fake the target if this was not evoked from the html
        //   if (!event){
        //     event = {target: document.getElementById(this.assignedId+'select')}
        //   }
        //   // do the context lookup, try to only fire when they land on one
        //   window.clearTimeout(this.selectNavTimeout)
        //   this.selectNavTimeout = window.setTimeout(()=>{
        //     event.target.options.forEach((o)=>{
        //       if (o.selected){
        //         // remove the context because we're about to get a new one
        //         this.$store.dispatch("clearContext", { self: this})            
        //         // if they are on the literal value
        //         if (!o.value){
        //           let tempContext = {
        //               "contextValue": true,                  
        //               "source": [],
        //               "type": "Literal Value",
        //               "variant": [],
        //               "uri": null,
        //               "title": o.dataset.label,
        //               "contributor": [],
        //               "date": null,
        //               "genreForm": null,
        //               "nodeMap": {},
        //               "precoordinated" : false,
        //               "literal": true
        //           }        
        //           this.$store.dispatch("setContextManually", { self: this, context: tempContext, })
        //           return false
        //         }
        //         this.contextRequestInProgress = true
        //         this.$store.dispatch("fetchContext", { self: this, searchPayload: o.value }).then(() => {
        //           this.contextRequestInProgress = false
        //         })    
        //       }
        //     })            
        //   },300)
        // },
        // // moving through the list of results
        // selectNav: function(event){
        //   if (event.target.selectedIndex == 0){
        //     // pop back up into the search field
        //     if (event.key==='ArrowUp'){
        //       document.getElementById(this.assignedId+'search').focus()
        //       event.preventDefault();
        //       return false  
        //     }
        //   }
        //   // don't allow down arrow on the last one
        //   if (event.target.selectedIndex == event.target.options.length -1){
        //     if (event.key==='ArrowDown'){
        //       event.preventDefault();
        //       return false  
        //     }        
        //   }
        //   // console.log(event.key)
        //   if ((event.key === '1' || event.key === '!') && this.displayPreCoordinated == true && event.ctrlKey === true && event.shiftKey == true){
        //     this.precoordinatedAddSubdivision('Topic')
        //     event.preventDefault();
        //     return false 
        //   }
        //   if ((event.key === '2' || event.key === '@') && this.displayPreCoordinated == true && event.ctrlKey === true && event.shiftKey == true){
        //     this.precoordinatedAddSubdivision('Geographic')
        //     event.preventDefault();
        //     return false 
        //   }
        //   if ((event.key === '3' || event.key === '#') && this.displayPreCoordinated == true && event.ctrlKey === true && event.shiftKey == true){
        //     this.precoordinatedAddSubdivision('Temporal')
        //     event.preventDefault();
        //     return false 
        //   }
        //   if ((event.key === '4' || event.key === '$') && this.displayPreCoordinated == true && event.ctrlKey === true && event.shiftKey == true){        
        //     this.precoordinatedAddSubdivision('GenreForm')
        //     event.preventDefault();
        //     return false 
        //   }
        //   if ((event.key === '5' || event.key === '%') && this.displayPreCoordinated == true && event.ctrlKey === true && event.shiftKey == true){        
        //     this.precoordinatedRemoveLast()
        //     event.preventDefault();
        //     return false 
        //   }
        //   if (event.key==='Enter'){
        //     if (event.shiftKey){
        //       this.add()
        //     }
        //   }       
        //   // if (event.key === 'b' && event.ctrlKey === true && event.shiftKey == true && this.displayPreCoordinated == false){        
        //   //   this.togglePreCoordinated()
        //   //   event.preventDefault();
        //   //   return false 
        //   // }
        //   this.selectLastIndex = event.target.selectedIndex
        // },
        // switchTypes: function(event, buttonPush){
        //   // This section is for navigating inside the modal window
        //   // if they click the button fake the event like they pressed arrow key
        //   if (buttonPush=== true){
        //     event = {
        //       key : 'ArrowRight',
        //       // the input
        //       target: event.target.parentNode.querySelector('input')
        //     }
        //     // put focus back on input so the keys work if used
        //     event.target.parentNode.querySelector('input').focus()
        //   }
        //   if (event.key==='ArrowRight'){
        //     // get the current pos, and if we are at the end loop back to the beginning
        //     let currPos = this.modalSelectOptionsLabels.indexOf(this.modeSelect)
        //     if (currPos+1 > this.modalSelectOptionsLabels.length-1){
        //       currPos=-1
        //     }
        //     this.modeSelect  = this.modalSelectOptionsLabels[currPos+1]
        //     // update the results
        //     this.search()
        //   }else if (event.key==='ArrowLeft'){
        //     let currPos = this.modalSelectOptionsLabels.indexOf(this.modeSelect)
        //     if (currPos == 0){
        //       currPos=this.modalSelectOptionsLabels.length
        //     }
        //     this.modeSelect = this.modalSelectOptionsLabels[currPos-1]
        //     // update the results
        //     this.search()
        //   }else if (event.key==='ArrowDown'){
        //     document.getElementById(this.assignedId+'search').focus()
        //     event.preventDefault();
        //     return false    
        //   }else{
        //     event.preventDefault();
        //     return false        
        //   }
        // },
        // // two different methods for keyup and keydown is for the navigation between fields and the keyup is for invoking the search
        // searchNav: function(event){
        //   if (event.key==='ArrowUp'){  
        //     document.getElementById(this.assignedId+'switch').focus()
        //     event.preventDefault();
        //     return false              
        //   }
        //   // move focus to the select group
        //   if (event.key==='ArrowDown'){        
        //     if (document.getElementById(this.assignedId+'select').firstChild){
        //       document.getElementById(this.assignedId+'select').focus()
        //       document.getElementById(this.assignedId+'select').firstChild.selected=true
        //       this.selectChange()
        //     }
        //     event.preventDefault();
        //     return false              
        //   }
        // },
        // search: function(event){     
        //   if (event){
        //     this.searchValue = event.target.value
        //     // handled above do nothign
        //     if (event.key==='ArrowUp'){  
        //       return false              
        //     }
        //     if (event.key==='ArrowDown'){        
        //       return false              
        //     }
        //   }
        //   if (this.searchValue.trim()==''){
        //     return false
        //   }
        //   if (this.searchValue.length<3){
        //     // if it is non-latin 
        //     if (this.searchValue.match(/[\u3040-\u30ff\u3400-\u4dbf\u4e00-\u9fff\uf900-\ufaff\uff66-\uff9f]/)){
        //       // if it is a CJK language don't impose that limit
        //     }else{
        //       // check the config, some vocabs have very short codes, like the marc geo
        //       // so if it is configed to allow short search overtide the < 3 rule
        //       let minCharBeforeSearch = 3
        //       this.modalSelectOptions.forEach((a)=>{
        //         if (a.minCharBeforeSearch && a.minCharBeforeSearch < minCharBeforeSearch){
        //           minCharBeforeSearch = a.minCharBeforeSearch
        //         }
        //       })
        //       if (this.searchValue.length<minCharBeforeSearch){
        //         return false
        //       }
        //     }
        //   }
        //   window.clearTimeout(this.searchTimeout)
        //   let searchPayload = {
        //     processor: null,
        //     url: [],
        //     searchValue: this.searchValue
        //   }
        //   // if (this.modeSelect == 'All'){
        //   //   this.modalSelectOptions.forEach((a)=>{
        //   //     // use the ones in the config marked as "all" 
        //   //     if(a.all===true){
        //   //       searchPayload.processor=a.processor
        //   //       searchPayload.url.push(a.urls.replace('<QUERY>',this.searchValue))
        //   //     }
        //   //   })
        //   // }else{
        //     this.modalSelectOptions.forEach((a)=>{
        //       if (a.label==this.modeSelect){
        //         searchPayload.processor=a.processor
        //         searchPayload.url.push(a.urls.replace('<QUERY>',this.searchValue))            
        //       }
        //     })
        //   // }
        //   this.searchTimeout = window.setTimeout(()=>{
        //     // console.log('searching',searchPayload)    
        //     this.$store.dispatch("fetchLookupValuesComplex", { self: this, searchPayload: searchPayload }).then(() => {
        //       this.initalSearchState =false;
        //     })    
        //   }, 400)
        // },
        // // add this entity to the data for this component
        // add: function(){
        //   // are we adding a URI or building a pre-coordinated thing
        //   if (this.precoordinated.length > 0){
        //     // okay it is precoordinated
        //     // becase of how we are storing things in state and adding things to the profile in state we 
        //     // need to put our hand made pre-coordinated data into the context state and then trigger the 
        //     // add value state change
        //     // build the new context
        //     let precoordstring = this.precoordinated.map((p)=>{return p.label}).join("--")
        //     let tempContext = {
        //         "contextValue": true,
        //         "source": [],
        //         "type": "ComplexSubject",
        //         "variant": [],
        //         "uri": null,
        //         "title": precoordstring,
        //         "contributor": [],
        //         "date": null,
        //         "genreForm": null,
        //         "nodeMap": {},
        //         "precoordinated" : this.precoordinated
        //     }        
        //     // set it and then set the vlue when done
        //     this.$store.dispatch("setContextManually", { self: this, context: tempContext, }).then(() => {
        //       this.$store.dispatch("setValueComplex", { self: this, profileComponet: this.profileCompoent, template:this.activeTemplate, structure: this.structure, parentStructure: this.parentStructureObj, propertyPath: this.propertyPath }).then(() => {
        //         this.componentKey++
        //         this.displayModal = false
        //         this.$store.dispatch("enableMacroNav", { self: this})
        //         this.checkForUserData()
        //         this.validated = false
        //         this.validateHeading()
        //         // put the focus back on the input
        //         setTimeout(()=>{
        //           document.getElementById(this.assignedId).focus()
        //         },0)
        //       })  
        //     })  
        //   }else{
        //     if (Object.keys(this.contextData).length==0){
        //       return false
        //       // there is no context to add, so dont try
        //     }
        //     // if (this.contextData && this.contextData.literal){
        //     //   return false
        //     //   // they were tring to add only a literal value
        //     // }
        //     this.$store.dispatch("setValueComplex", { self: this, profileComponet: this.profileCompoent, template:this.activeTemplate, structure: this.structure, parentStructure: this.parentStructureObj, propertyPath: this.propertyPath }).then(() => {
        //       this.componentKey++
        //       this.displayModal = false
        //       this.checkForUserData()
        //       this.validated = false
        //       this.validateHeading()
        //       this.$store.dispatch("enableMacroNav", { self: this})
        //       // change the key on this element so it rerenderes
        //       this.editLabelDereferenceKey = Date.now()
        //       // put the focus back on the input
        //       setTimeout(()=>{
        //         document.getElementById(this.assignedId).focus()
        //       },0)
        //     })   
        //   }
        // }
      }
    };
    const __injectCSSVars__$2 = () => {
      useCssVars((_ctx) => ({
        "98d555da": _ctx.preferenceStore.returnValue("--c-edit-main-splitpane-edit-focused-field-color"),
        "d3026efc": _ctx.preferenceStore.returnValue("--n-edit-main-splitpane-edit-show-field-labels-size")
      }));
    };
    const __setup__$2 = _sfc_main$3.setup;
    _sfc_main$3.setup = __setup__$2 ? (props, ctx) => {
      __injectCSSVars__$2();
      return __setup__$2(props, ctx);
    } : __injectCSSVars__$2;
    const _withScopeId$1 = (n2) => (pushScopeId("data-v-9989523c"), n2 = n2(), popScopeId(), n2);
    const _hoisted_1$3 = ["title"];
    const _hoisted_2$2 = ["title"];
    const _hoisted_3$2 = ["onClick"];
    const _hoisted_4$2 = {
      key: 0,
      class: "complex-lookup-inline-mode"
    };
    const _hoisted_5$2 = { class: "complex-lookup-inline-mode-icon" };
    const _hoisted_6$2 = {
      key: 1,
      style: {}
    };
    const _hoisted_7$2 = {
      key: 0,
      class: "uncontrolled"
    };
    const _hoisted_8$2 = {
      key: 1,
      title: "Controlled Term",
      class: "",
      style: {}
    };
    const _hoisted_9$2 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("span", { class: "material-icons check-mark inline-mode-validation-icon" }, "check_circle_outline", -1));
    const _hoisted_10$2 = [
      _hoisted_9$2
    ];
    const _hoisted_11$2 = {
      key: 2,
      style: { "padding-right": "0.3em", "font-weight": "bold" }
    };
    const _hoisted_12$2 = {
      key: 0,
      title: "Controlled Term",
      class: ""
    };
    const _hoisted_13$2 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("span", { class: "material-icons check-mark inline-mode-validation-icon" }, "check_circle_outline", -1));
    const _hoisted_14$2 = [
      _hoisted_13$2
    ];
    const _hoisted_15$2 = ["onClick"];
    const _hoisted_16$2 = {
      key: 0,
      class: "lookup-fake-input-label"
    };
    const _hoisted_17$1 = {
      key: 1,
      class: "lookup-fake-input-text"
    };
    const _hoisted_18$1 = { class: "bfcode-display-mode-holder" };
    const _hoisted_19$1 = ["title"];
    const _hoisted_20$1 = { class: "bfcode-display-mode-holder-value" };
    const _hoisted_21$1 = {
      class: "lookup-fake-input-entities",
      style: { "display": "inline", "padding-left": "5px" }
    };
    const _hoisted_22$1 = { class: "selected-value-container" };
    const _hoisted_23$1 = { class: "selected-value-container-auth" };
    const _hoisted_24$1 = { class: "selected-value-container-title" };
    const _hoisted_25$1 = {
      key: 0,
      style: { "padding-right": "0.3em", "font-weight": "bold" }
    };
    const _hoisted_26$1 = {
      key: 0,
      class: "uncontrolled"
    };
    const _hoisted_27$1 = {
      key: 1,
      title: "Controlled Term",
      class: "selected-value-icon",
      style: {}
    };
    const _hoisted_28$1 = {
      key: 1,
      style: { "padding-right": "0.3em", "font-weight": "bold" }
    };
    const _hoisted_29$1 = {
      key: 0,
      title: "Controlled Term",
      class: "selected-value-icon"
    };
    const _hoisted_30$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("span", { class: "material-icons check-mark" }, "check_circle_outline", -1));
    const _hoisted_31$1 = [
      _hoisted_30$1
    ];
    const _hoisted_32$1 = { class: "selected-value-container-action" };
    const _hoisted_33$1 = ["onClick"];
    const _hoisted_34$1 = { class: "lookup-fake-input-entities" };
    const _hoisted_35$1 = { class: "selected-value-container" };
    const _hoisted_36$1 = { class: "selected-value-container-auth" };
    const _hoisted_37$1 = { class: "selected-value-container-title" };
    const _hoisted_38$1 = {
      key: 0,
      style: { "padding-right": "0.3em", "font-weight": "bold" }
    };
    const _hoisted_39$1 = {
      key: 0,
      class: "uncontrolled"
    };
    const _hoisted_40$1 = {
      key: 1,
      title: "Controlled Term",
      class: "selected-value-icon",
      style: {}
    };
    const _hoisted_41$1 = {
      key: 1,
      style: { "padding-right": "0.3em", "font-weight": "bold" }
    };
    const _hoisted_42$1 = {
      key: 0,
      title: "Controlled Term",
      class: "selected-value-icon"
    };
    const _hoisted_43$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("span", { class: "material-icons check-mark" }, "check_circle_outline", -1));
    const _hoisted_44$1 = [
      _hoisted_43$1
    ];
    const _hoisted_45 = { class: "selected-value-container-action" };
    const _hoisted_46 = ["onClick"];
    const _hoisted_47 = { class: "lookup-fake-input-text" };
    const _hoisted_48 = {
      key: 0,
      class: "lookup-action"
    };
    function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_AuthTypeIcon = resolveComponent("AuthTypeIcon");
      const _component_LabelDereference = resolveComponent("LabelDereference");
      const _component_action_button = resolveComponent("action-button");
      const _component_ComplexLookupModal = resolveComponent("ComplexLookupModal");
      const _component_SubjectEditor = resolveComponent("SubjectEditor");
      return openBlock(), createElementBlock(Fragment, null, [
        _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-inline-mode") == true ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          $options.inlineModeShouldDisplay ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            $options.complexLookupValues.length === 0 ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createBaseVNode("span", {
                class: "bfcode-display-mode-holder-label",
                title: $props.structure.propertyLabel
              }, toDisplayString$2(_ctx.profileStore.returnBfCodeLabel($props.structure)) + ":", 9, _hoisted_1$3),
              withDirectives(createBaseVNode("input", {
                class: "input-inline-mode can-select",
                onKeyup: _cache[0] || (_cache[0] = (...args) => $options.navKey && $options.navKey(...args)),
                onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.submitField && _ctx.submitField(...args), ["prevent"]), ["enter"])),
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.searchValue = $event),
                ref: "lookupInput",
                onFocusin: _cache[3] || (_cache[3] = (...args) => $options.focused && $options.focused(...args)),
                type: "text",
                onInput: _cache[4] || (_cache[4] = ($event) => $options.textInputEvent($event))
              }, null, 544), [
                [vModelText, _ctx.searchValue]
              ])
            ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList($options.complexLookupValues, (avl, idx) => {
                return openBlock(), createElementBlock(Fragment, null, [
                  createBaseVNode("span", {
                    class: "bfcode-display-mode-holder-label",
                    title: $props.structure.propertyLabel
                  }, toDisplayString$2(_ctx.profileStore.returnBfCodeLabel($props.structure)) + ":", 9, _hoisted_2$2),
                  createBaseVNode("a", {
                    href: "#",
                    class: "inline-auth-link",
                    onClick: ($event) => {
                      _ctx.searchValue = avl.label;
                      $options.textInputEvent();
                    }
                  }, [
                    avl.type ? (openBlock(), createElementBlock("span", _hoisted_4$2, [
                      createBaseVNode("span", _hoisted_5$2, [
                        createVNode(_component_AuthTypeIcon, {
                          small: true,
                          type: avl.type
                        }, null, 8, ["type"])
                      ])
                    ])) : createCommentVNode("", true),
                    !avl.needsDereference ? (openBlock(), createElementBlock("span", _hoisted_6$2, [
                      createTextVNode(toDisplayString$2(avl.label), 1),
                      avl.isLiteral ? (openBlock(), createElementBlock("span", _hoisted_7$2, "(uncontrolled)")) : createCommentVNode("", true),
                      !avl.isLiteral ? (openBlock(), createElementBlock("span", _hoisted_8$2, _hoisted_10$2)) : createCommentVNode("", true)
                    ])) : (openBlock(), createElementBlock("span", _hoisted_11$2, [
                      createVNode(_component_LabelDereference, {
                        URI: avl.URI
                      }, null, 8, ["URI"]),
                      !avl.isLiteral ? (openBlock(), createElementBlock("span", _hoisted_12$2, _hoisted_14$2)) : createCommentVNode("", true)
                    ]))
                  ], 8, _hoisted_3$2),
                  createBaseVNode("a", {
                    href: "#",
                    onClick: ($event) => $options.removeValue(idx),
                    style: { "padding": "0 0 0 2.5px", "text-decoration": "none", "font-size": "1em", "cursor": "pointer", "color": "gray" }
                  }, "x", 8, _hoisted_15$2)
                ], 64);
              }), 256)),
              withDirectives(createBaseVNode("input", {
                class: "input-inline-mode can-select",
                style: { "width": "20px" },
                onKeyup: _cache[5] || (_cache[5] = (...args) => $options.navKey && $options.navKey(...args)),
                onKeydown: _cache[6] || (_cache[6] = withKeys(withModifiers((...args) => _ctx.submitField && _ctx.submitField(...args), ["prevent"]), ["enter"])),
                "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => _ctx.searchValue = $event),
                ref: "lookupInput",
                onFocusin: _cache[8] || (_cache[8] = (...args) => $options.focused && $options.focused(...args)),
                type: "text",
                onInput: _cache[9] || (_cache[9] = ($event) => $options.textInputEvent($event))
              }, null, 544), [
                [vModelText, _ctx.searchValue]
              ])
            ], 64))
          ], 64)) : createCommentVNode("", true)
        ], 64)) : (openBlock(), createElementBlock("form", {
          key: 1,
          autocomplete: "off",
          onSubmit: _cache[21] || (_cache[21] = withModifiers(() => {
          }, ["prevent"]))
        }, [
          createBaseVNode("div", {
            class: "lookup-fake-input",
            onClick: _cache[20] || (_cache[20] = ($event) => $options.focusClick())
          }, [
            _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-shortcode-display-mode") == false ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-show-field-labels") && $options.complexLookupValues.length == 0 ? (openBlock(), createElementBlock("div", _hoisted_16$2, toDisplayString$2($props.structure.propertyLabel), 1)) : createCommentVNode("", true)
            ], 64)) : createCommentVNode("", true),
            _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-shortcode-display-mode") == true ? (openBlock(), createElementBlock("div", _hoisted_17$1, [
              createBaseVNode("div", _hoisted_18$1, [
                createBaseVNode("div", {
                  class: "bfcode-display-mode-holder-label",
                  title: $props.structure.propertyLabel
                }, toDisplayString$2(_ctx.profileStore.returnBfCodeLabel($props.structure)), 9, _hoisted_19$1),
                createBaseVNode("div", _hoisted_20$1, [
                  createBaseVNode("div", _hoisted_21$1, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList($options.complexLookupValues, (avl, idx) => {
                      return openBlock(), createElementBlock("div", _hoisted_22$1, [
                        createBaseVNode("div", _hoisted_23$1, [
                          avl.type ? (openBlock(), createBlock(_component_AuthTypeIcon, {
                            key: 0,
                            passClass: "complex-lookup-inline",
                            type: avl.type
                          }, null, 8, ["type"])) : createCommentVNode("", true)
                        ]),
                        createBaseVNode("div", _hoisted_24$1, [
                          !avl.needsDereference ? (openBlock(), createElementBlock("span", _hoisted_25$1, [
                            createTextVNode(toDisplayString$2(avl.label), 1),
                            avl.isLiteral ? (openBlock(), createElementBlock("span", _hoisted_26$1, "(uncontrolled)")) : createCommentVNode("", true),
                            !avl.isLiteral ? (openBlock(), createElementBlock("span", _hoisted_27$1)) : createCommentVNode("", true)
                          ])) : (openBlock(), createElementBlock("span", _hoisted_28$1, [
                            createVNode(_component_LabelDereference, {
                              URI: avl.URI
                            }, null, 8, ["URI"]),
                            !avl.isLiteral ? (openBlock(), createElementBlock("span", _hoisted_29$1, _hoisted_31$1)) : createCommentVNode("", true)
                          ]))
                        ]),
                        createBaseVNode("div", _hoisted_32$1, [
                          createBaseVNode("span", {
                            onClick: ($event) => $options.removeValue(idx),
                            style: { "border-left": "solid 1px black", "padding": "0 0.5em", "font-size": "1em", "cursor": "pointer" }
                          }, "x", 8, _hoisted_33$1)
                        ])
                      ]);
                    }), 256))
                  ]),
                  withDirectives(createBaseVNode("input", {
                    style: { "width": "auto" },
                    onKeyup: _cache[10] || (_cache[10] = (...args) => $options.navKey && $options.navKey(...args)),
                    class: "can-select",
                    onKeydown: _cache[11] || (_cache[11] = withKeys(withModifiers((...args) => _ctx.submitField && _ctx.submitField(...args), ["prevent"]), ["enter"])),
                    "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => _ctx.searchValue = $event),
                    ref: "lookupInput",
                    onFocusin: _cache[13] || (_cache[13] = (...args) => $options.focused && $options.focused(...args)),
                    type: "text",
                    onInput: _cache[14] || (_cache[14] = ($event) => $options.textInputEvent($event))
                  }, null, 544), [
                    [vModelText, _ctx.searchValue]
                  ])
                ])
              ])
            ])) : createCommentVNode("", true),
            _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-shortcode-display-mode") == false ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
              createBaseVNode("div", _hoisted_34$1, [
                (openBlock(true), createElementBlock(Fragment, null, renderList($options.complexLookupValues, (avl, idx) => {
                  return openBlock(), createElementBlock("div", _hoisted_35$1, [
                    createBaseVNode("div", _hoisted_36$1, [
                      avl.type ? (openBlock(), createBlock(_component_AuthTypeIcon, {
                        key: 0,
                        passClass: "complex-lookup-inline",
                        type: avl.type
                      }, null, 8, ["type"])) : createCommentVNode("", true)
                    ]),
                    createBaseVNode("div", _hoisted_37$1, [
                      !avl.needsDereference ? (openBlock(), createElementBlock("span", _hoisted_38$1, [
                        createTextVNode(toDisplayString$2(avl.label), 1),
                        avl.isLiteral ? (openBlock(), createElementBlock("span", _hoisted_39$1, "(uncontrolled)")) : createCommentVNode("", true),
                        !avl.isLiteral ? (openBlock(), createElementBlock("span", _hoisted_40$1)) : createCommentVNode("", true)
                      ])) : (openBlock(), createElementBlock("span", _hoisted_41$1, [
                        createVNode(_component_LabelDereference, {
                          URI: avl.URI
                        }, null, 8, ["URI"]),
                        !avl.isLiteral ? (openBlock(), createElementBlock("span", _hoisted_42$1, _hoisted_44$1)) : createCommentVNode("", true)
                      ]))
                    ]),
                    createBaseVNode("div", _hoisted_45, [
                      createBaseVNode("span", {
                        onClick: ($event) => $options.removeValue(idx),
                        style: { "border-left": "solid 1px black", "padding": "0 0.5em", "font-size": "1em", "cursor": "pointer" }
                      }, "x", 8, _hoisted_46)
                    ])
                  ]);
                }), 256))
              ]),
              createBaseVNode("div", _hoisted_47, [
                withDirectives(createBaseVNode("input", {
                  onKeydown: _cache[15] || (_cache[15] = withKeys(withModifiers((...args) => _ctx.submitField && _ctx.submitField(...args), ["prevent"]), ["enter"])),
                  onKeyup: _cache[16] || (_cache[16] = (...args) => $options.navKey && $options.navKey(...args)),
                  class: "can-select",
                  "onUpdate:modelValue": _cache[17] || (_cache[17] = ($event) => _ctx.searchValue = $event),
                  ref: "lookupInput",
                  onFocusin: _cache[18] || (_cache[18] = (...args) => $options.focused && $options.focused(...args)),
                  type: "text",
                  onInput: _cache[19] || (_cache[19] = ($event) => $options.textInputEvent($event))
                }, null, 544), [
                  [vModelText, _ctx.searchValue]
                ])
              ])
            ], 64)) : createCommentVNode("", true),
            createVNode(Transition, { name: "action" }, {
              default: withCtx(() => [
                _ctx.showActionButton && $options.myGuid == _ctx.activeField ? (openBlock(), createElementBlock("div", _hoisted_48, [
                  createVNode(_component_action_button, {
                    type: "lookupComplex",
                    guid: $props.guid,
                    onActionButtonCommand: $options.actionButtonCommand
                  }, null, 8, ["guid", "onActionButtonCommand"])
                ])) : createCommentVNode("", true)
              ]),
              _: 1
            })
          ])
        ], 32)),
        createVNode(_component_ComplexLookupModal, {
          ref: "complexLookupModal",
          searchValue: _ctx.searchValue,
          onEmitComplexValue: $options.setComplexValue,
          onHideComplexModal: _cache[22] || (_cache[22] = ($event) => {
            _ctx.searchValue = "";
            _ctx.displayModal = false;
          }),
          structure: $props.structure,
          modelValue: _ctx.displayModal,
          "onUpdate:modelValue": _cache[23] || (_cache[23] = ($event) => _ctx.displayModal = $event)
        }, null, 8, ["searchValue", "onEmitComplexValue", "structure", "modelValue"]),
        createVNode(_component_SubjectEditor, {
          ref: "subjectEditorModal",
          searchValue: _ctx.searchValue,
          onSubjectAdded: $options.subjectAdded,
          onHideSubjectModal: _cache[24] || (_cache[24] = ($event) => $options.hideSubjectModal()),
          structure: $props.structure,
          modelValue: _ctx.displaySubjectModal,
          "onUpdate:modelValue": _cache[25] || (_cache[25] = ($event) => _ctx.displaySubjectModal = $event)
        }, null, 8, ["searchValue", "onSubjectAdded", "structure", "modelValue"])
      ], 64);
    }
    const LookupComplex = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3], ["__scopeId", "data-v-9989523c"]]);
    const _sfc_main$2 = {
      name: "LookupSimple",
      props: {
        structure: Object,
        level: Number,
        nested: Boolean,
        propertyPath: Array,
        guid: String
        // parentStructure: Array,
        // isMini: Boolean,
        // profileName: String,
        // activeTemplate: Object,
        // parentStructureObj: Object,
        // profileCompoent: String,
        // bnodeProperty: String,
      },
      components: {
        ActionButton,
        LabelDereference
        // EditLabelRemark
      },
      data: function() {
        return {
          showActionButton: false,
          // helps populate the autocomplete list
          displayAutocomplete: false,
          displayList: [],
          activeSelect: "",
          activeKeyword: false,
          uri: this.structure.valueConstraint.useValuesFrom[0],
          debounceTimeout: null,
          doubleDelete: false,
          // activeLookupValue: [],
          // stores the guid to the place to add more if there is already a value
          // displayAutocomplete: false,
          // 
          // 
          // activeFilter: '',
          // 
          activeValue: ""
          // 
          // internalAssignID:false,
        };
      },
      watch: {
        // // watch when the undoindex changes, means they are undoing redoing, so refresh the
        // // value in the acutal input box
        // undoCounter: function(){
        //   this.refreshInputDisplay()
        // }
      },
      created: function() {
      },
      computed: {
        // other computed properties
        // ...
        // gives access to this.counterStore and this.userStore
        ...mapStores(useProfileStore),
        ...mapStores(usePreferenceStore),
        ...mapWritableState(useProfileStore, ["activeField", "activeProfile"]),
        simpleLookupValues() {
          let values = this.profileStore.returnSimpleLookupValueFromProfile(this.guid, this.propertyPath);
          return values;
        },
        // if there is already a value we just need one of them so we can find its parent to put new ones into
        existingGuid() {
          let values = this.profileStore.returnSimpleLookupValueFromProfile(this.guid, this.propertyPath);
          if (values && values[0] && values[0]["@guid"]) {
            return values[0]["@guid"];
          }
          return null;
        },
        myGuid() {
          return `${this.structure["@guid"]}--${this.guid}`;
        },
        inlineModeShouldDisplay() {
          if (this.profileStore.inlinePropertyHasValue(this.guid, this.structure, this.propertyPath)) {
            return true;
          } else if (this.profileStore.inlineFieldIsToggledForDisplay(this.guid, this.structure)) {
            return true;
          } else {
            if (this.profileStore.inlineIsMainProperty(this.guid, this.structure, this.propertyPath)) {
              return true;
            }
          }
          return false;
        }
      },
      // computed: mapState({
      //   lookupLibrary: 'lookupLibrary',
      //   activeInput: 'activeInput',
      //   activeProfile: 'activeProfile',
      //   activeProfileMini: 'activeProfileMini',
      //   workingOnMiniProfile: 'workingOnMiniProfile',
      //   settingsDisplayMode: 'settingsDisplayMode',
      //   undoCounter: 'undoCounter',
      //   assignedId (){
      //     // return uiUtils.assignID(this.structure,this.parentStructure)
      //     if (this.internalAssignID){
      //       return this.internalAssignID
      //     }else{
      //       this.internalAssignID = uiUtils.assignID(this.structure,this.parentStructure)
      //       return this.internalAssignID
      //     }     
      //   },  
      //   // to access local state with `this`, a normal function must be used
      //   lookupVocab (state) {
      //     // let uri = this.structure.valueConstraint.useValuesFrom[0]
      //     // let returnVal = []
      //     // Object.keys(state.lookupLibrary).forEach((s)=>{
      //     // })
      //     // if (state.lookupLibrary[this.structure.valueConstraint.useValuesFrom[0]]){
      //     //   return state.lookupLibrary[this.structure.valueConstraint.useValuesFrom[0]]
      //     // }else{
      //     //   return []
      //     // }
      //     return state.lookupLibrary[this.structure.valueConstraint.useValuesFrom[0]]
      //   }
      // }),  
      methods: {
        focusClick: function() {
          this.$refs.lookupInput.focus();
        },
        focused: function() {
          this.activeField = this.myGuid;
          if (this.preferenceStore.returnValue("--b-edit-general-action-button-display")) {
            this.showActionButton = true;
          } else {
            this.showActionButton = false;
          }
          utilsNetwork.loadSimpleLookup(this.uri);
        },
        actionButtonCommand: function(cmd) {
          this.$refs.input.focus();
          console.log(this.$refs.input);
        },
        // Takes the list of values from this lookup uri and filters it based on the input
        filter: async function(recursive) {
          this.displayList = [];
          this.activeSelect = "";
          this.activeKeyword = false;
          let addKeyword = "";
          if (recursive) {
            addKeyword = "KEYWORD";
            this.activeKeyword = true;
          }
          console.log(this.uri);
          console.log(utilsNetwork.lookupLibrary);
          console.log(utilsNetwork.lookupLibrary[this.uri + addKeyword]);
          if (!utilsNetwork.lookupLibrary[this.uri + addKeyword]) {
            this.activeValue = "🙀ERROR WITH LOOKUP";
          }
          Object.keys(utilsNetwork.lookupLibrary[this.uri + addKeyword]).forEach((v2) => {
            console.log(v2);
            if (v2 === "metadata") {
              return false;
            }
            if (this.activeFilter.trim() === "") {
              utilsNetwork.lookupLibrary[this.uri + addKeyword][v2].forEach((x2) => {
                console.log(x2);
                if (this.displayList.indexOf(x2) == -1) {
                  this.displayList.push(x2);
                }
              });
            } else {
              utilsNetwork.lookupLibrary[this.uri + addKeyword][v2].forEach((x2) => {
                if (x2.toLowerCase().startsWith(this.activeFilter.toLowerCase())) {
                  if (this.displayList.indexOf(x2) == -1) {
                    this.displayList.push(x2);
                  }
                }
                if (x2.toLowerCase().includes(" (" + this.activeFilter.toLowerCase())) {
                  if (this.displayList.indexOf(x2) == -1) {
                    this.displayList.push(x2);
                  }
                }
              });
            }
          });
          console.log("this.activeFilter", this.activeFilter);
          this.displayList = this.displayList.filter((v2) => {
            return v2 === "Englisch (eng)" ? false : true;
          });
          console.log("this.displayList", this.displayList);
          this.displayList.sort();
          if (this.displayList.length > 0 && this.activeFilter.length > 0) {
            this.activeSelect = this.displayList[0];
            this.displayAutocomplete = true;
          }
          if (this.displayList.length == 0) {
            if (!recursive) {
              if (this.uri.includes("id.loc.gov/vocabulary/")) {
                if (this.activeFilter.length > 3) {
                  this.displayList.push("Searching...");
                  window.clearTimeout(this.debounceTimeout);
                  this.debounceTimeout = window.setTimeout(async () => {
                    await utilsNetwork.loadSimpleLookupKeyword(this.structure.valueConstraint.useValuesFrom, this.activeFilter);
                    this.filter(true);
                  }, 500);
                } else {
                  this.displayList.push("No local match, enter more of the search term");
                }
              }
            } else {
              this.displayList.push("No Match - Press [Enter] to add uncontrolled value");
            }
            this.displayAutocomplete = true;
          }
          if (this.activeFilter.length == 0) {
            this.displayAutocomplete = true;
          }
          console.log(this.displayAutocomplete);
          if (this.displayAutocomplete)
            ;
        },
        keyUpEvent: function(event2) {
          if (event2 && event2.key && (event2.key !== "ArrowUp" && event2.key !== "ArrowDown" && event2.key !== "Escape" && event2.key !== "Backspace" && event2.key !== "Enter" && event2.key !== "PageUp" && event2.key !== "PageDown" && event2.ctrlKey == false)) {
            this.activeValue = event2.target.value.trimStart();
            this.doubleDelete = false;
            this.activeValue = event2.target.value.trimStart();
            this.activeFilter = event2.target.value.trimStart();
            this.displayAutocomplete = true;
            this.filter();
          } else if (event2 && event2.key && event2.key === "Backspace") {
            if (!this.doubleDelete && this.activeValue === "") {
              this.doubleDelete = true;
              return false;
            }
            if (this.activeValue == "" && this.doubleDelete) {
              this.doubleDelete = false;
              if (this.simpleLookupValues.length > 0) {
                this.removeValue(-1);
              }
              this.doubleDelete = false;
              this.displayAutocomplete = false;
            } else if (this.activeValue == "") {
              this.activeValue;
            }
            this.doubleDelete = false;
            this.activeValue = event2.target.value.trimStart();
            this.activeFilter = event2.target.value.trimStart();
            this.displayAutocomplete = true;
            this.filter();
          }
          if (event2 && event2.code === "ArrowUp" && this.displayAutocomplete == false) {
            utilsMisc.globalNav("up", event2.target);
          }
          if (event2 && event2.code === "ArrowDown" && this.displayAutocomplete == false) {
            utilsMisc.globalNav("down", event2.target);
          }
        },
        keyDownEvent: function(event2, reposLeft) {
          if (reposLeft) {
            this.findSelectListTime = window.setInterval(() => {
              if (this.$refs.selectlist && this.$refs.selectlist.style) {
                window.clearTimeout(this.findSelectListTime);
                console.log(this.$refs.selectlist);
                var rect = event2.target.getBoundingClientRect();
                console.log(rect.top, rect.right, rect.bottom, rect.left);
                this.$refs.selectlist.style.left = rect.left + "px";
              }
            }, 100);
          }
          this.activeValue = event2.target.value;
          if (event2 && event2.key && this.displayAutocomplete == true && (event2.key === "ArrowUp" || event2.key === "ArrowDown")) {
            this.doubleDelete = false;
            if (this.displayList.length <= 1) {
              return false;
            }
            if (!this.displayAutocomplete)
              this.displayAutocomplete = true;
            this.activeFilter = "";
            this.activeValue = "";
            if (this.activeSelect.trim() == "" && this.displayList.length > 0) {
              this.activeSelect = this.displayList[0];
              this.activeValue = this.displayList[0];
            } else {
              for (let step = 0; step < this.displayList.length; step++) {
                if (this.displayList[step] === this.activeSelect) {
                  if (event2.key === "ArrowDown") {
                    if (step + 1 < this.displayList.length) {
                      this.activeSelect = this.displayList[step + 1];
                      this.activeValue = this.displayList[step + 1];
                      break;
                    }
                  }
                  if (event2.key === "ArrowUp") {
                    if (step - 1 >= 0) {
                      this.activeSelect = this.displayList[step - 1];
                      this.activeValue = this.displayList[step - 1];
                      break;
                    }
                  }
                }
              }
            }
            return false;
          } else if (event2 && event2.key && event2.key === "Escape") {
            this.doubleDelete = false;
            this.activeFilter = "";
            this.activeValue = "";
            this.displayAutocomplete = false;
          } else if (event2 && event2.key && event2.key === "Enter") {
            this.doubleDelete = false;
            let metadata = utilsNetwork.lookupLibrary[this.uri].metadata.values;
            if (this.activeKeyword) {
              metadata = utilsNetwork.lookupLibrary[this.uri + "KEYWORD"].metadata.values;
            }
            Object.keys(metadata).forEach((key2) => {
              let idx = metadata[key2].displayLabel.indexOf(this.activeSelect);
              if (idx == -1) {
                idx = metadata[key2].displayLabel.indexOf(this.activeSelect.replace(/\s+/g, " "));
              }
              if (idx > -1) {
                this.activeFilter = "";
                this.activeValue = "";
                this.activeSelect = "";
                this.displayAutocomplete = false;
                event2.target.value = "";
                let useLabel = metadata[key2].authLabel ? metadata[key2].authLabel : metadata[key2].label[idx];
                this.profileStore.setValueSimple(this.guid, this.existingGuid, this.propertyPath, metadata[key2].uri, useLabel);
              }
            });
            if (event2.target.value !== "") {
              this.activeFilter = "";
              this.activeValue = "";
              this.activeSelect = "";
              this.displayAutocomplete = false;
              this.profileStore.setValueSimple(this.guid, this.existingGuid, this.propertyPath, null, event2.target.value);
            }
            event2.preventDefault();
          } else if (event2.target.value == "") {
            this.activeFilter = "";
            this.activeValue = "";
            this.activeSelect = "";
            this.displayAutocomplete = false;
          }
          if (this.displayAutocomplete)
            ;
        },
        removeValue: function(idx) {
          if (idx === -1) {
            idx = this.simpleLookupValues.length - 1;
          }
          let removeGuid = this.simpleLookupValues[idx]["@guid"];
          console.log(removeGuid);
          this.profileStore.removeValueSimple(this.guid, removeGuid);
        },
        // refreshInputDisplay: function(){
        //   this.activeLookupValue = []
        //   let userValue
        //   if (this.isMini){
        //     userValue = this.activeProfileMini.rt[this.profileName].pt[this.profileCompoent].userValue
        //   }else{
        //     userValue = this.activeProfile.rt[this.profileName].pt[this.profileCompoent].userValue  
        //   }
        //   // get the length of the properties, for our case we can filter out sameAs properties
        //   // as in simple lookups they are place holders and don't really need to be accounted for in the hierearchy of the properties
        //   let propertyPathLength = this.propertyPath.filter((p)=>{ return (p.propertyURI != 'http://www.w3.org/2002/07/owl#sameAs') ? true : false }).length     
        //   let possibleLiteralProperties = ['http://www.w3.org/1999/02/22-rdf-syntax-ns#value', 'http://www.w3.org/2000/01/rdf-schema#label', 'http://id.loc.gov/ontologies/bibframe/code','http://www.loc.gov/mads/rdf/v1#authoritativeLabel']
        //   // filter out any bnodes with that guid starting from the bottom of the hiearchy
        //   // then go through and check if we left an empty bnode hiearchy and if so delete it
        //   if (propertyPathLength==4){
        //       let L0URI = this.propertyPath[0].propertyURI
        //       let L1URI = this.propertyPath[1].propertyURI
        //       let L2URI = this.propertyPath[2].propertyURI
        //       let L3URI = this.propertyPath[3].propertyURI
        //       if (userValue[L0URI] && userValue[L0URI][0] && userValue[L0URI][0][L1URI] && userValue[L0URI][0][L1URI][0] && userValue[L0URI][0][L1URI][0][L2URI] && userValue[L0URI][0][L1URI][0][L2URI][0] && userValue[L0URI][0][L1URI][0][L2URI][0][L3URI]){
        //         for (let v of userValue[L0URI][0][L1URI][0][L2URI][0][L3URI]){
        //           let label = null 
        //           let labelGuid = null
        //           let uri = null
        //           let uriGuid = null 
        //           for (let aKey in v){
        //             if (v['@id']){
        //               uri = v['@id']
        //               uriGuid = v['@guid']
        //             }
        //             if (possibleLiteralProperties.indexOf(aKey)>-1){
        //               if (v[aKey] && v[aKey][0][aKey]){
        //                 label = v[aKey][0][aKey]
        //                 labelGuid = v['@guid']
        //               }
        //               if (v[aKey] && v[aKey][0]['@id']){
        //                 uri = v[aKey][0]['@id']
        //                 // if the URI is stored at this level, we still want to point to the parent's guid
        //                 uriGuid = v['@guid']
        //               }
        //             }
        //           }
        //           if (!label){
        //             // no label was found, just use the URI and it will get dereferenced by the componet
        //             if (uri){
        //               label = uri
        //             }
        //           }
        //           this.activeLookupValue.push({
        //             'http://www.w3.org/2000/01/rdf-schema#label' : label,
        //             uri : uri,
        //             uriGuid: uriGuid,
        //             labelGuid: labelGuid
        //           })
        //         }
        //       }
        //   }
        //   if (propertyPathLength==3){
        //       let L0URI = this.propertyPath[0].propertyURI
        //       let L1URI = this.propertyPath[1].propertyURI
        //       let L2URI = this.propertyPath[2].propertyURI
        //       if (userValue[L0URI] && userValue[L0URI][0] && userValue[L0URI][0][L1URI] && userValue[L0URI][0][L1URI][0] && userValue[L0URI][0][L1URI][0][L2URI]){
        //         for (let v of userValue[L0URI][0][L1URI][0][L2URI]){
        //           let label = null 
        //           let labelGuid = null
        //           let uri = null
        //           let uriGuid = null 
        //           for (let aKey in v){
        //             if (v['@id']){
        //               uri = v['@id']
        //               uriGuid = v['@guid']
        //             }
        //             if (possibleLiteralProperties.indexOf(aKey)>-1){
        //               if (v[aKey] && v[aKey][0][aKey]){
        //                 label = v[aKey][0][aKey]
        //                 labelGuid = v['@guid']
        //               }
        //               if (v[aKey] && v[aKey][0]['@id']){
        //                 uri = v[aKey][0]['@id']
        //                 // if the URI is stored at this level, we still want to point to the parent's guid
        //                 uriGuid = v['@guid']
        //               }
        //             }
        //           }
        //           if (!label){
        //             // no label was found, just use the URI and it will get dereferenced by the componet
        //             if (uri){
        //               label = uri
        //             }
        //           }
        //           this.activeLookupValue.push({
        //             'http://www.w3.org/2000/01/rdf-schema#label' : label,
        //             uri : uri,
        //             uriGuid: uriGuid,
        //             labelGuid: labelGuid
        //           })
        //         }
        //       }
        //   }
        //   if (propertyPathLength==2){
        //       let L0URI = this.propertyPath[0].propertyURI
        //       let L1URI = this.propertyPath[1].propertyURI
        //       if (userValue[L0URI] && userValue[L0URI][0] && userValue[L0URI][0][L1URI]){
        //         for (let v of userValue[L0URI][0][L1URI]){
        //           let label = null 
        //           let labelGuid = null
        //           let uri = null
        //           let uriGuid = null 
        //           for (let aKey in v){
        //             if (v['@id']){
        //               uri = v['@id']
        //               uriGuid = v['@guid']
        //             }
        //             if (possibleLiteralProperties.indexOf(aKey)>-1){
        //               if (v[aKey] && v[aKey][0][aKey]){
        //                 label = v[aKey][0][aKey]
        //                 labelGuid = v['@guid']
        //               }
        //               if (v[aKey] && v[aKey][0]['@id']){
        //                 uri = v[aKey][0]['@id']
        //                 // if the URI is stored at this level, we still want to point to the parent's guid
        //                 uriGuid = v['@guid']
        //               }
        //             }
        //           }
        //           if (!label){
        //             // no label was found, just use the URI and it will get dereferenced by the componet
        //             if (uri){
        //               label = uri
        //             }
        //           }
        //           this.activeLookupValue.push({
        //             'http://www.w3.org/2000/01/rdf-schema#label' : label,
        //             uri : uri,
        //             uriGuid: uriGuid,
        //             labelGuid: labelGuid
        //           })
        //         }
        //       }
        //   }
        //   if (propertyPathLength==1){
        //       let L0URI = this.propertyPath[0].propertyURI
        //       console.log("!!!!!! HERE", L0URI, userValue,userValue[L0URI])
        //       if (userValue[L0URI]){
        //         for (let v of userValue[L0URI]){
        //           let label = null 
        //           let labelGuid = null
        //           let uri = null
        //           let uriGuid = null 
        //           for (let aKey in v){
        //             if (v['@id']){
        //               uri = v['@id']
        //               uriGuid = v['@guid']
        //             }
        //             if (possibleLiteralProperties.indexOf(aKey)>-1){
        //               if (v[aKey] && v[aKey][0][aKey]){
        //                 label = v[aKey][0][aKey]
        //                 labelGuid = v['@guid']
        //               }
        //               if (v[aKey] && v[aKey][0]['@id']){
        //                 uri = v[aKey][0]['@id']
        //                 // if the URI is stored at this level, we still want to point to the parent's guid
        //                 uriGuid = v['@guid']
        //               }
        //             }
        //           }
        //           if (!label){
        //             // no label was found, just use the URI and it will get dereferenced by the componet
        //             if (uri){
        //               label = uri
        //             }
        //           }
        //           if (label !== null || uri !== null){
        //             this.activeLookupValue.push({
        //               'http://www.w3.org/2000/01/rdf-schema#label' : label,
        //               uri : uri,
        //               uriGuid: uriGuid,
        //               labelGuid: labelGuid
        //             })
        //           }
        //         }
        //       }
        //   }
        // },
        // fakeContainerFocus: function(event){
        //     // 
        //     return event
        // },
        // removeValue: function(idx){
        //   let toRemove = this.activeLookupValue.splice(idx,1)
        //   toRemove = toRemove[0]
        //   // TODO unhack this, put it in the tempalte or put it in the config :(
        //   if (this.structure.valueConstraint && this.structure.valueConstraint.defaults && this.structure.valueConstraint.defaults[0] && this.structure.valueConstraint.defaults[0].defaultURI && this.structure.valueConstraint.defaults[0].defaultURI === 'http://id.loc.gov/ontologies/bibframe/hasSeries'){
        //     this.refreshInputDisplay()
        //     return false
        //   }
        //   this.$store.dispatch("removeValueSimple", { self: this, ptGuid: this.ptGuid, idGuid: toRemove.uriGuid, labelGuid: toRemove.labelGuid, propertyPath: this.propertyPath }).then(() => {
        //     this.$refs.lookupInput.focus()
        //   })  
        //   // if (this.activeLookupValue.length>1){
        //   //   this.activeLookupValue.splice(-1,1)
        //   // }else{
        //   //   this.activeLookupValue = []
        //   // }
        // },  
        // autoFocus: function(event){
        //   // let the rest of the app know what is the active input right now
        //   this.$store.dispatch("setActiveInput", { self: this, id: event.target.id, profileCompoent: this.profileCompoent, profileName: this.profileName }).then(()=>{
        //     // now focus the side bars
        //     this.$nextTick(()=>{
        //       uiUtils.focusSidebars()
        //     })
        //   })
        //   // assing the input value to the filter value
        //   this.activeFilter = event.target.value;
        //   // tell the store to load this specific lookup table into memory
        //   this.$store.dispatch("fetchLookupValues", { self: this, url: this.structure.valueConstraint.useValuesFrom[0] }).then(() => {
        //     this.uri = this.structure.valueConstraint.useValuesFrom[0]
        //     // if there is already a value don't open up the full list, they can type ahead but dont open everything
        //     // if (this.activeLookupValue.length==0){
        //       // this.filter()
        //     // }
        //   })    
        // },
        // blur: function(){
        //  // we want to hide the menu on deblur but not if they just click an item in the list
        //  this.$store.dispatch("enableMacroNav") 
        //  setTimeout(()=>{ 
        //   this.displayAutocomplete=false 
        // },500)
        // },
        clickAdd: function(item) {
          this.displayAutocomplete = false;
          console.log(item);
          this.activeSelect = item;
          let metadata = utilsNetwork.lookupLibrary[this.uri].metadata.values;
          if (this.activeKeyword) {
            metadata = utilsNetwork.lookupLibrary[this.uri + "KEYWORD"].metadata.values;
          }
          console.log(metadata);
          Object.keys(metadata).forEach((key2) => {
            let idx = metadata[key2].displayLabel.indexOf(this.activeSelect);
            if (idx > -1) {
              this.activeFilter = "";
              this.activeValue = "";
              this.activeSelect = "";
              this.displayAutocomplete = false;
              event.target.value = "";
              let useLabel = metadata[key2].authLabel ? metadata[key2].authLabel : metadata[key2].label[idx];
              this.profileStore.setValueSimple(this.guid, this.existingGuid, this.propertyPath, metadata[key2].uri, useLabel);
              this.$refs.lookupInput.focus();
            }
          });
        }
        // clickAdd: function(event){
        //   this.displayAutocomplete=false
        //   if (event && event.target && event.target.innerText){
        //     this.activeSelect = event.target.innerText
        //   }
        //   let metadata = utilsNetwork.lookupLibrary[this.uri].metadata.values
        //   if (this.activeKeyword){
        //     metadata = utilsNetwork.lookupLibrary[this.uri+'KEYWORD'].metadata.values          
        //   }
        //   // find the active selected in the data
        //   Object.keys(metadata).forEach((key)=>{
        //     let idx = metadata[key].displayLabel.indexOf(this.activeSelect)
        //     if (idx >-1){
        //       // this.activeLookupValue.push({'http://www.w3.org/2000/01/rdf-schema#label':metadata[key].label[idx],URI:metadata[key].uri})
        //       this.activeFilter = ''
        //       this.activeValue = ''
        //       this.activeSelect = ''
        //       this.displayAutocomplete=false
        //       event.target.value = ''     
        //       // let parentURI = (this.parentStructureObj) ? this.parentStructureObj.propertyURI : null 
        //       let useLabel = (metadata[key].authLabel) ? metadata[key].authLabel : metadata[key].label[idx]
        //       this.$store.dispatch("setValueSimple", { self: this, ptGuid: this.ptGuid, propertyPath: this.propertyPath, valueURI: metadata[key].uri, valueLabel:useLabel}).then((resultData) => {
        //         this.activeLookupValue.push({'http://www.w3.org/2000/01/rdf-schema#label':resultData.valueLabel, uri: resultData.valueURI, uriGuid: resultData.guid, labelGuid:resultData.guid})
        //       })
        //     }
        //     // let data = utilsNetwork.lookupLibrary[this.uri].metadata[v]
        //     // let idx = data.defaultsisplayLabel.indexOf(this.activeSelect)
        //     // if (idx > -1){
        //     //   this.structure.valueConstraint.defaults.push({defaultLiteral:data.label[idx],defaultURI:data.uri[idx]})
        //     // }
        //   })
        //   // let label = this.displayList[event.target.dataset.idx]
        //   // let metadata = utilsNetwork.lookupLibrary[this.uri].metadata.values
        //   // // find the active selected in the data
        //   // Object.keys(metadata).forEach((key)=>{
        //   //   let idx = metadata[key].displayLabel.indexOf(label)
        //   //   if (idx >-1){
        //   //     // this.activeLookupValue.push({'http://www.w3.org/2000/01/rdf-schema#label':,URI:})
        //   //     // this.activeFilter = ''
        //   //     // this.activeValue = ''
        //   //     // this.activeSelect = ''
        //   //     // this.displayAutocomplete=false
        //   //     // // this.$store.dispatch("addValueLiteral", { self: this, profileComponet: this.profileCompoent, structure: this.structure, template:this.activeTemplate, value:this.activeLookupValue }).then(() => {
        //   //     // // })        
        //   //     // this.$store.dispatch("setValueSimple", { self: this, ptGuid: this.ptGuid, parentURI: this.parentStructureObj.propertyURI, URI: this.structure.propertyURI, valueURI: metadata[key].uri, valueLabel:metadata[key].label[idx]}).then((resultData) => {
        //   //     //   this.activeLookupValue.push({'http://www.w3.org/2000/01/rdf-schema#label':resultData.valueLabel, uri: resultData.valueURI, uriGuid: resultData.guid, labelGuid:resultData.guid})
        //   //     // })
        //   //     this.activeFilter = ''
        //   //     this.activeValue = ''
        //   //     this.activeSelect = ''
        //   //     this.displayAutocomplete=false
        //   //     event.target.value = ''
        //   //     // this.$store.dispatch("addValueLiteral", { self: this, profileComponet: this.profileCompoent, structure: this.structure, template:this.activeTemplate, value:this.activeLookupValue }).then(() => {
        //   //     // })               
        //   //     let parentURI = (this.parentStructureObj) ? this.parentStructureObj.propertyURI : null 
        //   //     this.$store.dispatch("setValueSimple", { self: this, ptGuid: this.ptGuid, parentURI: parentURI, URI: this.structure.propertyURI, valueURI: metadata[key].uri, valueLabel:metadata[key].label[idx]}).then((resultData) => {
        //   //       this.activeLookupValue.push({'http://www.w3.org/2000/01/rdf-schema#label':resultData.valueLabel, uri: resultData.valueURI, uriGuid: resultData.guid, labelGuid:resultData.guid})
        //   //     })
        //   //     this.$store.dispatch("enableMacroNav")    
        //   //   }
        //   // })
        //   // refocus
        //   this.$refs.lookupInput.focus()
        // },
        // submitField: uiUtils.globalMoveDown  
      }
    };
    const __injectCSSVars__$1 = () => {
      useCssVars((_ctx) => ({
        "841facc6": _ctx.preferenceStore.returnValue("--n-edit-main-splitpane-edit-show-field-labels-size")
      }));
    };
    const __setup__$1 = _sfc_main$2.setup;
    _sfc_main$2.setup = __setup__$1 ? (props, ctx) => {
      __injectCSSVars__$1();
      return __setup__$1(props, ctx);
    } : __injectCSSVars__$1;
    const _withScopeId = (n2) => (pushScopeId("data-v-89aa6b95"), n2 = n2(), popScopeId(), n2);
    const _hoisted_1$2 = ["title"];
    const _hoisted_2$1 = ["title"];
    const _hoisted_3$1 = {
      key: 0,
      style: {}
    };
    const _hoisted_4$1 = {
      key: 0,
      class: "uncontrolled"
    };
    const _hoisted_5$1 = {
      key: 1,
      style: {}
    };
    const _hoisted_6$1 = {
      key: 0,
      title: "Controlled Term",
      class: "selected-value-icon"
    };
    const _hoisted_7$1 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", { class: "material-icons check-mark" }, "check_circle_outline", -1));
    const _hoisted_8$1 = [
      _hoisted_7$1
    ];
    const _hoisted_9$1 = ["onClick"];
    const _hoisted_10$1 = {
      key: 0,
      class: "lookup-fake-input-label"
    };
    const _hoisted_11$1 = {
      key: 1,
      class: "bfcode-display-mode-holder"
    };
    const _hoisted_12$1 = ["title"];
    const _hoisted_13$1 = { class: "bfcode-display-mode-holder-value" };
    const _hoisted_14$1 = {
      class: "lookup-fake-input-entities",
      style: { "display": "inline-block" }
    };
    const _hoisted_15$1 = { class: "selected-value-container" };
    const _hoisted_16$1 = {
      key: 0,
      style: { "padding-right": "0.3em", "font-weight": "bold" }
    };
    const _hoisted_17 = {
      key: 0,
      class: "uncontrolled"
    };
    const _hoisted_18 = {
      key: 1,
      title: "Controlled Term",
      class: "selected-value-icon",
      style: {}
    };
    const _hoisted_19 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", { class: "material-icons check-mark" }, "check_circle_outline", -1));
    const _hoisted_20 = [
      _hoisted_19
    ];
    const _hoisted_21 = {
      key: 1,
      style: { "padding-right": "0.3em", "font-weight": "bold" }
    };
    const _hoisted_22 = {
      key: 0,
      title: "Controlled Term",
      class: "selected-value-icon"
    };
    const _hoisted_23 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", { class: "material-icons check-mark" }, "check_circle_outline", -1));
    const _hoisted_24 = [
      _hoisted_23
    ];
    const _hoisted_25 = ["onClick"];
    const _hoisted_26 = {
      class: "lookup-fake-input-text",
      style: { "display": "inline-block" }
    };
    const _hoisted_27 = { class: "lookup-fake-input-entities" };
    const _hoisted_28 = { class: "selected-value-container" };
    const _hoisted_29 = {
      key: 0,
      style: { "padding-right": "0.3em", "font-weight": "bold" }
    };
    const _hoisted_30 = {
      key: 0,
      class: "uncontrolled"
    };
    const _hoisted_31 = {
      key: 1,
      title: "Controlled Term",
      class: "selected-value-icon",
      style: {}
    };
    const _hoisted_32 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", { class: "material-icons check-mark" }, "check_circle_outline", -1));
    const _hoisted_33 = [
      _hoisted_32
    ];
    const _hoisted_34 = {
      key: 1,
      style: { "padding-right": "0.3em", "font-weight": "bold" }
    };
    const _hoisted_35 = {
      key: 0,
      title: "Controlled Term",
      class: "selected-value-icon"
    };
    const _hoisted_36 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", { class: "material-icons check-mark" }, "check_circle_outline", -1));
    const _hoisted_37 = [
      _hoisted_36
    ];
    const _hoisted_38 = ["onClick"];
    const _hoisted_39 = { class: "lookup-fake-input-text" };
    const _hoisted_40 = {
      key: 0,
      class: "lookup-action"
    };
    const _hoisted_41 = {
      key: 2,
      ref: "selectlist",
      class: "autocomplete-container"
    };
    const _hoisted_42 = ["data-idx", "onClick"];
    const _hoisted_43 = ["data-idx"];
    const _hoisted_44 = ["data-idx"];
    function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_LabelDereference = resolveComponent("LabelDereference");
      const _component_action_button = resolveComponent("action-button");
      return openBlock(), createElementBlock(Fragment, null, [
        _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-inline-mode") == true ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          $options.inlineModeShouldDisplay ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            $options.simpleLookupValues.length === 0 ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createBaseVNode("span", {
                class: "bfcode-display-mode-holder-label",
                title: $props.structure.propertyLabel
              }, toDisplayString$2(_ctx.profileStore.returnBfCodeLabel($props.structure)) + ":", 9, _hoisted_1$2),
              withDirectives(createBaseVNode("input", {
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.activeValue = $event),
                class: "inline-lookup-input can-select",
                ref: "lookupInput",
                onFocusin: _cache[1] || (_cache[1] = (...args) => $options.focused && $options.focused(...args)),
                type: "text",
                onKeydown: _cache[2] || (_cache[2] = ($event) => $options.keyDownEvent($event, true)),
                onKeyup: _cache[3] || (_cache[3] = ($event) => $options.keyUpEvent($event))
              }, null, 544), [
                [vModelText, _ctx.activeValue]
              ])
            ], 64)) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList($options.simpleLookupValues, (avl, idx) => {
              return openBlock(), createElementBlock(Fragment, null, [
                createBaseVNode("span", {
                  class: "bfcode-display-mode-holder-label",
                  title: $props.structure.propertyLabel
                }, toDisplayString$2(_ctx.profileStore.returnBfCodeLabel($props.structure)) + ":", 9, _hoisted_2$1),
                !avl.needsDereference ? (openBlock(), createElementBlock("span", _hoisted_3$1, [
                  createTextVNode(toDisplayString$2(avl.label) + " ", 1),
                  avl.isLiteral ? (openBlock(), createElementBlock("span", _hoisted_4$1, " (uncontrolled)")) : createCommentVNode("", true)
                ])) : (openBlock(), createElementBlock("span", _hoisted_5$1, [
                  createVNode(_component_LabelDereference, {
                    URI: avl.URI
                  }, null, 8, ["URI"]),
                  !avl.isLiteral ? (openBlock(), createElementBlock("span", _hoisted_6$1, _hoisted_8$1)) : createCommentVNode("", true)
                ])),
                createBaseVNode("a", {
                  href: "#",
                  class: "inline-remove-x",
                  onClick: ($event) => $options.removeValue(idx),
                  style: {}
                }, "x", 8, _hoisted_9$1)
              ], 64);
            }), 256))
          ], 64)) : createCommentVNode("", true)
        ], 64)) : (openBlock(), createElementBlock("form", {
          key: 1,
          autocomplete: "off",
          onSubmit: withModifiers(($event) => null, ["prevent"])
        }, [
          createBaseVNode("div", {
            class: "lookup-fake-input",
            onClick: _cache[12] || (_cache[12] = ($event) => $options.focusClick())
          }, [
            _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-shortcode-display-mode") == false ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-show-field-labels") && $options.simpleLookupValues.length == 0 ? (openBlock(), createElementBlock("div", _hoisted_10$1, toDisplayString$2($props.structure.propertyLabel), 1)) : createCommentVNode("", true)
            ], 64)) : createCommentVNode("", true),
            _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-shortcode-display-mode") == true ? (openBlock(), createElementBlock("div", _hoisted_11$1, [
              createBaseVNode("div", {
                class: "bfcode-display-mode-holder-label",
                title: $props.structure.propertyLabel
              }, toDisplayString$2(_ctx.profileStore.returnBfCodeLabel($props.structure)), 9, _hoisted_12$1),
              createBaseVNode("div", _hoisted_13$1, [
                createBaseVNode("div", _hoisted_14$1, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList($options.simpleLookupValues, (avl, idx) => {
                    return openBlock(), createElementBlock("div", _hoisted_15$1, [
                      !avl.needsDereference ? (openBlock(), createElementBlock("span", _hoisted_16$1, [
                        createTextVNode(toDisplayString$2(avl.label), 1),
                        avl.isLiteral ? (openBlock(), createElementBlock("span", _hoisted_17, "(uncontrolled)")) : createCommentVNode("", true),
                        !avl.isLiteral ? (openBlock(), createElementBlock("span", _hoisted_18, _hoisted_20)) : createCommentVNode("", true)
                      ])) : (openBlock(), createElementBlock("span", _hoisted_21, [
                        createVNode(_component_LabelDereference, {
                          URI: avl.URI
                        }, null, 8, ["URI"]),
                        !avl.isLiteral ? (openBlock(), createElementBlock("span", _hoisted_22, _hoisted_24)) : createCommentVNode("", true)
                      ])),
                      createBaseVNode("span", {
                        onClick: ($event) => $options.removeValue(idx),
                        style: { "border-left": "solid 1px black", "padding": "0 0.5em", "font-size": "1em", "cursor": "pointer" }
                      }, "x", 8, _hoisted_25)
                    ]);
                  }), 256))
                ]),
                createBaseVNode("div", _hoisted_26, [
                  withDirectives(createBaseVNode("input", {
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.activeValue = $event),
                    class: "can-select",
                    ref: "lookupInput",
                    onFocusin: _cache[5] || (_cache[5] = (...args) => $options.focused && $options.focused(...args)),
                    type: "text",
                    onKeydown: _cache[6] || (_cache[6] = ($event) => $options.keyDownEvent($event)),
                    onKeyup: _cache[7] || (_cache[7] = ($event) => $options.keyUpEvent($event))
                  }, null, 544), [
                    [vModelText, _ctx.activeValue]
                  ])
                ])
              ])
            ])) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
              createBaseVNode("div", _hoisted_27, [
                (openBlock(true), createElementBlock(Fragment, null, renderList($options.simpleLookupValues, (avl, idx) => {
                  return openBlock(), createElementBlock("div", _hoisted_28, [
                    !avl.needsDereference ? (openBlock(), createElementBlock("span", _hoisted_29, [
                      createTextVNode(toDisplayString$2(avl.label), 1),
                      avl.isLiteral ? (openBlock(), createElementBlock("span", _hoisted_30, "(uncontrolled)")) : createCommentVNode("", true),
                      !avl.isLiteral ? (openBlock(), createElementBlock("span", _hoisted_31, _hoisted_33)) : createCommentVNode("", true)
                    ])) : (openBlock(), createElementBlock("span", _hoisted_34, [
                      createVNode(_component_LabelDereference, {
                        URI: avl.URI
                      }, null, 8, ["URI"]),
                      !avl.isLiteral ? (openBlock(), createElementBlock("span", _hoisted_35, _hoisted_37)) : createCommentVNode("", true)
                    ])),
                    createBaseVNode("span", {
                      onClick: ($event) => $options.removeValue(idx),
                      style: { "border-left": "solid 1px black", "padding": "0 0.5em", "font-size": "1em", "cursor": "pointer" }
                    }, "x", 8, _hoisted_38)
                  ]);
                }), 256))
              ]),
              createBaseVNode("div", _hoisted_39, [
                withDirectives(createBaseVNode("input", {
                  "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => _ctx.activeValue = $event),
                  class: "can-select",
                  ref: "lookupInput",
                  onFocusin: _cache[9] || (_cache[9] = (...args) => $options.focused && $options.focused(...args)),
                  type: "text",
                  onKeydown: _cache[10] || (_cache[10] = ($event) => $options.keyDownEvent($event)),
                  onKeyup: _cache[11] || (_cache[11] = ($event) => $options.keyUpEvent($event))
                }, null, 544), [
                  [vModelText, _ctx.activeValue]
                ])
              ])
            ], 64)),
            createVNode(Transition, { name: "action" }, {
              default: withCtx(() => [
                _ctx.showActionButton && $options.myGuid == _ctx.activeField ? (openBlock(), createElementBlock("div", _hoisted_40, [
                  createVNode(_component_action_button, {
                    type: "lookupSimple",
                    guid: $props.guid,
                    onActionButtonCommand: $options.actionButtonCommand
                  }, null, 8, ["guid", "onActionButtonCommand"])
                ])) : createCommentVNode("", true)
              ]),
              _: 1
            })
          ])
        ], 32)),
        _ctx.displayAutocomplete == true ? (openBlock(), createElementBlock("div", _hoisted_41, [
          createBaseVNode("ul", null, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.displayList, (item, idx) => {
              return openBlock(), createElementBlock("li", {
                "data-idx": idx,
                key: idx,
                onClick: ($event) => $options.clickAdd(item)
              }, [
                item == _ctx.activeSelect ? (openBlock(), createElementBlock("span", {
                  key: 0,
                  "data-idx": idx,
                  class: "selected"
                }, toDisplayString$2(item), 9, _hoisted_43)) : (openBlock(), createElementBlock("span", {
                  key: 1,
                  "data-idx": idx
                }, toDisplayString$2(item), 9, _hoisted_44))
              ], 8, _hoisted_42);
            }), 128))
          ])
        ], 512)) : createCommentVNode("", true)
      ], 64);
    }
    const LookupSimple = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2], ["__scopeId", "data-v-89aa6b95"]]);
    const _sfc_main$1 = {
      name: "Literal",
      components: {
        ActionButton
        // EditLiteralEditor,
        // EditLabelRemark,
        // Keypress: () => import('vue-keypress')    
      },
      props: {
        guid: String,
        nested: Boolean,
        propertyPath: Array,
        level: Number,
        structure: Object
        // structure: Object,
        // parentStructure: Array,
        // parentStructureObj: Object,
        // profileCompoent: String,
        // profileName: String,
        // activeTemplate: Object,
        // parentURI: String,
        // nested: Boolean,
        // isMini: Boolean,
        // ptGuid: String,
        // level: Number,
        // propertyPath: Array
      },
      methods: {
        inlineEmptyFocus: function(event2) {
          if (event2.target.innerText.trim() === "") {
            event2.target.innerText = "";
          }
        },
        navKey: function(event2) {
          if (event2 && event2.code === "ArrowUp") {
            utilsMisc.globalNav("up", event2.target);
          }
          if (event2 && event2.code === "ArrowDown") {
            utilsMisc.globalNav("down", event2.target);
          }
        },
        focusClick: function(lValue) {
          this.$refs["input_" + lValue["@guid"]][0].focus();
        },
        focused: function() {
          this.activeField = this.myGuid;
          if (this.preferenceStore.returnValue("--b-edit-general-action-button-display")) {
            this.showActionButton = true;
          } else {
            this.showActionButton = false;
          }
        },
        blured: function() {
        },
        expandHeightToContent: function() {
          for (let key2 of Object.keys(this.$refs)) {
            if (key2.startsWith("input_")) {
              this.$refs[key2][0].style.height = this.$refs[key2][0].scrollHeight + "px";
            }
          }
        },
        valueChanged: async function(event2, setFocus) {
          let v2 = event2.target.value;
          if (event2.target.tagName === "SPAN") {
            v2 = event2.target.innerText;
            if (event2.data && event2.data === "|") {
              event2.target.innerText = event2.target.innerText.slice(0, -1);
              event2.preventDefault();
              return false;
            }
          }
          await this.profileStore.setValueLiteral(this.guid, event2.target.dataset.guid, this.propertyPath, v2, event2.target.dataset.lang);
          if (setFocus) {
            let r2 = "input_" + this.literalValues[0]["@guid"];
            let el = this.$refs[r2][0];
            el.focus();
            if (typeof window.getSelection != "undefined" && typeof document.createRange != "undefined") {
              var range = document.createRange();
              range.selectNodeContents(el);
              range.collapse(false);
              var sel = window.getSelection();
              sel.removeAllRanges();
              sel.addRange(range);
            } else if (typeof document.body.createTextRange != "undefined") {
              var textRange = document.body.createTextRange();
              textRange.moveToElementText(el);
              textRange.collapse(false);
              textRange.select();
            }
          }
        },
        actionButtonCommand: async function(cmd, options) {
          if (cmd == "addField") {
            this.profileStore.setValueLiteral(this.guid, short.generate(), this.propertyPath, "new value", null, true);
          }
          if (cmd == "trans") {
            let fieldValue = this.literalValues.filter((v2) => {
              return v2["@guid"] == options.fieldGuid;
            });
            console.log(options, fieldValue[0].value);
            let transValue = await utilsNetwork.scriptShifterRequestTrans(options.lang, fieldValue[0].value, null, options.dir);
            transValue = JSON.parse(transValue);
            this.profileStore.setValueLiteral(this.guid, short.generate(), this.propertyPath, transValue.output, null, true);
            console.log();
          }
          this.$refs["input_" + this.literalValues[0]["@guid"]][0].focus();
        }
        // jumpToLangWindow: function(idVal){
        //   // just trigger it manually
        //   document.getElementsByTagName('header')[0].classList.remove('retracted') 
        //   document.getElementsByTagName('header')[0].classList.remove('inital') 
        //   document.getElementsByTagName('header')[0].classList.add('deployed')
        //   this.$nextTick(()=>{
        //     document.getElementById('toolbar-lang-button').click()
        //     console.log(`literal-lang-${idVal}`)
        //     console.log(document.getElementById('toolbar-lang-button'))
        //     this.$nextTick(()=>{
        //       window.setTimeout(()=>{          
        //         document.getElementById(`literal-lang-${idVal}`).scrollIntoView({block: "center"})
        //       },500)
        //     })
        //   })
        // },
        // addAnotherLiteral: function(){
        //   this.inputValue.push({value:'',guid:'new_' + short.generate()})
        // },
        // closeEditor: function(){
        //   this.showEditor = false
        //   this.$store.dispatch("enableMacroNav")
        // },
        // updateFromEditor: function(value){
        //   if (!this.$refs[`input_${this.showDiacriticsGuid}`]){
        //     return false
        //   }
        //   if (this.$refs[`input_${this.showDiacriticsGuid}`][0].getAttribute('id') != this.activeInput){
        //     return false
        //   }
        //   this.showEditor = false
        //   this.$store.dispatch("enableMacroNav")
        //   // also kick off the save function
        //   for (let inputV of this.inputValue){
        //     if (inputV.guid == this.showDiacriticsGuid){
        //       inputV.value = value
        //       this.change({}, inputV)
        //     }
        //   }
        // },
        // containsNonLatinCodepoints: function(s) {
        //     return /[^\u0000-\u00ff]/.test(s); // eslint-disable-line
        // },
        // blured: function(){
        //   this.$store.dispatch("enableMacroNav")
        // },
        // // this stores the active input at the global var level so it knows how to tab forward
        // focused: function(event){     
        //   // when we nav into a literal and its a text area type then turn off the global nav and we will handel it internally
        //   // this allows for default keyboard navigation inside the text area
        //   if (event && event.target && event.target.tagName === 'TEXTAREA'){
        //     this.$store.dispatch("disableMacroNav")
        //     // resize the field to accomdate the value
        //     // event.target.style.height = ""
        //     // event.target.style.height = event.target.scrollHeight + "px"
        //   } 
        //   this.$store.dispatch("setActiveInput", { self: this, id: event.target.id, profileCompoent: this.profileCompoent, profileName: this.profileName }).then(()=>{
        //     // now add the highlights to the side bars for this field
        //     this.$nextTick(()=>{
        //       uiUtils.focusSidebars()
        //     })
        //   })
        // },
        // submitField: uiUtils.globalMoveDown,
        // insertUnicodeHex: function(hex){
        //   this.inputValue = String.fromCodePoint(hex);
        // },
        // isNoteField: function(label,value){
        //   if (this.settingsTreatLikeNoteFields && this.settingsTreatLikeNoteFields == 'NOTE_FIELDS'){
        //     if (label == 'Note Text') return true
        //     if (label == 'Note') return true
        //     if (label == 'Contents note') return true
        //     if (label == 'Summary') return true
        //   }else if(this.settingsTreatLikeNoteFields && this.settingsTreatLikeNoteFields == 'LARGE_FIELDS'){
        //     if (value.length>=50) return true
        //   }else if(this.settingsTreatLikeNoteFields && this.settingsTreatLikeNoteFields == 'ALL_FIELDS'){
        //     return true
        //   }
        //   return false
        // },
        // openEditor: function(event){
        //   if (!event.target && event.event){        
        //     event = event.event
        //   }      
        //   this.showDiacriticsGuid=event.target.dataset.guid
        //   // we are using global dicratics so stop if this is one of the other components and not this one
        //   if (!this.$refs[`input_${this.showDiacriticsGuid}`]){
        //     return false
        //   }
        //   if (this.$refs[`input_${this.showDiacriticsGuid}`][0].getAttribute('id') != this.activeInput){
        //     return false
        //   }
        //   // showDiacriticsGuid
        //   this.$store.dispatch("disableMacroNav")
        //   this.showEditorValue=this.$refs[`input_${this.showDiacriticsGuid}`][0].value
        //   this.showEditor=true
        //   this.$nextTick(()=>{
        //     document.getElementById('literal-editor-textarea').focus()
        //     this.$refs.literalEditor.loadDataFromInput(this.$refs[`input_${this.showDiacriticsGuid}`][0].value)
        //   })
        //   // // if they acticated it via button then put the focus back on the input text box to recive key commands
        //   // if (event && event.target && event.target.localName && event.target.localName == 'button'){
        //   //   if (event.target.parentNode.querySelector('input')){
        //   //     event.target.parentNode.querySelector('input').focus()
        //   //   }else if (event.target.parentNode.querySelector('textarea')){
        //   //     event.target.parentNode.querySelector('textarea').focus()
        //   //   }
        //   // }
        // },
        // openDiacriticSelect: function(event){
        //   if (!event.target && event.event){        
        //     event = event.event
        //   }      
        //   this.showDiacriticsGuid=event.target.dataset.guid
        //   // we are using global dicratics so stop if this is one of the other components and not this one
        //   if (!this.$refs[`input_${this.showDiacriticsGuid}`]){
        //     return false
        //   }
        //   if (this.$refs[`input_${this.showDiacriticsGuid}`][0].getAttribute('id') != this.activeInput){
        //     return false
        //   }
        //   // showDiacriticsGuid
        //   this.$store.dispatch("disableMacroNav")
        //   this.showDiacritics=true
        //   this.$nextTick(()=>{
        //     this.$refs.diacriticTable[this.diacriticDataNav].style.backgroundColor="#dfe5f1"
        //   })
        //   // if they acticated it via button then put the focus back on the input text box to recive key commands
        //   if (event && event.target && event.target.localName && event.target.localName == 'button'){
        //     if (event.target.parentNode.querySelector('input')){
        //       event.target.parentNode.querySelector('input').focus()
        //     }else if (event.target.parentNode.querySelector('textarea')){
        //       event.target.parentNode.querySelector('textarea').focus()
        //     }
        //   }
        // },
        // diacriticSelect: function(event){
        //   // depending on where they click the parent maybe the td or it may be the tr where the data-id attrubture is storeing the trigger 
        //   let pos = (event.target.parentNode.dataset.id) ? event.target.parentNode.dataset.id : event.target.parentNode.parentNode.dataset.id
        //   let insertAt = false
        //   for (let inputV of this.inputValue){
        //     if (inputV.guid == this.showDiacriticsGuid){
        //       insertAt = inputV.value.length
        //       if (this.$refs[`input_${this.showDiacriticsGuid}`] && this.$refs[`input_${this.showDiacriticsGuid}`][0] && this.$refs[`input_${this.showDiacriticsGuid}`][0].selectionStart){
        //         insertAt=this.$refs[`input_${this.showDiacriticsGuid}`][0].selectionStart
        //       }
        //       inputV.value = inputV.value.substring(0, insertAt) + this.diacriticData[pos].letter + inputV.value.substring(insertAt);
        //     }
        //   }
        //   // if (this.inputValue){
        //   //   this.inputValue = this.inputValue + this.diacriticData[pos].letter
        //   // }else{
        //   //   this.inputValue = this.diacriticData[pos].letter
        //   // }
        //   // focus back on the input
        //   this.$nextTick(()=>{
        //     // focus back on the element,  but also set the cursor at the point we inserted
        //     if (insertAt){
        //       document.getElementById(this.$refs[`input_${this.showDiacriticsGuid}`][0].getAttribute('id')).setSelectionRange(insertAt+1,insertAt+1)
        //     }
        //     document.getElementById(this.$refs[`input_${this.showDiacriticsGuid}`][0].getAttribute('id')).focus()
        //     this.showDiacriticsGuid=null
        //     this.showDiacritics=false
        //     this.$store.dispatch("enableMacroNav")
        //     // also kick off the save function
        //     for (let inputV of this.inputValue){
        //       if (inputV.guid == this.showDiacriticsGuid){
        //         this.change(event, inputV)
        //       }
        //     }
        //   })
        // },
        // nav: function(event){
        //   let guid = event.target.dataset.guid
        //   // turn it on
        //   if (this.settingsDPackVoyagerNative && this.diacrticsVoyagerNativeMode == false && event.code == 'KeyE' && event.ctrlKey == true){
        //     this.$refs["input_"+guid].style.color="blue"
        //     this.diacrticsVoyagerNativeMode = true
        //     event.preventDefault()
        //     return false
        //   // turn it off
        //   }else if (this.settingsDPackVoyagerNative && this.diacrticsVoyagerNativeMode == true && event.code == 'KeyE' && event.ctrlKey == true){
        //     this.diacrticsVoyagerNativeMode = false
        //     window.setTimeout(()=>{
        //       this.$refs["input_"+guid].style.color="black"
        //     },500)
        //     event.preventDefault()
        //     return false
        //   // execute it
        //   }
        //   if (event && event.key && this.showDiacritics == true){
        //     if (event.key == 'Escape'){
        //       this.showDiacritics=false
        //       this.$store.dispatch("enableMacroNav")
        //     }else if (event.key == 'ArrowDown' || event.key == 'ArrowUp' ){
        //         if (event.key == 'ArrowDown' &&  this.diacriticDataNav < this.$refs.diacriticTable.length-1){
        //           this.diacriticDataNav++
        //         }else if (event.key == 'ArrowUp' && this.diacriticDataNav>0){
        //           this.diacriticDataNav = this.diacriticDataNav - 1
        //         }
        //         this.$refs.diacriticTable.forEach((el)=>{
        //           el.style.backgroundColor = 'transparent'
        //         })
        //         this.$refs.diacriticTable[this.diacriticDataNav].style.backgroundColor="#dfe5f1"
        //         this.$refs.diacriticTable[this.diacriticDataNav].scrollIntoView({behavior: "smooth", block: "nearest", inline: "nearest"})
        //     }else if (event.key == 'Enter'){
        //       let letter = this.diacriticData[this.diacriticDataNav].letter
        //       let useGuid = guid
        //       if (!useGuid){
        //         useGuid=this.showDiacriticsGuid
        //       }
        //       let insertAt = false
        //       for (let inputV of this.inputValue){
        //         if (inputV.guid == useGuid){
        //           insertAt = inputV.value.length
        //           if (this.$refs[`input_${useGuid}`] && this.$refs[`input_${useGuid}`][0] && this.$refs[`input_${useGuid}`][0].selectionStart){
        //             insertAt=this.$refs[`input_${useGuid}`][0].selectionStart
        //           }
        //           inputV.value = inputV.value.substring(0, insertAt) + letter + inputV.value.substring(insertAt);
        //           if (insertAt){
        //             this.$nextTick(()=>{
        //               this.$refs[`input_${useGuid}`][0].setSelectionRange(insertAt+1,insertAt+1)
        //               this.$nextTick(()=>{
        //                 this.$refs[`input_${useGuid}`][0].focus()
        //               })
        //             })
        //           }else{
        //               this.$nextTick(()=>{
        //                 this.$refs[`input_${useGuid}`][0].focus()
        //               })
        //           }
        //         }
        //       }
        //       this.showDiacritics=false
        //       this.$store.dispatch("enableMacroNav")
        //     }else{
        //       for (let key of this.diacriticData){
        //         if (event.key == key.trigger){
        //           let useGuid = guid
        //           if (!useGuid){
        //             useGuid=this.showDiacriticsGuid
        //           }
        //           let insertAt = false
        //           for (let inputV of this.inputValue){
        //             if (inputV.guid == useGuid){
        //               insertAt = inputV.value.length
        //               if (this.$refs[`input_${useGuid}`] && this.$refs[`input_${useGuid}`][0] && this.$refs[`input_${useGuid}`][0].selectionStart){
        //                 insertAt=this.$refs[`input_${useGuid}`][0].selectionStart
        //               }
        //               inputV.value = inputV.value.substring(0, insertAt) + key.letter + inputV.value.substring(insertAt);
        //               if (insertAt){
        //                 this.$nextTick(()=>{
        //                   this.$refs[`input_${useGuid}`][0].setSelectionRange(insertAt+1,insertAt+1)
        //                   this.$nextTick(()=>{
        //                     this.$refs[`input_${useGuid}`][0].focus()
        //                   })
        //                 })
        //               }else{
        //                   this.$nextTick(()=>{
        //                     this.$refs[`input_${useGuid}`][0].focus()
        //                   })
        //               }
        //             }
        //           }
        //           // if (this.inputValue){
        //           //   this.inputValue = this.inputValue + key.letter
        //           // }else{
        //           //   this.inputValue = key.letter
        //           // }
        //           this.showDiacritics=false
        //           this.$store.dispatch("enableMacroNav")              
        //         }            
        //       }
        //     }
        //     event.preventDefault()
        //     return false
        //   }
        //   if (event && (event.key == 'ArrowDown' || event.key == 'ArrowUp') && this.showDiacritics == false){
        //     if (event.target.tagName === 'TEXTAREA' && this.disableMacroKeyNav){
        //       // nothing in the field then enable macro and nav it
        //       if (event.target.value.length === 0){
        //           this.$store.dispatch("enableMacroNav").then(()=>{
        //             if (event.key == 'ArrowDown'){
        //               uiUtils.globalMoveDown()
        //             }else{
        //               uiUtils.globalMoveUp()
        //             }
        //           })
        //       }else{
        //         // if its not empty are we at the very start of it or at the very end of it?
        //         if (event.target.selectionStart === 0 && event.key == 'ArrowUp'){
        //           this.$store.dispatch("enableMacroNav").then(()=>{
        //               uiUtils.globalMoveUp()            
        //           })
        //         }else if (event.target.selectionStart === event.target.value.length && event.key == 'ArrowDown'){
        //           this.$store.dispatch("enableMacroNav").then(()=>{
        //               uiUtils.globalMoveDown()            
        //           })
        //         }
        //       }
        //     }
        //   }
        // },
        // /**
        // * Change the value of the field, via state change and parseProfile method
        // * @param {object} event - the event obj passed
        // * @param {string} inputV - the current value of the input element
        // * @return {void}
        // */
        // change: function(event,inputV){
        //   // find where we are inserting the value into
        //   // default to the end of the string
        //   let insertAt = inputV.value.length
        //   if (this.$refs[`input_${inputV.guid}`] && this.$refs[`input_${inputV.guid}`][0] && this.$refs[`input_${inputV.guid}`][0].selectionStart){
        //     insertAt=this.$refs[`input_${inputV.guid}`][0].selectionStart
        //   }            
        //   if (diacrticsVoyagerMacroExpress[event.code] && this.settingsDPackVoyager){
        //     for (let macro of diacrticsVoyagerMacroExpress[event.code]){
        //       if (event.ctrlKey == macro.ctrlKey && event.altKey == macro.altKey && event.shiftKey == macro.shiftKey){
        //         event.preventDefault();
        //         this.$refs["input"+ '_' + inputV.guid][0].style.color="blue"
        //         window.setTimeout(()=>{
        //           this.$refs["input"+ '_' + inputV.guid][0].style.color="black"
        //         },500)
        //         if (!macro.combining){
        //           // there is behavior where if it is a digit shortcut the numerial is still sent
        //           // so if thats the case remove the last digit from the value
        //           if (event.code.includes('Digit')){
        //             // if it is in fact a digit char then remove it
        //             if (inputV.value.charAt(insertAt) == event.code.replace('Digit','')){
        //               // remove the last char
        //               // inputV.value = inputV.value.slice(0, -1); 
        //               inputV.value = inputV.value.slice(0,insertAt) + inputV.value.slice(insertAt)
        //             }
        //           }
        //           // same for euqal key
        //           if (event.code == 'Equal'){
        //             if (inputV.value.charAt(inputV.value.length-1) == '='){
        //               // remove the last char
        //               // inputV.value = inputV.value.slice(0, -1);
        //               inputV.value = inputV.value.slice(0,insertAt) + inputV.value.slice(insertAt)
        //             }
        //           }
        //           // same for Backquote key
        //           if (event.code == 'Backquote'){
        //             if (inputV.value.charAt(inputV.value.length-1) == '`'){
        //               // remove the last char
        //               // inputV.value = inputV.value.slice(0, -1);
        //               inputV.value = inputV.value.slice(0,insertAt) + inputV.value.slice(insertAt) 
        //             }
        //           }
        //           // it is not a combining unicode char so just insert it into the value
        //           if (inputV.value){
        //             // inputV.value=inputV.value+macro.codeEscape
        //             inputV.value = inputV.value.substring(0, insertAt) + macro.codeEscape + inputV.value.substring(insertAt);
        //             if (insertAt){
        //               this.$nextTick(()=>{
        //                 this.$refs[`input_${inputV.guid}`][0].setSelectionRange(insertAt+1,insertAt+1)
        //                 this.$nextTick(()=>{
        //                   this.$refs[`input_${inputV.guid}`][0].focus()
        //                 })
        //               })
        //             }else{
        //                 this.$nextTick(()=>{
        //                   this.$refs[`input_${inputV.guid}`][0].focus()
        //                 })
        //             }
        //           }else{
        //             inputV.value = macro.codeEscape
        //           }
        //         }else{
        //           // same for Backquote key
        //           if (event.code == 'Backquote'){
        //             if (inputV.value.charAt(inputV.value.length-1) == '`'){
        //               // remove the last char
        //               inputV.value = inputV.value.slice(0, -1); 
        //             }
        //           }
        //           // little cheap hack here, on macos the Alt+9 makes ª digits 1-0 do this with Alt+## but we only 
        //           // have one short cut that uses Alt+9 so just remove that char for now
        //           inputV.value=inputV.value.replace('ª','')
        //           inputV.value = inputV.value.substring(0, insertAt) + macro.codeEscape + inputV.value.substring(insertAt);
        //           // inputV.value=inputV.value+macro.codeEscape
        //           document.getElementById(this.$refs[`input_${inputV.guid}`][0].getAttribute('id')).setSelectionRange(insertAt+1,insertAt+1)
        //           document.getElementById(this.$refs[`input_${inputV.guid}`][0].getAttribute('id')).focus()
        //           if (insertAt){
        //             this.$nextTick(()=>{
        //               this.$refs[`input_${inputV.guid}`][0].setSelectionRange(insertAt+1,insertAt+1)
        //               this.$nextTick(()=>{
        //                 this.$refs[`input_${inputV.guid}`][0].focus()
        //               })
        //             })
        //           }else{
        //               this.$nextTick(()=>{
        //                 this.$refs[`input_${inputV.guid}`][0].focus()
        //               })
        //           }
        //         }
        //       }
        //     }
        //   }
        //   // handled in the keydown
        //   if (this.settingsDPackVoyagerNative && this.diacrticsVoyagerNativeMode == false && event.code == 'KeyE' && event.ctrlKey == true){
        //     event.preventDefault()
        //     return false
        //   // turn it off
        //   }else if (this.settingsDPackVoyagerNative && this.diacrticsVoyagerNativeMode == true && event.code == 'KeyE' && event.ctrlKey == true){
        //     event.preventDefault()
        //     return false
        //   // execute it
        //   }else if (this.settingsDPackVoyagerNative && diacrticsVoyagerNative[event.code] && this.diacrticsVoyagerNativeMode == true){
        //     window.setTimeout(()=>{
        //       this.$refs["input"].style.color="black"
        //     },500)
        //     // remove the shortcut key we just dumped into the text box
        //     inputV.value = inputV.value.slice(0, -1); 
        //     this.diacrticsVoyagerNativeMode = false
        //     let useMacro
        //     for (let macro of diacrticsVoyagerNative[event.code]){          
        //       if (macro.shiftKey == event.shiftKey){
        //         useMacro = macro
        //         break
        //       }
        //     }
        //     if (!useMacro.combining){
        //       // it is not a combining unicode char so just insert it into the value
        //       if (inputV.value){
        //         // inputV.value=inputV.value+useMacro.codeEscape
        //         inputV.value = inputV.value.substring(0, insertAt) + useMacro.codeEscape + inputV.value.substring(insertAt);
        //       }else{
        //         inputV.value = useMacro.codeEscape
        //       }
        //     }else{
        //           // inputV.value=inputV.value+useMacro.codeEscape
        //           inputV.value = inputV.value.substring(0, insertAt) + useMacro.codeEscape + inputV.value.substring(insertAt);
        //     }
        //   }
        //   let useGuid = inputV.guid
        //   if (inputV.guid.startsWith('new_')){
        //     useGuid = null
        //   }
        //   // find the previous value
        //   let previousValue = null
        //   if (this.inputValueLast && this.inputValueLast.length>0){
        //     for (let preval of this.inputValueLast){
        //       if (preval.guid == inputV.guid){
        //         previousValue = preval.value
        //       }
        //     }
        //   }
        //   // if its empty don't do anytihng, unless its newly empty, meaning they just deleted the whole thing
        //   if (inputV.value === null) return false
        //   if (inputV.value.trim() === '' && (previousValue === '' || previousValue === null)) return false
        //   // don't update if nothing changed or havent entered anythign yet...
        //   if (inputV.value == null){
        //        return false
        //   }
        //   if (JSON.stringify(this.inputValue) == this.inputValueLast){        
        //     return false
        //   }
        //   // if they "blank" out the value by just puttin a space for some reason then make it empty string
        //   if (inputV.value.trim() === '' && previousValue !== ''){
        //     inputV.value = inputV.value.trim()
        //   }
        //   // this resizes the textarea as there is more content
        //   if (event.target && event.target.localName && event.target.localName == 'textarea'){
        //     event.target.style.height = ""
        //     event.target.style.height = event.target.scrollHeight + "px"
        //   }
        //   let parentURI = null
        //   if (this.parentStructureObj){
        //     parentURI = this.parentStructureObj.propertyURI
        //   }
        //   // don't fire on command keys, heres a few common ones to ignore
        //   // when they do SHIFT+A the A gets its own keyup and so does the shift, so ignore the shift for example
        //   if (event && event.key && ['Shift','Control','Meta','Alt','CapsLock'].indexOf(event.key) > -1){
        //     return false
        //   }
        //   this.$store.dispatch("setValueLiteral", { self: this, ptGuid: this.ptGuid, guid: useGuid, parentURI:parentURI, URI: this.structure.propertyURI, value: inputV.value, propertyPath: this.propertyPath }).then((newGuid) => {
        //     // this.inputValueLast = this.inputValue
        //     // if this is here then we created a new value, store it for future edits
        //     if(newGuid){
        //       inputV.guid = newGuid
        //     }
        //     // but if it is explictly set to false that means we just unset the value, so reset the guid here
        //     if (newGuid===false){
        //       inputV.guid = 'new_' + short.generate()
        //     }
        //     this.inputValueLast = JSON.parse(JSON.stringify(this.inputValue))
        //   })   
        // },
        // refreshInputDisplay: function(){
        //   let data
        //   if (this.isMini){
        //     data = this.activeProfileMini.rt[this.profileName].pt[this.profileCompoent] 
        //   }else{
        //     data = this.activeProfile.rt[this.profileName].pt[this.profileCompoent]  
        //   }
        //   // this will keep track of all the guids for data found
        //   // it is used below to reconcile the component cache of the current values and
        //   // what is in state, which becomes unaligned when things like undos happen
        //   let allGuidsFound = []
        //   // if (this.profileCompoent=='http://id.loc.gov/ontologies/bflc/relationship|Input Transcribed Series'){
        //   //   console.log('http://id.loc.gov/ontologies/bflc/relationship --- DATA', this.profileCompoent)
        //   //   console.log(data)
        //   // }
        //   // depending on the depth 
        //   // we know where to look because we have the property path
        //   if (this.propertyPath.length === 1){
        //       let L0URI = this.propertyPath[0].propertyURI
        //       if (data.userValue[L0URI]){
        //           for (let uv of data.userValue[L0URI]){
        //                 allGuidsFound.push(uv['@guid'])
        //                 // check that it doesn't yet exist, if it does just update value
        //                 if (this.inputValue.map((v)=> {return v.guid} ).includes(uv['@guid'])){
        //                     for (let iv of this.inputValue){
        //                       if (iv.guid == uv['@guid']){
        //                         if (typeof uv[L0URI] == 'object' && uv[L0URI] !== null && uv[L0URI][0][L0URI] ){
        //                           iv.value = uv[L0URI][0][L0URI]
        //                           if (uv[L0URI][0]['@language']){
        //                             iv.language = uv[L0URI][0]['@language']
        //                           }else{
        //                             iv.language = false
        //                           }
        //                         }else{
        //                           iv.value = uv[L0URI]
        //                           if (uv['@language']){
        //                             iv.language = uv['@language']
        //                           }else{
        //                             iv.language = false
        //                           }
        //                         }
        //                       }
        //                     }                  
        //                 }else{
        //                   if (typeof uv[L0URI] == 'object' && uv[L0URI] !== null && uv[L0URI][0][L0URI] ){
        //                     this.inputValue.push({value:uv[L0URI][0][L0URI], guid:uv['@guid'], language:uv[L0URI][0]['@language'] })
        //                   }else{
        //                     this.inputValue.push({value:uv[L0URI], guid:uv['@guid'], language:uv['@language'] })
        //                   }
        //                 }
        //           }
        //       }
        //   }else if (this.propertyPath.length === 2){
        //       let L0URI = this.propertyPath[0].propertyURI
        //       let L1URI = this.propertyPath[1].propertyURI
        //       if (data.userValue[L0URI] && data.userValue[L0URI][0] && data.userValue[L0URI][0][L1URI]){
        //           for (let uv of data.userValue[L0URI][0][L1URI]){
        //                 allGuidsFound.push(uv['@guid'])
        //                 // check that it doesn't yet exist, if it does just update value
        //                 if (this.inputValue.map((v)=> {return v.guid} ).includes(uv['@guid'])){
        //                     for (let iv of this.inputValue){
        //                       if (iv.guid == uv['@guid']){
        //                         iv.value = uv[L1URI]
        //                         if (uv['@language']){
        //                           iv.language = uv['@language']
        //                         }else{
        //                           iv.language = false
        //                         }
        //                       }
        //                     }                  
        //                 }else{
        //                   this.inputValue.push({value:uv[L1URI], guid:uv['@guid'], language:uv['@language'] })
        //                 }
        //           }
        //       }
        //   }else if (this.propertyPath.length === 3){
        //       let L0URI = this.propertyPath[0].propertyURI
        //       let L1URI = this.propertyPath[1].propertyURI
        //       let L2URI = this.propertyPath[2].propertyURI
        //       if (data.userValue[L0URI] && data.userValue[L0URI][0] && data.userValue[L0URI][0][L1URI] && data.userValue[L0URI][0][L1URI][0] && data.userValue[L0URI][0][L1URI][0][L2URI]){
        //           for (let uv of data.userValue[L0URI][0][L1URI][0][L2URI]){
        //                 allGuidsFound.push(uv['@guid'])
        //                 // check that it doesn't yet exist, if it does just update value
        //                 if (this.inputValue.map((v)=> {return v.guid} ).includes(uv['@guid'])){
        //                     for (let iv of this.inputValue){
        //                       if (iv.guid == uv['@guid']){
        //                         iv.value = uv[L2URI]
        //                         if (uv['@language']){
        //                           iv.language = uv['@language']
        //                         }else{
        //                           iv.language = false
        //                         }
        //                       }
        //                     }                  
        //                 }else{
        //                   this.inputValue.push({value:uv[L2URI], guid:uv['@guid'], language:uv['@language'] })
        //                 }
        //           }
        //       }
        //   }else if (this.propertyPath.length === 4){
        //       let L0URI = this.propertyPath[0].propertyURI
        //       let L1URI = this.propertyPath[1].propertyURI
        //       let L2URI = this.propertyPath[2].propertyURI
        //       let L3URI = this.propertyPath[3].propertyURI
        //       if (data.userValue[L0URI] && data.userValue[L0URI][0] && data.userValue[L0URI][0][L1URI] && data.userValue[L0URI][0][L1URI][0] && data.userValue[L0URI][0][L1URI][0][L2URI] && data.userValue[L0URI][0][L1URI][0][L2URI][0] && data.userValue[L0URI][0][L1URI][0][L2URI][0][L3URI]){
        //           for (let uv of data.userValue[L0URI][0][L1URI][0][L2URI][0][L3URI]){
        //                 allGuidsFound.push(uv['@guid'])
        //                 // check that it doesn't yet exist, if it does just update value
        //                 if (this.inputValue.map((v)=> {return v.guid} ).includes(uv['@guid'])){
        //                     for (let iv of this.inputValue){
        //                       if (iv.guid == uv['@guid']){
        //                         iv.value = uv[L3URI]
        //                         if (uv['@language']){
        //                           iv.language = uv['@language']
        //                         }else{
        //                           iv.language = false
        //                         }
        //                       }
        //                     }                  
        //                 }else{
        //                   this.inputValue.push({value:uv[L3URI], guid:uv['@guid'], language:uv['@language'] })
        //                 }
        //           }
        //       }
        //   }else{
        //       console.error("Error trying to update literal value but cannot find guid")
        //   }
        //   // // test to see if this property exists in the user value at the parent structure / properturi lvl
        //   // if (this.parentStructureObj && data.userValue[this.parentStructureObj.propertyURI]){
        //   //   for (let parentValueArray of data.userValue[this.parentStructureObj.propertyURI]){
        //   //     if (parentValueArray[this.structure.propertyURI]){          
        //   //       for (let childValue of parentValueArray[this.structure.propertyURI]){
        //   //         if (childValue[this.structure.propertyURI]){
        //   //               allGuidsFound.push(childValue['@guid'])
        //   //               // check that it doesn't yet exist, if it does just update value
        //   //               if (this.inputValue.map((v)=> {return v.guid} ).includes(childValue['@guid'])){
        //   //                   for (let iv of this.inputValue){
        //   //                     if (iv.guid == childValue['@guid']){
        //   //                       iv.value = childValue[this.structure.propertyURI]
        //   //                     }
        //   //                   }                  
        //   //               }else{
        //   //                 this.inputValue.push({value:childValue[this.structure.propertyURI], guid:childValue['@guid'] })
        //   //               }
        //   //         }
        //   //       }
        //   //     }
        //   //   }
        //   // }else if (!this.parentStructureObj && data.userValue[this.structure.propertyURI]){
        //   //   // if it is not a nested template literal then it should be a first lvl one
        //   //   for (let value of data.userValue[this.structure.propertyURI]){
        //   //     if (value[this.structure.propertyURI]){
        //   //         allGuidsFound.push(value['@guid'])
        //   //         // check that it doesn't yet exist, if it does just update value
        //   //         if (this.inputValue.map((v)=> {return v.guid} ).includes(value['@guid'])){
        //   //             for (let iv of this.inputValue){
        //   //               if (iv.guid == value['@guid']){
        //   //                 iv.value = value[this.structure.propertyURI]
        //   //               }
        //   //             }                  
        //   //         }else{
        //   //           this.inputValue.push({value:value[this.structure.propertyURI], guid:value['@guid'] })
        //   //         }
        //   //     }
        //   //   }
        //   // }else if (this.parentStructureObj && this.parentStructureObj.propertyURI == data.userValue['@root'] && data.userValue[this.structure.propertyURI]){
        //   //   for (let value of data.userValue[this.structure.propertyURI]){
        //   //     if (value[this.structure.propertyURI]){
        //   //           allGuidsFound.push(value['@guid'])
        //   //           // check that it doesn't yet exist, if it does just update value
        //   //           if (this.inputValue.map((v)=> {return v.guid} ).includes(value['@guid'])){
        //   //               for (let iv of this.inputValue){
        //   //                 if (iv.guid == value['@guid']){
        //   //                   iv.value = value[this.structure.propertyURI]
        //   //                 }
        //   //               }                  
        //   //           }else{
        //   //             this.inputValue.push({value:value[this.structure.propertyURI], guid:value['@guid'] })
        //   //           }
        //   //     }
        //   //   }
        //   // }
        //   // look at the config file to understand this flag
        //   if (config.profileHacks.agentsHideManualRDFLabelIfURIProvided.enabled){
        //     if (this.parentStructureObj && this.parentStructureObj.propertyURI == 'http://id.loc.gov/ontologies/bibframe/agent'){
        //       if (this.structure.propertyURI=='http://www.w3.org/2000/01/rdf-schema#label'){
        //           if (
        //               !this.parentStructureObj.parentId.includes('Information') &&
        //               !this.structure.parentId.includes('PubPlace') &&
        //               !this.structure.parentId.includes('PubName') &&
        //               !this.structure.parentId.includes(':Provision:')                
        //               ){
        //             this.hideField = true
        //           }
        //       }
        //     }
        //   }
        //   // if we have more than the default empty value it means we have a value, so remvoe the default blank one
        //   if (this.inputValue.length>1){
        //     this.inputValue = this.inputValue.filter((iv) => {return (iv.value!='')})
        //   }
        //   // also look to see that the guids in there are really in the data
        //   // they might be leftovers from when they did an undo command and we need to clean up the inputValue
        //   this.inputValue = this.inputValue.filter((iv) => {
        //     if (iv.guid.startsWith('new_')){
        //       return true
        //     }
        //     if (allGuidsFound.indexOf(iv.guid)==-1){
        //       return false
        //     }
        //     return true
        //   })
        //   // the did an undo and now there is nothing in the data, make sure there is at least an empty one
        //   if (this.inputValue.length==0){
        //     this.inputValue.push({value:'',guid:'new_' + short.generate()})
        //   }
        //   // check to make sure if it is a rtl lang that there is room for the buttons, so they don't over lap the text
        //   for (let inputV of this.inputValue){
        //     // and also clean up any escape chars here
        //     if (inputV.value){
        //       inputV.value= inputV.value.replace(/&amp;/g, '&');
        //     }
        //     if (this.rtlRegEx.test(inputV.value)){
        //       this.$nextTick(()=>{
        //         this.$refs[`input_${inputV.guid}`][0].classList.add('input-textarea-nested-rtl')
        //       })
        //     } 
        //   }
        // }
      },
      computed: {
        // other computed properties
        // ...
        // gives access to this.counterStore and this.userStore
        ...mapStores(useProfileStore),
        ...mapStores(usePreferenceStore),
        ...mapWritableState(useProfileStore, ["activeField", "activeProfile"]),
        myGuid() {
          return `${this.structure["@guid"]}--${this.guid}`;
        },
        literalValues() {
          let values = this.profileStore.returnLiteralValueFromProfile(this.guid, this.propertyPath);
          if (values === false) {
            values = [{
              value: "",
              "@lang": null,
              "@guid": short.generate()
            }];
          }
          return values;
        },
        inlineModeShouldDisplay() {
          if (this.profileStore.inlinePropertyHasValue(this.guid, this.structure, this.propertyPath)) {
            return true;
          } else if (this.profileStore.inlineFieldIsToggledForDisplay(this.guid, this.structure)) {
            return true;
          } else {
            if (this.profileStore.inlineIsMainProperty(this.guid, this.structure, this.propertyPath)) {
              return true;
            }
          }
          return false;
        }
        // literalFieldValue: {
        //   // getter
        //   get() {
        //     let literalValues = {}
        //     // to accommodate multiple values in the a literal field (@ language tags)
        //     // if (this.structure.propertyURI == 'http://id.loc.gov/ontologies/bflc/nonSortNum'){
        //     //   console.log("getting new data")
        //     //   console.log(this.guid)
        //     //   console.log(this.structure)
        //     //   console.log(this.activeProfile)
        //     //   // console.log(JSON.stringify(this.activeProfile))
        //     // }
        //     // for (let rt in this.activeProfile.rt){
        //     //   for (let pt in this.activeProfile.rt[rt].pt){              
        //     //     if (this.activeProfile.rt[rt].pt[pt]['@guid'] == this.guid){
        //     //       return this.activeProfile.rt[rt].pt[pt]['userValue']['@root']
        //     //     }
        //     //   }
        //     // }
        //     // no values were found stored in the profile, must be a empty / new value
        //     // if (Object.keys(literalValues).length == 0){
        //     //   literalValues['new'] = {
        //     //     value: '',  
        //     //     lang: null, 
        //     //     guid: 'new'  
        //     //   }
        //     // }
        //     return ['hello','okay']
        //     return literalValues
        //   },
        //   // setter
        //   set(newValue,event) {
        //     console.log(newValue, event)
        //   }
        // },
      },
      // computed: mapState({
      //   activeInput: 'activeInput',
      //   activeProfile: 'activeProfile',
      //   activeProfileMini: 'activeProfileMini',
      //   workingOnMiniProfile: 'workingOnMiniProfile',
      //   settingsDisplayMode: 'settingsDisplayMode',
      //   undoCounter: 'undoCounter',
      //   disableMacroKeyNav: 'disableMacroKeyNav',
      //   settingsTreatLikeNoteFields: 'settingsTreatLikeNoteFields',
      //   settingsDPackVoyager: 'settingsDPackVoyager',
      //   settingsDPackVoyagerNative: 'settingsDPackVoyagerNative',
      //   assignedId (){
      //     // return uiUtils.assignID(this.structure,this.parentStructure)
      //     if (this.internalAssignID){
      //       return this.internalAssignID
      //     }else{
      //       this.internalAssignID = uiUtils.assignID(this.structure,this.parentStructure)
      //       return this.internalAssignID
      //     }      
      //   },    
      //   showAddAddditonalLiteralButton (){
      //     // look to see if there are any language defined on any of the literals
      //     // if there are then turn on the add button
      //     // // does the profile have a literal lang somewhere
      //     // for (let rt in this.activeProfile.rt){
      //     //   if (this.activeProfile.rt[rt].hasLiteralLangFields){
      //         if (config.allowLiteralRepeatForNonRomain.includes(this.structure.propertyURI)){
      //           return true
      //         }
      //         if (this.parentStructureObj && config.allowLiteralRepeatForNonRomain.includes(this.parentStructureObj.propertyURI)){
      //           return true
      //         }
      //     //   }
      //     // }
      //     return false
      //     // return true
      //   },
      // }), 
      watch: {
        // // watch when the undoindex changes, means they are undoing redoing, so refresh the
        // // value in the acutal input box
        // undoCounter: function(){
        //   // put a little delay on it so there is no overlap of when the data value is saving and when it is asikng for the data value
        //   // to populate this input field
        //   window.setTimeout(()=>{
        //     this.refreshInputDisplay()
        //   },500)
        // }
      },
      data: function() {
        return {
          // used as toggle to show the button when field is focused
          showActionButton: false
          //
          // inputValue: [{value:'',guid:'new_' + short.generate()}],
          // inputValueLast: null,
          // inputValueCombiningDiacritic: null,
          // showDiacritics: false,
          // showEditor:false,
          // showEditorValue:'',
          // showDiacriticsGuid: null,
          // diacriticData: [],
          // diacriticDataNav: 0,
          // hideField: false,
          // rtlRegEx: /[\u0591-\u07FF]/,
          // guid: null,
          // initalGuid: null,
          // diacrticsVoyagerNativeMode:false,
          // internalAssignID: false,
          // language: false,
        };
      },
      mounted: function() {
        this.$nextTick().then(() => {
          this.expandHeightToContent();
        });
      },
      created: function() {
        this.$nextTick().then(() => {
          this.expandHeightToContent();
        });
      }
    };
    const __injectCSSVars__ = () => {
      useCssVars((_ctx) => ({
        "09ba8ba6": _ctx.preferenceStore.returnValue("--n-edit-main-literal-font-size"),
        "9df258ee": _ctx.preferenceStore.returnValue("--n-edit-main-splitpane-edit-show-field-labels-size")
      }));
    };
    const __setup__ = _sfc_main$1.setup;
    _sfc_main$1.setup = __setup__ ? (props, ctx) => {
      __injectCSSVars__();
      return __setup__(props, ctx);
    } : __injectCSSVars__;
    const _hoisted_1$1 = ["title"];
    const _hoisted_2 = ["data-guid"];
    const _hoisted_3 = ["title"];
    const _hoisted_4 = ["data-guid"];
    const _hoisted_5 = {
      key: 0,
      class: "literal-action-inline-mode"
    };
    const _hoisted_6 = {
      key: 1,
      class: "lookup-fake-input"
    };
    const _hoisted_7 = ["onClick"];
    const _hoisted_8 = { class: "literal-field" };
    const _hoisted_9 = {
      key: 0,
      class: "lookup-fake-input-label"
    };
    const _hoisted_10 = { autocomplete: "off" };
    const _hoisted_11 = {
      key: 0,
      class: "bfcode-display-mode-holder"
    };
    const _hoisted_12 = ["title"];
    const _hoisted_13 = { class: "bfcode-display-mode-holder-value" };
    const _hoisted_14 = ["onUpdate:modelValue", "data-guid"];
    const _hoisted_15 = ["onUpdate:modelValue", "data-guid"];
    const _hoisted_16 = {
      key: 0,
      class: "literal-action"
    };
    function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_action_button = resolveComponent("action-button");
      return _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-inline-mode") == true ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        $options.inlineModeShouldDisplay ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          $options.literalValues.length === 1 && $options.literalValues[0].value === "" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createBaseVNode("span", {
              class: "bfcode-display-mode-holder-label",
              title: $props.structure.propertyLabel
            }, toDisplayString$2(_ctx.profileStore.returnBfCodeLabel($props.structure)) + ":", 9, _hoisted_1$1),
            createBaseVNode("input", {
              type: "text",
              onFocusin: _cache[0] || (_cache[0] = (...args) => $options.focused && $options.focused(...args)),
              onKeyup: _cache[1] || (_cache[1] = (...args) => $options.navKey && $options.navKey(...args)),
              onInput: _cache[2] || (_cache[2] = ($event) => $options.valueChanged($event, true)),
              class: "inline-mode-editable-span-input can-select",
              ref: "input_" + $options.literalValues[0]["@guid"],
              "data-guid": $options.literalValues[0]["@guid"]
            }, null, 40, _hoisted_2)
          ], 64)) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList($options.literalValues, (lValue) => {
            return openBlock(), createElementBlock(Fragment, null, [
              createBaseVNode("span", {
                class: "bfcode-display-mode-holder-label",
                title: $props.structure.propertyLabel
              }, toDisplayString$2(_ctx.profileStore.returnBfCodeLabel($props.structure)) + ":", 9, _hoisted_3),
              createBaseVNode("span", {
                contenteditable: "true",
                onFocusin: _cache[3] || (_cache[3] = (...args) => $options.focused && $options.focused(...args)),
                onBlur: _cache[4] || (_cache[4] = (...args) => $options.blured && $options.blured(...args)),
                class: "inline-mode-editable-span can-select",
                onKeyup: _cache[5] || (_cache[5] = (...args) => $options.navKey && $options.navKey(...args)),
                onInput: _cache[6] || (_cache[6] = (...args) => $options.valueChanged && $options.valueChanged(...args)),
                ref_for: true,
                ref: "input_" + lValue["@guid"],
                "data-guid": lValue["@guid"]
              }, toDisplayString$2(lValue.value), 41, _hoisted_4)
            ], 64);
          }), 256)),
          createVNode(Transition, { name: "action" }, {
            default: withCtx(() => [
              _ctx.showActionButton && $options.myGuid == _ctx.activeField ? (openBlock(), createElementBlock("div", _hoisted_5, [
                createVNode(_component_action_button, {
                  clickmode: true,
                  small: true,
                  type: "literal",
                  guid: $props.guid,
                  onActionButtonCommand: $options.actionButtonCommand
                }, null, 8, ["guid", "onActionButtonCommand"])
              ])) : createCommentVNode("", true)
            ]),
            _: 1
          })
        ], 64)) : createCommentVNode("", true)
      ], 64)) : (openBlock(), createElementBlock("div", _hoisted_6, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($options.literalValues, (lValue) => {
          return openBlock(), createElementBlock("div", {
            class: "literal-holder",
            onClick: ($event) => $options.focusClick(lValue)
          }, [
            createBaseVNode("div", _hoisted_8, [
              _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-shortcode-display-mode") == false ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-show-field-labels") ? (openBlock(), createElementBlock("div", _hoisted_9, toDisplayString$2($props.structure.propertyLabel), 1)) : createCommentVNode("", true)
              ], 64)) : createCommentVNode("", true),
              createBaseVNode("form", _hoisted_10, [
                _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-shortcode-display-mode") == true ? (openBlock(), createElementBlock("div", _hoisted_11, [
                  createBaseVNode("div", {
                    class: "bfcode-display-mode-holder-label",
                    title: $props.structure.propertyLabel
                  }, toDisplayString$2(_ctx.profileStore.returnBfCodeLabel($props.structure)), 9, _hoisted_12),
                  createBaseVNode("div", _hoisted_13, [
                    withDirectives(createBaseVNode("textarea", {
                      class: normalizeClass(["literal-textarea", "can-select", { "bfcode-textarea": _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-shortcode-display-mode") }]),
                      "onUpdate:modelValue": ($event) => lValue.value = $event,
                      onKeydown: _cache[7] || (_cache[7] = withKeys(withModifiers((...args) => _ctx.submitField && _ctx.submitField(...args), ["prevent"]), ["enter"])),
                      autocomplete: "off",
                      onFocusin: _cache[8] || (_cache[8] = (...args) => $options.focused && $options.focused(...args)),
                      onBlur: _cache[9] || (_cache[9] = (...args) => $options.blured && $options.blured(...args)),
                      onInput: _cache[10] || (_cache[10] = (...args) => $options.valueChanged && $options.valueChanged(...args)),
                      onKeyup: _cache[11] || (_cache[11] = (...args) => $options.navKey && $options.navKey(...args)),
                      ref_for: true,
                      ref: "input_" + lValue["@guid"],
                      "data-guid": lValue["@guid"]
                    }, null, 42, _hoisted_14), [
                      [vModelText, lValue.value]
                    ])
                  ])
                ])) : withDirectives((openBlock(), createElementBlock("textarea", {
                  key: 1,
                  class: normalizeClass(["literal-textarea", "can-select", {}]),
                  "onUpdate:modelValue": ($event) => lValue.value = $event,
                  onKeydown: _cache[12] || (_cache[12] = withKeys(withModifiers((...args) => _ctx.submitField && _ctx.submitField(...args), ["prevent"]), ["enter"])),
                  autocomplete: "off",
                  onFocusin: _cache[13] || (_cache[13] = (...args) => $options.focused && $options.focused(...args)),
                  onBlur: _cache[14] || (_cache[14] = (...args) => $options.blured && $options.blured(...args)),
                  onInput: _cache[15] || (_cache[15] = (...args) => $options.valueChanged && $options.valueChanged(...args)),
                  onKeyup: _cache[16] || (_cache[16] = (...args) => $options.navKey && $options.navKey(...args)),
                  ref_for: true,
                  ref: "input_" + lValue["@guid"],
                  "data-guid": lValue["@guid"]
                }, null, 40, _hoisted_15)), [
                  [vModelText, lValue.value]
                ])
              ])
            ]),
            createVNode(Transition, { name: "action" }, {
              default: withCtx(() => [
                _ctx.showActionButton && $options.myGuid == _ctx.activeField ? (openBlock(), createElementBlock("div", _hoisted_16, [
                  createVNode(_component_action_button, {
                    type: "literal",
                    fieldGuid: lValue["@guid"],
                    guid: $props.guid,
                    onActionButtonCommand: $options.actionButtonCommand
                  }, null, 8, ["fieldGuid", "guid", "onActionButtonCommand"])
                ])) : createCommentVNode("", true)
              ]),
              _: 2
            }, 1024)
          ], 8, _hoisted_7);
        }), 256))
      ]));
    }
    const Literal = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1], ["__scopeId", "data-v-688979c3"]]);
    const _sfc_main = {
      name: "Main",
      components: {
        // EditLiteralComponent,
        // EditSimpleLookupComponent,
        // EditTemplateRefComponent,
        // EditComplexLookupComponent,
        // EditMetaComponent,
        // // EditAdminComponent,
        // VueJsonPretty
        Ref,
        LookupComplex,
        LookupSimple,
        Literal
      },
      props: {
        guid: String,
        level: Number,
        propertyPath: Array,
        inheritedStructure: Object,
        // this is the sturcture passed to it from its parents, we use this one if it is not the first level of the hierarchy
        nested: Boolean,
        id: String,
        parentId: String
        // structure: Object,
        // parentStructure: Array,
        // parentStructureObj: Object,
        // isMini: Boolean,
        // profileCompoent: String,
        // profileName: String,
        // activeTemplate: Object,
        // parentURI: String,
        // ptGuid: String,
        // dynamic: String,
      },
      data: function() {
        return {
          displayDebug: false
          // useKey: short.generate(),
          // levelPlusOne: this.plusOne(this.level),
          // is a lookup url require a simple or complex lookup interface, and its options
          // lookupType:config.lookupConfig
        };
      },
      computed: {
        // other computed properties
        // ...
        // gives access to this.counterStore and this.userStore
        ...mapStores(useProfileStore),
        ...mapStores(usePreferenceStore),
        // returns the structure from the state
        ...mapState(useProfileStore, {
          structure(store) {
            if (typeof this.inheritedStructure === "undefined") {
              return store.returnStructureByGUID(this.guid);
            } else {
              return this.inheritedStructure;
            }
          }
        }),
        ...mapState(useConfigStore, ["lookupConfig"]),
        // ...mapState(useProfileStore, ['returnStructureByGUID2']),
        // ...mapState(usePreferenceStore, ['styleDefault']),
        // gives read access to this.count and this.double
        // ...mapState(usePreferenceStore, ['profilesLoaded']),
        // ...mapState(useProfileStore, ['profilesLoaded','activeProfile']),
        componentType() {
          if (this.structure.propertyURI == "http://id.loc.gov/ontologies/bibframe/hasInstance") {
            return "META";
          }
          if (this.structure.propertyURI == "http://id.loc.gov/ontologies/bibframe/instanceOf") {
            return "META";
          }
          if (this.structure.propertyURI == "http://id.loc.gov/ontologies/bibframe/hasItem") {
            return "HIDE";
          }
          if (this.structure.valueConstraint.valueTemplateRefs.length > 0) {
            return "REF";
          }
          if (this.structure.type === "literal") {
            return "LITERAL";
          }
          let type = "SIMPLE";
          if (this.structure.valueConstraint.useValuesFrom.length == 0)
            return null;
          this.structure.valueConstraint.useValuesFrom.forEach((cs) => {
            if (this.lookupConfig[cs] && this.lookupConfig[cs].type.toLowerCase() == "complex") {
              type = "COMPLEX";
            }
          });
          return type;
        }
      },
      // computed: mapState({
      //   settingsDisplayMode: 'settingsDisplayMode',
      //   settingsLeftMenuEnriched: 'settingsLeftMenuEnriched',
      // }),
      methods: {
        buildPropertyPath: function(currentPath) {
          if (!currentPath) {
            currentPath = [];
          }
          if (this.level == 1) {
            currentPath = currentPath.filter((v2) => {
              return v2.level == 0;
            });
          }
          currentPath = currentPath.filter((v2) => {
            return v2.level < this.level;
          });
          let currentUris = currentPath.map((v2) => {
            return v2.propertyURI;
          });
          if (currentUris.indexOf(this.structure.propertyURI) == -1) {
            currentPath.push({ level: this.level, propertyURI: this.structure.propertyURI });
          }
          return currentPath;
        },
        plusOne: function(val) {
          return val + 1;
        }
        // prettifyXml: uiUtils.prettifyXml,
        // showDupeRemove: function(){
        //   let noControls = [
        //     'http://id.loc.gov/ontologies/bibframe/hasInstance',
        //     'http://id.loc.gov/ontologies/bibframe/instanceOf',
        //     'http://id.loc.gov/ontologies/bibframe/hasItem'
        //   ]
        //   if (noControls.indexOf(this.structure.propertyURI)>-1){
        //     return false
        //   }      
        //   return true
        // },
        // toggleDebug: function(){
        //   if (this.displayDebug){this.displayDebug=false}else{this.displayDebug=true}
        // },
        // duplicateProperty: function(){
        //   this.$store.dispatch("duplicateProperty", { self: this, id: this.profileCompoent, profile:this.profileName }).then(() => {
        //   })   
        // },
        // removeProperty: function(){
        //   const answer = window.confirm('Are you sure you want to remove the property?')
        //   if (answer) {
        //     this.$store.dispatch("removeProperty", { self: this, id: this.profileCompoent, profile:this.profileName }).then(() => {
        //     })         
        //   } else {
        //     return false
        //   }
        // },
      }
    };
    const _hoisted_1 = ["id"];
    function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Ref = resolveComponent("Ref");
      const _component_LookupComplex = resolveComponent("LookupComplex");
      const _component_LookupSimple = resolveComponent("LookupSimple");
      const _component_Literal = resolveComponent("Literal");
      return $options.componentType != "META" ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass([{ "component": $props.level == 0, "inline-mode": _ctx.preferenceStore.returnValue("--b-edit-main-splitpane-edit-inline-mode") }]),
        id: `edit_${$props.parentId}_${$props.id}`
      }, [
        $options.componentType === "REF" ? (openBlock(), createBlock(_component_Ref, {
          key: 0,
          propertyPath: $options.buildPropertyPath($props.propertyPath),
          level: $props.level + 1,
          structure: _ctx.structure,
          guid: $props.guid
        }, null, 8, ["propertyPath", "level", "structure", "guid"])) : createCommentVNode("", true),
        $options.componentType === "COMPLEX" ? (openBlock(), createBlock(_component_LookupComplex, {
          key: 1,
          propertyPath: $options.buildPropertyPath($props.propertyPath),
          level: $props.level + 1,
          structure: _ctx.structure,
          guid: $props.guid
        }, null, 8, ["propertyPath", "level", "structure", "guid"])) : createCommentVNode("", true),
        $options.componentType === "SIMPLE" ? (openBlock(), createBlock(_component_LookupSimple, {
          key: 2,
          propertyPath: $options.buildPropertyPath($props.propertyPath),
          level: $props.level + 1,
          structure: _ctx.structure,
          guid: $props.guid
        }, null, 8, ["propertyPath", "level", "structure", "guid"])) : createCommentVNode("", true),
        $options.componentType === "LITERAL" ? (openBlock(), createBlock(_component_Literal, {
          key: 3,
          propertyPath: $options.buildPropertyPath($props.propertyPath),
          level: $props.level + 1,
          structure: _ctx.structure,
          guid: $props.guid
        }, null, 8, ["propertyPath", "level", "structure", "guid"])) : createCommentVNode("", true)
      ], 10, _hoisted_1)) : createCommentVNode("", true);
    }
    const Main = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__scopeId", "data-v-31d7123f"]]);
    const i18n = vueI18n_cjs.createI18n({
      locale: "en",
      // set locale
      // fallbackLocale: 'en', // set fallback locale
      messages: i18nMessages
      // set locale messages
    });
    const app = createApp(App);
    app.component("Main", Main);
    const vfm = zo$2();
    app.use(vfm);
    app.use(createPinia());
    app.use(router);
    app.use(i18n);
    app.use(qt);
    app.mount("#app");
  }
});
export default require_index_001();
//# sourceMappingURL=index-JG6QQx_o.js.map
