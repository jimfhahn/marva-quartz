import {useConfigStore} from "../stores/config";
import {useProfileStore} from "../stores/profile";
import {usePreferenceStore} from "../stores/preference";
import utilsRDF from './utils_rdf';
import utilsMisc from './utils_misc';
import utilsNetwork from './utils_network';
import utilsProfile from './utils_profile';
import { parse as parseEDTF } from 'edtf'
import { md5 } from "hash-wasm";

const escapeHTML = str => str.replace(/[&<>'"]/g,
  tag => ({
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      "'": '&#39;',
      '"': '&quot;'
    }[tag]));

// Formats an XML string with indentation for easier reading
const formatXML = function (xml, tab = '\t', nl = '\n') {
    if (!xml) {
        return 'No XML';
    }
    let formatted = '', indent = '';
    const nodes = xml.slice(1, -1).split(/>\s*</);
    if (nodes[0][0] === '?') {
        formatted += '<' + nodes.shift() + '>' + nl;
    }
    for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (node[0] === '/') {
            indent = indent.slice(tab.length); // decrease indent
        }
        formatted += indent + '<' + node + '>' + nl;
        if (node[0] !== '/' && node[node.length - 1] !== '/' && node.indexOf('</') === -1) {
            indent += tab; // increase indent
        }
    }
    return formatted;
};

// Returns a DOMParser instance using the built-in browser API
const returnDOMParser = function () {
    let p;
    try {
        p = new DOMParser();
    } catch (error) {
        p = new window.DOMParser();
    }
    return p;
};


const utilsExport = {


  checkForEDTFDatatype: null,
  lastGoodXMLBuildProfile: null,
  lastGoodXMLBuildProfileTimestamp: null,

	// ignore these beause they control the shape of the xml and we want to control that
	ignoreProperties: [

		'http://id.loc.gov/ontologies/bibframe/instanceOf',
		'http://id.loc.gov/ontologies/bibframe/hasItem',
		'http://id.loc.gov/ontologies/bibframe/itemOf',
		'http://id.loc.gov/ontologies/bibframe/hasInstance',
		'http://id.loc.gov/ontologies/bibframe/Work'

	],

  /**
  * if passed full uri like http://id.loc.gov/ontology/bibframe/xxx will convert to a prefixed bf:xxx
  *
  * @param {string} uri - the uri to convert
  * @return {string}
  */
  namespaceUri: function(uri){
		for (let ns in utilsRDF.namespace){
			let nsuri = utilsRDF.namespace[ns]
			if (uri.includes(nsuri)){
				return uri.replace(nsuri,`${ns}:`)
			}
		}
	},

  /**
  * if passed a prefix like bf:xxx it will expand it to http://id.loc.gov/ontology/bibframe...
  *
  * @param {string} passedNS - the prefixed element/prop
  * @return {string}
  */
	UriNamespace: function(passedNS){
		for (let ns in utilsRDF.namespace){
			let nsuri = utilsRDF.namespace[ns]
			if (passedNS.startsWith(`${ns}:`)){
				return passedNS.replace(`${ns}:`,nsuri)
			}
		}
	},

  /**
  * creates a element with createElementNS using the correct namespace.
  * Now supports two signatures:
  *   a) createElByBestNS(qualifiedName)
  *   b) createElByBestNS(namespaceURI, localName)
  *
  * @param {string} nsOrQualified - either a qualified name or a namespace URI.
  * @param {string} [maybeLocal] - if provided, is the local name.
  * @return {Element|Text}
  */
  createElByBestNS: function(nsOrQualified, maybeLocal) {
    // Special case for Barcode element creation
    if (nsOrQualified === 'bf:Barcode' || 
        nsOrQualified === 'http://id.loc.gov/ontologies/bibframe/Barcode') {
      try {
        console.log('Creating barcode element with special handling');
        // Create the barcode element directly with proper namespace
        const barcodeEl = document.createElementNS(utilsRDF.namespace.bf, "bf:Barcode");
        return barcodeEl;
      } catch (error) {
        console.error("Error creating barcode element:", error);
        // Continue with normal handling as fallback
      }
    }
    
    // Even more defensive coding to handle undefined values
    if (nsOrQualified === undefined || nsOrQualified === null) {
      console.error("createElByBestNS: nsOrQualified is undefined or null", new Error().stack);
      return document.createElement("div"); // safe fallback
    }
    
    // --- New overload support ---
    if (arguments.length === 2) {
      let ns = nsOrQualified;
      
      // Handle undefined maybeLocal
      if (maybeLocal === undefined || maybeLocal === null) {
        console.error("createElByBestNS: maybeLocal is undefined or null", ns);
        return document.createElement("div"); // safe fallback
      }
      
      let localName = String(maybeLocal).trim();
      let prefix = "";
      
      for (let p in utilsRDF.namespace) {
        if (utilsRDF.namespace[p] === ns) { prefix = p; break; }
      }
      
      let qualifiedName = prefix ? `${prefix}:${localName}` : localName;
      
      try {
        return document.createElementNS(ns, qualifiedName);
      } catch (error) {
        console.error("Error in createElementNS:", error, "ns:", ns, "qualifiedName:", qualifiedName);
        return document.createElement("div"); // safe fallback
      }
    }
    // --- End overload support ---

    let elStr = nsOrQualified;
    if (!elStr || typeof elStr !== "string") {
      console.error("createElByBestNS: invalid elStr", elStr);
      return document.createElement("div"); // safe fallback
    }
    elStr = elStr.trim().replace(/\s+/g, '');
    // Updated numeric check:
    if (/^\d[\d\s]*$/.test(elStr)) {
      console.warn("createElByBestNS: elStr appears numeric/index only, returning text node", elStr);
      return document.createTextNode(escapeHTML(elStr));
    }
    // If elStr contains "://", follow URI logic
    if (elStr.includes("://")) {
      if (elStr === 'http://www.loc.gov/mads/rdf/v1#') {
        elStr = 'http://www.loc.gov/mads/rdf/v1#Authority';
      }
      elStr = elStr.replace('https://', 'http://');
      if (!elStr.startsWith('http')) {
        elStr = this.UriNamespace(elStr);
        if (!elStr || typeof elStr !== "string") {
          console.error("createElByBestNS: UriNamespace returned invalid value", elStr);
          return document.createElement("div");
        }
      }
      for (let ns of Object.keys(utilsRDF.namespace)) {
        if (elStr.startsWith(utilsRDF.namespace[ns])) {
          let tag = this.namespaceUri(elStr);
          if (!tag || typeof tag !== 'string') {
            console.error("createElByBestNS: namespaceUri returned invalid tag for", elStr);
            return document.createElement("div");
          }
          return document.createElementNS(utilsRDF.namespace[ns], tag);
        }
      }
      console.error("createElByBestNS: could not find namespace for", elStr);
      return document.createElement("div");
    }
    // If elStr does not contain "://", check if it is a qualified name like "bf:assigner"
    else if (elStr.includes(":")) {
      let parts = elStr.split(":");
      let prefix = parts[0];
      if (utilsRDF.namespace[prefix]) {
        return document.createElementNS(utilsRDF.namespace[prefix], elStr);
      } else {
        console.error("createElByBestNS: unknown prefix", prefix);
        return document.createElement("div");
      }
    }
    else {
      console.warn("createElByBestNS: elStr does not look like a valid URI or qualified name", elStr);
      return document.createElement("div");
    }
  },

    /**
   * Serializes an XML node to a string, preserving all namespace declarations
   * @param {Element} node - The XML node to serialize
   * @return {String} The serialized XML string with namespace declarations preserved
   */
    serializePreservingNamespaces: function(node) {
      // Create a new serializer that preserves namespaces
      const serializer = new XMLSerializer();
      let xmlString = serializer.serializeToString(node);
      
      // Ensure rdfs namespace declaration is present in rdfs:label elements
      xmlString = xmlString.replace(/<rdfs:label(?![^>]*xmlns:rdfs=)/g, 
        '<rdfs:label xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"');
      
      // Fix namespace declarations - add spaces between them
      xmlString = xmlString.replace(/xmlns:[a-z0-9]+="[^"]+"/g, match => match + ' ');
      
      // Fix any double quotes that might appear before a namespace
      xmlString = xmlString.replace(/"xmlns:/g, ' xmlns:');
      
      // Remove any extra spaces in closing tags
      xmlString = xmlString.replace(/\s+\/>/g, '/>');
      
      return xmlString;
    },

  /**
  * Creates a properly namespaced rdfs:label element
  * 
  * @param {string} text - The label text content
  * @return {Element} - The properly namespaced rdfs:label element
  */
  createRdfsLabel: function(text) {
    try {
      // Create the element with proper namespace
      const labelEl = document.createElementNS(utilsRDF.namespace.rdfs, "rdfs:label");
      
      // Set text content directly (no resource attribute)
      labelEl.textContent = text || '';
      
      return labelEl;
    } catch (error) {
      console.error("Error creating rdfs:label:", error);
      // Create fallback element if there's an error
      const fallbackEl = document.createElement("rdfs:label");
      fallbackEl.setAttribute("xmlns:rdfs", utilsRDF.namespace.rdfs);
      fallbackEl.textContent = text || '';
      return fallbackEl;
    }
  },

  /**
  * Formats an agent entity from a Wikidata source for RDF output
  * @param {Object} agent - The agent entity object
  * @return {String} - The formatted RDF for the agent
  */
  formatAgentEntity: function(agent) {
    // Check if this is a Wikidata entity that should use MADS RDF types
    if (agent.uri && agent.uri.includes('wikidata.org')) {
      // Determine the entity type (PersonalName is default for agents if not specified)
      const entityType = agent.type || 'PersonalName';
      const rdfType = agent.typeFull || `http://www.loc.gov/mads/rdf/v1#${entityType}`;
      
      // Modified to ensure xmlns:rdfs is properly included and no extra whitespace is added
      return `<madsrdf:${entityType} rdf:about="${agent.uri}">
  <rdf:type rdf:resource="${rdfType}" />
  <rdfs:label xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#">${agent.label || agent.title || ''}</rdfs:label>
</madsrdf:${entityType}>`;
    }
    
    // For non-Wikidata entities, use the standard bf:Agent format
    // Also add the namespace declaration here for consistency
    return `<bf:Agent rdf:about="${agent.uri}">
  <rdf:type rdf:resource="${agent.typeFull || 'http://id.loc.gov/ontologies/bibframe/Agent'}" />
  <rdfs:label xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#">${agent.label || agent.title || ''}</rdfs:label>
</bf:Agent>`;
  },

  /**
  * Generates RDF markup for a contribution
  * @param {Object} contribution - The contribution object
  * @param {String} contributionType - The type of contribution (Primary, etc.)
  * @return {String} - The formatted RDF for the contribution
  */
  formatContribution: function(contribution, contributionType = 'Contribution') {
    let agentMarkup;
    
    if (contribution.agent) {
      // Use our specific formatter for agents
      agentMarkup = this.formatAgentEntity(contribution.agent);
    } else {
      // Add xmlns:rdfs for consistency even in the fallback
      agentMarkup = '<bf:Agent><rdfs:label xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#">Unknown</rdfs:label></bf:Agent>';
    }
    
    // Ensure we properly preserve the XML structure when embedding
    return `<bf:${contributionType}>
  <bf:agent>
    ${agentMarkup}
  </bf:agent>
  ${contribution.role ? `<bf:role><bf:Role rdf:about="${contribution.role}"/></bf:role>` : ''}
</bf:${contributionType}>`;
  },

  /**
  * A helper function that will build blank node based on userValue obj
  *
  * @param {obj} userValue - the uservalue to test
  * @param {string} property - the property uri
  * @return {Element} - The created blank node element
  */
  createBnode: function(userValue, property) {
    // Add defensive check for undefined userValue
    if (!userValue) {
      console.error("createBnode: userValue is undefined or null", new Error().stack);
      return document.createElement("div"); // safe fallback
    }
    
    // some special cases here
    if (property == 'http://id.loc.gov/ontologies/bibframe/agent') {
      // if it is an agent create the Agent bnode and just add the type to it as rdf:type
      let bnode = this.createElByBestNS('bf:Agent');
      if (userValue['@id']) {
        bnode.setAttributeNS(utilsRDF.namespace.rdf, 'rdf:about', userValue['@id']);
      }
      
      // Check if @type exists before using it
      if (userValue['@type']) {
        let rdftype = this.createElByBestNS('rdf:type');
        rdftype.setAttributeNS(utilsRDF.namespace.rdf, 'rdf:resource', userValue['@type']);
        bnode.appendChild(rdftype);
      } else {
        console.warn("createBnode: agent missing @type");
      }
      
      if (userValue['@parseType']) {
        bnode.setAttribute('rdf:parseType', userValue['@parseType']);
      }
      return bnode;
    } else if (userValue['@type'] && userValue['@type'].includes('id.loc.gov/vocabulary/mnotetype')) {
      // if it is this specific note vocabulary type then create a bf:Note with a RDF type in it
      let bnode = this.createElByBestNS('bf:Note');
      let rdftype = this.createElByBestNS('rdf:type');
      rdftype.setAttributeNS(utilsRDF.namespace.rdf, 'rdf:resource', userValue['@type']);
      bnode.appendChild(rdftype);
      return bnode;
    } else {
      // CRITICAL FIX: Check for missing @type and provide fallback
      if (!userValue['@type']) {
        console.warn("createBnode: missing @type in userValue, using fallback element", property);
        
        // Simple static mapping for common properties
        const fallbackMap = {
          'http://id.loc.gov/ontologies/bibframe/mainTitle': 'bf:Title',
          'http://id.loc.gov/ontologies/bibframe/title': 'bf:Title',
          'http://id.loc.gov/ontologies/bflc/nonSortNum': 'bf:Title',
          'http://id.loc.gov/ontologies/bibframe/Barcode': 'bf:Barcode',
          'http://id.loc.gov/ontologies/bibframe/barcode': 'bf:Barcode',
          'http://www.w3.org/2000/01/rdf-schema#label': 'bf:Label',
          'rdfs:label': 'bf:Label'
        };
        
        // Use mapping or default to Resource
        let fallbackType = fallbackMap[property] || 'bf:Resource';
        console.log(`Using fallback type ${fallbackType} for property ${property}`);
        
        try {
          let bnode = this.createElByBestNS(fallbackType);
          if (userValue['@id']) {
            bnode.setAttributeNS(utilsRDF.namespace.rdf, 'rdf:about', userValue['@id']);
          }
          if (userValue['@parseType']) {
            bnode.setAttribute('rdf:parseType', userValue['@parseType']);
          }
          return bnode;
        } catch(e) {
          console.error("Failed to create fallback bnode", e);
          return document.createElement("div"); // emergency fallback
        }
      }
      
      // Original code path when @type exists
      try {
        let bnode = this.createElByBestNS(userValue['@type']);
        if (userValue['@id']) {
          bnode.setAttributeNS(utilsRDF.namespace.rdf, 'rdf:about', userValue['@id']);
        }
        if (userValue['@parseType']) {
          bnode.setAttribute('rdf:parseType', userValue['@parseType']);
        }
        return bnode;
      } catch(e) {
        console.error("Failed to create bnode with @type", userValue['@type'], e);
        return document.createElement("div"); // emergency fallback
      }
    }
  },

  /**
  * A helper function that will build a literal value element
  *
  * @param {string} property - the property uri
  * @param {obj} userValue - the uservalue to test
  * @return {Element|boolean} - Element or false if no valid element could be created
  */
  createLiteral: function(property, userValue) {
    // Defensive coding - check for undefined/null values
    if (property === undefined || property === null) {
      console.error("createLiteral: property is undefined or null");
      return false;
    }
    if (userValue === undefined || userValue === null) {
      console.error("createLiteral: userValue is undefined or null");
      return false;
    }

    // Special case for barcode values - process these first
    if (property === 'http://id.loc.gov/ontologies/bibframe/Barcode' || 
        property === 'bf:Barcode' || 
        (typeof property === 'string' && property.toLowerCase().includes('barcode'))) {
      console.log('Creating proper barcode structure directly');
      try {
        const barcodeEl = this.createElByBestNS('bf:Barcode');
        
        // Create rdf:value element to hold the barcode number
        const valueEl = this.createElByBestNS('rdf:value');
        
        // Extract the barcode value - handle various possible structures
        let barcodeValue = '';
        if (typeof userValue === 'string') {
          barcodeValue = userValue;
        } else if (typeof userValue === 'number') {
          barcodeValue = userValue.toString();
        } else if (userValue && typeof userValue === 'object') {
          // Try to find the barcode value in the object
          if (userValue['bf:Barcode']) {
            barcodeValue = userValue['bf:Barcode'];
          } else if (userValue['http://id.loc.gov/ontologies/bibframe/Barcode']) {
            barcodeValue = userValue['http://id.loc.gov/ontologies/bibframe/Barcode'];
          } else if (userValue['rdf:value']) {
            barcodeValue = userValue['rdf:value'];
          } else {
            // Look for any property that might contain the barcode value
            for (const key in userValue) {
              if (typeof userValue[key] === 'string' && !key.startsWith('@')) {
                barcodeValue = userValue[key];
                break;
              }
            }
          }
        }
        
        if (barcodeValue) {
          valueEl.textContent = barcodeValue;
          if (barcodeEl && barcodeEl.nodeType && valueEl && valueEl.nodeType) {
            barcodeEl.appendChild(valueEl);
            console.log('Created barcode structure with value:', barcodeValue);
          } else {
            console.error("Invalid nodes for barcode structure:", barcodeEl, valueEl);
            return document.createElement("div"); // Return fallback
          }
        }
        
        return barcodeEl;
      } catch (error) {
        console.error("Error creating barcode structure:", error);
        // Return a fallback element rather than continuing to avoid the appendChild error
        return document.createElement("div");
      }
    }
    
    // Handle numeric properties (only after barcode check)
    if (typeof property === 'number' || /^\d+$/.test(property)) {
      console.warn("createLiteral: property is numeric, using createElByBestNS to create safe text node");
      let textNode = this.createElByBestNS(property);
      if (typeof userValue === 'string' || typeof userValue === 'number') {
        textNode.textContent = userValue;
      }
      return textNode;
    }
    
    // Standard literal creation for non-barcode values
    try {
      let pEl;
      // Ensure property is a string before any methods are called on it
      if (typeof property === 'string') {
        pEl = this.createElByBestNS(property);
      } else {
        console.warn("createLiteral: property is not a string:", property);
        return false;
      }
      
      // Extract value from userValue
      let val = userValue;
      
      // If userValue is an object, try to extract the value
      if (userValue && typeof userValue === 'object') {
        if (userValue[property]) {
          val = userValue[property];
        } else if (userValue['rdf:value']) {
          val = userValue['rdf:value'];
        } else if (userValue['@id']) {
          pEl.setAttributeNS(utilsRDF.namespace.rdf, 'rdf:resource', userValue['@id']);
          return pEl;
        } else {
          // Look for any property that might contain a value
          let found = false;
          for (const key in userValue) {
            if (typeof userValue[key] === 'string' && !key.startsWith('@')) {
              val = userValue[key];
              found = true;
              break;
            }
          }
          if (!found) {
            console.warn("createLiteral: could not extract value from userValue:", userValue);
            return false;
          }
        }
      }
      
      // Set the text content
      if (typeof val === 'string' || typeof val === 'number') {
        pEl.textContent = val;
        return pEl;
      } else if (val && typeof val === 'object' && val['@value']) {
        pEl.textContent = val['@value'];
        return pEl;
      } else {
        console.warn("createLiteral: value is not a string or number:", val);
        return false;
      }
    } catch (error) {
      console.error("Error in createLiteral:", error);
      return false;
    }
  },

  /**
  * A helper function that will test if a userValue is a bnode
  *
  * @param {obj} userValue - the uservalue to test
  * @return {boolean}
  */
	isBnode: function(userValue){
		if (userValue['@type']){
			return true
		}
		return false
	},

  /**
  * Some structures share the same predicate
  *
  * @param {string} key - the uri
  * @return {boolean}
  */
	needsNewPredicate: function(key) {
		if (key == 'http://www.loc.gov/mads/rdf/v1#componentList'){
			return false
		}
		return true
	},

  /**
  * A helper function that will test if a userValue has a value
  *
  * @param {obj} userValue - the uservalue to test
  * @return {boolean}
  */
	hasUserValue: function(userValue){
		for (let key in userValue){
			if (key == '@id' || key.includes('http://') || key.includes('https://')){
				return true
			}
		}
		// this part looks to see if maybe it is an array of literals, like a top level propert like Statement of Work, etc.
		if (Array.isArray(userValue)){
			let allHaveCorrectKeys = true;
			for (let v of userValue){
				for (let key in v){
					if (!key.startsWith('@') && !key.startsWith('http://') && !key.startsWith('https://')){
						allHaveCorrectKeys = false
					}
				}
			}
			if (allHaveCorrectKeys){ return true }
		}
		return false
	},

  /**
  * returns the just the item portion of the profile
  *
  * @param {string} URI - the uri of the instance to look for it's items
  * @param {obj} profile - profile
  * @param {obj} tleLookup - the lookup created out of the export XML process
  * @return {obj}
  */
	returnHasItem: function(URI,profile,tleLookup){
		let results = []
		let parser = returnDOMParser()
		for (let rt in profile.rt){
			if (profile.rt[rt].itemOf && profile.rt[rt].itemOf == URI){
				if (tleLookup['Item'][profile.rt[rt].URI].getElementsByTagName('bf:itemOf').length==0){
					let hasItem = this.createElByBestNS('bf:itemOf')
					hasItem.setAttributeNS(utilsRDF.namespace.rdf, 'rdf:resource', profile.rt[rt].itemOf)
					tleLookup['Item'][profile.rt[rt].URI].appendChild(hasItem)
				}
				let item = (new XMLSerializer()).serializeToString(tleLookup['Item'][profile.rt[rt].URI])
				item = parser.parseFromString(item, "text/xml").children[0]
				results.push(item)
			}
		}
		return results
	},

  /**
  * returns the just the work portion of the profile
  *
  * @param {string} instanceURI - the uri of the instance
  * @param {obj} profile - profile
  * @param {obj} tleLookup - the lookup created out of the export XML process
  * @return {obj}
  */
	returnWorkFromInstance: function(instanceURI,profile,tleLookup){
		let parser = returnDOMParser()
		let results = null
		for (let rt in profile.rt){
			if (profile.rt[rt].instanceOf && profile.rt[rt].URI == instanceURI){
				results = (new XMLSerializer()).serializeToString(tleLookup['Work'][profile.rt[rt].instanceOf])
				results = parser.parseFromString(results, "text/xml").children[0]
			}
		}
		// if that didnt work just pick the first work
		if (!results){
			for (let wUri in tleLookup['Work']){
				results = tleLookup['Work'][wUri]
				break
			}
		}
		return results
	},

  /**
   * Builds the admin metadata XML ensuring the assigner element is correctly structured.
   * The assigner element is built with an Organization element containing the label.
   * @param {object} userValue - The user value containing catalogerId info
   * @return {Element} - The adminMetadata element
   */    
  buildAdminMetadata: function(userValue) {
    const adminMetadata = this.createElByBestNS('bf:adminMetadata');
    const adminContainer = this.createElByBestNS('bf:AdminMetadata');
    
    // Add date element
    const dateEl = this.createElByBestNS('bf:date');
    dateEl.textContent = new Date().toISOString();
    adminContainer.appendChild(dateEl);
    
    // Add catalogerId element if available
    if (userValue && userValue['http://id.loc.gov/ontologies/bflc/catalogerId'] && 
        userValue['http://id.loc.gov/ontologies/bflc/catalogerId'][0] && 
        userValue['http://id.loc.gov/ontologies/bflc/catalogerId'][0]['http://id.loc.gov/ontologies/bflc/catalogerId']) {
        
      const catalogerIdEl = this.createElByBestNS('bflc:catalogerId');
      catalogerIdEl.textContent = userValue['http://id.loc.gov/ontologies/bflc/catalogerId'][0]['http://id.loc.gov/ontologies/bflc/catalogerId'];
      adminContainer.appendChild(catalogerIdEl);
    }
    
    adminMetadata.appendChild(adminContainer);
    return adminMetadata;
  },

  /**   
   * Creates a default assigner element for admin metadata with proper organization structure
   * @return {Element} - The properly structured assigner element
   */ 
  buildDefaultAssignerElement: function() {
    const assignerEl = this.createElByBestNS('bf:assigner');
    const orgEl = this.createElByBestNS('bf:Organization');
    // Always set rdf:about and label
    orgEl.setAttributeNS(utilsRDF.namespace.rdf, 'rdf:about', 'http://id.loc.gov/vocabulary/organizations/pu');
    const labelEl = this.createRdfsLabel(useConfigStore().defaultAssignerLabel || "University of Pennsylvania, Van Pelt-Dietrich Library");
    orgEl.appendChild(labelEl);
    assignerEl.appendChild(orgEl);
    // Debug: log assigner structure
    // console.log('buildDefaultAssignerElement:', assignerEl.outerHTML);
    return assignerEl;
  },

  /** 
   * Clean up an assigner element to ensure it has no unwanted content
   * @param {Element} assignerEl - The assigner element to clean
   */ 
  cleanAssignerElement: function(assignerEl) {
    if (!assignerEl) return;
    const orgEls = assignerEl.querySelectorAll('*[local-name()="Organization"]');
    orgEls.forEach(orgEl => {
      // Remove text nodes that contain only zeros or whitespace
      Array.from(orgEl.childNodes).forEach(node => {
        if (node.nodeType === Node.TEXT_NODE) {
          const content = node.textContent.trim();
          if (!content || /^[0\s]+$/.test(content)) {
            orgEl.removeChild(node);
          }
        }
      });
      // If Organization has no meaningful content, add a proper label
      if (!orgEl.hasChildNodes() || (orgEl.childNodes.length === 1 && orgEl.firstChild.nodeType === Node.TEXT_NODE && !orgEl.firstChild.textContent.trim())) {
        while (orgEl.firstChild) {
          orgEl.removeChild(orgEl.firstChild);
        }
        const labelEl = document.createElementNS("http://www.w3.org/2000/01/rdf-schema#", "rdfs:label");
        labelEl.textContent = "University of Pennsylvania, Van Pelt-Dietrich Library";
        orgEl.appendChild(labelEl);
      }
    });
  },

  /** 
   * Remove redundant namespace declarations from XML nodes
   * @param {Element} node - The node to process
   * @param {Object} inherited - Inherited namespace declarations
   */ 
  removeRedundantNamespaces: function(node, inherited = {}) {
    if (node.nodeType !== 1) return; // process only element nodes
    let currentInherited = Object.assign({}, inherited);
    let attrsToRemove = [];
    for (let attr of Array.from(node.attributes)) {
      if (attr.name.startsWith("xmlns")) {
        let prefix = attr.name === "xmlns" ? "" : attr.name.split(":")[1];
        if (currentInherited[prefix] && currentInherited[prefix] === attr.value) {
          attrsToRemove.push(attr.name);
        } else {
          currentInherited[prefix] = attr.value;
        }
      }
    }
    attrsToRemove.forEach(name => node.removeAttribute(name));
    Array.from(node.children).forEach(child => this.removeRedundantNamespaces(child, currentInherited));
  },

  /** 
   * Clean organization elements in an XML string
   * @param {string} xmlString - The XML string to clean
   * @return {string} - The cleaned XML string
   */ 
  cleanOrganizationElement: function(xmlString) {
    if (!xmlString) return xmlString;
    try {
      const parser = new DOMParser();
      const doc = parser.parseFromString(xmlString, "application/xml");
      if (doc.getElementsByTagName("parsererror").length) {
        console.error("Cleaning encountered an XML parsing error. Returning original string.");
        return xmlString;
      }
      this.removeRedundantNamespaces(doc.documentElement);
      const assigners = doc.querySelectorAll("bf\\:assigner");
      assigners.forEach(assignerEl => this.cleanAssignerElement(assignerEl));
      return new XMLSerializer().serializeToString(doc);
    } catch (e) {
      console.error("Error when cleaning XML:", e);
      return xmlString;
    }
  },

  /** 
   * Ensures all Organization elements in the XML have proper labels for MARC conversion
   * @param {string} xmlString - The XML to process
   * @return {string} - XML with properly structured Organization elements or original on failure
   */ 
  ensureOrganizationLabels: function(xmlString) {
    if (!xmlString) return xmlString;
    try {
      const parser = new DOMParser();
      const doc = parser.parseFromString(xmlString, "text/xml");
      if (doc.getElementsByTagName("parsererror").length) {
        console.error("XML parsing error in ensureOrganizationLabels.");
        return xmlString;
      }
      const organizations = doc.querySelectorAll("bf\\:Organization");
      organizations.forEach(org => {
        if (org.querySelector("rdfs\\:label")) return;
        const aboutAttr = org.getAttribute('rdf:about');
        if (aboutAttr) {
          let label = null;
          if (aboutAttr === 'http://id.loc.gov/vocabulary/organizations/dlc') {
            label = "United States, Library of Congress";
          } else if (aboutAttr === 'http://id.loc.gov/vocabulary/organizations/dlcmrc') {
            label = "United States, Library of Congress, Network Development and MARC Standards Office";
          } else if (aboutAttr === 'http://id.loc.gov/vocabulary/organizations/pu') {
            label = "University of Pennsylvania, Van Pelt-Dietrich Library";
          }
          if (label) {
            const labelEl = this.createRdfsLabel(label);
            org.appendChild(labelEl);
          }
        }
      });
      return new XMLSerializer().serializeToString(doc);
    } catch (e) {
      console.error("Error in ensureOrganizationLabels:", e);
      return xmlString;
    }
  },

  /** 
  * Processes profile data and converts it to XML
  * @param {object} profile - the profile to convert to XML
  * @return {Promise<object|boolean>} - XML output object or false on failure
  */ 
  buildXML: async function(profile){
    if (!profile || (profile && Object.keys(profile).length==0)){
      console.warn("Trying to build XML with bad profile:", profile);
      return false;
    }

    // if we are in dev mode let the error bubble, but otherwise catch the error and try to recover
    if (useConfigStore().returnUrls.dev === true){
      return await this.buildXMLProcess(profile);
    } else {
      try {
        let xmlObj = await this.buildXMLProcess(profile);
        this.lastGoodXMLBuildProfile = JSON.parse(JSON.stringify(profile));
        this.lastGoodXMLBuildProfileTimestamp = Math.floor(Date.now() / 1000);
        return xmlObj;
      } catch (error) {
        console.warn("XML Parsing Error:");
        console.warn(error);
        useProfileStore().triggerBadXMLBuildRecovery(this.lastGoodXMLBuildProfile, this.lastGoodXMLBuildProfileTimestamp);
        let profileAsJson;
        try {
          profileAsJson = JSON.stringify(profile,null,2);
        } catch {
          profileAsJson = 'Error stringify-ing profile!';
        }
        let user = `${usePreferenceStore().catInitals}_${usePreferenceStore().catCode}`.replace("/\s/g",'_');
        const filename = `${Math.floor(Date.now() / 1000)}_${user}_` + `${new Date().toDateString()}_${new Date().toTimeString()}`.replaceAll(' ','_').replaceAll(':','-') + '.txt';
        console.warn(error);
        let errorReport = `
        Error: ${error}
        ----------------
        XML Creation Log
        ----------------
        ----End Creation Log----
        ****************
        XML Source = "";
        ****************
        ${(profile.xmlSource) ? profile.xmlSource : 'No Source Found'}
        ***End Source***
        `;
        utilsNetwork.sendErrorReportLog(errorReport,filename,profileAsJson);
        return false;
      }
    }
  },

  /** 
  * The core XML building process that transforms profile data into XML structure
  * @param {object} profile - the profile to convert to XML
  * @return {object} multiple XML strings and metadata
  */ 
  buildXMLProcess: async function(profile){
    // Add validation at the start
    if (!profile || typeof profile !== 'object') {
      console.error("buildXMLProcess: Invalid profile object", profile);
      return {
        xmlDom: document.createElement("rdf:RDF"),
        xmlStringFormatted: "<rdf:RDF/>",
        xlmString: "<rdf:RDF/>",
        bf2Marc: "<rdf:RDF/>",
        xlmStringBasic: "<rdf:RDF/>",
        voidTitle: "",
        voidContributor: "",
        componentXmlLookup: {}
      };
    }

    // keep track of the process for later
    let xmlLog = [];
    let componentXmlLookup = {};

    // keep a copy of the org profile around
    let orginalProfile = profile;
    // cut the ref to the original
    profile = JSON.parse(JSON.stringify(profile));

    let xmlParser = returnDOMParser();
    // these will store the top level elements
    let tleWork = [];
    let tleInstance = [];
    let tleItem = [];

    // we are creating the xml in two formats, create the root node for both
    let rdf = document.createElementNS(utilsRDF.namespace.rdf, "RDF");
    let rdfBasic = document.createElementNS(utilsRDF.namespace.rdf, "RDF");

    // just add all the namespaces into the root element
    for (let ns of Object.keys(utilsRDF.namespace)){
      rdf.setAttributeNS("http://www.w3.org/2000/xmlns/", `xmlns:${ns}`, utilsRDF.namespace[ns]);
      rdfBasic.setAttributeNS("http://www.w3.org/2000/xmlns/", `xmlns:${ns}`, utilsRDF.namespace[ns]);
    }

    // these are elements used to store metadata about the record in the backend
    let xmlVoidDataRtsUsed = [];
    let xmlVoidDataType = [];
    let xmlVoidExternalID = [];
    let xmlVoidDataTitle = "";
    let xmlVoidDataContributor = "";
    let xmlVoidDataLccn = "";
    let tleLookup = {
      Work: {},
      Instance: {},
      Item: {},
      Hub: {}
    };

    for (let rt of profile.rtOrder){
      xmlLog.push(`Processing rt: ${rt}`);

      if (profile.rt[rt].noData){
        xmlLog.push(` - ${rt} has no data, skipping it.`);
        continue;
      }

      let tleArray; // eslint-disable-line
      let rootEl;
      let rootElName;

      if (rt.includes(':Work')){
        tleArray = tleWork;
        rootEl = document.createElementNS(utilsRDF.namespace.bf,"bf:Work");
        rootElName = "Work";
      } else if (rt.includes(':Instance')){
        tleArray = tleInstance;
        rootEl = document.createElementNS(utilsRDF.namespace.bf,"bf:Instance");
        rootElName = "Instance";
      } else if (rt.includes(':Item')){
        tleArray = tleItem;
        rootEl = document.createElementNS(utilsRDF.namespace.bf,"bf:Item");
        rootElName = "Item";
      } else if (rt.endsWith(':Hub')){
        tleArray = tleItem;;
        rootEl = document.createElementNS(utilsRDF.namespace.bf,"bf:Hub");
        rootElName = "Hub";
      } else {
        // don't mess with anything that is not a top level entity in the profile
        xmlLog.push(`Dunno what this part is, skipping ${rt}`);
        continue;
      }

      xmlLog.push(`Building ${rootElName}`);

      if (profile.rt[rt].URI){
        rootEl.setAttributeNS(utilsRDF.namespace.rdf, 'rdf:about', profile.rt[rt].URI);
        xmlLog.push(`Setting URI for this resource rdf:about to: ${profile.rt[rt].URI}`);
        xmlVoidExternalID.push(profile.rt[rt].URI);
      }

      if (profile.rt[rt]['@type']){
        let type = this.createElByBestNS('http://www.w3.org/1999/02/22-rdf-syntax-ns#type');
        type.setAttributeNS(utilsRDF.namespace.rdf, 'rdf:resource', profile.rt[rt]['@type']);
        xmlLog.push(`Setting URI for this resource rdf:resource to: ${profile.rt[rt]['@type']}`);
        rootEl.appendChild(type);
      }

      xmlLog.push(`Looping through the PTs`);

      // Process property templates
      for (let pt of profile.rt[rt].ptOrder){
        // extract the pt, this is the individual component like a <mainTitle>
        let ptObj = profile.rt[rt].pt[pt];
        if (ptObj.deleted){
          continue;
        }

        if (ptObj.deepHierarchy){
          // just take our existing XML and plop it into the root element
          let orgNode = xmlParser.parseFromString(ptObj.xmlSource, "text/xml").children[0];
          rootEl.appendChild(orgNode);
          continue;
        }

        xmlLog.push(`Working on: ${pt}`);

        // Process userValue and create XML elements - THIS IS THE CRITICAL SECTION
        let userValue;
        let userValueSiblings = [];

        // the uservalue could be stored in a few places depending on the nesting
        if (ptObj.userValue[ptObj.propertyURI] && ptObj.userValue[ptObj.propertyURI][0]){
          userValue = ptObj.userValue[ptObj.propertyURI][0];

          let nonGuidProps = Object.keys(ptObj.userValue[ptObj.propertyURI][0]).filter(k => (!k.includes('@') ? true : false));
          if (nonGuidProps.length==1){
            if (typeof ptObj.userValue[ptObj.propertyURI][0][nonGuidProps[0]] == 'string' || 
                typeof ptObj.userValue[ptObj.propertyURI][0][nonGuidProps[0]] == 'number'){
              // does it have more than one?
              if (ptObj.userValue[ptObj.propertyURI].length > 1){
                // set it to the sibling group not the individual
                userValue = ptObj.userValue[ptObj.propertyURI];
              }
            }
          }

          // some top level simpleLookup values could have multiple values
          if (ptObj.userValue[ptObj.propertyURI].length > 1){
            userValueSiblings = JSON.parse(JSON.stringify(ptObj.userValue[ptObj.propertyURI])).slice(1);
          }
        } else if (ptObj.userValue[ptObj.propertyURI]){
          userValue = ptObj.userValue[ptObj.propertyURI];
        } else {
          userValue = ptObj.userValue;
        }

        // clean up bad data
        for (let k of Object.keys(userValue)){
          if (k === 'undefined'){
            delete userValue[k];
          }
        }

        let mostCommonScript = useProfileStore().setMostCommonNonLatinScript();

        // check if we need to process multiple language variants for certain properties
        if ([
          'http://id.loc.gov/ontologies/bibframe/contribution',
          'http://id.loc.gov/ontologies/bibframe/subject',
          'http://id.loc.gov/ontologies/bibframe/geographicCoverage'
        ].indexOf(ptObj.propertyURI) > -1){
          // Process non-latin variants
          // ...existing code for non-Latin processing...
        }

        xmlLog.push(['Set userValue to:', JSON.parse(JSON.stringify(userValue))]);

        // <START> Special handling for usageAndAccessPolicy
        if (ptObj.propertyURI === 'http://id.loc.gov/ontologies/bibframe/usageAndAccessPolicy') {
          console.log('--- Debugging usageAndAccessPolicy Lookup (Attempt 4 - More Robust Profile Store Lookup) ---');
          const policyType = userValue['@type'];
          let policyId = null;
          let labelText = null;
          const rdfsLabelURI = 'http://www.w3.org/2000/01/rdf-schema#label';
          const madsAuthLabelURI = 'http://www.loc.gov/mads/rdf/v1#authoritativeLabel';

          // Attempt to extract the @id from the nested structure observed in logs
          try {
            if (userValue[rdfsLabelURI] &&
                userValue[rdfsLabelURI][0] &&
                userValue[rdfsLabelURI][0]['@id']) {
              policyId = userValue[rdfsLabelURI][0]['@id'];
            } else if (userValue['@id']) { // Fallback if @id is directly present
              policyId = userValue['@id'];
            }
            console.log(`Extracted policyId: ${policyId}`);
          } catch (e) {
            xmlLog.push(`Error extracting policyId for usageAndAccessPolicy: ${e.message}`);
            console.error(`Error extracting policyId: ${e.message}`);
          }

          console.log(`Extracted policyType: ${policyType}`);

          // If we have an ID and Type, proceed with creating the policy XML structure
          if (policyId && policyType) {
            try {
              // Get access to the profile store
              const profileStore = useProfileStore();
              
              // Try multiple approaches to find the policy data
              let lookupData = [];
              let policyData = null;
              
              // Method 1: Directly fetch policies from appropriate JSON file based on policy type
              console.log(`Looking up policy data directly from JSON based on type: ${policyType}`);
              const isAccessPolicy = policyType.includes('AccessPolicy');
              const fileUrl = isAccessPolicy ? '/accessPolicies.json' : '/usePolicies.json';
              
              try {
                // Try to fetch the policy data from the appropriate file
                const response = await fetch(fileUrl);
                if (response.ok) {
                  lookupData = await response.json();
                  console.log(`Loaded ${lookupData.length} policies from ${fileUrl}`);
                  
                  // Find the policy with matching ID
                  policyData = lookupData.find(p => p['@id'] === policyId);
                  if (policyData) {
                    console.log(`Found policy data directly from JSON file:`, policyData);
                  }
                }
              } catch (fetchError) {
                console.warn(`Error fetching policy data from ${fileUrl}:`, fetchError);
              }
              
              // Method 2: If direct fetch failed, try to find it in the profile store
              if (!policyData) {
                // Look through all profiles for a matching property template
                console.log(`Searching all profiles for policy data...`);
                
                const allProfileIds = Object.keys(profileStore.profiles);
                for (const profileId of allProfileIds) {
                  const profile = profileStore.profiles[profileId];
                  if (!profile || !profile.rt) continue;
                  
                  // Search all resource templates
                  for (const rtKey in profile.rt) {
                    if (!profile.rt[rtKey].pt) continue;
                    
                    // Search all property templates
                    for (const ptKey in profile.rt[rtKey].pt) {
                      const propTemplate = profile.rt[rtKey].pt[ptKey];
                      
                      // Check if this is a usageAndAccessPolicy property template
                      if (propTemplate.propertyURI === 'http://id.loc.gov/ontologies/bibframe/usageAndAccessPolicy' &&
                          propTemplate.valueConstraint?.useValuesFrom?.[0]?.data) {
                        // Check if the data contains our policy
                        const ptLookupData = propTemplate.valueConstraint.useValuesFrom[0].data;
                        console.log(`Found potential lookup data in ${profileId}.${rtKey}.${ptKey}, ${ptLookupData.length} items`);
                        
                        const foundPolicy = ptLookupData.find(p => p['@id'] === policyId);
                        if (foundPolicy) {
                          policyData = foundPolicy;
                          console.log(`Found policy data in profile ${profileId}:`, policyData);
                          break;
                        }
                      }
                    }
                    if (policyData) break;
                  }
                  if (policyData) break;
                }
              }
              
              // Method 3: Hardcoded fallback labels for common policies
              if (!policyData) {
                console.log(`Trying fallback hardcoded labels for known policies`);
                
                // Map of known policy IDs to labels
                const knownPolicies = {
                  'local:accessPolicy1': 'Free to access',
                  'local:accessPolicy2': 'Access restricted',
                  'local:accessPolicy3': 'Accessible online',
                  'local:accessPolicy4': 'For use in library only',
                  'local:accessPolicy5': 'Limited circulation, long loan period',
                  'local:accessPolicy6': 'No restrictions on access',
                  'local:usePolicy1': 'Copyright constraints',
                  'local:usePolicy2': 'Free to use',
                  'local:usePolicy3': 'License restrictions',
                  'local:usePolicy4': 'No commercial use',
                  'local:usePolicy5': 'No known legal restrictions',
                  'local:usePolicy6': 'Permission to use explicitly granted by publisher'
                };
                
                if (policyId in knownPolicies) {
                  // Create a synthetic policy data object
                  policyData = {
                    '@id': policyId,
                    [madsAuthLabelURI]: [{ '@value': knownPolicies[policyId] }]
                  };
                  console.log(`Using hardcoded label for ${policyId}: ${knownPolicies[policyId]}`);
                }
              }

              // If we found the policy data through any method, extract the label
              if (policyData) {
                if (policyData[madsAuthLabelURI] && policyData[madsAuthLabelURI][0] && policyData[madsAuthLabelURI][0]['@value']) {
                  labelText = policyData[madsAuthLabelURI][0]['@value'];
                  console.log(`Successfully extracted labelText: '${labelText}'`);
                  xmlLog.push(`Special handling for usageAndAccessPolicy: ID=${policyId}, Type=${policyType}, Found Label='${labelText}'`);

                  // Build the XML structure
                  const outerEl = this.createElByBestNS(ptObj.propertyURI);
                  const innerEl = this.createElByBestNS(policyType);
                  const labelEl = this.createRdfsLabel(labelText);

                  innerEl.appendChild(labelEl);
                  outerEl.appendChild(innerEl);
                  rootEl.appendChild(outerEl);
                  componentXmlLookup[`${rt}-${pt}`] = formatXML(outerEl.outerHTML);
                  console.log('--- Finished Debugging usageAndAccessPolicy Lookup (Success) ---');
                  continue; // Skip the rest of the loop for this property
                } else {
                  console.error('Found policyData, but label structure is unexpected:', JSON.stringify(policyData, null, 2));
                }
              } else {
                console.error(`Could not find policy data for ID: ${policyId}`);
              }
            } catch (lookupError) {
              xmlLog.push(`Error during policy lookup/XML creation for usageAndAccessPolicy: ${lookupError.message}`);
              console.error(`Error during policy lookup/XML creation: ${lookupError.message}`, lookupError);
            }
          } else {
            xmlLog.push(`Special handling for usageAndAccessPolicy: Missing policyId or policyType in userValue: ${JSON.stringify(userValue)}`);
            console.warn(`Missing policyId (${policyId}) or policyType (${policyType})`);
          }
          console.log('--- Finished Debugging usageAndAccessPolicy Lookup (End) ---');
        }
        // <END> Special handling for usageAndAccessPolicy

        if (this.ignoreProperties.indexOf(ptObj.propertyURI) > -1){
          xmlLog.push(`Skipping it because it is in the ignoreProperties list`);
          continue;
        }

        xmlLog.push(['Set userValue to:', JSON.parse(JSON.stringify(userValue))]);

        // Does it have any userValues?
        if (this.hasUserValue(userValue)){
          // Keep track of resource templates used
          if (xmlVoidDataRtsUsed.indexOf(rt) === -1){
            xmlVoidDataRtsUsed.push(rt);
          }
          if (xmlVoidDataType.indexOf(rootElName) === -1){
            xmlVoidDataType.push(rootElName);
          }

          // Process based on whether it's a blank node or literal
          if (this.isBnode(userValue)){
            xmlLog.push(`Root level bnode: ${ptObj.propertyURI}`);
            let pLvl1 = this.createElByBestNS(ptObj.propertyURI);
            let bnodeLvl1 = this.createBnode(userValue, ptObj.propertyURI);
            xmlLog.push(`Created lvl 1 predicate: ${pLvl1.tagName} and bnode: ${bnodeLvl1.tagName}`);

            // Process all properties in this blank node
            for (let key1 of Object.keys(userValue).filter(k => (!k.includes('@') ? true : false))){
              // key1 is the property URI, e.g. http://id.loc.gov/ontologies/bibframe/classificationPortion
              let value1Array = userValue[key1]; // This should be an array of values for this property
              if (!Array.isArray(value1Array)) {
                value1Array = [value1Array]; // Ensure it's always an array
              }

              for (let value1 of value1Array) { // Iterate through each value for the property
                // value1 is the actual value object, e.g. { '@type': '...', 'rdf:value': '...' } or { '@id': '...' }
                xmlLog.push(`Processing key1: ${key1} with value1: ${JSON.stringify(value1)}`);

                // Create the element for the property itself (e.g., <bf:classificationPortion>)
                let pLvl2 = this.createElByBestNS(key1);
                if (!pLvl2 || !pLvl2.nodeType) {
                  xmlLog.push(`Failed to create pLvl2 element for key ${key1}`);
                  continue; // Skip if element creation failed
                }

                // Check if value1 represents another blank node
                if (this.isBnode(value1)){
                  xmlLog.push(`Nested bnode found for key: ${key1}`);
                  let bnodeLvl2 = this.createBnode(value1, key1);
                  if (!bnodeLvl2 || !bnodeLvl2.nodeType) {
                     xmlLog.push(`Failed to create bnodeLvl2 for key ${key1}`);
                     continue;
                  }
                  xmlLog.push(`Created nested bnode: ${bnodeLvl2.tagName}`);

                  // Recursively process properties of the nested bnode
                  for (let key2 of Object.keys(value1).filter(k => (!k.includes('@') ? true : false))){
                    let value2Array = value1[key2];
                    if (!Array.isArray(value2Array)) {
                       value2Array = [value2Array];
                    }
                    for (let value2 of value2Array) {
                      // Create element for the nested property (e.g., <bf:assigner>)
                      let pLvl3 = this.createElByBestNS(key2);
                      if (!pLvl3 || !pLvl3.nodeType) {
                         xmlLog.push(`Failed to create pLvl3 element for key ${key2}`);
                         continue;
                      }

                      if (this.isBnode(value2)) {
                         // Handle deeper nesting if necessary (level 3 bnode)
                         let bnodeLvl3 = this.createBnode(value2, key2);
                         // ... process bnodeLvl3 properties ...
                         pLvl3.appendChild(bnodeLvl3);
                      } else if (value2['@id']) {
                         // Handle URI resource reference
                         pLvl3.setAttributeNS(utilsRDF.namespace.rdf, 'rdf:resource', value2['@id']);
                      } else {
                         // Handle literal value
                         let literalVal = value2;
                         if (typeof value2 === 'object' && value2['@value']) {
                            literalVal = value2['@value'];
                         }
                         if (typeof literalVal === 'string' || typeof literalVal === 'number') {
                            pLvl3.textContent = literalVal;
                         } else {
                            xmlLog.push(`Unhandled literal type for key2 ${key2}: ${JSON.stringify(value2)}`);
                            continue;
                         }
                      }
                      bnodeLvl2.appendChild(pLvl3); // Append property to nested bnode
                    }
                  }
                  pLvl2.appendChild(bnodeLvl2); // Append nested bnode to property element
                  bnodeLvl1.appendChild(pLvl2); // Append property element to level 1 bnode

                } else if (value1['@id']) {
                  // Handle simple URI resource reference (e.g., <bf:role rdf:resource="..."/>)
                  xmlLog.push(`Handling URI reference for key: ${key1}`);
                  pLvl2.setAttributeNS(utilsRDF.namespace.rdf, 'rdf:resource', value1['@id']);
                  bnodeLvl1.appendChild(pLvl2); // Append property element to level 1 bnode

                } else {
                  // Handle literal value (could be simple string/number or object with @value/@language)
                  xmlLog.push(`Handling literal for key: ${key1}`);
                  let literalVal = value1;
                  let lang = null;

                  if (typeof value1 === 'object') {
                    if (value1['@value']) {
                      literalVal = value1['@value'];
                      lang = value1['@language'];
                    } else if (value1['rdf:value']) { // Handle cases like barcode where value is under rdf:value
                      literalVal = value1['rdf:value'];
                    } else {
                      // Check if it's an object containing the literal directly (e.g., from language map)
                      const literalKeys = Object.keys(value1).filter(k => !k.startsWith('@'));
                      if (literalKeys.length === 1 && (typeof value1[literalKeys[0]] === 'string' || typeof value1[literalKeys[0]] === 'number')) {
                        literalVal = value1[literalKeys[0]];
                      } else {
                         xmlLog.push(`Unhandled literal object structure for key ${key1}: ${JSON.stringify(value1)}`);
                         continue; // Skip if we can't extract a literal value
                      }
                    }
                  }

                  if (typeof literalVal === 'string' || typeof literalVal === 'number') {
                    pLvl2.textContent = literalVal;
                    if (lang) {
                      pLvl2.setAttribute('xml:lang', lang);
                    }
                    bnodeLvl1.appendChild(pLvl2); // Append property element to level 1 bnode
                  } else {
                    xmlLog.push(`Could not extract literal value for key ${key1}: ${JSON.stringify(value1)}`);
                  }
                }
              }
            }
            pLvl1.appendChild(bnodeLvl1);
            rootEl.appendChild(pLvl1);
            componentXmlLookup[`${rt}-${pt}`] = formatXML(pLvl1.outerHTML);

            // Handle sibling nodes
            if (userValueSiblings.length > 0){
              // ...existing code for sibling nodes...
            }
          } else {
            // Not a blank node
            xmlLog.push(`Root level does not look like a bnode: ${ptObj.propertyURI}`);
            let userValueArray = userValue;
            if (!Array.isArray(userValue)){
              userValueArray = [userValue]; // Wrap non-array value in an array
            }

            // Process each user value in the array
            for (let userValueItem of userValueArray){
              if (this.hasUserValue(userValueItem)){
                if (await utilsRDF.suggestTypeNetwork(ptObj.propertyURI) == 'http://www.w3.org/2000/01/rdf-schema#Literal'){
                  // Handle top level literals
                  let allXMLFragments = '';
                  // Check if userValueItem is a simple literal or an object with literal values
                  if (typeof userValueItem === 'string' || typeof userValueItem === 'number') {
                    let p1 = this.createLiteral(ptObj.propertyURI, userValueItem);
                    if (p1 !== false && p1.nodeType) { // Ensure p1 is a valid node
                      rootEl.appendChild(p1);
                      xmlLog.push(`Creating literal at root level for ${ptObj.propertyURI} with value ${p1.innerHTML}`);
                      allXMLFragments = formatXML(p1.outerHTML);
                    } else {
                      xmlLog.push(`Failed to create literal for ${ptObj.propertyURI} with value ${userValueItem}`);
                    }
                  } else if (typeof userValueItem === 'object') {
                    // Iterate through keys if it's an object (like language maps)
                    for (let key1 of Object.keys(userValueItem).filter(k => (!k.includes('@') ? true : false))){
                      if (typeof userValueItem[key1] === 'string' || typeof userValueItem[key1] === 'number'){
                        let p1 = this.createLiteral(ptObj.propertyURI, userValueItem[key1]);
                        if (p1 !== false && p1.nodeType) {
                          // Handle language tags if present
                          if (userValueItem['@language']) {
                            p1.setAttribute('xml:lang', userValueItem['@language']);
                          }
                          rootEl.appendChild(p1);
                          xmlLog.push(`Creating literal at root level for ${key1} with value ${p1.innerHTML}`);
                          allXMLFragments += `\n${formatXML(p1.outerHTML)}`;
                        } else {
                          xmlLog.push(`Failed to create literal for ${key1} with value ${userValueItem[key1]}`);
                        }
                      } else {
                        // Handle nested structures if necessary, though less common for root literals
                        xmlLog.push(`Skipping non-literal nested value for key ${key1}`);
                      }
                    }
                  }
                  if (allXMLFragments) {
                    componentXmlLookup[`${rt}-${pt}`] = allXMLFragments.trim();
                  }
                } else if (ptObj.propertyURI != "http://id.loc.gov/ontologies/bibframe/electronicLocator" &&
                           await utilsRDF.suggestTypeNetwork(ptObj.propertyURI) == 'http://www.w3.org/2000/01/rdf-schema#Resource'){
                  // Handle resources (This part seems less likely for non-bnodes, might need review)
                  xmlLog.push(`Handling resource at root level for ${ptObj.propertyURI}`);
                  // ... (logic for handling root-level resources if needed) ...
                } else if (userValueItem['@id']){
                  // Handle simple URI references
                  let p = this.createElByBestNS(ptObj.propertyURI);
                  if (p && p.nodeType) { // Check if p is a valid element
                    p.setAttributeNS(utilsRDF.namespace.rdf, 'rdf:resource', userValueItem['@id']);
                    rootEl.appendChild(p);
                    componentXmlLookup[`${rt}-${pt}`] = formatXML(p.outerHTML);
                  } else {
                     xmlLog.push(`Failed to create element for URI reference ${ptObj.propertyURI}`);
                  }
                } else if (ptObj.propertyURI == 'http://www.w3.org/2000/01/rdf-schema#label'){
                  // Handle simple labels
                  let labelValue = '';
                  if (typeof userValueItem === 'string') {
                    labelValue = userValueItem;
                  } else if (userValueItem['http://www.w3.org/2000/01/rdf-schema#label']) {
                    // Extract label from nested structure if necessary
                    // This might need adjustment based on actual data structure
                    labelValue = userValueItem['http://www.w3.org/2000/01/rdf-schema#label'];
                    if (Array.isArray(labelValue) && labelValue[0]) {
                       labelValue = labelValue[0]['http://www.w3.org/2000/01/rdf-schema#label'] || labelValue[0];
                    }
                    if (typeof labelValue !== 'string') labelValue = JSON.stringify(labelValue); // Fallback
                  }

                  if (labelValue) {
                    let p = this.createElByBestNS(ptObj.propertyURI);
                    if (p && p.nodeType) {
                      p.innerHTML = escapeHTML(labelValue);
                      rootEl.appendChild(p);
                      componentXmlLookup[`${rt}-${pt}`] = formatXML(p.outerHTML);
                    } else {
                      xmlLog.push(`Failed to create element for label ${ptObj.propertyURI}`);
                    }
                  } else {
                     xmlLog.push(`No label value found for ${ptObj.propertyURI}`);
                  }
                } else {
                  // Fallback for simple string/number literals if not caught by suggestTypeNetwork
                  if (typeof userValueItem === 'string' || typeof userValueItem === 'number') {
                     let p1 = this.createLiteral(ptObj.propertyURI, userValueItem);
                     if (p1 !== false && p1.nodeType) {
                       rootEl.appendChild(p1);
                       xmlLog.push(`Creating fallback literal at root level for ${ptObj.propertyURI} with value ${p1.innerHTML}`);
                       componentXmlLookup[`${rt}-${pt}`] = formatXML(p1.outerHTML);
                     } else {
                       xmlLog.push(`Failed to create fallback literal for ${ptObj.propertyURI}`);
                     }
                  } else {
                    xmlLog.push(`Unhandled case for non-bnode root property: ${ptObj.propertyURI} with value ${JSON.stringify(userValueItem)}`);
                    console.warn("Should not be here - unhandled non-bnode root property", ptObj.propertyURI, userValueItem);
                  }
                }
              } else {
                 xmlLog.push(`Skipping item in array because hasUserValue == false`);
              }
            } // <-- closes loop over userValueArray
          } // <-- This closes the else block for `isBnode`
        } else { // <-- This else now correctly corresponds to `if (this.hasUserValue(userValue))`
          xmlLog.push(`Skipping it because hasUserValue == false`);
        }
      
        // Special handling for rdfs:label properties
        if (ptObj.propertyURI == 'http://www.w3.org/2000/01/rdf-schema#label') {
            // does it just have a label?

            // Check if this label comes from a lookup
            if (ptObj.valueConstraint && ptObj.valueConstraint.useValuesFrom && userValue['@id']) {
                const lookupId = userValue['@id'];
                // Attempt to find the label using utilsNetwork.lookupLibrary (assuming it holds the cached data)
                // Make sure utilsNetwork.lookupLibrary is loaded and accessible here
                const lookupEntry = (utilsNetwork.lookupLibrary || []).find(entry => entry['@id'] === lookupId);

                if (lookupEntry && lookupEntry['http://www.loc.gov/mads/rdf/v1#authoritativeLabel'] && lookupEntry['http://www.loc.gov/mads/rdf/v1#authoritativeLabel'][0] && lookupEntry['http://www.loc.gov/mads/rdf/v1#authoritativeLabel'][0]['@value']) {
                    const labelText = lookupEntry['http://www.loc.gov/mads/rdf/v1#authoritativeLabel'][0]['@value'];
                    let p = this.createRdfsLabel(labelText); // Use helper for namespaced label
                    rootEl.appendChild(p);
                    componentXmlLookup[`${rt}-${pt}`] = formatXML(p.outerHTML);
                } else {
                    // Fallback: If lookup fails, use the @id as resource
                    console.warn(`Could not find label for lookup ID: ${lookupId} in pt: ${pt}. Falling back to rdf:resource.`);
                    let p = this.createElByBestNS(ptObj.propertyURI); // Creates <rdfs:label>
                    p.setAttributeNS(utilsRDF.namespace.rdf, 'rdf:resource', lookupId); // Set rdf:resource attribute
                    rootEl.appendChild(p);
                    componentXmlLookup[`${rt}-${pt}`] = formatXML(p.outerHTML);
                }
            } else {
                // Original logic for non-lookup rdfs:label (with added checks)
                let labelText = '';
                if (typeof userValue === 'string') {
                    labelText = userValue;
                } else if (userValue && typeof userValue === 'object' && userValue['@value']) {
                     labelText = userValue['@value'];
                } else if (userValue && userValue[ptObj.propertyURI] && typeof userValue[ptObj.propertyURI] === 'string') {
                     // Handle cases where the value might be nested under the property URI key
                     labelText = userValue[ptObj.propertyURI];
                } else if (userValue && Array.isArray(userValue[ptObj.propertyURI]) && userValue[ptObj.propertyURI][0] && userValue[ptObj.propertyURI][0][ptObj.propertyURI]) {
                     // Deeper nesting as seen in the original problematic line
                     labelText = userValue[ptObj.propertyURI][0][ptObj.propertyURI];
                } else {
                     console.warn(`Could not determine label text for non-lookup rdfs:label in pt: ${pt}`, userValue);
                     // Fallback or leave empty? Using empty for now.
                }

                let p = this.createRdfsLabel(labelText); // Use helper for namespaced label
                rootEl.appendChild(p);
                componentXmlLookup[`${rt}-${pt}`] = formatXML(p.outerHTML);
            }
        } else if (ptObj.propertyURI === 'http://id.loc.gov/ontologies/bibframe/physicalLocation') {
            // Special handling for physicalLocation
            console.log('--- Special handling for physicalLocation ---');
            let locationId = userValue && userValue['@id'] ? userValue['@id'] : (userValue && userValue.uri ? userValue.uri : null);

            if (locationId) {
                console.log(`[physicalLocation] Processing ID: ${locationId}`);
                let locationLabel = null;
                let lookupSource = 'None';

                try {
                    // 1. Try lookup library
                    if (utilsNetwork.lookupLibrary && Array.isArray(utilsNetwork.lookupLibrary)) {
                        const entry = utilsNetwork.lookupLibrary.find(e => e['@id'] === locationId);
                        if (entry && entry['http://www.loc.gov/mads/rdf/v1#authoritativeLabel']?.[0]?.['@value']) {
                            locationLabel = entry['http://www.loc.gov/mads/rdf/v1#authoritativeLabel'][0]['@value'];
                            lookupSource = 'lookupLibrary';
                            console.log(`[physicalLocation] Found label in lookupLibrary: '${locationLabel}'`);
                        }
                    }

                    // 2. If not found, try extracting from URI structure
                    if (!locationLabel && locationId.includes('alma:library:')) {
                        const match = locationId.match(/alma:library:([^:]+)/);
                        if (match && match[1]) {
                            locationLabel = match[1];
                            lookupSource = 'URI Extraction';
                            console.log(`[physicalLocation] Extracted label from URI: '${locationLabel}'`);
                        }
                    }

                    // Create the XML element
                    const locationEl = this.createElByBestNS(ptObj.propertyURI);
                    // let labelEl; // No longer creating a separate label element

                    let labelText = null;
                    if (locationLabel) {
                        labelText = locationLabel;
                        console.log(`[physicalLocation] Using label text: '${labelText}' (Source: ${lookupSource})`);
                    } else {
                        // Fallback: Use simplified ID as text
                        console.warn(`[physicalLocation] Could not find/extract authoritative label for ID: ${locationId}. Using simplified ID as text.`);
                        labelText = locationId.split(':').pop() || locationId;
                        console.log(`[physicalLocation] Using fallback label text: '${labelText}'`);
                    }

                    // Set the text content directly on the physicalLocation element
                    locationEl.textContent = labelText;

                    // locationEl.appendChild(labelEl); // Removed appending label element
                    rootEl.appendChild(locationEl);
                } catch (error) {
                    console.error(`[physicalLocation] Error processing: ${error}`);
                    // Minimal fallback on error
                    const locationEl = this.createElByBestNS(ptObj.propertyURI);
                    locationEl.setAttributeNS(utilsRDF.namespace.rdf, 'rdf:resource', locationId); // Fallback to resource on error
                    rootEl.appendChild(locationEl);
                    componentXmlLookup[`${rt}-${pt}`] = formatXML(locationEl.outerHTML);
                }
                console.log('--- End special handling for physicalLocation ---');
                continue; // Skip standard processing
            } else {
                 console.log('[physicalLocation] No ID found in userValue.');
            }
        } else if (ptObj.propertyURI === 'http://id.loc.gov/ontologies/bibframe/sublocation') {
            console.log('--- Special handling for sublocation (Revised) ---');

            // 1. Remove any existing sublocation elements from this item first
            const existingSublocationElements = Array.from(rootEl.querySelectorAll('bf\\:sublocation'));
            if (existingSublocationElements.length > 0) {
                console.log(`[sublocation] Removing ${existingSublocationElements.length} existing sublocation elements before processing.`);
                existingSublocationElements.forEach(el => {
                    if (el.parentNode) {
                       el.parentNode.removeChild(el);
                    }
                });
            }

            // 2. Determine the primary userValue object to process
            //    (Handle cases where userValue might be nested or an array)
            let primaryUserValue = null;
            if (Array.isArray(userValue)) {
                if (userValue.length > 0) {
                    primaryUserValue = userValue[0]; // Process only the first item if it's an array
                    console.log('[sublocation] userValue is an array, processing only the first item.');
                }
            } else if (typeof userValue === 'object' && userValue !== null) {
                primaryUserValue = userValue; // Process the object directly
            }

            if (!primaryUserValue) {
                console.log('[sublocation] No valid primaryUserValue found to process.');
                continue; // Skip if no data
            }

            console.log('[sublocation] Processing primaryUserValue:', JSON.stringify(primaryUserValue, null, 2));

            // 3. Extract ID and Label from the primaryUserValue
            let sublocationId = null;
            let sublocationLabel = null;
            const rdfsLabelURI = 'http://www.w3.org/2000/01/rdf-schema#label';
            const madsAuthLabelURI = 'http://www.loc.gov/mads/rdf/v1#authoritativeLabel';

            try {
                 // Try direct extraction first (based on observed log structure)
                if (primaryUserValue[rdfsLabelURI] && primaryUserValue[rdfsLabelURI][0]) {
                    const labelObj = primaryUserValue[rdfsLabelURI][0];
                    sublocationId = labelObj["@id"];
                     if (labelObj[rdfsLabelURI] && labelObj[rdfsLabelURI][0] && labelObj[rdfsLabelURI][0][rdfsLabelURI]) {
                         sublocationLabel = labelObj[rdfsLabelURI][0][rdfsLabelURI];
                     }
                }
                // Fallback ID extraction methods
                if (!sublocationId) {
                    if (primaryUserValue['@id']) sublocationId = primaryUserValue['@id'];
                    else if (primaryUserValue.uri) sublocationId = primaryUserValue.uri;
                }
            } catch (e) {
                console.warn(`[sublocation] Error during ID/label extraction: ${e.message}`);
            }

            // 4. Process if an ID was found
            if (sublocationId) {
                console.log(`[sublocation] Processing ID: ${sublocationId}`);
                let lookupSource = 'None';

                try {
                    // Lookup label if not extracted directly
                    if (!sublocationLabel) {
                        // Assuming utilsNetwork.lookupLibrary is available and populated
                        if (typeof utilsNetwork !== 'undefined' && utilsNetwork.lookupLibrary && Array.isArray(utilsNetwork.lookupLibrary)) {
                            const entry = utilsNetwork.lookupLibrary.find(e => e['@id'] === sublocationId);
                            if (entry && entry[madsAuthLabelURI]?.[0]?.['@value']) {
                                sublocationLabel = entry[madsAuthLabelURI][0]['@value'];
                                lookupSource = 'Lookup Library';
                            }
                        }
                    } else {
                        lookupSource = 'Direct Extraction';
                    }

                    // 5. Create and append *only one* sublocation element
                    const sublocationEl = this.createElByBestNS(ptObj.propertyURI);
                    let labelEl;

                    if (sublocationLabel) {
                        labelEl = this.createRdfsLabel(sublocationLabel);
                        console.log(`[sublocation] Creating label element with text: '${sublocationLabel}' (Source: ${lookupSource})`);
                    } else {
                        // Fallback label from ID
                        let displayLabel = sublocationId.split(':').pop() || sublocationId;
                        labelEl = this.createRdfsLabel(displayLabel);
                        console.warn(`[sublocation] Could not find/extract label for ID: ${sublocationId}. Using fallback text: '${displayLabel}'`);
                    }

                    sublocationEl.appendChild(labelEl);
                    rootEl.appendChild(sublocationEl); // Append the single new sublocation
                    componentXmlLookup[`${rt}-${pt}`] = formatXML(sublocationEl.outerHTML);
                    console.log('[sublocation] Successfully added single sublocation element.');

                } catch (error) {
                    console.error(`[sublocation] Error processing ID ${sublocationId}: ${error}`);
                    // Fallback: Add sublocation with rdf:resource if processing fails
                    const sublocationEl = this.createElByBestNS(ptObj.propertyURI);
                    sublocationEl.setAttributeNS(utilsRDF.namespace.rdf, 'rdf:resource', sublocationId);
                    rootEl.appendChild(sublocationEl);
                    componentXmlLookup[`${rt}-${pt}`] = formatXML(sublocationEl.outerHTML);
                    console.error('[sublocation] Added fallback sublocation with rdf:resource due to error.');
                }
            } else {
                 console.log('[sublocation] No ID found in primaryUserValue. Skipping sublocation creation.');
            }

            console.log('--- End special handling for sublocation (Revised) ---');
            continue; // Continue skipping default PT processing
        } else if (ptObj.type === 'literal-lang') {
          // ...existing code...
        }
      } // <-- This closes the `for (let pt of profile.rt[rt].ptOrder)` loop

      // Handle any unused XML
      let unusedXmlNode = xmlParser.parseFromString(orginalProfile.rt[rt].unusedXml, "text/xml");
      unusedXmlNode = unusedXmlNode.children[0];
      for (let el of unusedXmlNode.children){
        if (el.tagName != 'rdfs:label'){
          let newEl = (new XMLSerializer()).serializeToString(el);
          newEl = xmlParser.parseFromString(newEl, "text/xml");
          newEl = newEl.children[0];
          rootEl.appendChild(newEl);
        }
      }

      // <--- Add cleanup here specifically for Item elements, AFTER processing PTs --->
      if (rootElName === "Item") {
          console.log("[Item Cleanup] Starting cleanup for Item element:", rootEl.outerHTML);

          // --- Physical Location Cleanup (using querySelectorAll for robustness) ---
          // Find ALL potential physicalLocation elements, regardless of nesting depth initially
          const physicalLocationsManual = Array.from(rootEl.querySelectorAll('bf\\:physicalLocation'));
          console.log(`[Item Cleanup] Manually found ${physicalLocationsManual.length} potential physicalLocation elements.`);

          // --- Physical Location Cleanup (using manually found elements) ---
          const physicalLocations = physicalLocationsManual; // Use manually found elements
          let finalLocationLabelText = null; // Store the correct label text if found
          let lookupSource = 'None'; // Track where the label came from

          if (physicalLocations.length > 0) {
              console.log(`[Item Cleanup] Found ${physicalLocations.length} physicalLocation elements. Consolidating...`);

              // Try to find the correct label from the potentially incorrect structures
              for (const pl of physicalLocations) {
                  console.log('[Item Debug] Processing physicalLocation for cleanup:', pl.outerHTML);
                  let potentialLabel = null;
                  let resourceId = null; // Variable to store the found resource ID

                  // Check for the specific nested structure: <bf:physicalLocation><bf:physicalLocation><rdfs:label rdf:resource="..."></rdfs:label></bf:physicalLocation></bf:physicalLocation>
                  const nestedPl = pl.querySelector(':scope > bf\\:physicalLocation'); // Look for direct child
                  if (nestedPl) {
                      console.log('[Item Debug] Found nested bf:physicalLocation:', nestedPl.outerHTML);
                      const labelInsideNested = nestedPl.querySelector(':scope > rdfs\\:label[rdf\\:resource]'); // Look for direct child label with resource
                      if (labelInsideNested) {
                          console.log('[Item Debug] Found nested rdfs:label[rdf:resource]:', labelInsideNested.outerHTML);
                          // Try getting the attribute with namespace first
                          resourceId = labelInsideNested.getAttributeNS(utilsRDF.namespace.rdf, 'resource');
                          console.log(`[Item Debug] resourceId from getAttributeNS: ${resourceId}`);
                          // Fallback if NS version fails
                          if (!resourceId) {
                              resourceId = labelInsideNested.getAttribute('rdf:resource');
                              console.log(`[Item Debug] resourceId from getAttribute (fallback): ${resourceId}`);
                          }

                          if (resourceId) {
                              console.log(`[Item Cleanup] Found nested structure with resource: ${resourceId}`);
                              // --- Logic to get label from resourceId (adapted from special handling block) ---
                              let locationLabel = null;
                              // lookupSource = 'None'; // Reset lookupSource for this attempt - MOVED outside loop
                              try {
                                  // 1. Try lookup library
                                  if (utilsNetwork.lookupLibrary && Array.isArray(utilsNetwork.lookupLibrary)) {
                                      const entry = utilsNetwork.lookupLibrary.find(e => e['@id'] === resourceId);
                                      if (entry && entry['http://www.loc.gov/mads/rdf/v1#authoritativeLabel']?.[0]?.['@value']) {
                                          locationLabel = entry['http://www.loc.gov/mads/rdf/v1#authoritativeLabel'][0]['@value'];
                                          lookupSource = 'lookupLibrary'; // Update lookupSource here
                                          console.log(`[Item Cleanup/LocationLookup] Found label in lookupLibrary: '${locationLabel}'`);
                                      }
                                  }
                                  // 2. If not found, try extracting from URI structure
                                  if (!locationLabel && resourceId.includes('alma:library:')) {
                                      const match = resourceId.match(/alma:library:([^:]+)/);
                                      if (match && match[1]) {
                                          locationLabel = match[1];
                                          lookupSource = 'URI Extraction'; // Update lookupSource here
                                          console.log(`[Item Cleanup/LocationLookup] Extracted label from URI: '${locationLabel}'`);
                                      }
                                  }
                                  // 3. Fallback
                                  if (!locationLabel) {
                                      locationLabel = resourceId.split(':').pop() || resourceId;
                                      lookupSource = 'Fallback ID Parsing'; // Update lookupSource here
                                      console.log(`[Item Cleanup/LocationLookup] Using fallback label: '${locationLabel}'`);
                                  }
                              } catch (lookupError) {
                                  console.error(`[Item Cleanup/LocationLookup] Error looking up label for ${resourceId}: ${lookupError}`);
                                  locationLabel = resourceId.split(':').pop() || resourceId; // Fallback on error
                                  lookupSource = 'Error Fallback'; // Update lookupSource here
                              }
                              potentialLabel = locationLabel;
                              // --- End label lookup logic ---
                          } else {
                               console.warn('[Item Debug] Could not extract resourceId from label element.');
                          }
                      } else {
                           console.warn('[Item Debug] Did not find rdfs:label[rdf:resource] inside nested bf:physicalLocation.');
                      }
                  } else {
                       console.warn('[Item Debug] Did not find nested bf:physicalLocation element.');
                  }
                  // TODO: Add checks for other potential incorrect structures if needed

                  if (potentialLabel) {
                      finalLocationLabelText = potentialLabel;
                      console.log(`[Item Cleanup] Determined final location label: '${finalLocationLabelText}' (Source: ${lookupSource})`);
                      break; // Found a label, no need to check further
                  } else {
                      console.warn('[Item Debug] No potentialLabel determined in this iteration for:', pl.outerHTML);
                  }
              } // <-- End of for loop

              // Remove ALL existing physicalLocation elements found initially
              physicalLocations.forEach(pl => {
                  // Check if parentNode exists before attempting removal
                  if (pl.parentNode) {
                      // Check if the parent is the root element we are processing
                      if (pl.parentNode === rootEl) {
                          rootEl.removeChild(pl);
                      } else {
                          // If the parent is not the rootEl, it might be nested.
                          // We still want to remove it if it was part of the initial find.
                          // Check if the parent itself is one of the elements we targeted for removal.
                          if (physicalLocations.includes(pl.parentNode)) {
                              // This case is complex: removing a parent while iterating might cause issues.
                              // A safer approach might be to mark for removal and do it in a separate pass,
                              // but for now, let's log and proceed cautiously.
                              console.warn("[Item Cleanup] Attempting to remove nested physicalLocation whose parent is also targeted. Potential issue.", pl.outerHTML);
                              pl.parentNode.removeChild(pl); // Try removing from its direct parent
                          } else {
                              console.warn("[Item Cleanup] physicalLocation parent is not rootEl during removal, might be expected if nested within non-physicalLocation.", pl.outerHTML);
                              // It's possible it's nested inside something else that *isn't* being removed.
                              // We should still remove it from its current parent.
                              pl.parentNode.removeChild(pl);
                          }
                      }
                  } else {
                      console.warn("[Item Cleanup] physicalLocation has no parentNode during removal attempt.", pl.outerHTML);
                  }
              });
              console.log(`[Item Cleanup] Finished removing initially found physicalLocation elements.`);

              // If we found a label, create and append ONE clean physicalLocation
              if (finalLocationLabelText !== null) {
                  const newLocationEl = this.createElByBestNS('bf:physicalLocation');
                  newLocationEl.textContent = finalLocationLabelText;
                  rootEl.appendChild(newLocationEl);
                  console.log(`[Item Cleanup] Appended single clean physicalLocation with text: '${finalLocationLabelText}'`);
              } else {
                  console.warn(`[Item Cleanup] Could not determine a final label for physicalLocation. No element added.`);
              }

          } else {
              console.log(`[Item Cleanup] No physicalLocation elements found for item (using manual find).`);
          }
      }
      // <--- End added cleanup --->

      // Add the completed root element to the lookup
      tleLookup[rootElName][profile.rt[rt].URI] = rootEl;
      xmlLog.push(`Finished building ${rootElName}`);
    } // <-- This closes the `for (let rt of profile.rtOrder)` loop

    // Add admin metadata to Work and Instance elements
    // Add in adminMetadata to the resources with this user ID
    let userInitial = usePreferenceStore().catInitals;
    let catCode = usePreferenceStore().catCode;
    let user = `${userInitial} (${catCode})`;
    profile.user = user;

    // Create admin metadata elements
    let bf_adminMetadata = this.createElByBestNS("bf:adminMetadata");
    let bf_AdminMetadtat = this.createElByBestNS("bf:AdminMetadata");

    // Add status information
    let bf_status = this.createElByBestNS("bf:status");
    let bf_Status = this.createElByBestNS("bf:Status");
    bf_Status.setAttributeNS(utilsRDF.namespace.rdf, 'rdf:about','http://id.loc.gov/vocabulary/mstatus/c');
    let bf_StatusLabel = this.createElByBestNS("rdfs:label");
    bf_StatusLabel.innerHTML = "changed";

    // Add cataloger information
    let bf_catalogerId = this.createElByBestNS("bflc:catalogerId");
    bf_catalogerId.innerHTML = escapeHTML(catCode);
    let bf_date = this.createElByBestNS("bf:date");
    bf_date.innerHTML = new Date().toISOString();

    bf_AdminMetadtat.appendChild(bf_date);
    bf_AdminMetadtat.appendChild(bf_catalogerId);

    // Remove any existing assigner before adding a new one
    if (bf_AdminMetadtat.querySelector("bf\\:assigner")) {
      bf_AdminMetadtat.removeChild(bf_AdminMetadtat.querySelector("bf\\:assigner"));
    }

    // Add default assigner if enabled in configuration
    let includeDefaultAssigner = useConfigStore().includeDefaultAssigner;
    if (includeDefaultAssigner) {
      let bf_assigner = this.buildDefaultAssignerElement();
      // Only add if no existing organization is found
      if (!bf_AdminMetadtat.querySelector('bf\\:Organization[rdf\\:about="http://id.loc.gov/vocabulary/organizations/dlc"], bf\\:agent[rdf\\:about="http://id.loc.gov/vocabulary/organizations/dlc"]')) {
        bf_AdminMetadtat.appendChild(bf_assigner);
      }
    }

    bf_Status.appendChild(bf_StatusLabel);
    bf_status.appendChild(bf_Status);
    bf_AdminMetadtat.appendChild(bf_status);
    bf_adminMetadata.appendChild(bf_AdminMetadtat);

    // Always add assigner to bf:AdminMetadata if not present, and ensure it is fully populated
    // (This is now handled by deduplicateAssignersInAdminMetadata)
    this.deduplicateAssignersInAdminMetadata(bf_AdminMetadtat);

    let adminMetadataText = (new XMLSerializer()).serializeToString(bf_adminMetadata);

    // Add admin metadata to Work and Instance elements
    for (let URI in tleLookup['Work']){
      // Create a fresh copy of admin metadata for each Work
      const adminCopy = xmlParser.parseFromString(adminMetadataText, "text/xml").children[0];
      // Only add if the Work doesn't already have admin metadata
      if (!tleLookup['Work'][URI].querySelector('bf\\:adminMetadata')) {
        tleLookup['Work'][URI].appendChild(adminCopy);
      }
    }

    for (let URI in tleLookup['Instance']){
      // Create a fresh copy of admin metadata for each Instance
      const adminCopy = xmlParser.parseFromString(adminMetadataText, "text/xml").children[0];
      // Only add if the Instance doesn't already have admin metadata
      if (!tleLookup['Instance'][URI].querySelector('bf\\:adminMetadata')) {
        tleLookup['Instance'][URI].appendChild(adminCopy);
      }
    }

    // Build basic version to save
    for (let URI in tleLookup['Work']){
      let theWork = (new XMLSerializer()).serializeToString(tleLookup['Work'][URI]);
          instance.appendChild(p);
        }
      }
      
      // Add instanceOf relationship with work
      let work = this.returnWorkFromInstance(URI, orginalProfile, tleLookup);
      if (work) {
        let p = this.createElByBestNS('bf:instanceOf');
        // Set rdf:resource to the Work's URI if available
        const workAbout = work.getAttribute && work.getAttribute('rdf:about');
        if (workAbout) {
          p.setAttributeNS(utilsRDF.namespace.rdf, 'rdf:resource', workAbout);
        }
        // Optionally, append the work as a child if needed for other consumers
        // p.appendChild(work);
        instance.appendChild(p);
      }
      rdfBasic.appendChild(instance);
    }

    // Build RDF centered around instance or work based on procInfo
    if (orginalProfile.procInfo && orginalProfile.procInfo.includes("update")){
      // Build centered around instance
      if (Object.keys(tleLookup['Instance']).length > 0){
        for (let URI in tleLookup['Instance']){
          let instance = (new XMLSerializer()).serializeToString(tleLookup['Instance'][URI]);
          instance = xmlParser.parseFromString(instance, "text/xml").children[0];
          // Add hasItem relationships
          let items = this.returnHasItem(URI, orginalProfile, tleLookup);
          if (items.length > 0){
            for (let item of items){
              let p = this.createElByBestNS('bf:hasItem');
              p.appendChild(item);
              instance.appendChild(p);
            }
          }
          // Add instanceOf relationship with work
          let work = this.returnWorkFromInstance(URI, orginalProfile, tleLookup);
          if (work){
            let p = this.createElByBestNS('bf:instanceOf');
            p.appendChild(work);
            instance.appendChild(p);
          }
          rdf.appendChild(instance);
        }
      } else {
        // No instances - use the first work
        let workKey = Object.keys(tleLookup['Work'])[0];
        let work = tleLookup['Work'][workKey];
        if (work){
          rdf.appendChild(work);
        }
      }
    } else {
      // Default case - centered around instance with work as child
      for (let URI in tleLookup['Instance']){
        let instance = (new XMLSerializer()).serializeToString(tleLookup['Instance'][URI]);
        instance = xmlParser.parseFromString(instance, "text/xml").children[0];
        
        // Add items
        let items = this.returnHasItem(URI, orginalProfile, tleLookup);
        if (items.length > 0){
          for (let item of items){
            let p = this.createElByBestNS('bf:hasItem');
            p.appendChild(item);
            instance.appendChild(p);
          }
        }

        // Add works
        let work = this.returnWorkFromInstance(URI, orginalProfile, tleLookup);
        if (work){
          let p = this.createElByBestNS('bf:instanceOf');
          p.appendChild(work);
          instance.appendChild(p);
        }
        rdf.appendChild(instance);
      }
    }

    // Always append all hubs as direct children of rdf
    for (let URI in tleLookup['Hub']){
      let theHub = (new XMLSerializer()).serializeToString(tleLookup['Hub'][URI]);
      theHub = xmlParser.parseFromString(theHub, "text/xml").children[0];
      rdf.appendChild(theHub);
    }

    // Extract metadata for database
    if (rdfBasic.getElementsByTagName("bf:mainTitle").length > 0){
      xmlVoidDataTitle = rdfBasic.getElementsByTagName("bf:mainTitle")[0].innerHTML;
    } else if (rdfBasic.getElementsByTagName("bfsimple:prefTitle").length > 0){
      xmlVoidDataTitle = rdfBasic.getElementsByTagName("bfsimple:prefTitle")[0].innerHTML;
    } else {
      console.warn('no title found for db');
    }

    // Extract contributor information
    if (rdfBasic.getElementsByTagName("bf:PrimaryContribution").length > 0){
      if (rdfBasic.getElementsByTagName("bf:PrimaryContribution")[0].getElementsByTagName("rdfs:label").length > 0){
        xmlVoidDataContributor = rdfBasic.getElementsByTagName("bf:PrimaryContribution")[0].getElementsByTagName("rdfs:label")[0].innerHTML;
      }
    } else {
      if (rdfBasic.getElementsByTagName("bf:Contribution").length > 0){
        if (rdfBasic.getElementsByTagName("bf:Contribution")[0].getElementsByTagName("rdfs:label").length > 0){
          xmlVoidDataContributor = rdfBasic.getElementsByTagName("bf:Contribution")[0].getElementsByTagName("rdfs:label")[0].innerHTML;
        } else {
          console.warn('no PrimaryContribution or Contribution found for db');
        }
      } else {
        console.warn('no PrimaryContribution or Contribution found for db');
      }
    }

    // Extract LCCN
    if (rdfBasic.getElementsByTagName("bf:Instance").length > 0){
      let i = rdfBasic.getElementsByTagName("bf:Instance")[0];
      // Find LCCN in bf:identifiedBy
      for (let c of i.children){
        if (c.tagName === 'bf:identifiedBy'){
          // Look for bf:Lccn elements
          if (c.getElementsByTagName("bf:Lccn").length > 0){
            let lccnEl = c.getElementsByTagName("bf:Lccn")[0];
            // Check if it has a status
            if (lccnEl.getElementsByTagName("bf:Status").length == 0){
              // No status element, use this LCCN
              xmlVoidDataLccn = lccnEl.innerText || lccnEl.textContent;
            } else if (lccnEl.getElementsByTagName("bf:Status").length > 0){
              // If it has a status, check if it's canceled
              if (lccnEl.getElementsByTagName("bf:Status")[0].hasAttribute('rdf:about') && 
                  lccnEl.getElementsByTagName("bf:Status")[0].attributes['rdf:about'].value == 'http://id.loc.gov/vocabulary/mstatus/cancinv'){
                continue;
              }
              // Use this LCCN if not canceled
              for (let cc of lccnEl.children){
                if (cc.tagName == 'rdf:value'){
                  xmlVoidDataLccn = cc.innerText || cc.textContent;
                }
              }
            }
          }
        }
      }
    }

    // Create dataset description element
    let datasetDescriptionEl = document.createElementNS(utilsRDF.namespace.void, 'void:DatasetDescription');
    datasetDescriptionEl.setAttributeNS("http://www.w3.org/2000/xmlns/", `xmlns:void`, utilsRDF.namespace.void);
    datasetDescriptionEl.setAttributeNS("http://www.w3.org/2000/xmlns/", `xmlns:lclocal`, utilsRDF.namespace.lclocal);

    // Add metadata elements
    let el;
    for (let x of xmlVoidDataRtsUsed){
      el = document.createElementNS(utilsRDF.namespace.lclocal, 'lclocal:rtsused');
      el.innerHTML = escapeHTML(x);
      datasetDescriptionEl.appendChild(el);
    }
    for (let x of xmlVoidDataType){
      el = document.createElementNS(utilsRDF.namespace.lclocal, 'lclocal:profiletypes');
      el.innerHTML = escapeHTML(x);
      datasetDescriptionEl.appendChild(el);
    }
    el = document.createElementNS(utilsRDF.namespace.lclocal, 'lclocal:title');
    el.innerHTML = escapeHTML(xmlVoidDataTitle);
    datasetDescriptionEl.appendChild(el);
    el = document.createElementNS(utilsRDF.namespace.lclocal, 'lclocal:contributor');
    el.innerHTML = escapeHTML(xmlVoidDataContributor);
    datasetDescriptionEl.appendChild(el);
    el = document.createElementNS(utilsRDF.namespace.lclocal, 'lclocal:lccn');
    el.innerHTML = escapeHTML(xmlVoidDataLccn);
    datasetDescriptionEl.appendChild(el);
    el = document.createElementNS(utilsRDF.namespace.lclocal, 'lclocal:user');
    el.innerHTML = escapeHTML(profile.user);
    datasetDescriptionEl.appendChild(el);
    el = document.createElementNS(utilsRDF.namespace.lclocal, 'lclocal:status');
    el.innerHTML = escapeHTML(profile.status);
    datasetDescriptionEl.appendChild(el);
    el = document.createElementNS(utilsRDF.namespace.lclocal, 'lclocal:eid');
    el.innerHTML = escapeHTML(profile.eId);
    datasetDescriptionEl.appendChild(el);
    el = document.createElementNS(utilsRDF.namespace.lclocal, 'lclocal:typeid');
    el.innerHTML = escapeHTML(profile.id);
    datasetDescriptionEl.appendChild(el);
    el = document.createElementNS(utilsRDF.namespace.lclocal, 'lclocal:procinfo');
    el.innerHTML = escapeHTML(orginalProfile.procInfo);
    datasetDescriptionEl.appendChild(el);
    for (let x of xmlVoidExternalID){
      el = document.createElementNS(utilsRDF.namespace.lclocal, 'lclocal:externalid');
      el.innerHTML = escapeHTML(x);
      datasetDescriptionEl.appendChild(el);
    }

    // Format XML output
    // Only serialize the rdf DOM node directly, do not use ensureRoot or prettifyXmlJS for the main RDF output
    let strXml = this.serializePreservingNamespaces(rdf);
    let strXmlBasic = this.serializePreservingNamespaces(rdfBasic);
    let strXmlFormatted = strXml; // Optionally, you can prettify for display, but do not break the structure

    // Build BF2MARC package
    let bf2MarcXmlElRdf = this.createElByBestNS('http://www.w3.org/1999/02/22-rdf-syntax-ns#RDF');
    for (let el of rdfBasic.getElementsByTagName("bf:Work")){ bf2MarcXmlElRdf.appendChild(el); }
    for (let el of rdfBasic.getElementsByTagName("bf:Instance")){ bf2MarcXmlElRdf.appendChild(el); }
    for (let el of rdfBasic.getElementsByTagName("bf:Item")){ bf2MarcXmlElRdf.appendChild(el); }
    let strBf2MarcXmlElBib = (new XMLSerializer()).serializeToString(bf2MarcXmlElRdf);

    // clean it up a bit for the component
    if (strXmlFormatted.trim().length > 0) {
      strXmlFormatted = this.cleanOrganizationElement(strXmlFormatted);
    }
    if (strXmlBasic.trim().length > 0) {
      strXmlBasic = this.cleanOrganizationElement(strXmlBasic);
    }
    if (strXml.trim().length > 0) {
      strXml = this.cleanOrganizationElement(strXml);
    }
    if (strBf2MarcXmlElBib.trim().length > 0) {
      strBf2MarcXmlElBib = this.cleanOrganizationElement(strBf2MarcXmlElBib);
      strBf2MarcXmlElBib = this.ensureOrganizationLabels(strBf2MarcXmlElBib);
    }

    // After all XML is built, deduplicate assigners in all AdminMetadata elements in the final DOM trees
    const deduplicateAllAdminMetadataAssigners = (xmlDoc) => {
      if (!xmlDoc) return;
      // Use TreeWalker to traverse all nodes, including nested ones
      const walker = document.createTreeWalker(
        xmlDoc,
        NodeFilter.SHOW_ELEMENT,
        {
          acceptNode: (node) => node.nodeName === 'bf:AdminMetadata' ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
        },
        false
      );
      let node = walker.nextNode();
      while (node) {
        this.deduplicateAssignersInAdminMetadata(node);
        node = walker.nextNode();
      }
    };
    deduplicateAllAdminMetadataAssigners(rdf);
    deduplicateAllAdminMetadataAssigners(rdfBasic);
    deduplicateAllAdminMetadataAssigners(bf2MarcXmlElRdf);

    // Fix barcode structures before returning the final XML
    rdf = this.fixBarcodeStructures(rdf);
    rdfBasic = this.fixBarcodeStructures(rdfBasic);
    bf2MarcXmlElRdf = this.fixBarcodeStructures(bf2MarcXmlElRdf); // Corrected variable name

    // Return the XML in various formats
    return {
      xmlDom: rdf,
      xmlStringFormatted: strXmlFormatted,
      xlmString: strXml,
      bf2Marc: strBf2MarcXmlElBib,
      xlmStringBasic: strXmlBasic,
      voidTitle: xmlVoidDataTitle,
      voidContributor: xmlVoidDataContributor,
      componentXmlLookup: componentXmlLookup
    };
  }, // Comma after buildXMLProcess

  /**
   * Fixes barcode structures in an XML document
   * @param {Element} xmlDoc - The XML document element to process
   * @return {Element} - The processed XML document element
   */
  fixBarcodeStructures: function(xmlDoc) {
    if (!xmlDoc || typeof xmlDoc.querySelectorAll !== 'function') {
      console.warn("[fixBarcodeStructures] Invalid xmlDoc provided");
      return xmlDoc;
    }
    
    try {
      console.log("[fixBarcodeStructures] Starting barcode structure fix process");
      
      // Find all barcode elements
      const barcodes = xmlDoc.querySelectorAll('bf\\:Barcode');
      console.log(`[fixBarcodeStructures] Found ${barcodes.length} barcode elements`);
      
      barcodes.forEach((barcode, index) => {
        // Check if it already has a proper rdf:value element
        if (barcode.querySelector('rdf\\:value')) {
          console.log(`[fixBarcodeStructures] Barcode ${index} already has rdf:value, skipping`);
          return;
        }
        
        // Get text content directly from the barcode element
        let barcodeText = barcode.textContent && barcode.textContent.trim();
        
        if (barcodeText) {
          console.log(`[fixBarcodeStructures] Fixing barcode ${index} with text content: ${barcodeText}`);
          
          // Clear the text content
          while (barcode.firstChild) {
            barcode.removeChild(barcode.firstChild);
          }
          
          // Create a proper rdf:value element
          const valueEl = document.createElementNS(utilsRDF.namespace.rdf, "rdf:value");
          valueEl.textContent = barcodeText;
          barcode.appendChild(valueEl);
          
          console.log(`[fixBarcodeStructures] Fixed barcode ${index}`);
        }
      });
      
      console.log("[fixBarcodeStructures] Barcode structure fix process complete");
      return xmlDoc;
    } catch (error) {
      console.error(`[fixBarcodeStructures] Error: ${error}`);
      return xmlDoc;
    }
  }, // Comma after fixBarcodeStructures
  
  /**
   * Deduplicates assigners in AdminMetadata to ensure there's only one properly structured assigner
   * @param {Element} adminMetadata - The AdminMetadata element to process
   */
  deduplicateAssignersInAdminMetadata: function(adminMetadata) {
    if (!adminMetadata) return;
    
    try {
      const assigners = adminMetadata.querySelectorAll('bf\\:assigner');
      
      // If no assigners, add a default one
      if (assigners.length === 0) {
        const defaultAssigner = this.buildDefaultAssignerElement();
        adminMetadata.appendChild(defaultAssigner);
        return; // Exit after adding default
      }
      
      // Find the best assigner (one with proper Organization structure)
      let bestAssigner = null;
      
      for (let i = 0; i < assigners.length; i++) {
        const assigner = assigners[i];
        const org = assigner.querySelector('bf\\:Organization[rdf\\:about]');
        if (org && org.querySelector('rdfs\\:label')) {
          bestAssigner = assigner;
          break;
        }
      }
      
      // If we found a good assigner, remove others and make sure it's properly structured
      if (bestAssigner) {
        // Ensure the best assigner has the correct structure
        this.cleanAssignerElement(bestAssigner);
        // Remove all other assigners
        assigners.forEach(assigner => {
          if (assigner !== bestAssigner && assigner.parentNode === adminMetadata) {
             adminMetadata.removeChild(assigner);
          }
        });
      } else {
        // No ideal assigner found, pick the first one and try to fix it or add default
        const firstAssigner = assigners[0];
        this.cleanAssignerElement(firstAssigner); // Try cleaning the first one
        // Remove all other assigners
        assigners.forEach(assigner => {
          if (assigner !== firstAssigner && assigner.parentNode === adminMetadata) {
             adminMetadata.removeChild(assigner);
          }
        });
        // If the cleaned first assigner still lacks an org/label, replace with default
        const org = firstAssigner.querySelector('bf\\:Organization[rdf\\:about]');
        if (!org || !org.querySelector('rdfs\\:label')) {
           console.warn("[deduplicateAssigners] First assigner couldn't be fixed, replacing with default.");
           if (firstAssigner.parentNode === adminMetadata) {
               adminMetadata.removeChild(firstAssigner);
           }
           const defaultAssigner = this.buildDefaultAssignerElement();
           adminMetadata.appendChild(defaultAssigner);
        }
      }
    } catch (error) { 
      console.error("[deduplicateAssignersInAdminMetadata] Error:", error);
    }
  }
};

export default utilsExport;